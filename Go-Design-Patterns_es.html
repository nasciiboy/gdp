<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" class="translated-ltr" lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>Ir a patrones de diseño</title>

  <meta name="author" content="Mario Castro Contreras">
  <meta name="id" content="isbn-978-1-78646-620-4">
  <meta name="date" content="02/2017">
  <link rel="stylesheet" type="text/css" href="worg-data/worg.css">
</head>

<body>
<h1>Ir a patrones de diseño</h1>
<h2 id="about-the-author">Sobre el Autor</h2>
<div class="hBody-2">
<p><b>Mario Castro Contreras</b> es un ingeniero de software
especializado en sistemas distribuidos y soluciones de big data. Trabaja
 como ingeniero de confiabilidad del sitio, y ahora se concentra en
soluciones y aplicaciones en contenedores que utilizan la mayor parte de
 la suite Google Cloud; especialmente, Kubernetes. Tiene una amplia
experiencia en integración de sistemas y soluciones, y ha escrito muchas
 aplicaciones de 12 factores escalables y confiables que utilizan Go and
 Docker. Ha diseñado arquitecturas Big Data para servicios financieros y
 medios, y ha escrito tuberías de procesamiento de datos usando
arquitecturas basadas en eventos escritas puramente en Go. También es
muy activo en la comunidad de código abierto, y puedes encontrarlo en su
 cuenta de GitHub con el nombre de usuario <i>sayden</i>. En el pasado, también ha escrito aplicaciones móviles y backends en Java.</p>
<p>Mario es un apasionado de los lenguajes de programación, y encontró
el mejor equilibrio entre diversión y productividad en Go; sin embargo,
recientemente, le gusta escribir en Rust y sistemas integrados en C.
También es un apasionado del ciclismo de ruta y los deportes de
invierno.</p>
<blockquote>
<p>Me gustaría expresar mi profunda gratitud a mis padres por apoyarme
en mi viaje a través de las computadoras desde que tenía 8 años. A
Urszula, Tyrion y Tesla por su apoyo diario y por estar conmigo en las
largas noches escribiendo este libro.</p>
<p>Me gustaría agradecer a Chaitanya, por su guía al principio del
libro, Zeeyan, por su paciencia y ayuda en cada capítulo, y a Pavan, por
 la ayuda y las explicaciones. Pero también a todos los revisores,
especialmente a Shiju, y a todo el equipo de Packt que hizo posible este
 libro.</p>
</blockquote>
</div>
<h2 id="about-the-reviewer">Sobre el revisor</h2>
<div class="hBody-2">
<p><b>Shiju Varghese</b> es un arquitecto de soluciones enfocado en la
construcción de aplicaciones nativas de nube altamente escalables con un
 interés especial en API, microservicios, arquitecturas en contenedores y
 sistemas distribuidos. Actualmente se especializa en Go, Google Cloud y
 tecnologías de contenedores. Es uno de los primeros en adoptar el
lenguaje de programación Go y proporciona consultas y capacitación para
construir sistemas back-end y microservicios con el ecosistema Go. Ha
sido mentor de varias empresas y emprendimientos para la transformación
de la tecnología en Go. Ha sido ponente en numerosas conferencias
tecnológicas, incluida GopherCon India.</p>
<p>Shiju es autor de dos libros sobre Go, titulados <i>Desarrollo web con Go</i> and Go <i>Recipes</i>, ambos publicados por Apress.</p>
</div>
<h2 id="preface">Prefacio</h2>
<div class="hBody-2">
<p>¡Bienvenido al libro <i>Go Design Patterns</i>! Con este libro,
aprenderás técnicas y patrones básicos y avanzados con el lenguaje Go.
No se preocupe si nunca antes ha escrito el código Go; este libro le
presentará gradualmente los diversos conceptos en la programación de Go.
 Al mismo tiempo, los expertos encontrarán muchos consejos y trucos
sobre el idioma, por lo que le recomiendo que no se pierda ningún
capítulo. Si ya conoce los patrones de diseño clásico, encontrará este
libro muy útil, no solo como un libro de referencia, sino también como
una forma de aprender los enfoques idiomáticos de Go para resolver
problemas comunes que quizás ya conozca. El libro está dividido en tres
secciones:</p>
<p>Introducción al lenguaje Go: esta es la primera parte del libro,
donde aprenderá la sintaxis básica, las herramientas que vienen con las
distribuciones binarias, las pruebas básicas, el análisis JSON y más.
Dejamos concurrencia para un capítulo posterior para centrarnos en la
forma en que la sintaxis y el compilador funcionan en una aplicación
típica de Go.</p>
<p>Patrones de diseño clásico en Go idiomático: la segunda sección
presenta los patrones de diseño clásico, pero como veremos, son bastante
 diferentes, en parte debido a la falta de herencia en Go, sino también
porque tenemos diferentes y más óptimas formas de resolver el mismo
problemas. Un recién llegado al lenguaje encontrará los ejemplos en esta
 sección muy útiles como una forma de entender las raíces de Go y las
formas idiomáticas en las que puede resolver problemas usando Go de la
misma manera que lo resolvería en lenguajes como Java o C ++. .</p>
<p>La mayoría de los ejemplos se presentan utilizando TDD y algunos de
ellos incluso muestran ejemplos dentro de la biblioteca estándar Go que
usa estos patrones. Patrones de simultaneidad: el enfoque en esta
sección es aprender sobre estructuras concurrentes y ejecución paralela.
 Aprenderá la mayoría de las primitivas en Go to write apps
concurrentes, y desarrollaremos algunos de los patrones de diseño
clásicos con estructuras concurrentes para maximizar el paralelismo.
Además, aprenderemos algunas de las estructuras típicas para desarrollar
 aplicaciones concurrentes en Go. Aprenderá cómo un patrón clásico puede
 volverse más complejo si necesitamos que funcione de forma concurrente,
 pero la idea es comprender las primitivas concurrentes de Go para que
el lector termine el libro sabiendo cómo escribir sus propios patrones
de diseño concurrentes utilizando los conocimientos adquiridos. del
libro.</p>
<p>El libro aumentará lentamente la dificultad de algunas tareas. Hemos explicado consejos y trucos en cada capítulo.</p>
</div>
<h3 id="what-this-book-covers">Lo que cubre este libro</h3>
<div class="hBody-3">
<p><a href="https://nasciiboy.github.io/book4all/Go%20Design%20Patterns.html#chapter-1">Capítulo 1</a>, <i>Listo ... Firme ... ¡Vete! </i>,
 intenta ayudar a los recién llegados al lenguaje de programación Go que
 tienen algunos antecedentes en cualquier otro lenguaje de programación.
 Comenzará mostrando cómo instalar el entorno Go en una máquina Linux,
pasando a la sintaxis, el tipo y el control de flujo.</p>
<p><a href="https://nasciiboy.github.io/book4all/Go%20Design%20Patterns.html#chapter-2">Capítulo 2</a>, <i>Patrones de creación: Singleton, Builder, Factory, Prototype y Abstract Factory Design Patterns</i>,
 presenta los problemas que pueden surgir cuando una creación o
administración de objetos es particularmente compleja o costosa
utilizando los patrones de diseño de Singleton, Builder, Factory y
Abstract Factory.</p>
<p><a href="https://nasciiboy.github.io/book4all/Go%20Design%20Patterns.html#chapter-3">El Capítulo 3</a>, <i>Patrones estructurales - Compuesto, Adaptador y Patrones de diseño de puente</i>,
 trata del primer conjunto de patrones estructurales sobre la
composición de objetos para obtener nuevas funcionalidades. Como crear
un objeto intermedio y usar varios objetos como si solo hubiera uno.</p>
<p><a href="https://nasciiboy.github.io/book4all/Go%20Design%20Patterns.html#chapter-4">El Capítulo 4</a>, <i>Patrones estructurales: Patrones de diseño Proxy, Fachada, Decorador y Flyweight</i>,
 está menos orientado a la composición de objetos múltiples, pero se
centra más en obtener nuevas funcionalidades en objetos existentes. El
patrón Decorator se usa comúnmente para seguir el principio de apertura
abierta. Facade se usa ampliamente en las API en las que desea una
fuente única para muchas fuentes de información y acciones. El peso
mosca no es tan común, pero es un patrón muy útil cuando la memoria se
está convirtiendo en un problema causado por una gran colección de
objetos similares. Finalmente, el patrón Proxy se ajusta a un objeto
para proporcionar la misma funcionalidad, pero al mismo tiempo, agrega
algo a la funcionalidad del proxy.</p>
<p><a href="https://nasciiboy.github.io/book4all/Go%20Design%20Patterns.html#chapter-5">El Capítulo 5</a>, <i>Patrones de comportamiento: Estrategia, Cadena de responsabilidad, Comando y Patrones de diseño del mediador</i>,
 trata sobre el primer patrón de comportamiento para hacer que los
objetos reaccionen de una manera esperada o limitada. Comenzaremos con
el patrón de Estrategia, quizás el patrón de diseño más importante en la
 programación orientada a objetos, ya que muchos patrones de diseño
tienen algo en común. Luego pasaremos a la Cadena de responsabilidad
para construir <i>cadenas</i> de objetos que puedan decidir cuál de
ellos debe tratar con un caso particular. Finalmente, el patrón de
comando para encapsular acciones que no necesariamente deben ejecutarse
inmediatamente o deben almacenarse.</p>
<p><a href="https://nasciiboy.github.io/book4all/Go%20Design%20Patterns.html#chapter-6">El Capítulo 6</a>, <i>Patrones de comportamiento - Patrones de diseño de plantilla, recuerdo e intérprete</i>
 continúa con los patrones de comportamiento que introducen el patrón de
 intérprete, un patrón bastante complejo para crear idiomas pequeños e
intérpretes para ellos. Puede ser muy útil cuando se puede resolver un
problema inventando un pequeño lenguaje para ello. El patrón Memento
está delante de nuestros ojos todos los días con el botón <b>Deshacer</b>
 en las aplicaciones. El patrón de Plantilla ayuda a los desarrolladores
 definiendo una estructura inicial de una operación para que los
usuarios finales del código puedan finalizarla.</p>
<p><a href="https://nasciiboy.github.io/book4all/Go%20Design%20Patterns.html#chapter-7">El Capítulo 7</a>, <i>Patrones de comportamiento -</i> Patrón de <i>visitante, estado, mediador y diseño de observador</i>,
 representa el patrón Observer, un patrón importante que se está
volviendo tremendamente popular en sistemas distribuidos y programación
reactiva. El patrón Visitor se ocupa de jerarquías complejas de objetos
donde necesita aplicar una acción particular según el objeto.
Finalmente, el patrón state se usa comúnmente en videojuegos y máquinas
de estados finitos y permite que un objeto cambie su comportamiento en
función de su propio estado.</p>
<p><a href="https://nasciiboy.github.io/book4all/Go%20Design%20Patterns.html#chapter-8">El Capítulo 8</a>, <i>Introducción a la concurrencia de Go</i>,
 explica con más detalle el modelo de simultaneidad CSP utilizado en Go,
 repasando algunos ejemplos usando Goroutines y canales, así como
mutexes y sincronizaciones.</p>
<p><a href="https://nasciiboy.github.io/book4all/Go%20Design%20Patterns.html#chapter-9">El Capítulo 9</a>, <i>Patrones de Concurrencia - Barrier, Future, y Pipeline Design Patterns</i>,
 presentará algunos de los patrones de concurrencia CSP que son
idiomáticos para el lenguaje Go al recorrer algunos ejemplos y
explicaciones. Estos son patrones pequeños pero realmente potentes, así
que daremos algunos ejemplos del uso de cada uno de ellos, así como
algunos esquemas (si es posible) que facilitarán la comprensión de cada
uno de ellos.</p>
<p><a href="https://nasciiboy.github.io/book4all/Chapter-10">El Capítulo 10</a>, <i>Patrones de Concurrencia - Grupo de Trabajadores, y Patrones de Diseño de Publicación o Suscriptor</i>,
 habla sobre un par de patrones con estructuras concurrentes.
Explicaremos cada paso en detalle para que pueda seguir los ejemplos
cuidadosamente. La idea es aprender patrones para diseñar aplicaciones
simultáneas en Go idiomático. Estamos utilizando canales y Goroutines en
 gran medida, en lugar de bloquear o compartir variables.</p>
</div>
<h3 id="what-you-need-for-this-book">Lo que necesitas para este libro</h3>
<div class="hBody-3">
<p>La mayoría de los capítulos de este libro están escritos siguiendo un
 enfoque TDD simple, aquí los requisitos se escriben primero, luego
algunas pruebas unitarias y finalmente el código que satisface esos
requisitos. Utilizaremos solo las herramientas que vienen con la
biblioteca estándar de Go como una forma de comprender mejor el lenguaje
 y sus posibilidades. Esta idea es clave para seguir el libro y
comprender la forma en que Go resuelve problemas, especialmente en
sistemas distribuidos y aplicaciones concurrentes.</p>
</div>
<h3 id="who-this-book-is-for">para quien es este libro</h3>
<div class="hBody-3">
<p>Este libro es para principiantes y desarrolladores de nivel avanzado
en el lenguaje de programación Go. No se espera conocimiento de los
patrones de diseño.</p>
</div>
<h4 id="downloading-the-example-code">Descargar el código de ejemplo</h4>
<div class="hBody-4">
<p>Puede descargar los archivos de código de ejemplo para este libro desde su cuenta en <a href="http://www.packtpub.com/">http://www.packtpub.com</a>. Si compró este libro en otro lugar, puede visitar <a href="http://www.packtpub.com/support">http://www.packtpub.com/support</a> y registrarse para recibir los archivos por correo electrónico directamente.</p>
<p>Puede descargar los archivos de código siguiendo estos pasos:</p>
<ol class="num">
<li>
<p>Inicie sesión o regístrese en nuestro sitio web usando su dirección de correo electrónico y contraseña.</p>
</li>
<li>
<p>Coloque el puntero del mouse en la pestaña <b>SOPORTE</b> en la parte superior.</p>
</li>
<li>
<p>Haga clic en <b>Descargas de código y errata</b>.</p>
</li>
<li>
<p>Ingrese el nombre del libro en el cuadro de <b>búsqueda</b>.</p>
</li>
<li>
<p>Seleccione el libro para el que desea descargar los archivos de código.</p>
</li>
<li>
<p>Elija del menú desplegable donde compró este libro.</p>
</li>
<li>
<p>Haga clic en <b>Descargar Código</b>.</p>
</li>
</ol>
<p>Una vez que se haya descargado el archivo, asegúrese de descomprimir o extraer la carpeta con la última versión de:</p>
<ul>
<li>
<p>WinRAR / 7-Zip para Windows</p>
</li>
<li>
<p>Zipeg / iZip / UnRarX para Mac</p>
</li>
<li>
<p>7-Zip / PeaZip para Linux</p>
</li>
</ul>
<p>El paquete de códigos para el libro también está alojado en GitHub en <a href="https://github.com/PacktPublishing/Go-Design-Patterns">https://github.com/PacktPublishing/Go-Design-Patterns</a>. También tenemos otros paquetes de códigos de nuestro rico catálogo de libros y videos disponibles en <a href="https://github.com/PacktPublishing/">https://github.com/PacktPublishing/</a>. Échales un vistazo!</p>
</div>
<h4 id="errata">Errata</h4>
<div class="hBody-4">
<p>Aunque hemos tomado todas las precauciones para garantizar la
precisión de nuestro contenido, los errores ocurren. Si encuentra un
error en uno de nuestros libros, tal vez un error en el texto o el
código, le agradeceríamos que nos lo informara. Al hacerlo, puede salvar
 a otros lectores de la frustración y ayudarnos a mejorar las versiones
posteriores de este libro. Si encuentra alguna errata, infórmenos
visitando <a href="http://www.packtpub.com/submit-errata">http://www.packtpub.com/submit-errata</a>, seleccionando su libro, haciendo clic en el enlace <b>Errata Submission Form</b>
 e ingresando los detalles de su errata. Una vez que se verifique su
errata, se aceptará su envío y la errata se cargará en nuestro sitio web
 o se agregará a cualquier lista de erratas existentes en la sección de
Erratas de ese título.</p>
<p>Para ver la errata enviada anteriormente, vaya a <a href="https://www.packtpub.com/books/content/support">https://www.packtpub.com/books/content/support</a> e ingrese el nombre del libro en el campo de búsqueda. La información requerida aparecerá debajo de la sección <b>Errata</b>.</p>
</div>
<h4 id="questions">Preguntas</h4>
<div class="hBody-4">
<p>Si tiene algún problema con algún aspecto de este libro, puede
contactarnos en @l(mailto:questions@@packtpub.com) y haremos nuestro
mejor esfuerzo para resolver el problema.</p>
</div>
<h2 id="chapter-1">¡Preparados listos ya!</h2>
<div class="hBody-2">
<p>Los patrones de diseño han sido la base de cientos de miles de piezas de software. Dado que The <i>Gang Of Four</i> (Erich Gamma, Richard Helm, Ralph Johnson y John Vlissides) escribió el libro <i>Design Patterns: Elements of Reusable Object-Oriented Software</i>
 en 1994 con ejemplos en C ++ y Smalltalk, los veintitrés patrones
clásicos han sido revisados implementado en la mayoría de los
principales idiomas de hoy y se han utilizado en casi todos los
proyectos que conoce.</p>
<p>The <i>Gang of Four</i> detectó que muchas arquitecturas pequeñas
estaban presentes en muchos de sus proyectos, comenzaron a reescribirlas
 de una manera más abstracta y lanzaron el famoso libro.</p>
<p>Este libro es una explicación completa y la implementación de los patrones de diseño más comunes de la <i>Banda de los Cuatro</i> y los patrones de hoy más algunos de los patrones de concurrencia más idiomáticos en Go.</p>
<p>Pero, ¿qué es Go...?</p>
</div>
<h3 id="a-little-bit-of-history">Un poquito de historia</h3>
<div class="hBody-3">
<p>En los últimos 20 años, hemos vivido un crecimiento increíble en
ciencias de la computación. Los espacios de almacenamiento se han
incrementado dramáticamente, la memoria RAM ha sufrido un crecimiento
sustancial y las CPU son... bueno... simplemente más rápidas. ¿Han
crecido tanto como el almacenamiento y la memoria RAM? No en realidad,
la industria de la CPU ha alcanzado un límite en la velocidad que su CPU
 puede ofrecer, principalmente porque se han vuelto tan rápidos que no
pueden obtener suficiente energía para funcionar mientras disipan
suficiente calor. Los fabricantes de CPU ahora están enviando más
núcleos en cada computadora. Esta situación se bloquea en el contexto de
 muchos lenguajes de programación de sistemas que no fueron diseñados
para CPU multiprocesador o grandes sistemas distribuidos que actúan como
 una máquina única. En Google,</p>
<p>Al mismo tiempo, nuestros programas eran más grandes, más complejos,
más difíciles de mantener y con mucho margen para malas prácticas. Si
bien nuestras computadoras tenían más núcleos y eran más rápidas, no
fuimos más rápidos al desarrollar nuestro código ni nuestras
aplicaciones distribuidas. Este era el objetivo de Go.</p>
<p>Go design comenzó en 2007 por tres Googlers en la búsqueda de un
lenguaje de programación que pudiera resolver problemas comunes en
sistemas distribuidos a gran escala como los que puedes encontrar en
Google. Los creadores fueron:</p>
<ul>
<li>
<p>Rob Pike: Plan 9 e Inferno OS.</p>
</li>
<li>
<p>Robert Griesemer: trabajó en el motor de JavaScript V8 de Google que impulsa Google Chrome.</p>
</li>
<li>
<p>Ken Thompson: Trabajó en Bell Labs y el equipo de Unix. Ha
participado en el diseño del sistema operativo Plan 9 y en la definición
 de la codificación UTF-8.</p>
</li>
</ul>
<p>En 2008, el compilador terminó y el equipo recibió la ayuda de Russ
Cox e Ian Lance Taylor. El equipo comenzó su viaje hacia el proyecto de
código abierto en 2009 y en marzo de 2012 alcanzaron una versión 1.0
después de más de cincuenta lanzamientos.</p>
</div>
<h3 id="installing-go">Instalando Go</h3>
<div class="hBody-3">
<p>Cualquier instalación de Go necesita dos cosas básicas: los binarios del idioma en algún lugar de su disco y una <code>GOPATH</code> ruta en su sistema donde se almacenarán sus proyectos y los proyectos que descargue de otras personas.</p>
<p>En las siguientes líneas, exploraremos cómo instalar los binarios de
Go en Linux, Windows y OS X. Para obtener una explicación detallada de
cómo instalar la última versión de Go, puede consultar la documentación
oficial en <a href="https://golang.org/doc/install">https://golang.org / doc / install</a>.</p>
</div>
<h4 id="linux">Linux</h4>
<div class="hBody-4">
<p>Para instalar Go en Linux tiene dos opciones:</p>
<ul>
<li>
<p><b>Opción fácil</b> : use su administrador de paquete de distribución:</p>
<ul>
<li>
<p>Usuarios de RHEL / Fedora / Centos con YUM / DNF:</p>
<pre class="code"><code class="sh">sudo yum install -y golang
</code></pre>
</li>
<li>
<p>Usuarios de Ubuntu / Debian que usan APT con:</p>
<pre class="code"><code class="sh">sudo apt-get install -y golang
</code></pre>
</li>
</ul>
</li>
<li>
<p><b>Avanzado</b> : descargar la última distribución de <a href="https://golang.org/">https://golang.org</a>.</p>
</li>
</ul>
<p>Recomiendo usar el segundo y descargar una distribución. Las
actualizaciones de Go mantienen la compatibilidad con versiones
anteriores y, por lo general, no debería preocuparse por actualizar sus
binarios de Go con frecuencia.</p>
</div>
<h4 id="go-linux-advanced-installation">Ir a la instalación avanzada de Linux</h4>
<div class="hBody-4">
<p>La instalación avanzada de Go en Linux requiere que descargues los binarios de la página web de <b>golang</b>. Después de ingresar a <a href="https://golang.org/">https://golang.org</a>, haga clic en el botón <b>Descargar para ir</b> (generalmente a la derecha), hay disponible una opción de <b>Descargas destacadas</b> para cada distribución. Seleccione la distribución de <b>Linux</b> para descargar la última versión estable.</p>
<div class="about">
<div class="about-dt">Nota</div>
<div class="about-dd">
<p>En <a href="https://golang.org/">https://golang.org</a> también puede descargar versiones beta del idioma.</p>
</div>
</div>
<p>Digamos que hemos guardado el archivo tar.gz en la carpeta Descargas,
 así que vamos a extraerlo y moverlo a una ruta diferente. Por
convención, los binarios de Go generalmente se colocan en el directorio /
 usr / local / go:</p>
<pre class="code"><code class="sh">tar -zxvf go*.*.*.linux-amd64.tar.gz
sudo mv go /usr/local/go
</code></pre>
<p>En la extracción recuerde reemplazar los asteriscos (*) con la versión que ha descargado.</p>
<p>Ahora tenemos nuestra instalación Go en la <code>/usr/local/go</code> ruta, así que ahora tenemos que agregar la subcarpeta bin a nuestra <code>PATH</code> carpeta bin y dentro de nuestra <code>GOPATH</code>.</p>
<pre class="code"><code class="sh">mkdir -p $HOME/go/bin
</code></pre>
<p>Con <code>-p</code> nosotros le decimos a bash que cree todos los
directorios que sean necesarios. Ahora tenemos que anexar las rutas de
la carpeta bin a nuestra <code>PATH</code>, anexar las siguientes líneas al final de su <span class="file">~ /.bashrc</span> :</p>
<pre class="code"><code class="sh">export PATH=$PATH:/usr/local/go/bin
</code></pre>
<p>Verifique que nuestro directorio go / bin esté disponible:</p>
<pre class="srci"><code class="sh"><span class="in"><span class="prompt">&gt; </span>go version Go version go1.6.2 linux/amd64
</span></code></pre>
</div>
<h4 id="windows">Windows</h4>
<div class="hBody-4">
<p>Para instalar Go en Windows, necesitará privilegios de administrador.
 Abra su navegador favorito y navegue a https://golang.org. Una vez
allí, haga clic en el botón <b>Descargar</b> y seleccione la distribución de <b>Microsoft Windows</b>. Un archivo <span class="file">*.msi</span> comenzará a descargarse.</p>
<p>Ejecute el instalador de MSI haciendo doble clic en él. Aparecerá un instalador pidiéndole que acepte el <b>Contrato de licencia de usuario final</b> ( <span class="acronym">EULA</span> ) y seleccione una carpeta de destino para su instalación. Continuaremos con la ruta predeterminada que en mi caso fue <span class="file">C: \ Go</span>.</p>
<p>Una vez que la instalación haya finalizado, deberá agregar la carpeta <b>binaria Go</b>, ubicada en <span class="file">C: \ Go \ bin</span> a su ruta. Para esto, debe ir al Panel de control y seleccionar la opción <b>Sistema</b>. Una vez en Sistema, seleccione la pestaña <b>Avanzado</b> y haga clic en el botón <b>Variables</b> del <b>entorno</b>.
 Aquí encontrará una ventana con variables para su usuario actual y las
variables del sistema. En las variables del sistema, encontrará la
variable <b>Path</b>. Haga clic en él y haga clic en el botón <b>Editar</b> para abrir un cuadro de texto. Puede agregar su ruta agregando<code>;C:\Go/bin</code>
 al final de la línea actual (tenga en cuenta el punto y coma al
comienzo de la ruta). En las versiones recientes de Windows (Windows
10), tendrá un administrador para agregar variables fácilmente.</p>
</div>
<h4 id="mac-os-x">Mac OS X</h4>
<div class="hBody-4">
<p>En Mac OS X, el proceso de instalación es muy similar a Linux. Abra su navegador favorito y vaya a <a href="https://golang.org/">https://golang.org</a> y haga clic en <b>Descargar Ir</b>. En la lista de posibles distribuciones que aparecen, seleccione <b>Apple OS X</b>. Esto descargará un archivo <span class="file">*.pkg</span> a su carpeta de descargas.</p>
<p>Una ventana lo guiará a través del proceso de instalación donde deberá <span class="file">ingresar</span> su contraseña de administrador para poder colocar los archivos binarios de Go en la carpeta <span class="file">/ usr / local / go / bin</span> con los permisos adecuados. Ahora, abra <b>Terminal</b> para probar la instalación tipeando esto en ella:</p>
<pre class="srci"><code class="sh"><span class="in"><span class="prompt">&gt; </span>go version
</span><span class="out">Go version go1.6.2 darwin/amd64
</span></code></pre>
<p>Si ves la versión instalada, todo estaba bien. Si no funciona,
verifique que haya seguido correctamente cada paso o consulte la
documentación en <a href="https://golang.org/">https://golang.org</a>.</p>
</div>
<h4 id="setting-the-workspace---linux-and-apple-os-x">Configuración del área de trabajo: Linux y Apple OS X</h4>
<div class="hBody-4">
<p>Ir siempre funcionará en el mismo espacio de trabajo. Esto ayuda al
compilador a encontrar paquetes y bibliotecas que podría estar usando.
Este espacio de trabajo se llama comúnmente <code>GOPATH</code>.</p>
<p><code>GOPATH</code> tiene un papel muy importante en su entorno de
trabajo mientras desarrolla el software Go. Cuando importe una
biblioteca en su código, buscará esta biblioteca en su <span class="file">$ GOPATH / src</span>. Lo mismo cuando instalas algunas aplicaciones Go, los binarios se almacenan en <span class="file">$ GOPATH / bin</span>.</p>
<p>Al mismo tiempo, todo su código fuente debe almacenarse en una ruta válida dentro de la carpeta $ GOPATH / src. Por ejemplo, <i>almaceno</i> mis proyectos en GitHub y mi nombre de usuario es <i>Sayden</i> entonces, para un proyecto llamado <b>minimal-mesos-go-framework</b> tendré esta estructura de carpetas como <span class="file">$ GOPATH / src / github.com / sayden / minimal-mesos-go -framework</span> que refleja el URI donde se almacena este repositorio en GitHub:</p>
<pre class="code"><code class="sh">mkdir -p $HOME/go
</code></pre>
<p>El camino <span class="file">$ HOME / go</span> va a ser el destino de nuestro <code>$GOPATH</code>. Tenemos que establecer una variable de entorno con nuestro <code>$GOPATH</code> apuntando a esta carpeta. Para establecer la variable de entorno, abra nuevamente el archivo <code>$HOME/.bashrc</code> con su editor de texto favorito y agregue la siguiente línea al final:</p>
<pre class="code"><code class="sh">export GOPATH=${HOME}/go
</code></pre>
<p>Guarde el archivo y abra una nueva terminal. Para comprobar que todo funciona, solo escribe un eco en la variable <code>$GOPATH</code> de esta manera:</p>
<pre class="srci"><code class="sh"><span class="in"><span class="prompt">&gt; </span>echo $GOPATH
</span><span class="out">/home/mcastro/go
</span></code></pre>
<p>Si la salida del comando anterior apunta a la ruta de Go elegida,
todo es correcto y puede continuar escribiendo su primer programa.</p>
</div>
<h3 id="starting-with-hello-world">Comenzando con Hello World</h3>
<div class="hBody-3">
<p>Este no sería un buen libro sin un ejemplo de Hello World. Nuestro
ejemplo de Hello World no puede ser más simple, abra su editor de texto
favorito y cree un archivo llamado <span class="file">main.go</span> dentro de nuestro <code>$GOPATH/src/[your_name]/hello_world</code> con el siguiente contenido:</p>
<pre class="code"><code class="go">package main

func main(){
  println("Hello World!")
}
</code></pre>
<p>Guarda el archivo. Para ejecutar nuestro programa, abra la ventana Terminal de su sistema operativo:</p>
<ul>
<li>
<p>En Linux, ve a programas y encuentra un programa llamado <b>Terminal</b>.</p>
</li>
<li>
<p>En Windows, pulse <kbd>Windows + R</kbd>, escriba <code class="command">cmd</code> sin comillas en la nueva ventana y presione <i>Enter</i>.</p>
</li>
<li>
<p>En Mac OS X, presione <kbd>Command + Space</kbd> para abrir una búsqueda de foco, escriba <code>terminal</code> sin comillas. La aplicación del terminal debe estar resaltada, así que presiona Enter.</p>
</li>
</ul>
<p>Una vez que estemos en nuestra terminal, navegue a la carpeta donde hemos creado nuestro archivo <span class="file">main.go. </span>Esto debe estar debajo de <span class="file">$ GOPATH / src / [your_name] / hello_world</span> y ejecutarlo:</p>
<pre class="srci"><code class="sh"><span class="in"><span class="prompt">&gt; </span>go run main.go
</span><span class="out">Hello World!
</span></code></pre>
<p>Eso es todo. El comando <code class="command">go run [file]</code>
compilará y ejecutará nuestra aplicación, pero no generará un archivo
ejecutable. Si solo desea compilarlo y obtener un archivo ejecutable,
debe compilar la aplicación con el siguiente comando:</p>
<pre class="srci"><code class="sh"><span class="in"><span class="prompt">&gt; </span>go build -o hello_world
</span></code></pre>
<p>No pasa nada. Pero si busca en el directorio actual ( comando <code class="command">ls</code> en Linux y Mac OS X y <code class="command">dir</code> en Windows), encontrará un archivo ejecutable con el nombre <span class="file">hello_world</span>. Hemos dado este nombre al archivo ejecutable cuando escribimos el <code>-o hello_world</code> comando durante la compilación. Ahora puede ejecutar este archivo:</p>
<pre class="srci"><code class="sh"><span class="in"><span class="prompt">&gt; </span>/hello_world
</span><span class="out">Hello World!
</span></code></pre>
<p>¡Y nuestro mensaje apareció! En Windows, solo necesita escribir el nombre del archivo <span class="file">.exe</span> para obtener el mismo resultado.</p>
<div class="about">
<div class="about-dt">Tip</div>
<div class="about-dd">
<p>El comando <code class="command">go run [my_main_file.go]</code> construirá y ejecutará la aplicación sin archivos intermedios. El comando <code class="command">go build -o [filename]</code> creará un archivo ejecutable que puedo llevar a cualquier lugar y no tiene dependencias.</p>
</div>
</div>
</div>
<h3 id="integrated-development-environment---ide">Entorno de desarrollo integrado - IDE</h3>
<div class="hBody-3">
<p>Un <span class="acronym">IDE</span> ( <b>Integrated Development Environment</b>
 ) es básicamente una interfaz de usuario para ayudar a los
desarrolladores, codificar sus programas al proporcionar un conjunto de
herramientas para acelerar las tareas comunes durante el proceso de
desarrollo, como la compilación, creación o administración de
dependencias. Los IDE son herramientas poderosas que toman un tiempo
para dominar y el propósito de este libro no es explicarlos (un IDE como
 Eclipse tiene sus propios libros).</p>
<p>En Go, tiene muchas opciones, pero solo hay dos que están completamente orientadas a Go development <b>LiteIDE</b> e <b>Intellij Gogland</b>.
 LiteIDE no es el más potente, pero Intellij ha puesto muchos esfuerzos
para hacer de Gogland un editor muy bueno con finalización, depuración,
refactorización, pruebas, cobertura visual, inspecciones, etc. IDEs
comunes o editores de texto que tienen un plugin / integración Go son
como sigue:</p>
<ul>
<li>
<p>Idea IntelliJ</p>
</li>
<li>
<p>Texto Sublime 2/3</p>
</li>
<li>
<p>Átomo</p>
</li>
<li>
<p>Eclipse</p>
</li>
</ul>
<p>Pero también puedes encontrar complementos de Go para:</p>
<ul>
<li>
<p>Emacs</p>
</li>
<li>
<p>Empuje</p>
</li>
<li>
<p>Visual Studio y código visual</p>
</li>
</ul>
<p>Los IDE IntelliJ Idea y Atom, para el momento de escribir estas
líneas, tienen soporte para la depuración usando un complemento llamado <b>Delve</b>. La Idea IntelliJ se incluye con el complemento Go oficial. En Atom, tendrás que descargar un complemento llamado <b>Go-plus</b> y un depurador que puedes encontrar buscando la palabra <code>Delve</code>.</p>
</div>
<h3 id="types">Tipos</h3>
<div class="hBody-3">
<p>Los tipos le dan al usuario la capacidad de almacenar valores en
nombres mnemotécnicos. Todos los lenguajes de programación tienen tipos
relacionados con los números (para almacenar enteros, negativos o
flotantes, por ejemplo) con caracteres (para almacenar un único
carácter) con cadenas (para almacenar palabras completas), etc. Go
language tiene los tipos comunes que se encuentran en la mayoría de los
lenguajes de programación:</p>
<ul>
<li>
<p>La palabra clave <code>bool</code> es para tipo booleano, que representa un estado <em>verdadero</em> o <em>falso</em>.</p>
</li>
<li>
<p>Muchos tipos numéricos son los más comunes:</p>
<ul>
<li>
<p>El tipo <code>int</code> representa un número del 0 al 4294967295 en máquinas de 32 bits y de 0 a 18446744073709551615 en 64 bits.</p>
</li>
<li>
<p>El tipo <code>byte</code> representa un número de 0 a 255.</p>
</li>
<li>
<p>The <code>float32</code> y <code>float64</code> types son el conjunto de todos los números de punto flotante IEEE-754 64 / - bit, respectivamente.</p>
</li>
<li>
<p>Usted también tiene <code>signed int</code> el tipo como <code>rune</code> que es un alias de tipo <code>int32</code>, un número que va de -2147483648 a 2147483647 y <code>complex64</code>y <code>complex128</code> que son el conjunto de los números complejos con <code>float32</code>/ <code>float64</code> partes real e imaginaria como <span class="math">2.0i</span>.</p>
</li>
</ul>
</li>
<li>
<p>La palabra clave <code>string</code> para tipo de cadena representa una matriz de caracteres entre comillas como <code>"golang"</code>o <code>"computer"</code>.</p>
</li>
<li>
<p>Una <code>array</code> que es una secuencia numerada de elementos de
un solo tipo y un tamaño fijo (más sobre las matrices más adelante en
este capítulo). Una lista de números o listas de palabras con un tamaño
fijo se considera matrices.</p>
</li>
<li>
<p>El tipo <code>slice</code> es un segmento de una matriz subyacente
(más sobre esto más adelante en este capítulo). Este tipo es un poco
confuso al principio porque parece una matriz, pero veremos que en
realidad son más poderosos.</p>
</li>
<li>
<p>Las estructuras que son los objetos que se componen de otros objetos o tipos.</p>
</li>
<li>
<p>Los indicadores (más sobre esto más adelante en este capítulo) son
como instrucciones en la memoria de nuestro programa (sí, como buzones
de correo que usted no sabe lo que hay adentro).</p>
</li>
<li>
<p>Las funciones son interesantes (más sobre esto más adelante en este
capítulo). También puede definir funciones como variables y pasarlas a
otras funciones (sí, una función que utiliza una función, ¿le gustó la
película Inception?).</p>
</li>
<li>
<p>El <code>interface</code> es increíblemente importante para el
lenguaje, ya que proporcionan muchas funcionalidades de encapsulación y
abstracción que necesitaremos a menudo. Utilizaremos las interfaces
extensamente durante el libro y se presentarán con mayor detalle más
adelante.</p>
</li>
<li>
<p>Los variable <code>map</code> son estructuras clave-valor desordenadas. Entonces, para una clave dada, tiene un valor asociado.</p>
</li>
<li>
<p>Los canales son la primitiva de comunicación en Ir para programas de
concurrencia. Buscaremos en los canales más detalles sobre el capítulo
8, <em>Cómo lidiar con la concurrencia CSP de Go</em>.</p>
</li>
</ul>
</div>
<h3 id="variables-and-constants">Variables y constantes</h3>
<div class="hBody-3">
<p>Las variables son espacios en la memoria de la computadora para
almacenar valores que pueden modificarse durante la ejecución del
programa. Las variables y constantes tienen un tipo como los descritos
en el texto anterior. Aunque no es necesario que escriba explícitamente
el tipo de ellos (aunque puede hacerlo). Esta propiedad para evitar la
declaración de tipo explícita es lo que se llama <b>tipos Inferidos</b>. Por ejemplo:</p>
<pre class="code"><code class="go">//Explicitly declaring a "string" variable
var explicit string = "Hello, I'm a explicitly declared variable"
</code></pre>
<p>Aquí estamos declarando una variable (con la palabra clave <code>var</code>) llamada <code>explicit</code> de tipo de cadena. Al mismo tiempo, estamos definiendo el valor para <code>Hello World!</code>.</p>
<pre class="code"><code class="go">// Implicitly declaring a "string". Type inferred
inferred := ", I'm an inferred variable "
</code></pre>
<p>Pero aquí estamos haciendo exactamente lo mismo. Hemos evitado la palabra clave <code>var</code> y la declaración de tipo <code>string</code>.
 Internamente, el compilador de Go inferirá (adivinará) el tipo de la
variable a un tipo de cadena. De esta forma, debe escribir mucho menos
código para cada definición de variable.</p>
<p>Las siguientes líneas usan el paquete <code>reflect</code> para recopilar información sobre una variable. Lo estamos usando para imprimir el tipo de (la variable <code>TypeOf</code> en el código) de ambas variables:</p>
<pre class="code"><code class="go">fmt.Println("Variable 'explicit' is of type:",
    reflect.TypeOf(explicit))
fmt.Println("Variable 'inferred' is of type:",
    reflect.TypeOf(inferred))
</code></pre>
<p>Cuando ejecutamos el programa, el resultado es el siguiente:</p>
<pre class="srci"><code class="sh"><span class="in"><span class="prompt">&gt; </span>go run main.go
</span><span class="out">Hello, I'm a explicitly declared variable
Hello, I'm an inferred variable
Variable 'explicit' is of type: string
Variable 'inferred' is of type: string
</span></code></pre>
<p>Como esperábamos, el compilador también ha inferido el tipo de la
variable implícita a la cadena. Ambos han escrito el resultado esperado
para la consola.</p>
</div>
<h3 id="operators">Operadores</h3>
<div class="hBody-3">
<p>Los operadores se usan para realizar operaciones aritméticas y hacer
comparaciones entre muchas cosas. Los siguientes operadores están
reservados por el idioma Go.</p>
<div class="pre-block">
<pre class="pre">+ Y + = &amp; = &amp;&amp; ==! = ()
- | - = | = || &lt;&lt;= []
* ^ * = ^ = &lt;=&gt;&gt; = {}
/ &lt;&lt; / = &lt;&lt; = ++ =: =,;
% &gt;&gt;% = &gt;&gt; = -! ... :
     &amp; ^ &amp; ^ =
</pre>
</div>
<p>Los operadores más comúnmente utilizados son los operadores
aritméticos y los comparadores. Los operadores aritméticos son los
siguientes:</p>
<ul>
<li>
<p>El operador <code>+</code> por sumas</p>
</li>
<li>
<p>El operador <code>-</code> de sustracciones</p>
</li>
<li>
<p>El operador <code>*</code> de multiplicaciones</p>
</li>
<li>
<p>El operador <code>/</code> de divisiones</p>
</li>
<li>
<p>El operador <code>%</code> para los restos de la división</p>
</li>
<li>
<p>El operador <code>++</code> agrega 1 a la variable actual</p>
</li>
<li>
<p>El operador <code>--</code> para restar 1 a la variable actual</p>
</li>
</ul>
<p>Por otro lado, los comparadores se utilizan para verificar las diferencias entre dos declaraciones:</p>
<ul>
<li>
<p>El operador <code>==</code> para verificar si dos valores son iguales</p>
</li>
<li>
<p>El operador <code>!=</code> para verificar si dos valores son diferentes</p>
</li>
<li>
<p>El operador <code>&gt;</code> para verificar si el valor de la izquierda es mayor que el valor correcto</p>
</li>
<li>
<p>El operador <code>&lt;</code> para verificar si el valor de la izquierda es menor que el valor de la derecha</p>
</li>
<li>
<p>El operador <code>&gt;=</code> para verificar si el valor de la izquierda es mayor o igual al valor correcto</p>
</li>
<li>
<p>El operador <code>&lt;=</code> para verificar si el valor de la izquierda es menor o igual al valor correcto</p>
</li>
<li>
<p>El operador <code>&amp;&amp;</code> para verificar si dos valores son<code>true</code></p>
</li>
</ul>
<p>También tiene las desplazadoras para realizar un desplazamiento
binario hacia la izquierda o hacia la derecha de un valor y un operador
negado para invertir algún valor. Usaremos estos operadores mucho
durante los siguientes capítulos, así que no se preocupe demasiado por
ellos ahora, solo tenga en cuenta que no puede establecer el nombre de
ninguna variable, campo o función en su código como este operador.</p>
<div class="about">
<div class="about-dt">Tip</div>
<div class="about-dd">
<p>¿Cuál es el valor invertido de 10? ¿Cuál es el valor negado de 10? -10? Incorrecto. 10 en el código binario es <code>1010</code> así si negamos cada número que tendremos <code>0101</code>o <code>101</code> cuál es el número 5.</p>
</div>
</div>
</div>
<h3 id="flow-control">Control de flujo</h3>
<div class="hBody-3">
<p>El control de flujo se conoce como la capacidad de decidir qué parte
del código o cuántas veces ejecuta algún código en una condición. En Go,
 se implementa usando cláusulas imperativas familiares como if, else,
switch y for. La sintaxis es fácil de entender. Repasemos las
principales declaraciones de control de flujo en Go.</p>
</div>
<h4 id="the-if...-else-statement">La sentencia if ... else</h4>
<div class="hBody-4">
<p>Go language, como la mayoría de los lenguajes de programación, tiene
if ... else statement condicional para control de flujo. La sintaxis es
similar a otros idiomas, pero no es necesario encapsular la condición
entre paréntesis:</p>
<pre class="code"><code class="go">ten := 10
if ten == 20 {
  println("This shouldn't be printed as 10 isn't equal to 20")
} else {
  println("Ten is not equals to 20");
}
</code></pre>
<p>La condición <code>else...if</code> funciona de manera similar, tampoco necesitas paréntesis y se declaran como esperaría el programador:</p>
<pre class="code"><code class="go">if "a" == "b" ||  10 == 10 || true == false {
  println("10 is equal to 10")
} else if 11 == 11 &amp;&amp; "go" == "go" {
  println("This isn't print because previous condition was satisfied");
} else {
  println("In case no condition is satisfied, print this")
}
</code></pre>
<div class="about">
<div class="about-dt">Nota</div>
<div class="about-dd">
<p>Go no tiene condiciones ternarias como la condición <code>? true : false</code>.</p>
</div>
</div>
</div>
<h4 id="the-switch-statement">La declaración de cambio</h4>
<div class="hBody-4">
<p>La declaración <code>switch</code> también es similar a la mayoría de los idiomas imperativos. Tomas una variable y verifica valores posibles para ella:</p>
<pre class="code"><code class="go">number := 3
switch(number){
case 1:
  println("Number is 1")
case 2:
  println("Number is 2")
case 3:
  println("Number is 3")
}
</code></pre>
</div>
<h4 id="the-for…range-statement">La declaración de rango de ...</h4>
<div class="hBody-4">
<p>El bucle <code>for</code> también es similar que en los lenguajes de programación comunes, pero tampoco usa paréntesis</p>
<pre class="code"><code class="go">for i := 0; i&lt;=10; i++ {
  println(i)
}
</code></pre>
<p>Como probablemente haya imaginado, si tiene conocimientos de informática, inferimos una variable <code>int</code> definida como 0 y ejecutamos el código entre corchetes mientras <code>i&lt;=10</code> se cumple la condición. Finalmente, para cada ejecución, agregamos 1 al valor de <code>i</code>.
 Este código imprimirá los números del 0 al 10. También tiene una
sintaxis especial para iterar sobre las matrices o sectores, que es <code>range</code>:</p>
<pre class="code"><code class="go">for index, value := range my_array {
  fmt.Printf("Index is %d and value is %d", index, value)
}
</code></pre>
<p>Primero, el <code>fmt</code>(formato) es un paquete Go muy común que utilizaremos ampliamente para dar forma al mensaje que imprimiremos en la consola.</p>
<p>En cuanto a, puede usar la palabra clave <code>range</code> para recuperar cada elemento de una colección similar <code>my_array</code>y asignarlos a la variable temporal de valor. También le dará una variable <code>index</code> para conocer la posición del valor que está recuperando. Es equivalente a escribir lo siguiente:</p>
<pre class="code"><code class="go">for index := 0, index &lt; len(my_array); index++ {
  value := my_array[index]
  fmt.Printf("Index is %d and value is %d", index, value)
}
</code></pre>
<div class="about">
<div class="about-dt">Tip</div>
<div class="about-dd">
<p>El método <code>len</code> se usa para conocer la longitud de una colección.</p>
</div>
</div>
<p>Si ejecuta este código, verá que el resultado es el mismo.</p>
</div>
<h3 id="functions">Funciones</h3>
<div class="hBody-3">
<p>Una función es una pequeña porción de código que rodea alguna acción
que desea realizar y devuelve uno o más valores (o nada). Son la
herramienta principal para que el desarrollador mantenga la estructura,
el encapsulado y la legibilidad del código, pero también permiten que un
 programador experimentado desarrolle pruebas unitarias adecuadas en
contra de sus funciones.</p>
<p>Las funciones pueden ser muy simples o increíblemente complejas. Por
lo general, encontrará que las funciones más simples también son más
fáciles de mantener, probar y depurar. También hay un muy buen consejo
en el mundo de la informática que dice: <i>Una función debe hacer una sola cosa, pero debe hacerlo muy bien</i>.</p>
</div>
<h4 id="what-does-a-function-look-like?">¿Cómo se ve una función?</h4>
<div class="hBody-4">
<p>Una función es una pieza de código con sus propias variables y flujo
que no afecta a nada fuera de la apertura y cierra corchetes, pero el
paquete global o las variables del programa. Funciones en Go tiene la
siguiente composición:</p>
<pre class="code"><code class="go">func [function_name] (param1 type, param2 type...) (returned type1, returned type2...) {
  //Function body
}
</code></pre>
<p>Siguiendo la definición anterior, podríamos tener el siguiente ejemplo:</p>
<pre class="code"><code class="go">func hello(message string) error {
  fmt.Printf("Hello %s\n", message)
  return nil
}
</code></pre>
<p>Las funciones pueden llamar a otras funciones. Por ejemplo, en nuestra función <code>hello</code> anterior, estamos recibiendo un argumento del mensaje de tipo cadena y estamos llamando a una función diferente <code>fmt.Printf("Hello %s\n", message)</code>
 con nuestro argumento como parámetro. Las funciones también se pueden
usar como parámetros al llamar a otras funciones o se pueden devolver.</p>
<p>Es muy importante elegir un buen nombre para su función para que
quede muy claro de qué se trata sin escribir demasiados comentarios
sobre él. Esto puede parecer un poco trivial, pero elegir un buen nombre
 no es tan fácil. Un nombre corto debe mostrar lo que hace la función y
dejar que el lector imagine qué error está manejando o si está haciendo
algún tipo de registro. Dentro de su función, desea hacer todo lo que un
 comportamiento particular necesita, pero también controlar los errores
esperados y ajustarlos adecuadamente.</p>
<p>Por lo tanto, escribir una función es más que simplemente lanzar un
par de líneas que hacen lo que necesita, es por eso que es importante
escribir una prueba unitaria, hacerlas pequeñas y concisas.</p>
</div>
<h4 id="what-is-an-anonymous-function?">¿Qué es una función anónima?</h4>
<div class="hBody-4">
<p>Una función anónima es una función sin nombre. Esto es útil cuando
desea devolver una función desde otra función que no necesita un
contexto o cuando desea pasar una función a una función diferente. Por
ejemplo, crearemos una función que acepta un número y devuelve una
función que acepta un segundo número que lo agrega al primero. La
segunda función no tiene un nombre declarativo (como la hemos asignado a
 una variable) por eso se dice que es anónimo:</p>
<pre class="code"><code class="go">func main(){
  add := func(m int){
    return m+1
  }

  result := add(6)

  // 1 + 6 must print 7
  println(result)
}
</code></pre>
<p>La variable <code>add</code> apunta a una función anónima que agrega
uno al parámetro especificado. Como puede ver, se puede usar solo para
el alcance de su función principal <code>main</code>y no se puede invocar desde ningún otro lado.</p>
<p>Las funciones anónimas son herramientas realmente poderosas que utilizaremos ampliamente en los patrones de diseño.</p>
</div>
<h4 id="closures">Cierres</h4>
<div class="hBody-4">
<p>Los cierres son algo muy similar a las funciones anónimas, pero aún
más poderosas. La diferencia clave entre ellos es que una función
anónima no tiene contexto dentro de sí misma y tiene un cierre. Vamos a
reescribir el ejemplo anterior para agregar un número arbitrario en
lugar de uno:</p>
<pre class="code"><code class="go">func main(){
  addN := func(m int){
    return func(n int){
      return m+n
    }
  }

  addFive := addN(5)
  result := addN(6)
  // 5 + 6 must print 7

  println(result)
}
</code></pre>
<p>La variable <code>addN</code> apunta a una función que devuelve otra función. Pero la función devuelta tiene el contexto del parámetro <code>m</code> dentro de ella. Cada llamada a <code>addN</code> will crea una nueva función con un valor fijo <code>m</code>, por lo que podemos tener <code>addN</code> funciones principales, cada una agregando un valor diferente.</p>
<p>Esta capacidad de cierres es muy útil para crear bibliotecas o tratar funciones con tipos no compatibles.</p>
</div>
<h4 id="creating-errors,-handling-errors-and-returning-errors.">Creando errores, manejando errores y devolviendo errores.</h4>
<div class="hBody-4">
<p>Los errores se usan ampliamente en Go, probablemente gracias a su
simplicidad. Para crear un error simplemente realice una llamada <code>errors.New(string)</code> con el texto que desea crear en el error. Por ejemplo:</p>
<pre class="code"><code class="go">err := errors.New("Error example")
</code></pre>
<p>Como hemos visto antes, podemos devolver errores a una función. Para
manejar un error, verá el siguiente patrón extensamente en el código Go:</p>
<pre class="code"><code class="go">func main(){
  err := doesReturnError()
  if err != nil {
    panic(err)
  }
}

func doesReturnError() error {
  err := errors.New("this function simply returns an error")
  return err
}
</code></pre>
</div>
<h4 id="function-with-undetermined-number-of-parameters">Función con un número indeterminado de parámetros</h4>
<div class="hBody-4">
<p>Las funciones se pueden declarar como <i>variadas</i>. Esto significa
 que su número de argumentos puede variar. Lo que hace es proporcionar
una matriz al alcance de la función que contiene los argumentos con los
que se invocó la función. Esto es conveniente si no desea obligar al
usuario a proporcionar una matriz al usar esta función. Por ejemplo:</p>
<pre class="code"><code class="go">func main() {
  fmt.Printf("%d\n", sum(1,2,3))
  fmt.Printf("%d\n", sum(4,5,6,7,8))
}

func sum(args ...int) (result int) {
  for _, v := range args {
    result += v
  }
  return
}
</code></pre>
<p>En este ejemplo, tenemos una función <code>sum</code> que devolverá la suma de todos sus argumentos, pero eche un vistazo más de cerca a la función <code>main</code> a la que llamamos <code>sum</code>. Como puede ver ahora, primero llamamos <code>sum</code> con tres argumentos y luego con cinco argumentos. Para las funciones <code>sum</code>, no importa cuántos argumentos pase, ya que trata sus argumentos como una matriz en total. Por lo tanto, en nuestra <code>sum</code> definición, simplemente iteramos sobre la matriz para agregar cada número al <code>result</code> entero.</p>
</div>
<h5 id="naming-returned-types">Nombrar tipos devueltos</h5>
<div class="hBody-5">
<p>¿Te has dado cuenta de que hemos dado un nombre al tipo devuelto? Por lo general, nuestra declaración se escribirá como, <code>func sum(args int) int</code>
 pero también puede nombrar la variable que usará dentro de la función
como un valor de retorno. Nombrar la variable en el tipo de retorno
también lo valoriza en cero (en este caso, un <code>int</code> se
inicializará como cero). Al final, solo necesita devolver la función
(sin valor) y tomará la variable respectiva del alcance como valor
devuelto. Esto también hace más fácil seguir la mutación que está
sufriendo la variable que regresa, así como también asegurarse de que no
 está devolviendo un argumento mutado.</p>
</div>
<h3 id="arrays,-slices,-and-maps">Arrays, slices y mapas</h3>
<div class="hBody-3">
<p>Las matrices son uno de los tipos de programación informática más
utilizados. Son listas de otros tipos a las que puede acceder utilizando
 su posición en la lista. El único inconveniente de una matriz es que su
 tamaño no se puede modificar. Las divisiones permiten el uso de
matrices con tamaño variable. El tipo <code>maps</code> nos permitirá tener un diccionario como estructuras en Go. Veamos cómo funciona cada uno.</p>
</div>
<h4 id="arrays">Arrays</h4>
<div class="hBody-4">
<p>Una matriz es una secuencia numerada de elementos de un solo tipo.
Puede almacenar 100 enteros diferentes sin signo en una variable única,
tres cadenas o 400 valores <code>bool</code>. Su tamaño no puede ser cambiado.</p>
<p>Debe declarar la longitud de la matriz en su creación, así como el
tipo. También puede asignar algún valor a la creación. Por ejemplo, aquí
 tienes 100 valores <code>int</code>, todos con un valor <code>0</code>:</p>
<pre class="code"><code class="go">var arr [100]int
</code></pre>
<p>O una matriz de tamaño 3 con <code>string</code>s ya asignado:</p>
<pre class="code"><code class="go">arr := [3]string{"go", "is", "awesome"}
</code></pre>
<p>Aquí tiene una matriz de 2 valores <code>bool</code> que inicializamos más adelante:</p>
<pre class="code"><code class="go">var arr [2]bool
arr[0] = true
arr[1] = false
</code></pre>
</div>
<h5 id="zero-initialization">Inicialización cero</h5>
<div class="hBody-5">
<p>En nuestro ejemplo anterior, hemos inicializado una <code>array</code> de valores <code>bool</code> de tamaño <code>2</code>. No tendríamos que asignar <code>arr[1]</code>a <code>false</code> causa de la naturaleza de cero inicialización en el idioma. Ir inicializará todos los valores de una <code>bool</code> matriz <code>false</code>. Vamos a mirar más a fondo a la inicialización cero más adelante en este capítulo.</p>
</div>
<h4 id="slices">Slices</h4>
<div class="hBody-4">
<p>Las divisiones son similares a las matrices, pero su tamaño se puede
modificar en tiempo de ejecución. Esto se logra gracias a la estructura
subyacente de una porción que es una matriz. Por lo tanto, al igual que
las matrices, debe especificar el tipo de sector y su tamaño. Por lo
tanto, use la siguiente línea para crear un segmento:</p>
<pre class="code"><code class="go">mySlice := make([]int, 10)
</code></pre>
<p>Este comando ha creado una matriz subyacente de diez elementos. Si
necesitamos cambiar el tamaño del segmento, por ejemplo, agregando un
nuevo número, agregamos el número al sector:</p>
<pre class="code"><code class="go">mySlice := append(mySlice, 5)
</code></pre>
<p>La sintaxis de append es de la forma ([matriz para anexar un elemento
 a], [elemento para agregar]) y devuelve la nueva porción, no modifica
la porción real. Esto también es cierto para eliminar un elemento. Por
ejemplo, borremos el primer elemento de la matriz de la siguiente
manera:</p>
<pre class="code"><code class="go">mySlice := mySlice[1:]
</code></pre>
<p>Sí, como en las matrices. Pero, ¿qué hay de eliminar el segundo elemento? Usamos la misma sintaxis:</p>
<pre class="code"><code class="go">mySlice = append(mySlice[:1], mySlice[2:]...)
</code></pre>
<p>Tomamos todos los elementos desde el índice cero (incluido) hasta el
primer índice (no incluido) y cada elemento desde el segundo índice
(incluido) hasta el final de la matriz, eliminando efectivamente el
valor en la segunda posición en el segmento (índice 1 como comenzamos a
contar con 0). Como puede ver, utilizamos la sintaxis de argumentos
indeterminados como el segundo parámetro.</p>
</div>
<h4 id="maps">Mapas</h4>
<div class="hBody-4">
<p>Los mapas son como diccionarios: para cada palabra, tenemos una
definición, pero podemos usar cualquier tipo como palabra o definición y
 nunca se ordenarán alfabéticamente. Podemos crear mapas de cadena que
apuntan a un número, una cadena que apunta a <em>las interfaces</em> y <em>estructuras</em> que apuntan a <code>int</code>y <code>int</code>a <em>funcionar</em>.
 No puede usar como clave: sectores, funciones y mapas. Finalmente, crea
 mapas usando la palabra clave make y especificando el tipo de clave y
el tipo de valor:</p>
<pre class="code"><code class="go">myMap := make(map[string]int)
myMap["one"] = 1
myMap["two"] = 2
fmt.Println(myMap["one"])
</code></pre>
<p>Al analizar contenido JSON, también puede usarlos para obtener un <code>string[interface]</code> mapa:</p>
<pre class="code"><code class="go">myJsonMap := make(map[string]interface{})
jsonData := []byte(`{"hello":"world"}`)
err := json.Unmarshal(jsonData, &amp;myJsonMap)
if err != nil {
  panic(err)
}
fmt.Printf("%s\n", myJsonMap["hello"])
</code></pre>
<p>La variable <code>myJsonMap</code> es un mapa que almacenará los contenidos de JSON y que tendremos que pasar su puntero a la función <code>Unmarshal</code>. La variable <code>jsonData</code>
 declara una matriz de bytes con el contenido típico de un objeto JSON;
estamos usando esto como el objeto simulado. Luego, deshacemos el
contenido de JSON almacenando el resultado de la ubicación de memoria de
 la variable <code>myJsonMap</code>. Después de comprobar que la
conversión era correcta y que el conjunto de bytes JSON no tenía errores
 de sintaxis, podemos acceder al contenido del mapa en una sintaxis
similar a JSON.</p>
</div>
<h3 id="visibility">Visibilidad</h3>
<div class="hBody-3">
<p>La visibilidad es el atributo de una función o una variable para ser
visible en diferentes partes del programa. Entonces, una variable solo
se puede usar en la función que se declara, en todo el paquete o en todo
 el programa.</p>
<p>¿Cómo puedo establecer la visibilidad de una variable o función?
Bueno, puede ser confuso al principio, pero no puede ser más simple:</p>
<ul>
<li>
<p>Las definiciones mayúsculas son públicas (visibles en todo el programa).</p>
</li>
<li>
<p>Las minúsculas son privadas (no se ven a nivel de paquete) y las
definiciones de funciones (variables dentro de las funciones) son
visibles solo en el alcance de la función.</p>
</li>
</ul>
<p>Aquí puede ver un ejemplo de una función <em>pública</em> :</p>
<pre class="code"><code class="go">package hello

func Hello_world(){
  println("Hello World!")
}
</code></pre>
<p>Aquí, <code>Hello_world</code> hay una función global (una función
que es visible en todo el código fuente y para los usuarios de terceros
de su código). Entonces, si se llama a nuestro paquete <code>hello</code>, podríamos llamar a esta función desde fuera de este paquete utilizando el método <code>hello.Hello_world()</code>.</p>
<pre class="code"><code class="go">package different_package

import "github.com/sayden/go-design-
  patters/first_chapter/hello"

func myLibraryFunc() {
  hello.Hello_world()
}
</code></pre>
<p>Como puede ver, estamos en el paquete <code>different_package</code>. Tenemos que importar el paquete que queremos usar con la palabra clave import. La ruta entonces es la ruta dentro de su <span class="file">$ GOPATH / src</span>
 que contiene el paquete que estamos buscando. Esta ruta coincide
convenientemente con la URL de una cuenta GitHub o cualquier otro
repositorio del <b>Sistema de Versiones Simultáneas</b> ( <span class="acronym">CVS</span> ).</p>
</div>
<h3 id="zero-initialization">Inicialización cero</h3>
<div class="hBody-3">
<p>La inicialización a cero es a veces una fuente de confusión. Son
valores predeterminados para muchos tipos que se asignan incluso si no
proporciona un valor para la definición. Los siguientes son la
inicialización cero para varios tipos:</p>
<ul>
<li>
<p>La <code>false</code> inicialización para tipo <code>bool</code>.</p>
</li>
<li>
<p>Usando valores <code>0</code> para tipo <code>int</code>.</p>
</li>
<li>
<p>Utilizando <code>0.0</code> para tipo <code>float</code>.</p>
</li>
<li>
<p>Usando <code>""</code>(cadenas vacías) para tipo <code>string</code>.</p>
</li>
<li>
<p>Uso de palabra clave <code>nil</code> para punteros, funciones, interfaces, sectores, canales y mapas.</p>
</li>
<li>
<p>Vacío <code>struct</code> para estructuras sin campos.</p>
</li>
<li>
<p>Puesta a cero inicializada <code>struct</code> para estructuras con
campos. El valor cero de una estructura se define como la estructura que
 tiene sus campos inicializados también como valor cero.</p>
</li>
</ul>
<p>La inicialización a cero es importante cuando se programa en Go porque no podrá devolver un valor <code>nil</code> si tiene que devolver un tipo <code>int</code> o a <code>struct</code>. Tenga esto en cuenta, por ejemplo, en las funciones donde debe devolver un valor <code>bool</code>. Imagine que desea saber si un número es divisible por un número diferente, pero pasa <code>0</code>(cero) como el divisor.</p>
<pre class="code"><code class="go">func main() {
  res := divisibleBy(10,0)
  fmt.Printf("%v\n", res)
}

func divisibleBy(n, divisor int) bool {
  if divisor == 0 {
    // You cannot divide by zero
    return false
  }

  return (n % divisor == 0)
}
</code></pre>
<p>La salida de este programa es <code>false</code> pero esto es
incorrecto. Un número dividido por cero es un error, no es que 10 no sea
 divisible por cero, sino que un número no puede dividirse por cero por
definición. La inicialización cero está haciendo las cosas difíciles en
esta situación. Entonces, ¿cómo podemos resolver este error? Considera
el siguiente código:</p>
<pre class="code"><code class="go">func main() {
  res, err := divisibleBy(10,0)
  if err != nil {
    log.Fatal(err)
  }

  log.Printf("%v\n", res)
}

func divisibleBy(n, divisor int) (bool, error) {
  if divisor == 0 {
    // You cannot divide by zero
    return false, errors.New("A number cannot be divided by zero")
  }

  return (n % divisor == 0), nil
}
</code></pre>
<p>Estamos dividiendo <code>10</code> de <code>0</code> nuevo, pero ahora la salida de esta función es <code>A number cannot be divided by zero</code>. Error capturado, el programa terminó con gracia.</p>
</div>
<h3 id="pointers-and-structures">Punteros y estructuras</h3>
<div class="hBody-3">
<p>Los punteros son la fuente principal de un dolor de cabeza de cada
programador C o C ++. Pero son una de las principales herramientas para
lograr un código de alto rendimiento en lenguajes no recogidos de
basura. Afortunadamente para nosotros, los indicadores de Go han logrado
 lo mejor de ambos mundos al proporcionar punteros de alto rendimiento
con capacidades y facilidad de recolección de basura.</p>
<p>Por otro lado, para sus detractores, Go carece de herencia en favor de la composición. En lugar de hablar sobre los objetos que <i>están</i> en Go, sus objetos <i>tienen otro</i>. Entonces, en lugar de tener una estructura <code>car</code> que hereda la clase <code>vehicle</code>(un automóvil es un vehículo), podrías tener una estructura <code>vehicle</code> que contenga una estructura <code>car</code> interna.</p>
</div>
<h4 id="what-is-a-pointer?-why-are-they-good?">¿Qué es un puntero? ¿Por qué son buenos?</h4>
<div class="hBody-4">
<p>Los punteros son odiados, amados y muy útiles al mismo tiempo.
Comprender qué puntero es puede ser difícil, así que intentemos con una
explicación del mundo real. Como mencionamos anteriormente en este
capítulo, un puntero es como un buzón. Imagina un montón de buzones en
un edificio; todos tienen el mismo tamaño y forma, pero cada uno se
refiere a una casa diferente dentro del edificio. El hecho de que todos
los buzones tengan el mismo tamaño no significa que cada casa tenga el
mismo tamaño. Incluso podríamos tener un par de casas unidas, una casa
que estaba allí pero ahora tiene una licencia de comercio, o una casa
que está completamente vacía. Entonces los punteros son los buzones,
todos del mismo tamaño y que se refieren a una casa. El edificio es
nuestra memoria y las casas son los tipos a los que se refieren nuestros
 indicadores y la memoria que asignan. Si quieres recibir algo en tu
casa, es mucho más fácil simplemente enviar la dirección de su casa
(para enviar el puntero) en lugar de enviar toda la casa para que su
paquete se deposite adentro. Pero tienen algunos inconvenientes, como si
 usted envíe su dirección y su casa (la variable a la que se refiere)
desaparece después del envío, o cambia el propietario de su tipo: usted
tendrá problemas.</p>
<p>¿Cómo es esto útil? Imagina que de alguna manera tienes 4 GB de datos
 en una variable y necesitas pasarlos a una función diferente. Sin un
puntero, toda la variable se clona al alcance de la función que va a
usarlo. Por lo tanto, tendrá 8 GB de memoria ocupados al usar esta
variable dos veces, con suerte, la segunda función no volverá a usarse
en una función diferente para elevar aún más este número.</p>
<p>Puede utilizar un puntero para pasar una referencia muy pequeña a
este fragmento a la primera función, de modo que solo se clone la
referencia pequeña y pueda mantener bajo el uso de la memoria.</p>
<p>Si bien esta no es la explicación más académica ni exacta, ofrece una
 buena visión de lo que es un puntero sin explicar qué es una pila o un
montón o cómo funcionan en las arquitecturas x86.</p>
<p>Los punteros en Go son muy limitados en comparación con los punteros C
 o C ++. No puede usar la aritmética del puntero ni puede crear un
puntero para hacer referencia a una posición exacta en la pila.</p>
<p>Los punteros en Go se pueden declarar así:</p>
<pre class="code"><code class="go">number := 5
</code></pre>
<p>Aquí el <code>number := 5</code>código representa nuestra variable de 4 GB y <code>pointer_to_number</code>
 contiene la referencia (representada por un símbolo comercial) a esta
variable. Es la dirección de la variable (la que pones en el buzón de
esta <span class="file">casa / tipo / variable</span> ). Vamos a imprimir la variable <code>pointer_to_number</code>, que es una variable simple:</p>
<pre class="code"><code class="go">println(pointer_to_number)
0x005651FA
</code></pre>
<p>¿Cuál es ese número? Bueno, la dirección de nuestra variable en la
memoria. ¿Y cómo puedo imprimir el valor real de la casa? Bueno, con un
asterisco (*) le decimos al compilador que tome el valor al que hace
referencia el puntero, que es nuestra variable de 4 GB.</p>
<pre class="code"><code class="go">println(*pointer_to_number)
5
</code></pre>
</div>
<h4 id="structs">Estructura</h4>
<div class="hBody-4">
<p>Una estructura es un objeto en Go. Tiene algunas similitudes con las
clases en OOP ya que tienen campos. Las estructuras pueden implementar
interfaces y declarar métodos. Pero, por ejemplo, en Go, no hay
herencia. La falta de herencia parece limitada, pero de hecho, la <i>composición sobre la herencia</i> era un requisito del idioma.</p>
<p>Para declarar una estructura, debe anteponer su nombre con la palabra clave <code>type</code>y el sufijo con la palabra clave <code>struct</code>y luego declarar cualquier campo o método entre paréntesis, por ejemplo:</p>
<pre class="code"><code class="go">type Person struct {
  Name string
  Surname string
  Hobbies []string
  id string
}
</code></pre>
<p>En este fragmento de código, hemos declarado una estructura <code>Person</code> con tres campos públicos ( <code>Name</code>, <code>Age</code>y <code>Hobbies</code>) y un campo privado ( <code>id</code> si usted recuerda la <i>visibilidad</i>
 sección de este capítulo, los campos minúsculas en Go se refiere a los
campos privados son sólo visibles dentro de la misma paquete). Con esto <code>struct</code>, ahora podemos crear tantas instancias <code>Person</code> como queramos. Ahora escribiremos una función llamada <code>GetFullName</code> que dará la composición del nombre y el apellido del <code>struct</code> que pertenece:</p>
<pre class="code"><code class="go">func (person *Person) GetFullName() string {
  return fmt.Sprintf("%s %s", person.Name, person.Surname)
}

func main() {
  p := Person{
    Name: "Mario",
    Surname: "Castro",
    Hobbies: []string{"cycling", "electronics", "planes"},
    id: "sa3-223-asd",
  }

  fmt.Printf("%s likes %s, %s and %s\n", p.GetFullName(),
    p.Hobbies[0], p.Hobbies[1], p.Hobbies[2])
}
</code></pre>
<p>Los métodos se definen de manera similar a las funciones, pero de una manera ligeramente diferente. Hay un ( <code>p *Person</code>) que hace referencia a un puntero a la instancia creada de <code>struct</code>(recuérdese la sección <i>Punteros</i> en este capítulo). Es como usar la palabra clave <code>this</code> en Java o <code>self</code> en Python al referirse al objeto que apunta.</p>
<p>Quizás esté pensando por qué does ( <code>p *Person</code>) tiene el operador del puntero para reflejar que en <code>p</code>
 realidad es un puntero y no un valor. Esto se debe a que también puede
pasar Person por valor eliminando la firma del puntero, en cuyo caso se
pasa una copia del valor de Person a la función. Esto tiene algunas
implicaciones, por ejemplo, cualquier cambio que realice <code>p</code> si lo pasa por valor no se reflejará en la fuente <code>p</code>. Pero, ¿qué hay de nuestro método <code>GetFullName()</code>?</p>
<pre class="code"><code class="go">func (person Person) GetFullName() string {
  return fmt.Sprintf("%s %s", person.Name, person.Surname)
}
</code></pre>
<p>La salida de la consola no tiene ningún efecto en la apariencia, pero
 se pasó una copia completa antes de evaluar la función. Pero si
modificamos <code>person</code> aquí, la fuente <code>p</code> no se verá afectada y el nuevo valor <code>person</code> estará disponible solo en el alcance de esta función.</p>
<p>En la función <code>main</code>, creamos una instancia de nuestra estructura llamada <code>p</code>. Como puede ver, hemos usado la notación implícita para crear la variable (el símbolo <code>:=</code>).
 Para configurar los campos, debe referirse al nombre del campo, dos
puntos, el valor y la coma (¡no olvide la coma al final!). Para acceder a
 los campos de la estructura instanciada, solo nos referimos a ellos por
 su nombre como <code>p.Name</code>o <code>p.Surname</code>. Utiliza la misma sintaxis para acceder a los métodos de la estructura como <code>p.GetFullName()</code>.</p>
<p>El resultado de este programa es:</p>
<pre class="srci"><code class="sh"><span class="in"><span class="prompt">&gt; </span>go run main.go
</span><span class="out">Mario Castro likes cycling, electronics and planes
</span></code></pre>
<p>Las estructuras también pueden contener otra estructura (composición)
 e implementar métodos de interfaz aparte de los propios, pero, ¿qué es
un método de interfaz?</p>
</div>
<h3 id="interfaces">Interfaces</h3>
<div class="hBody-3">
<p>Las interfaces son esenciales en la programación orientada a objetos, en la programación funcional ( <code>traits</code>)
 y, especialmente, en los patrones de diseño. El código fuente de Go
está lleno de interfaces en todas partes porque proporcionan la
abstracción necesaria para entregar código desacoplado con la ayuda de
funciones. Como programador, también necesita este tipo de abstracción
cuando escribe bibliotecas, pero también cuando escribe código que se
mantendrá en el futuro con nuevas funcionalidades.</p>
<p>Las interfaces son algo difícil de entender al principio, pero muy
fácil una vez que ha entendido su comportamiento y ofrece soluciones muy
 elegantes para problemas comunes. Los usaremos extensamente durante
este libro, así que pon atención especial en esta sección.</p>
</div>
<h4 id="interfaces---signing-a-contract">Interfaces: firma de un contrato</h4>
<div class="hBody-4">
<p>Una interfaz es algo realmente simple pero poderoso. Por lo general,
se define como un contrato entre los objetos que lo implementan, pero
esta explicación no es lo suficientemente clara en mi opinión honesta
para los recién llegados al mundo de la interfaz.</p>
<p>Una tubería de agua también es un contrato; lo que sea que atraviese
debe ser un líquido. Cualquiera puede usar la tubería, y la tubería
transportará cualquier líquido que coloques en ella (sin saber el
contenido). La tubería de agua es la interfaz que obliga a los usuarios a
 pasar líquidos (y no a otra cosa).</p>
<p>Pensemos en otro ejemplo: un tren. Los ferrocarriles de un tren son
como una interfaz. Un tren debe construir (implementar) su ancho con un
valor específico para que pueda ingresar al ferrocarril, pero el
ferrocarril nunca sabe exactamente lo que está transportando (pasajeros o
 carga). Entonces, por ejemplo, una interfaz del ferrocarril tendrá el
siguiente aspecto:</p>
<pre class="code"><code class="go">type RailroadWideChecker interface {
  CheckRailsWidth() int
}
</code></pre>
<p>El <code>RailroadWideChecker</code> es el tipo de nuestros trenes
deben poner en práctica para proporcionar información acerca de su
anchura. Los trenes verificarán que el tren no sea demasiado ancho ni
demasiado estrecho para usar sus ferrocarriles:</p>
<pre class="code"><code class="go">type Railroad struct {
  Width int
}

func (r *Railroad) IsCorrectSizeTrain(r RailRoadWideChecker)
bool {
  return r.CheckRailsWidth() != r.Width
}
</code></pre>
<p>El <code>Railroad</code> es implementado por un objeto de estación
imaginaria que contiene la información sobre el ancho de los
ferrocarriles en esta estación y que tiene un método para verificar si
un tren se ajusta a las necesidades del ferrocarril con el método <code>IsCorrectSizeTrain</code>. El método <code>IsCorrectSizeTrain</code>
 recibe un objeto de interfaz que es un puntero a un tren que implementa
 esta interfaz y devuelve una validación entre el ancho del tren y el
ferrocarril:</p>
<pre class="code"><code class="go">Type Train struct {
  TrainWidth int
}

func (p *Train) CheckRailsWidth() int {
  return p.TrainWidth
}
</code></pre>
<p>Ahora hemos creado un tren de pasajeros. Tiene un campo para contener su ancho e implementa nuestro método <code>CheckRailsWidth</code> de interfaz. Se considera que esta estructura satisface las necesidades de una <code>RailRoadWideChecker</code> interfaz (porque tiene una implementación de los métodos que las interfaces solicitan).</p>
<p>Así que ahora, crearemos un ferrocarril de <code>10</code> unidades de ancho y dos trenes, uno de <code>10</code> unidades de ancho que se ajuste al tamaño del ferrocarril y otro de <code>15</code> unidades que no puedan usar el ferrocarril.</p>
<pre class="code"><code class="go">func main(){
  railroad := Railroad{Width:10}

  passengerTrain := Train{TrainWidth: 10}
  cargoTrain := Train {TrainWidth: 15}

  canPassengerTrainPass := railroad.IsCorrectSizeTrain(passengerTrain)
  canCargoTrainPass := railroad.IsCorrectSizeTrain(cargoTrain)

  fmt.Printf("Can passenger train pass? %b\n", canPassengerTrainPass)
  fmt.Printf("Can cargo train pass? %b\n", canCargoTrainPass)
}
</code></pre>
<p>Analicemos esta función <code>main</code>. Primero, creamos un objeto ferroviario de <code>10</code> unidades llamado <code>railroad</code>. Luego dos trenes, de <code>10</code>y <code>15</code>
 ancho de unidades para pasajeros y carga respectivamente. Luego,
pasamos ambos objetos al método de ferrocarril que acepta las interfaces
 de la <code>RailroadWideChecker</code> interfaz. El ferrocarril en sí
no conoce el ancho de cada tren por separado (tendremos una gran lista
de trenes) pero tiene una interfaz que los trenes deben implementar para
 que pueda solicitar cada ancho y devuelva un valor que le diga si un
tren puede o no puede usar los ferrocarriles. Finalmente, el resultado
de la llamada a la función <code>printf</code> es el siguiente:</p>
<pre class="srci"><code class="sh"><span class="out">Can passenger train pass? true
Can cargo train pass? false
</span></code></pre>
<p>Como mencioné anteriormente, las interfaces son tan ampliamente
utilizadas durante este libro que no importa si todavía se ve confuso
para el lector, ya que serán muchos ejemplos durante el libro.</p>
</div>
<h3 id="testing-and-tdd">Pruebas y TDD</h3>
<div class="hBody-3">
<p>Cuando escribes las primeras líneas de alguna biblioteca, es difícil
introducir muchos errores. Pero una vez que el código fuente se vuelve
más y más grande, se vuelve más fácil romper las cosas. El equipo crece y
 ahora muchas personas escriben el mismo código fuente, se agrega una
nueva funcionalidad sobre el código que usted escribió al principio. Y
el código dejó de funcionar por alguna modificación en alguna función
que ahora nadie puede rastrear.</p>
<p>Este es un escenario común en las empresas que las pruebas intentan
reducir (no lo resuelve por completo, no es un santo grial). Cuando
escribe pruebas unitarias durante su proceso de desarrollo, puede
verificar si alguna característica nueva está rompiendo algo más antiguo
 o si su nueva característica actual está logrando todo lo esperado en
los requisitos.</p>
<p>Go tiene un potente paquete de prueba que también le permite trabajar
 en un entorno TDD con bastante facilidad. También es muy conveniente
verificar las partes de su código sin la necesidad de escribir una
aplicación principal completa que lo use.</p>
</div>
<h4 id="the-testing-package">El paquete de prueba</h4>
<div class="hBody-4">
<p>Las pruebas son muy importantes en todos los lenguajes de
programación. Los creadores de Go lo sabían y decidieron proporcionar
todas las bibliotecas y paquetes necesarios para la prueba en el paquete
 básico. No necesita ninguna biblioteca de terceros para pruebas o
cobertura de código.</p>
<p>El paquete que permite probar Go aplicaciones se llama,
convenientemente, testing. Creamos una pequeña aplicación que suma dos
números que proporcionamos a través de la línea de comando:</p>
<pre class="code"><code class="go">func main() {
  // Atoi converts a string to an int
  a, _ := strconv.Atoi(os.Args[1])
  b, _ := strconv.Atoi(os.Args[2])

  result := sum(a,b)
  fmt.Printf("The sum of %d and %d is %d\n", a, b, result)
}

func sum(a, b int) int {
  return a + b
}
</code></pre>
<p>Ejecutamos nuestro programa en la terminal para obtener la suma:</p>
<pre class="srci"><code class="sh"><span class="in"><span class="prompt">&gt; </span>go run main.go 3 4
</span><span class="out">The sum of 3 and 4 is 7
</span></code></pre>
<p>Por cierto, estamos usando el paquete <code>strconv</code> para convertir cadenas a otros tipos, en este caso, a <code>int</code>. El método <code>Atoi</code> recibe una cadena y devuelve un <code>int</code>y un <code>error</code> que, por simplicidad, estamos ignorando aquí (usando el guión bajo).</p>
<div class="about">
<div class="about-dt">Tip</div>
<div class="about-dd">
<p>Puede ignorar los retornos variables usando los guiones bajos si es necesario, pero generalmente no desea ignorar los errores.</p>
</div>
</div>
<p>Ok, entonces vamos a escribir una prueba que verifique el resultado
correcto de la suma. Estamos creando un nuevo archivo llamado <span class="file">main_test.go</span>. Por convención, los archivos de prueba se denominan como los archivos que están probando más el <code>_test</code> sufijo:</p>
<pre class="code"><code class="go">func TestSum(t *testing.T) {
  a := 5
  b := 6
  expected := 11

  res := sum(a, b)
  if res != expected {
    t.Errorf("Our sum function doens't work, %d+%d isn't %d\n", a, b, res)
  }
}
</code></pre>
<p>La prueba en Go se usa al escribir métodos iniciados con el prefijo <code>Test</code>, un nombre de prueba y la inyección del <code>testing.T</code> puntero llamado <code>t</code>.
 A diferencia de otros idiomas, no hay afirmaciones ni una sintaxis
especial para probar en Go. Puede usar la sintaxis de Go para buscar
errores y llamar <code>t</code> con información sobre el error en caso de que falle. Si el código llega al final de la función <code>Test</code> sin que surjan errores, la función ha pasado las pruebas.</p>
<p>Para ejecutar una prueba en Go, debe usar el comando <code class="command">go test -v</code> ( <code>-v</code> es para recibir una salida detallada de la prueba) palabra clave, de la siguiente manera:</p>
<pre class="srci"><code class="sh"><span class="in"><span class="prompt">&gt; </span>go test -v
</span><span class="out">=== RUN   TestSum
--- PASS: TestSum (0.00s)
PASS
ok   github.com/go-design-patterns/introduction/ex_xx_testing
0.001s
</span></code></pre>
<p>Nuestras pruebas fueron correctas. Veamos qué sucede si rompemos las
cosas a propósito y cambiamos el valor esperado de la prueba de <code>11</code>a <code>10</code>:</p>
<pre class="srci"><code class="sh"><span class="in"><span class="prompt">&gt; </span>go test
</span><span class="out">--- FAIL: TestSum (0.00s)
    main_test.go:12: Our sum function doens't work, 5+6 isn't
10
FAIL
exit status 1
FAIL  github.com/sayden/go-design-
patterns/introduction/ex_xx_testing 0.002s
</span></code></pre>
<p>La prueba ha fallado (como esperábamos). El paquete de prueba
proporciona la información que establece en la prueba. Hagamos que
funcione nuevamente y verifiquemos la cobertura de la prueba. Cambie el
valor de la variable <code>expected</code> de <code>10</code>a <code>11</code> nuevamente y ejecute el comando <code class="command">go test -cover</code> para ver la cobertura del código:</p>
<pre class="srci"><code class="sh"><span class="in"><span class="prompt">&gt; </span>go test -cover
</span><span class="out">PASS
coverage: 20.0% of statements
ok  github.com/sayden/go-design-
patterns/introduction/ex_xx_testing 0.001s
</span></code></pre>
<p>Las opciones <code>-cover</code> nos dan información sobre la
cobertura del código para un paquete determinado. Lamentablemente, no
proporciona información sobre la cobertura general de la aplicación.</p>
</div>
<h4 id="what-is-tdd?">Que es TDD?</h4>
<div class="hBody-4">
<p>TDD es el acrónimo de <b>Test Driven Development</b>. Consiste en
escribir las pruebas primero antes de escribir la función (en lugar de
lo que hicimos justo antes cuando escribimos la función <code>sum</code> primero y luego escribimos la función de prueba).</p>
<p>TDD cambia la forma de escribir código y código de estructura para
que pueda ser probado (una gran cantidad de código que puedes encontrar
en GitHub, incluso el código que probablemente has escrito en el pasado
es probablemente muy difícil, si no imposible, de probar).</p>
<p>¿Entonces, cómo funciona? Vamos a explicar esto con un ejemplo de la
vida real: imagina que estás en verano y quieres refrescarte de alguna
manera. Puedes construir un grupo, llenarlo con agua fría y saltar a él.
 Pero en términos de TDD, los pasos serán:</p>
<ol class="num">
<li>
<p>Saltas a un lugar donde se construirá la piscina (escribes una prueba que sabes que fallará).</p>
</li>
<li>
<p>Duele ... y tú tampoco eres bueno (sí ... la prueba falló, como predijimos).</p>
</li>
<li>
<p>Usted construye un grupo y lo llena con agua fría (usted codifica la funcionalidad).</p>
</li>
<li>
<p>Saltas al grupo (repites la prueba del punto 1 de nuevo).</p>
</li>
<li>
<p>Tienes frío ahora. ¡Increíble! Objeto completado (prueba aprobada).</p>
</li>
<li>
<p>Ve a la nevera y toma una cerveza a la piscina. Beber. Doble genialidad (refactorizar el código).</p>
</li>
</ol>
<p>Entonces, repitamos el ejemplo anterior pero con una multiplicación.
Primero, escribiremos la declaración de la función que vamos a probar:</p>
<pre class="code"><code class="go">func multiply(a, b int) int {
  return 0
}
</code></pre>
<p>Ahora vamos a escribir la prueba que verificará la corrección de la función anterior:</p>
<pre class="code"><code class="go">import "testing"

func TestMultiply(t *testing.T) {
  a := 5
  b := 6
  expected := 30

  res := multiply(a, b)
  if res != expected {
    t.Errorf("Our multiply function doens't work, %d*%d isn't %d\n", a, b, res)
  }
}
</code></pre>
<p>Y lo probamos a través de la línea de comando:</p>
<pre class="srci"><code class="sh"><span class="in"><span class="prompt">&gt; </span>go test
</span><span class="out">--- FAIL: TestMultiply (0.00s)
main_test.go:12: Our multiply function doens't work, 5+6 isn't
0
FAIL
exit status 1
FAIL    github.com/sayden/go-
designpatterns/introduction/ex_xx_testing/multiply

0.002s
</span></code></pre>
<ol class="alpha">
<li>
<p>Como en nuestro ejemplo de piscina donde el agua aún no estaba allí, nuestra</p>
</li>
</ol>
<p>la función también devuelve un valor incorrecto. Entonces ahora
tenemos una declaración de función (pero aún no está definida) y la
prueba falla. Ahora tenemos que hacer que pase la prueba escribiendo la
función y ejecutando la prueba para verificar:</p>
<pre class="code"><code class="go">func multiply(a, b int) int {
  return a*b
}
</code></pre>
<p>Y ejecutamos nuevamente nuestro conjunto de pruebas. Después de
escribir nuestro código correctamente, la prueba debe pasar para que
podamos continuar con el proceso de refracción:</p>
<pre class="code"><code class="go">&gt; go test
PASS
ok      github.com/sayden/go-design-
patterns/introduction/ex_xx_testing/multiply
0.001s
</code></pre>
<p>¡Estupendo! Hemos desarrollado la función <code>multiply</code>
después de TDD. Ahora debemos refactorizar nuestro código pero no
podemos hacerlo más simple o legible por lo que el ciclo se puede
considerar cerrado.</p>
<p>Durante este libro, escribiremos muchas pruebas que definen la
funcionalidad que queremos lograr en nuestros patrones. TDD promueve la
encapsulación y la abstracción (al igual que los patrones de diseño).</p>
</div>
<h3 id="libraries">Bibliotecas</h3>
<div class="hBody-3">
<p>Hasta ahora, la mayoría de nuestros ejemplos eran aplicaciones. Una aplicación se define por su función y paquete <code>main</code>.
 Pero con Go, también puedes crear bibliotecas puras. En las
bibliotecas, el paquete no necesita ser llamado main ni necesita la
función <code>main</code>.</p>
<p>Como las bibliotecas no son aplicaciones, no puede construir un archivo binario con ellas y necesita el paquete <code>main</code> que las va a usar.</p>
<p>Por ejemplo, creemos una biblioteca aritmética para realizar
operaciones comunes en enteros: sumas, restas, multiplicaciones y
divisiones. No vamos a entrar en muchos detalles sobre la implementación
 para centrarnos en las particularidades de las bibliotecas de Go:</p>
<pre class="code"><code class="go">package arithmetic

func Sum(args ...int) (res int) {
  for _, v := range args {
    res += v
  }
  return
}
</code></pre>
<p>Primero, necesitamos un nombre para nuestra biblioteca; establecemos
este nombre dando un nombre a todo el paquete. Esto significa que cada
archivo en esta carpeta debe tener también este nombre de paquete y el
grupo completo de archivos compone la biblioteca llamada <b>aritmética</b>
 también en este caso (porque solo contiene un paquete). De esta forma,
no necesitaremos referirnos a los nombres de archivo de esta biblioteca y
 proporcionar el nombre de la biblioteca y la ruta será suficiente para
importarla y usarla. Hemos definido una función <code>Sum</code> que toma todos los argumentos que necesita y que devolverá un entero que, durante el alcance de la función, se va a llamar <code>res</code>. Esto nos permite inicializar a 0 el valor que estamos devolviendo. Definimos un paquete (no el paquete <code>main</code>, sino uno de biblioteca) y lo llamamos<code>arithmetic</code>.
 Como se trata de un paquete de biblioteca, no podemos ejecutarlo
directamente desde la línea de comandos, así que tendremos que crear la
función <code>main</code> para él o un archivo de prueba de unidad. Para simplificar, crearemos una función <code>main</code> que ejecute algunas de las operaciones ahora, pero terminemos primero la biblioteca:</p>
<pre class="code"><code class="go">func Subtract(args ...int) int {
  if len(args) &lt; 2 {
    return 0
  }

  res := args[0]
  for i := 1; i &lt; len(args); i++ {
    res -= args[i]
  }
  return res
}
</code></pre>
<p>El <code>Subtraction</code>código devolverá 0 si el número de
argumentos es menor que cero y la resta de todos sus argumentos si tiene
 dos argumentos o más:</p>
<pre class="code"><code class="go">func Multiply(args ...int) int {
  if len(args) &lt; 2 {
    return 0
  }

  res := 1
  for i := 0; i &lt; len(args); i++ {
    res *= args[i]
  }
  return res
}
</code></pre>
<p>La función <code>Multiply</code> funciona de manera similar. Devuelve
 0 cuando los argumentos son menores que dos y la multiplicación de
todos sus argumentos cuando tiene dos o más. Finalmente, el <code>Division</code>código cambia un poco porque devolverá un error si lo pide dividido por cero:</p>
<pre class="code"><code class="go">func Divide(a, b int) (float64, error) {
  if b == 0 {
    return 0, errors.New("You cannot divide by zero")
  }
  return float64(a) / float64(b), nil
}
</code></pre>
<p>Así que ahora tenemos nuestra biblioteca terminada, pero necesitamos una función <code>main</code>
 para usarla ya que las bibliotecas no se pueden convertir a archivos
ejecutables directamente. Nuestra función principal es similar a la
siguiente:</p>
<pre class="code"><code class="go">package main

import (
  "fmt"

  "bitbucket.org/mariocastro/go-design-patterns/introduction/libraries/arithmetic"
)

func main() {
  sumRes := arithmetic.Sum(5, 6)
  subRes := arithmetic.Subtract(10, 5)
  multiplyRes := arithmetic.Multiply(8, 7)
  divideRes, _ := arithmetic.Divide(10, 2)

  fmt.Printf("5+6 is %d. 10-5 is %d, 8*7 is %d and 10/2 is %f\n",
    sumRes, subRes, multiplyRes, divideRes)
}
</code></pre>
<p>Estamos realizando una operación sobre cada función que hemos definido. Eche un vistazo más de cerca a la cláusula <code>import</code>. Está tomando la biblioteca que hemos escrito desde su carpeta dentro de la <code>$GOPATH</code> que coincide con su URL en <a href="https://bitbucket.org/">https://bitbucket.org/</a>.
 Luego, para usar cada una de las funciones definidas dentro de una
biblioteca, debe nombrar el nombre del paquete que la biblioteca tiene
antes de cada método.</p>
<div class="about">
<div class="about-dt">Nota</div>
<div class="about-dd">
<p>¿Te has dado cuenta de que hemos llamado a nuestras funciones con
mayúsculas? Debido a las reglas de visibilidad que hemos visto
anteriormente, las funciones exportadas en un paquete deben tener
nombres en mayúscula o no serán visibles fuera del alcance del paquete.
Entonces, con esta regla en mente, no puede llamar a una función o
variable en minúsculas dentro de un paquete y las llamadas de paquete
siempre estarán seguidas por nombres en mayúscula.</p>
</div>
</div>
<p>Recordemos, algunas convenciones de nombres sobre bibliotecas:</p>
<ul>
<li>
<p>Cada archivo en la misma carpeta debe contener el mismo nombre de
paquete. Los archivos no necesitan ser nombrados de ninguna manera
especial.</p>
</li>
<li>
<p>Una carpeta representa un nombre de paquete dentro de una biblioteca.
 El nombre de la carpeta se utilizará en las rutas de importación y no
es necesario que refleje el nombre del paquete (aunque se recomienda
para el paquete principal).</p>
</li>
<li>
<p>Una biblioteca es uno o más paquetes que representan un árbol que
usted importa por el padre de la carpeta de todos los paquetes.</p>
</li>
<li>
<p>Usted llama cosas dentro de una biblioteca por su nombre de paquete.</p>
</li>
</ul>
</div>
<h3 id="the-go-get-tool">La herramienta Go get</h3>
<div class="hBody-3">
<p>Go get es una herramienta para obtener proyectos de terceros de repositorios de CVS. En lugar de usar el comando <code class="command">git clone</code>, puede usar Go get para recibir una serie de beneficios adicionales. Vamos a escribir un ejemplo utilizando el proyecto <b>ETCD</b> de CoreOS, que es un famoso almacén de valores-clave distribuidos.</p>
<p>El ETCD de CoreOS está alojado en GitHub en <a href="https://github.com/coreos/etcd.git">https://github.com/coreos/etcd.git</a>.
 Para descargar este código fuente del proyecto mediante la herramienta
Ir a get, debemos escribir en el terminal la ruta de importación
resultante que tendrá en nuestro <code>GOPATH</code>:</p>
<pre class="srci"><code class="sh"><span class="in"><span class="prompt">&gt; </span>go get github.com/coreos/etcd
</span></code></pre>
<p>Tenga en cuenta que acabamos de tipear la información más relevante
para que Go get descubra el resto. Obtendrás algún resultado,
dependiendo del estado del proyecto, pero después, mientras,
desaparecerá. Pero, ¿qué pasó?</p>
<ul>
<li>
<p>Go get ha creado una carpeta en <span class="file">$ GOPATH / src / github.com / coreos</span>.</p>
</li>
<li>
<p>Ha clonado el proyecto en esa ubicación, por lo que ahora el código fuente de ETCD está disponible en <span class="file">$ GOPATH / src / github.com / coreos / etcd</span>.</p>
</li>
<li>
<p>Go get ha clonado cualquier repositorio que ETCD pueda necesitar.</p>
</li>
<li>
<p>Ha intentado instalar el proyecto si no es una biblioteca. Esto
significa que ha generado un archivo binario de ETCD y lo ha colocado en
 la <span class="file">carpeta $ GOPATH / bin</span>.</p>
</li>
</ul>
<p>Simplemente escribiendo el comando <code class="command">go get [project]</code>,
 obtendrá todo ese material de un proyecto en su sistema. Luego, en sus
aplicaciones Go, puede usar cualquier biblioteca importando la ruta
dentro de la fuente. Entonces, para el proyecto ETCD, será:</p>
<pre class="code"><code class="go">import "github.com/coreos/etcd"
</code></pre>
<p>Es muy importante que se familiarice con el uso de la herramienta Obtener y deje de usar <code class="command">git clone</code>
 cuando desee un proyecto de un repositorio de Git. Esto te ahorrará
algunos dolores de cabeza al tratar de importar un proyecto que no está
contenido dentro de ti <code>GOPATH</code>.</p>
</div>
<h3 id="managing-json-data">Administrando datos JSON</h3>
<div class="hBody-3">
<p>JSON es el acrónimo de <b>JavaScript Object Notation</b> y, como su
nombre lo indica, es nativamente JavaScript. Se ha vuelto muy popular y
es el formato más utilizado para la comunicación en la actualidad. Go
tiene un soporte muy bueno para la serialización / deserialización JSON
con el paquete <code>JSON</code> que hace la mayor parte del trabajo
sucio para usted. En primer lugar, hay dos conceptos para aprender
cuando se trabaja con JSON:</p>
<ul>
<li>
<p><b>Marshal</b>: cuando establece una instancia de una estructura u objeto, la convierte a su contraparte JSON.</p>
</li>
<li>
<p><b>Unmarshal</b>: cuando se están desmarcando algunos datos, en forma
 de una matriz de bytes, está tratando de convertir algunos datos
JSON-expected-to a una estructura u objeto conocido. También puede <i>desempaquetar</i> a una <code>map[string]interface{}</code> forma rápida pero no muy segura de interpretar los datos como lo veremos ahora.</p>
</li>
</ul>
<p>Veamos un ejemplo de ordenar una cadena:</p>
<pre class="code"><code class="go">import (
  "encoding/json"
  "fmt"
)

func main(){
  packt := "packt"
  jsonPackt, ok := json.Marshal(packt)
  if !ok {
    panic("Could not marshal object")
  }
  fmt.Println(string(jsonPackt))
}
</code></pre>
<pre class="srci"><code class="sh"><span class="in"><span class="prompt">&gt; </span>"pack"
</span></code></pre>
<p>Primero, hemos definido una variable llamada <code>packt</code> para contener el contenido de la cadena <code>packt</code>. Luego, hemos utilizado la <code>json</code> biblioteca para usar el <code>Marshal</code> comando con nuestra nueva variable. Esto devolverá un nuevo <code>bytearray</code> con el JSON y una bandera para proporcionar y el <code>boolOK</code>
 resultado para la operación. Cuando imprimimos el contenido de la
matriz de bytes (conversión previa a cadena) aparece el valor esperado.
Tenga en cuenta que <code>packt</code> apareció realmente entre comillas como sería la representación JSON.</p>
</div>
<h4 id="the-encoding-package">El paquete de codificación</h4>
<div class="hBody-4">
<p>¿Te has dado cuenta de que hemos importado el paquete <code>encoding/json</code>? ¿Por qué está prefijado con la palabra <code>encoding</code>? Si echas un vistazo al código fuente de Go en la carpeta <span class="file">&gt;src/encoding</span>, encontrarás muchos paquetes interesantes para codificar / decodificar, como XML, HEX, binario o incluso CSV.</p>
<p>Ahora algo un poco más complicado:</p>
<pre class="code"><code class="go">type MyObject struct {
  Number int `json:"number"`
  Word string
}

func main(){
  object := MyObject{5, "Packt"}
  oJson, _ := json.Marshal(object)
  fmt.Printf("%s\n", oJson)
}
</code></pre>
<pre class="srci"><code class="sh"><span class="out">{"Número": 5, "Palabra": "Packt"}
</span></code></pre>
<p>Convenientemente, también funciona bastante bien con las estructuras,
 pero ¿qué ocurre si no quiero utilizar mayúsculas en los datos JSON?
Puede definir el nombre de salida / entrada del JSON en la declaración
de estructura:</p>
<pre class="code"><code class="go">type MyObject struct {
  Number int
  Word string
}

func main(){
  object := MyObject{5, "Packt"}
  oJson, _ := json.Marshal(object)
  fmt.Printf("%s\n", oJson)
}
</code></pre>
<pre class="srci"><code class="sh"><span class="out">{"number": 5, "string": "Packt"}
</span></code></pre>
<p>No solo hemos puesto en minúscula los nombres de las teclas, sino que incluso hemos cambiado el nombre de la <code>Word</code> clave a cadena.</p>
<p>Ya basta de ordenar, recibiremos datos JSON como una matriz de bytes, pero el proceso es muy similar con algunos cambios:</p>
<pre class="code"><code class="go">type MyObject struct {
  Number int`json:"number"`
  Word string`json:"string"`
}

func main(){
  jsonBytes := []byte(`{"number":5, "string":"Packt"}`)
  var object MyObject
  err := json.Unmarshal(jsonBytes, &amp;object)
  if err != nil {
    panic(err)
  }
  fmt.Printf("Number is %d, Word is %s\n", object.Number, object.Word)
}
</code></pre>
<p>La gran diferencia aquí es que primero debe asignar el espacio para
la estructura (con un valor cero) y pasar la referencia al método <code>Unmarshal</code> para que intente llenarlo. Cuando lo utiliza <code>Unmarshal</code>,
 el primer parámetro es la matriz de bytes que contiene la información
JSON, mientras que el segundo parámetro es la referencia (es por eso que
 estamos usando un signo) en la estructura que queremos llenar.
Finalmente, usemos un método <code>map[string]interface{}</code> genérico para contener el contenido de un JSON:</p>
<pre class="code"><code class="go">type MyObject struct {
  Number int     `json:"number"`
  Word string    `json:"string"`
}

func main(){
  jsonBytes := []byte(`{"number":5, "string":"Packt"}`)
  var dangerousObject map[string]interface{}
  err := json.Unmarshal(jsonBytes, &amp;dangerousObject)
  if err != nil {
    panic(err)
  }

  fmt.Printf("Number is %d, ", dangerousObject["number"])
  fmt.Printf("Word is %s\n", dangerousObject["string"])
  fmt.Printf("Error reference is %v\n", dangerousObject["nothing"])
}
</code></pre>
<div class="example-block">
<pre class="example">&gt; El número es%! D (float64 = 5), Word es Packt
La referencia de error es &lt;nil&gt;
</pre>
</div>
<p>¿Qué pasó en el resultado? Es por eso que describimos el objeto como peligroso. Puede señalar una ubicación <code>nil</code>
 cuando usa este modo si llama a una clave no existente en el JSON. No
solo esto, como en el ejemplo, también podría interpretar un valor como <code>float64</code> cuando es simplemente un byte, desperdiciando mucha memoria. Así que recuerde utilizar <code>map[string]interface{}</code>
 cuando necesite un acceso rápido sucio a datos JSON que es bastante
simple y tiene bajo control el tipo de escenarios descritos
anteriormente.</p>
</div>
<h3 id="go-tools">Ir herramientas</h3>
<div class="hBody-3">
<p>Go viene con una serie de herramientas útiles para facilitar el
proceso de desarrollo todos los días. También en la página de golang de
GitHub, hay algunas herramientas que son compatibles con el equipo de Go
 pero no son parte del compilador.</p>
<p>La mayoría de los proyectos usan herramientas tales como <code class="command">gofmt</code>
 para que toda la base de código tenga un aspecto similar. Godoc nos
ayuda a encontrar información útil en la documentación de Go y el
comando <code class="command">goimport</code> de importar automáticamente los paquetes que estamos usando. Veámoslos.</p>
</div>
<h4 id="the-golint-tool">La herramienta golint</h4>
<div class="hBody-4">
<p>Un linter analiza el código fuente para detectar errores o mejoras. El <code class="command">golint</code> linter está disponible en <a href="https://github.com/golang/lint">https://github.com/golang/lint</a>
 para su instalación (no viene incluido con el compilador). Es muy fácil
 de usar y está integrado con algunos IDE que se ejecutarán cuando
guarde un archivo de código fuente (Atom o Sublime Text, por ejemplo).
¿Recuerdas el código implícito / explícito que ejecutamos cuando
hablamos de variables? Vamos a picarlo:</p>
<pre class="code"><code class="go">// Explicitly declaring a "string" variable
var explicit string = "Hello, I'm a explicitly declared variable"

// Implicitly declaring a "string".
Type inferred inferred := ", I'm an inferred variable "
</code></pre>
<pre class="srci"><code class="sh"><span class="in"><span class="prompt">&gt; </span>golint main.go
</span></code></pre>
<p>El <code>main.go:10:21:</code> comando debe omitir el tipo cadena de la declaración de la variable <code>explicitString</code>; se deducirá del lado derecho.</p>
<p>Nos dice que el compilador de Go deducirá realmente este tipo de
variable del código y no necesita declarar su tipo. ¿Qué pasa con el
tipo <code>Train</code> en la sección de interfaz?</p>
<pre class="code"><code class="go">Type Train struct {
  TrainWidth int
}
</code></pre>
<pre class="srci"><code class="sh"><span class="in"><span class="prompt">&gt; </span>golint main.go
</span></code></pre>
<p>El tipo <code>main.go:5:6:</code> de tipo exportado <code>train</code> debe tener un comentario o permanecer sin exportar.</p>
<p>en este caso, nos señala que un tipo público como el tipo <code>train</code> debe comentarse para que los usuarios puedan leer la documentación generada para conocer su comportamiento.</p>
</div>
<h4 id="the-gofmt-tool">la herramienta gofmt</h4>
<div class="hBody-4">
<p>la <code class="command">gofmt</code> herramienta viene incluida con
el compilador que ya tiene acceso a ella. Su propósito es proporcionar
un conjunto de sangrías, formateo, espaciado y algunas otras reglas para
 lograr un buen código de go. por ejemplo, tomemos el código de hello
world y hagámoslo un poco más extraño insertando espacios en todas
partes:</p>
<pre class="code"><code class="go">package main
func  main(){
  println("Hello World!")
}
</code></pre>
<pre class="srci"><code class="sh"><span class="in"><span class="prompt">&gt; </span>gofmt main.go
</span><span class="out">package main

func main() {
    println("Hello World!")
}
</span></code></pre>
<p>El comando <code class="command">gofmt</code> lo imprime correctamente de nuevo. Además, podemos usar la bandera <code>-w</code> para sobreescribir el archivo original:</p>
<pre class="srci"><code class="sh"><span class="in"><span class="prompt">&gt; </span>gofmt -w main.go
</span></code></pre>
<p>Y ahora tendremos nuestro archivo corregido correctamente.</p>
</div>
<h4 id="the-godoc-tool">La herramienta godoc</h4>
<div class="hBody-4">
<p>La documentación de Go está bastante extendida y es prolija. Puede
encontrar información detallada sobre cualquier tema que desee lograr.
La herramienta <code class="command">godoc</code> también le ayuda a
acceder a esta documentación directamente desde la línea de comandos.
Por ejemplo, podemos consultar el paquete <code>encoding/json</code>:</p>
<pre class="srci"><code class="sh"><span class="in"><span class="prompt">&gt; </span>godoc cmd/encoding/json
</span><span class="out">[...]
FUNCTIONS
func Compact(dst *bytes.Buffer, src []byte) error
Compact appends to dst the JSON-encoded src with insignificant
space
characters elided.
func HTMLEscape(dst *bytes.Buffer, src []byte)
[...]
</span></code></pre>
<p>También puede usar <code class="command">grep</code>, una utilidad
bash para Linux y Mac, para encontrar información específica sobre
alguna funcionalidad. Por ejemplo, usaremos grep para buscar texto que
mencione algo sobre el análisis de archivos JSON:</p>
<pre class="srci"><code class="sh"><span class="in"><span class="prompt">&gt; </span>godoc cmd/encoding/json | grep parse
</span></code></pre>
<p>El comando <code>Unmarshal</code> analiza los datos codificados JSON y almacena el resultado en el objeto que se analiza.</p>
<p>Una de las cosas que <code class="command">golint</code> advierte el
comando es usar el comienzo de un comentario con el mismo nombre de la
función que describe. De esta forma, si no recuerda el nombre de la
función que analiza JSON, puede usar <code>godoc</code> con <code class="command">grep</code>y
 buscar el análisis, por lo que el comienzo de la línea siempre será el
nombre de la función, como en el ejemplo que precede al comando <code>Unmarshal</code>.</p>
</div>
<h4 id="the-goimport-tool">La herramienta goimport</h4>
<div class="hBody-4">
<p>La herramienta <code class="command">goimport</code> es
imprescindible en Go. A veces recuerdas tus paquetes tan bien que no
necesitas buscar mucho para recordar su API, pero es más difícil
recordar el proyecto al que pertenecen cuando realizas la importación.
El comando <code class="command">goimport</code> lo ayuda buscando <code>$GOPATH</code> en las apariciones de un paquete que podría estar utilizando para proporcionarle la línea <code>import</code> del proyecto automáticamente. Esto es muy útil si configura su IDE para que se ejecute <code class="command">goimport</code>
 en el modo de guardar para que todos los paquetes utilizados en el
archivo de origen se importen automáticamente si los utilizó. También
funciona al revés: si elimina la función que estaba usando de un paquete
 y el paquete ya no se usa, eliminará la línea <code>import</code>.</p>
</div>
<h3 id="contributing-to-go-open-source-projects-in-github">Contribuir a proyectos de código abierto Go en GitHub</h3>
<div class="hBody-3">
<p>Una cosa importante para mencionar sobre el sistema de empaque Go es
que necesita tener una estructura de carpeta adecuada dentro de GOPATH.
Esto presenta un pequeño problema cuando se trabaja con proyectos de
GitHub. Estamos acostumbrados a bifurcar un proyecto, clonar nuestro
tenedor y comenzar a trabajar antes de comprometer la solicitud de
extracción del proyecto original. ¡Incorrecto!</p>
<p>Cuando organiza un proyecto, crea un nuevo repositorio en GitHub
dentro de su nombre de usuario. Si clonas este repositorio y comienzas a
 trabajar con él, ¡todas las nuevas referencias de importación en el
proyecto apuntarán a tu repositorio en lugar del original! Imagine el
siguiente caso en el repositorio original:</p>
<pre class="code"><code class="go">package main
import "github.com/original/a_library"
[some code]
</code></pre>
<p>Luego, crea un tenedor y agrega una subcarpeta con una biblioteca llamada <code>a_library/my_library</code> que desea usar del paquete principal. El resultado será el siguiente:</p>
<pre class="code"><code class="go">package main
import (
  "github.com/original/a_library"
  "github.com/myaccount/a_library/my_library"
)
</code></pre>
<p>Ahora, si compromete esta línea, el repositorio original que contiene
 el código que ha enviado volverá a descargar este código de su cuenta y
 utilizará las referencias descargadas. ¡No los que están en el
proyecto!</p>
<p>Entonces, la solución a esto es simplemente reemplazar el comando git clone con un <code class="command">go get</code> puntero a la biblioteca original:</p>
<pre class="srci"><code class="sh"><span class="in"><span class="prompt">&gt; </span>go get github.com/original/a_library
</span><span class="in"><span class="prompt">&gt; </span>cd $GOPATH/src/github.com/original/a_library
</span><span class="in"><span class="prompt">&gt; </span>git remote add my_origin
</span><span class="out">https://github.com/myaccount/a_libbrary
</span></code></pre>
<p>Con esta modificación, puede trabajar normalmente en el código
original sin temor ya que las referencias se mantendrán correctas. Una
vez que haya terminado, solo tiene que comprometerse y presionar a su
control remoto.</p>
<pre class="srci"><code class="sh"><span class="in"><span class="prompt">&gt; </span>git push my_origin my_brach
</span></code></pre>
<p>De esta forma, ahora puede acceder a la interfaz de usuario web de
GitHub y abrir la solicitud de extracción sin contaminar el código
original con referencias a su cuenta.</p>
</div>
<h3 id="summary">Resumen</h3>
<div class="hBody-3">
<p>Después de este primer capítulo, debe estar familiarizado con la
sintaxis de Go y algunas de las herramientas de línea de comandos que
vienen incluidas con el compilador. Hemos dejado aparte capacidades de
concurrencia para un capítulo posterior, ya que son grandes y bastante
complejo de entender al principio para que el lector se entera de la
sintaxis de la lengua primera, se vuelve familiar y confiado con él, y
luego se puede saltar a la comprensión <b>comunicación secuencial</b> Patrones de simultaneidad de <b>procesos</b> ( <span class="acronym">CSP</span> ) y aplicaciones distribuidas. Los próximos pasos son comenzar con los patrones de diseño creacional.</p>
</div>
<h2 id="chapter-2">Patrones de creación: Singleton, Builder, Factory, Prototype y Abstract Factory Patrones de diseño</h2>
<div class="hBody-2">
<p>Hemos definido dos tipos de automóviles: lujo y familia. La fábrica
de automóviles tendrá que regresar Los primeros grupos de patrones de
diseño que vamos a cubrir son los patrones de Creación. Como su nombre
lo indica, agrupa prácticas comunes para la creación de objetos, por lo
que la creación de objetos está más encapsulada de los usuarios que
necesitan esos objetos. Principalmente, los patrones de creación
intentan dar objetos listos para usar a los usuarios en lugar de
solicitar su creación, que, en algunos casos, podría ser compleja, o que
 relacionaría su código con las implementaciones concretas de la
funcionalidad que debería definirse en una interfaz.</p>
</div>
<h3 id="singleton-design-pattern---having-a-unique-instance-of-a-type-in-the-entire-program">Patrón de diseño de Singleton: tener una instancia única de un tipo en todo el programa</h3>
<div class="hBody-3">
<p>¿Alguna vez has hecho entrevistas para ingenieros de software? Es
interesante que cuando les preguntas sobre los patrones de diseño, más
del 80% mencione el patrón de diseño de <b>Singleton</b>. ¿Porqué es
eso? Tal vez sea porque es uno de los patrones de diseño más utilizados o
 uno de los más fáciles de comprender. Comenzaremos nuestro viaje en
patrones de diseño creacional debido a la última razón.</p>
</div>
<h4 id="description">Descripción</h4>
<div class="hBody-4">
<p>El patrón de Singleton es fácil de recordar. Como su nombre lo
indica, le proporcionará una instancia única de un objeto y le
garantizará que no haya duplicados.</p>
<p>En la primera llamada para usar la instancia, se crea y luego se
reutiliza entre todas las partes de la aplicación que necesitan usar ese
 comportamiento particular.</p>
<p>Utilizará el patrón de Singleton en muchas situaciones diferentes. Por ejemplo:</p>
<ul>
<li>
<p>Cuando desee usar la misma conexión a una base de datos para realizar cada consulta</p>
</li>
<li>
<p>Cuando abre una <b>conexión de Secure Shell</b> ( <span class="acronym">SSH</span> ) a un servidor para realizar algunas tareas y no desea volver a abrir la conexión para cada tarea</p>
</li>
<li>
<p>Si necesita limitar el acceso a alguna variable o espacio, use un
Singleton como la puerta a esta variable (veremos en los siguientes
capítulos que esto es más factible en Ir usando canales de todos modos)</p>
</li>
<li>
<p>Si necesita limitar el número de llamadas a algunos lugares, cree una
 instancia Singleton para realizar las llamadas en la ventana aceptada.</p>
</li>
</ul>
<p>Las posibilidades son infinitas, y acabamos de mencionar algunas de ellas.</p>
</div>
<h4 id="objectives">Objetivos</h4>
<div class="hBody-4">
<p>Como guía general, consideramos usar el patrón de Singleton cuando se aplica la siguiente regla:</p>
<ul>
<li>
<p>Necesitamos un único valor compartido de algún tipo en particular.</p>
</li>
<li>
<p>Necesitamos restringir la creación de objetos de algún tipo a una sola unidad a lo largo de todo el programa.</p>
</li>
</ul>
</div>
<h4 id="example---a-unique-counter">Ejemplo: un contador único</h4>
<div class="hBody-4">
<p>Como ejemplo de un objeto del cual debemos asegurarnos de que solo
hay una instancia, escribiremos un contador que contiene el número de
veces que se ha llamado durante la ejecución del programa. No importa
cuántas instancias tengamos del contador, todas ellas deben <i>contar</i> el mismo valor y deben ser consistentes entre las instancias.</p>
</div>
<h4 id="requirements-and-acceptance-criteria">Requisitos y criterios de aceptación</h4>
<div class="hBody-4">
<p>Hay algunos requisitos y criterios de aceptación para escribir el contador único descrito. Ellos son los siguientes:</p>
<ul>
<li>
<p>Cuando no se ha creado ningún contador, se crea uno nuevo con el valor 0</p>
</li>
<li>
<p>Si ya se ha creado un contador, devuelve esta instancia que contiene el conteo real</p>
</li>
<li>
<p>Si llamamos al método <code>AddOne</code>, el recuento debe incrementarse en 1</p>
</li>
</ul>
<p>Tenemos un escenario con tres pruebas para verificar nuestras pruebas unitarias.</p>
</div>
<h4 id="writing-unit-tests-first">Pruebas de unidad de escritura primero</h4>
<div class="hBody-4">
<p>La implementación de Go de este patrón es ligeramente diferente de lo
 que encontrará en los lenguajes puros orientados a objetos, como Java o
 C ++, donde tiene miembros estáticos. En Go, no hay nada como miembros
estáticos, pero tenemos el alcance del paquete para ofrecer un resultado
 similar.</p>
<p>Para configurar nuestro proyecto, debemos crear una nueva carpeta dentro de nuestro directorio <span class="file">$ GOPATH / src</span>. La regla general, como mencionamos en el <a href="https://nasciiboy.github.io/book4all/Go%20Design%20Patterns.html#chapter-1">Capítulo 1</a> ( <i>Listo ... ¡Firme ... Adelante!</i> ), Es crear una subcarpeta con el proveedor de VCS (como GitHub), el nombre de usuario y el nombre del proyecto.</p>
<p>Por ejemplo, en mi caso, uso GitHub como mi VCS y mi nombre de usuario es <i>sayden,</i> así que crearé la ruta <code>$GOPATH/src/github.com/sayden/go-design-patterns/creational/singleton</code>. La <code>go-design-patterns</code>
 instancia en la ruta es el nombre del proyecto, la subcarpeta
creacional también será nuestro nombre de biblioteca y el nombre de este
 paquete y subcarpeta en particular:</p>
<pre class="code"><code class="sh">mkdir -p $GOPATH/src/github.com/sayden/go-design-patterns/creational/singleton
cd $GOPATH/src/github.com/sayden/go-design-patterns/creational/singleton
</code></pre>
<p>Cree un nuevo archivo dentro de la carpeta singleton llamada <span class="file">singleton.go</span> para reflejar también el nombre del paquete y escriba las siguientes declaraciones de paquete para el tipo <code>singleton</code>:</p>
<pre class="code"><code class="go">package singleton

type Singleton interface {
  AddOne() int
}

type singleton struct {
  count int
}

var instance *singleton

func GetInstance() Singleton {
  return nil
}
func (s *singleton) AddOne() int {
  return 0
}
</code></pre>
<p>Como estamos siguiendo un enfoque TDD mientras escribimos el código,
codifiquemos las pruebas que usan las funciones que acabamos de
declarar. Las pruebas se definirán siguiendo los criterios de aceptación
 que hemos escrito anteriormente. Por convención en archivos de prueba,
debemos crear un archivo con el mismo nombre que el archivo para probar,
 con el sufijo <span class="file">_test.go</span>. Ambos deben residir en la misma carpeta:</p>
<pre class="code"><code class="go">package singleton

import "testing"

func TestGetInstance(t *testing.T) {
  counter1 := GetInstance()

  if counter1 == nil {
    // Test of acceptance criteria 1 failed
    t.Error("expected pointer to Singleton after calling GetInstance(), not nil")
  }

  expectedCounter := counter1
}
</code></pre>
<p>La primera prueba comprueba algo obvio, pero no menos importante, en
aplicaciones complejas. De hecho, recibimos algo cuando pedimos una
instancia del contador. Tenemos que pensarlo como un patrón de Creación:
 delegamos la creación del objeto a un paquete desconocido que podría
fallar en la creación o recuperación del objeto. También almacenamos el
contador actual en la variable <code>expectedCounter</code> para hacer una comparación más adelante:</p>
<pre class="code"><code class="go">currentCount := counter1.AddOne()
if currentCount != 1 {
  t.Errorf("After calling for the first time to count, the count must be 1 but it is %d\n", currentCount)
}
</code></pre>
<p>Ahora aprovechamos la función de inicialización cero de Go. Recuerde
que los tipos enteros en Go no pueden ser nulos y, como sabemos, esta es
 la primera llamada al contador, y es un tipo entero de variable, y
también sabemos que tiene cero inicialización. Entonces, después de la
primera llamada a la función <code>AddOne()</code>, el valor del conteo debe ser 1.</p>
<p>La prueba que verifica la segunda condición demuestra que la variable <code>expectedConnection</code> no es diferente a la conexión devuelta que solicitamos más adelante. Si fueran diferentes, el mensaje <code>Singleton instances must be different</code> hará que la prueba falle:</p>
<pre class="code"><code class="go">counter2 := GetInstance()
if counter2 != expectedCounter {
  // Test 2 failed
  t.Error("Expected same instance in counter2 but it got a different instance")
}
</code></pre>
<p>La última prueba es simplemente contar 1 nuevamente con la segunda
instancia. El resultado anterior fue 1, por lo que ahora debe darnos 2:</p>
<pre class="code"><code class="go">currentCount = counter2.AddOne()
if currentCount != 2 {
  t.Errorf("After calling 'AddOne' using the second counter, the current count must be 2 but was %d\n", currentCount)
}
</code></pre>
<p>Lo último que tenemos que hacer para finalizar nuestra prueba es
ejecutar las pruebas para asegurarnos de que están fallando antes de la
implementación. Si uno de ellos no falla, implica que hemos hecho algo
mal, y tenemos que reconsiderar esa prueba en particular. Debemos abrir
la terminal y navegar a la ruta del paquete singleton para ejecutar:</p>
<pre class="srci"><code class="sh"><span class="in"><span class="prompt">&gt; </span>go test -v .
</span><span class="out">=== RUN   TestGetInstance
--- FAIL: TestGetInstance (0.00s)
        singleton_test.go:9: expected pointer to Singleton
after calling GetInstance(), not nil
        singleton_test.go:15: After calling for the first time
to count, the count must be 1 but it is 0
        singleton_test.go:27: After calling 'AddOne' using the
second counter, the current count must be 2 but was 0
FAIL
exit status 1
FAIL
</span></code></pre>
</div>
<h4 id="implementation">Implementación</h4>
<div class="hBody-4">
<p>Finalmente, tenemos que implementar el patrón de Singleton. Como mencionamos anteriormente, generalmente escribiremos un método <code>static</code> e instancia para recuperar la instancia de Singleton en lenguajes como Java o C ++. En Go, no tenemos la palabra clave <code>static</code>, pero podemos lograr el mismo resultado utilizando el alcance del paquete. Primero, creamos un <code>struct</code> archivo que contiene el objeto que queremos garantizar como Singleton durante la ejecución del programa:</p>
<pre class="code"><code class="go">package creational

type singleton struct{
  count int
}

var instance *singleton

func GetInstance() *singleton {
  if instance == nil {
    instance = new(singleton)
  }
  return instance
}

func (s *singleton) AddOne() int {
  s.count++
  return s.count
}
</code></pre>
<p>Debemos prestar mucha atención a esta pieza de código. En idiomas
como Java o C ++, la instancia variable se inicializaría a NULL al
comienzo del programa. En Go, puede inicializar un puntero a una
estructura como <code>nil</code>, pero no puede inicializar una estructura <code>nil</code>(el equivalente de NULL). Entonces la línea <code>var instance *singleton</code> define un puntero a una estructura de tipo Singleton como nil, y la variable llamada <code>instance</code>.</p>
<p>Creamos un método <code>GetInstance</code> que verifica si la instancia no se ha inicializado ya ( <code>instance == nil</code>) y crea una instancia en el espacio ya asignado en la línea <code>instance = new(singleton)</code>. Recuerde, cuando usamos la palabra clave <code>new</code>, estamos creando un puntero a una instancia del tipo entre paréntesis.</p>
<p>El método <code>AddOne</code> tomará el recuento de la instancia
variable, la aumentará en 1 y devolverá el valor actual del contador.
Corramos ahora nuestras pruebas unitarias nuevamente:</p>
<pre class="srci"><code class="sh"><span class="in"><span class="prompt">&gt; </span>go test -v -run=GetInstance
</span><span class="out">=== RUN   TestGetInstance
--- PASS: TestGetInstance (0.00s)
PASS
ok
</span></code></pre>
</div>
<h4 id="a-few-words-about-the-singleton-design-pattern">Algunas palabras sobre el patrón de diseño de Singleton</h4>
<div class="hBody-4">
<p>Hemos visto un ejemplo muy simple del patrón de Singleton,
parcialmente aplicado a alguna situación, es decir, un contador simple.
Solo tenga en cuenta que el patrón de Singleton le dará el poder de
tener una instancia única de alguna estructura en su aplicación y que
ningún paquete puede crear ningún clon de esta estructura.</p>
<p>Con Singleton, también está ocultando la complejidad de crear el
objeto, en caso de que requiera algún cálculo, y la trampa de crearlo
cada vez que necesite una instancia si todos son similares. Toda esta
escritura de código, verificando si la variable ya existe, y el
almacenamiento, están encapsulados en el singleton y no necesitará
repetirlo en todas partes si usa una variable global.</p>
<p>Aquí estamos aprendiendo la implementación clásica de singleton para
el contexto de un solo hilo. Veremos una implementación concurrente
única cuando lleguemos a los capítulos sobre concurrencia porque esta
implementación no es segura para subprocesos.</p>
</div>
<h3 id="builder-design-pattern---reusing-an-algorithm-to-create-many-implementations-of-an-interface">Patrón de diseño del generador: reutilización de un algoritmo para crear muchas implementaciones de una interfaz</h3>
<div class="hBody-3">
<p>Al hablar sobre los patrones de diseño de <b>Creational</b>, parece bastante semántico tener un patrón de diseño de <b>Builder</b>.
 El patrón Builder nos ayuda a construir objetos complejos sin
instanciar directamente su estructura o escribir la lógica que
requieren. Imagine un objeto que podría tener docenas de campos que son
estructuras más complejas. Ahora imagina que tienes muchos objetos con
estas características, y podrías tener más. No queremos escribir la
lógica para crear todos estos objetos en el paquete que solo necesita
usar los objetos.</p>
</div>
<h4 id="description">Descripción</h4>
<div class="hBody-4">
<p>La creación de instancias puede ser tan simple como proporcionar las llaves de apertura y cierre <code>{}</code>y
 dejar la instancia con valores cero, o tan complejo como un objeto que
necesita hacer algunas llamadas a la API, verificar estados y crear
objetos para sus campos. También podría tener un objeto compuesto por
muchos objetos, algo que es realmente idiomático en Go, ya que no admite
 la herencia.</p>
<p>Al mismo tiempo, podría estar usando la misma técnica para crear
muchos tipos de objetos. Por ejemplo, usarás casi la misma técnica para
construir un automóvil que construir un autobús, excepto que serán de
diferentes tamaños y número de asientos, entonces, ¿por qué no
reutilizamos el proceso de construcción? Aquí es donde el patrón Builder
 viene al rescate.</p>
</div>
<h4 id="objectives">Objetivos</h4>
<div class="hBody-4">
<p>Un patrón de diseño de Builder intenta:</p>
<ul>
<li>
<p>Creaciones complejas abstractas para que la creación de objetos esté separada del usuario del objeto</p>
</li>
<li>
<p>Cree un objeto paso a paso llenando sus campos y creando los objetos incrustados</p>
</li>
<li>
<p>Reutilice el algoritmo de creación de objetos entre muchos objetos</p>
</li>
</ul>
</div>
<h4 id="example---vehicle-manufacturing">Ejemplo: fabricación de vehículos</h4>
<div class="hBody-4">
<p>El patrón de diseño de Builder ha sido comúnmente descrito como la
relación entre un director, unos pocos constructores y el producto que
construyen. Continuando con nuestro ejemplo del automóvil, crearemos un
generador de vehículos. El proceso (ampliamente descrito como el
algoritmo) de crear un vehículo (el producto) es más o menos el mismo
para cada tipo de vehículo: elija el tipo de vehículo, ensamble la
estructura, coloque las ruedas y coloque los asientos. Si lo piensas
bien, puedes construir un automóvil y una motocicleta (dos
Constructores) con esta descripción, por lo que estamos reutilizando la
descripción para crear automóviles en la fabricación. El director está
representado por el tipo <code>ManufacturingDirector</code> en nuestro ejemplo.</p>
</div>
<h4 id="requirements-and-acceptance-criteria">Requisitos y criterios de aceptación</h4>
<div class="hBody-4">
<p>Por lo que hemos descrito, debemos deshacernos de un Constructor de tipo Auto <code>Motorbike</code>y un único director llamado <code>ManufacturingDirector</code> para tomar constructores y construir productos. Entonces los requisitos para un <code>Vehicle</code> ejemplo de constructor serían los siguientes:</p>
<ul>
<li>
<p>Debo tener un tipo de fabricación que construye todo lo que un vehículo necesita</p>
</li>
<li>
<p>Al usar un constructor de automóviles, <code>VehicleProduct</code> con cuatro ruedas, cinco asientos y una estructura definida como <code>Car</code> debe ser devuelta</p>
</li>
<li>
<p>Al usar un constructor de motocicletas, <code>VehicleProduct</code> con dos ruedas, dos asientos y una estructura definida como <code>Motorbike</code> debe ser devuelta</p>
</li>
<li>
<p>Un <code>VehicleProduct</code> construido por cualquier constructor <code>BuildProcess</code> debe estar abierto a modificaciones</p>
</li>
</ul>
</div>
<h4 id="unit-test-for-the-vehicle-builder">Prueba de unidad para el constructor de vehículos</h4>
<div class="hBody-4">
<p>Con los criterios de aceptación anteriores, crearemos una variable de director, el tipo <code>ManufacturingDirector</code>,
 para usar los procesos de compilación representados por las variables
del generador de productos para un automóvil y una motocicleta. El
director es el encargado de la construcción de los objetos, pero los
constructores son los que devuelven el vehículo real. Entonces nuestra
declaración del constructor se verá de la siguiente manera:</p>
<pre class="code"><code class="go">package creational

type BuildProcess interface {
  SetWheels() BuildProcess
  SetSeats() BuildProcess
  SetStructure() BuildProcess
  GetVehicle() VehicleProduct
}
</code></pre>
<p>Esta interfaz anterior define los pasos que son necesarios para construir un vehículo. Todo constructor debe implementar esto <code>interface</code> si van a ser utilizados por la fabricación. En cada paso del <em>Conjunto</em>,
 devolvemos el mismo proceso de compilación, de modo que podemos
encadenar varios pasos juntos en la misma declaración, como veremos más
adelante. Finalmente, necesitaremos un método <code>GetVehicle</code> para recuperar la <code>Vehicle</code> instancia del constructor:</p>
<pre class="code"><code class="go">type ManufacturingDirector struct {}

func (f *ManufacturingDirector) Construct() {
  // Implementation goes here
}

func (f *ManufacturingDirector) SetBuilder(b BuildProcess) {
  // Implementation goes here
}
</code></pre>
<p>La variable <code>ManufacturingDirector</code> directora es la encargada de aceptar a los constructores. Tiene un método <code>Construct</code> que utilizará el generador que está almacenado <code>Manufacturing</code>y reproducirá los pasos necesarios. El método <code>SetBuilder</code> nos permitirá cambiar el constructor que se está utilizando en el <code>Manufacturing</code> director:</p>
<pre class="code"><code class="go">type VehicleProduct struct {
  Wheels    int
  Seats     int
  Structure string
}
</code></pre>
<p>El producto es el objeto final que queremos recuperar al usar la
fabricación. En este caso, un vehículo se compone de ruedas, asientos y
una estructura:</p>
<pre class="code"><code class="go">type CarBuilder struct {}

func (c *CarBuilder) SetWheels() BuildProcess {
  return nil
}

func (c *CarBuilder) SetSeats() BuildProcess {
  return nil
}

func (c *CarBuilder) SetStructure() BuildProcess {
  return nil
}

func (c *CarBuilder) Build() VehicleProduct {
  return VehicleProduct{}
}
</code></pre>
<p>El primer constructor es el constructor <code>Car</code>. Debe implementar todos los métodos definidos en la interfaz <code>BuildProcess</code>. Aquí es donde estableceremos la información para este constructor en particular:</p>
<pre class="code"><code class="go">type BikeBuilder struct {}

func (b *BikeBuilder) SetWheels() BuildProcess {
  return nil
}

func (b *BikeBuilder) SetSeats() BuildProcess {
  return nil
}

func (b *BikeBuilder) SetStructure() BuildProcess {
  return nil
}

func (b *BikeBuilder) Build() VehicleProduct {
  return VehicleProduct{}
}
</code></pre>
<p>La estructura <code>Motorbike</code> debe ser la misma que la estructura <code>Car</code>,
 ya que todas son implementaciones de Builder, pero tenga en cuenta que
el proceso de construcción de cada una puede ser muy diferente. Con esta
 declaración de objetos, podemos crear las siguientes pruebas:</p>
<pre class="code"><code class="go">package creational

import "testing"

func TestBuilderPattern(t *testing.T) {
  manufacturingComplex := ManufacturingDirector{}

  carBuilder := &amp;CarBuilder{}
  manufacturingComplex.SetBuilder(carBuilder)
  manufacturingComplex.Construct()

  car := carBuilder.Build()

  // code continues here...
</code></pre>
<p>Comenzaremos con el <code>Manufacturing</code> director y el constructor <code>Car</code> para cumplir los primeros dos criterios de aceptación. En el código anterior, estamos creando nuestro <code>Manufacturing</code> director que estará a cargo de la creación de cada vehículo durante la prueba. Después de crear el <code>Manufacturing</code> director, creamos un <code>CarBuilder</code> que luego pasamos a fabricación utilizando el método <code>SetBuilder</code>. Una vez que el <code>Manufacturing</code> director sabe lo que tiene que construir ahora, podemos llamar al método <code>Construct</code> para crear el <code>VehicleProduct</code> uso <code>CarBuilder</code>. Finalmente, una vez que tenemos todas las piezas para nuestro automóvil, llamamos al método <code>GetVehicle</code> <code>CarBuilder</code> para recuperar una <code>Car</code> instancia:</p>
<pre class="code"><code class="go">if car.Wheels != 4 {
  t.Errorf("Wheels on a car must be 4 and they were %d\n", car.Wheels)
}

if car.Structure != "Car" {
  t.Errorf("Structure on a car must be 'Car' and was %s\n", car.Structure)
}

if car.Seats != 5 {
  t.Errorf("Seats on a car must be 5 and they were %d\n", car.Seats)
}
</code></pre>
<p>Hemos escrito tres pruebas pequeñas para verificar si el resultado es
 un automóvil. Comprobamos que el automóvil tiene cuatro ruedas, la
estructura tiene la descripción <code>Car</code>y el número de asientos
es cinco. Tenemos suficientes datos para ejecutar las pruebas y
asegurarnos de que están fallando para que podamos considerarlos
confiables:</p>
<pre class="srci"><code class="sh"><span class="in"><span class="prompt">&gt; </span>go test -v -run=TestBuilder .
</span><span class="out">=== RUN   TestBuilderPattern
--- FAIL: TestBuilderPattern (0.00s)
        builder_test.go:15: Wheels on a car must be 4 and they
were 0
        builder_test.go:19: Structure on a car must be 'Car'
and was
        builder_test.go:23: Seats on a car must be 5 and they
were 0
FAIL
</span></code></pre>
<p>¡Perfecto! Ahora crearemos pruebas para un <code>Motorbike</code> generador que cubra los criterios de aceptación tercero y cuarto:</p>
<pre class="code"><code class="go">bikeBuilder := &amp;BikeBuilder{}

manufacturingComplex.SetBuilder(bikeBuilder)
manufacturingComplex.Construct()

motorbike := bikeBuilder.GetVehicle()
motorbike.Seats = 1

if motorbike.Wheels != 2 {
  t.Errorf("Wheels on a motorbike must be 2 and they were %d\n",
    motorbike.Wheels)
}

if motorbike.Structure != "Motorbike" {
  t.Errorf("Structure on a motorbike must be 'Motorbike' and was %s\n",
    motorbike.Structure)
}
</code></pre>
<p>El código anterior es una continuación de las pruebas del automóvil.
Como puede ver, reutilizamos la fabricación creada anteriormente para
crear la bicicleta ahora pasando el constructor <code>Motorbike</code> a ella. Luego <code>construct</code> presionamos nuevamente el botón para crear las partes necesarias, y llamamos al método <code>GetVehicle</code> del constructor para recuperar la instancia de la moto.</p>
<p>Eche un vistazo rápido, porque hemos cambiado el número
predeterminado de asientos para esta motocicleta en particular a 1. Lo
que queremos mostrar aquí es que, aunque tenga un constructor, también
debe poder cambiar la información predeterminada en la instancia
devuelta a adaptarse a algunas necesidades específicas. Como
configuramos las ruedas manualmente, no probaremos esta característica.</p>
<p>Volver a ejecutar las pruebas desencadena el comportamiento esperado:</p>
<pre class="srci"><code class="sh"><span class="in"><span class="prompt">&gt; </span>go test -v -run=Builder .
</span><span class="out">=== RUN   TestBuilderPattern
--- FAIL: TestBuilderPattern (0.00s)
        builder_test.go:15: Wheels on a car must be 4 and they
were 0
        builder_test.go:19: Structure on a car must be 'Car'
and was
        builder_test.go:23: Seats on a car must be 5 and they
were 0
        builder_test.go:35: Wheels on a motorbike must be 2 and
they were 0
        builder_test.go:39: Structure on a motorbike must be
'Motorbike' and was
FAIL
</span></code></pre>
</div>
<h4 id="implementation">Implementación</h4>
<div class="hBody-4">
<p>Comenzaremos a implementar la fabricación. Como dijimos anteriormente (y como establecemos en nuestras pruebas unitarias), el <code>Manufacturing</code> director debe aceptar un constructor y construir un vehículo usando el constructor provisto. Para recordar, la interfaz <code>BuildProcess</code> definirá los pasos comunes necesarios para construir cualquier vehículo y el <code>Manufacturing</code> director debe aceptar constructores y construir vehículos junto con ellos:</p>
<pre class="code"><code class="go">package creational

type ManufacturingDirector struct {
  builder BuildProcess
}

func (f *ManufacturingDirector) SetBuilder(b BuildProcess) {
  f.builder = b
}

func (f *ManufacturingDirector) Construct() {
  f.builder.SetSeats().SetStructure().SetWheels()
}
</code></pre>
<p>Nuestra <code>ManufacturingDirector</code> necesita un campo para almacenar el constructor en uso; este campo se llamará <em>constructor</em>. El método <code>SetBuilder</code> reemplazará el generador almacenado con el proporcionado en los argumentos. Finalmente, eche un vistazo más de cerca al método <code>Construct</code>. Toma el constructor que se ha almacenado y reproduce el método <code>BuildProcess</code>
 que creará un vehículo completo de algún tipo desconocido. Como puede
ver, hemos utilizado todas las llamadas de configuración en la misma
línea gracias a la devolución de la interfaz <code>BuildProcess</code> en cada una de las llamadas. De esta forma el código es más compacto:</p>
<div class="about">
<div class="about-dt">Tip</div>
<div class="about-dd">
<p>¿Te has dado cuenta de que la entidad directora en el patrón del
Constructor es un candidato claro para un patrón de Singleton también?
En algunos escenarios, podría ser crítico que solo esté disponible una
instancia del Director, y allí es donde creará un patrón de Singleton
solo para el Director del Constructor. ¡La composición de patrones de
diseño es una técnica muy común y muy poderosa!</p>
</div>
</div>
<pre class="code"><code class="go">type CarBuilder struct {
  v VehicleProduct
}

func (c *CarBuilder) SetWheels() BuildProcess {
  c.v.Wheels = 4
  return c
}

func (c *CarBuilder) SetSeats() BuildProcess {
  c.v.Seats = 5
  return c
}

func (c *CarBuilder) SetStructure() BuildProcess {
  c.v.Structure = "Car"
  return c
}

func (c *CarBuilder) GetVehicle() VehicleProduct {
  return c.v
}
</code></pre>
<p>Aquí está nuestro primer constructor, el constructor <code>car</code>. Un constructor tendrá que almacenar un objeto <code>VehicleProduct</code>,
 que aquí hemos nombrado v. Luego establecemos las necesidades
específicas que tiene un automóvil en nuestro negocio: cuatro ruedas,
cinco asientos y una estructura definida como <code>Car</code>. En el método <code>GetVehicle</code>, simplemente devolvemos el <code>VehicleProduct</code> almacenado dentro del Constructor que debe estar ya construido por el tipo <code>ManufacturingDirector</code>.</p>
<pre class="code"><code class="go">type BikeBuilder struct {
  v VehicleProduct
}

func (b *BikeBuilder) SetWheels() BuildProcess {
  b.v.Wheels = 2
  return b
}

func (b *BikeBuilder) SetSeats() BuildProcess {
  b.v.Seats = 2
  return b
}

func (b *BikeBuilder) SetStructure() BuildProcess {
  b.v.Structure = "Motorbike"
  return b
}

func (b *BikeBuilder) GetVehicle() VehicleProduct {
  return b.v
}
</code></pre>
<p>The <code>Motorbike</code> Builder es lo mismo que el constructor <code>car</code>. Definimos una motocicleta para tener dos ruedas, dos asientos y una estructura llamada <code>Motorbike</code>. Es muy similar al objeto <code>car</code>,
 pero imagina que quieres diferenciar entre una moto deportiva (con un
solo asiento) y una moto de crucero (con dos asientos). Simplemente
podría crear una nueva estructura para motos deportivas que implemente
el proceso de construcción.</p>
<p>Puede ver que se trata de un patrón repetitivo, pero dentro del alcance de cada método de la interfaz <code>BuildProcess</code>,
 puede encapsular tanta complejidad como desee, de modo que el usuario
no necesita conocer los detalles sobre la creación del objeto.</p>
<p>Con la definición de todos los objetos, ejecutemos las pruebas nuevamente:</p>
<pre class="srci"><code class="sh"><span class="out">=== RUN   TestBuilderPattern
--- PASS: TestBuilderPattern (0.00s)
PASS
ok  _/home/mcastro/pers/go-design-patterns/creational 0.001s
</span></code></pre>
<p>¡Bien hecho! Piense en lo fácil que puede ser agregar vehículos nuevos al <code>ManufacturingDirector</code> director, simplemente crear una nueva clase que encapsule los datos del nuevo vehículo. Por ejemplo, agreguemos una estructura <code>BusBuilder</code>:</p>
<pre class="code"><code class="go">type BusBuilder struct {
  v VehicleProduct
}

func (b *BusBuilder) SetWheels() BuildProcess {
  b.v.Wheels = 4*2
  return b
}

func (b *BusBuilder) SetSeats() BuildProcess {
  b.v.Seats = 30
  return b
}

func (b *BusBuilder) SetStructure() BuildProcess {
  b.v.Structure = "Bus"
  return b
}

func (b *BusBuilder) GetVehicle() VehicleProduct {
  return b.v
}
</code></pre>
<p>Eso es todo; su <code>ManufacturingDirector</code> estaría listo para usar el nuevo producto siguiendo el patrón de diseño de Builder.</p>
</div>
<h4 id="wrapping-up-the-builder-design-pattern">Completando el patrón de diseño de Builder</h4>
<div class="hBody-4">
<p>El patrón de diseño de Builder nos ayuda a mantener una cantidad
impredecible de productos mediante el uso de un algoritmo de
construcción común que utiliza el director. El proceso de construcción
siempre se abstrae del usuario del producto.</p>
<p>Al mismo tiempo, tener un patrón de construcción definido ayuda
cuando un recién llegado a nuestro código fuente necesita agregar un
nuevo producto a la <i>tubería</i>. La interfaz <code>BuildProcess</code> especifica qué debe cumplir para formar parte de los posibles constructores.</p>
<p>Sin embargo, trate de evitar el patrón de Builder cuando no esté
completamente seguro de que el algoritmo sea más o menos estable porque
cualquier cambio pequeño en esta interfaz afectará a todos sus
constructores y podría ser incómodo si agrega un nuevo método que
algunos de sus constructores necesita y otros constructores no.</p>
</div>
<h3 id="factory-method---delegating-the-creation-of-different-types-of-payments">Método de fábrica: delegar la creación de diferentes tipos de pagos</h3>
<div class="hBody-3">
<p>El patrón de método de Fábrica (o simplemente, Fábrica) es
probablemente el segundo patrón de diseño más conocido y usado en la
industria. Su objetivo es abstraer al usuario del conocimiento de la
estructura que necesita alcanzar para un propósito específico, como
recuperar algún valor, tal vez de un servicio web o una base de datos.
El usuario solo necesita una interfaz que le proporcione este valor. Al
delegar esta decisión a una fábrica, esta fábrica puede proporcionar una
 interfaz que se adapte a las necesidades del usuario. También facilita
el proceso de degradación o actualización de la implementación del tipo
subyacente si es necesario.</p>
</div>
<h4 id="description">Descripción</h4>
<div class="hBody-4">
<p>Al utilizar el patrón de diseño de método de fábrica, obtenemos una
capa adicional de encapsulado para que nuestro programa pueda crecer en
un entorno controlado. Con el método Factory, delegamos la creación de
familias de objetos en un paquete u objeto diferente para abstraernos
del conocimiento del conjunto de posibles objetos que podríamos usar.
Imagine que desea organizar sus vacaciones con una agencia de viajes.
Usted no se ocupa de los hoteles y los viajes y simplemente le dice a la
 agencia el destino que le interesa para que le brinden todo lo que
necesita. La agencia de viajes representa una fábrica de viajes.</p>
</div>
<h4 id="objectives">Objetivos</h4>
<div class="hBody-4">
<p>Después de la descripción anterior, los siguientes objetivos del
patrón de diseño del Método de fábrica deben ser claros para usted:</p>
<ul>
<li>
<p>Delegar la creación de nuevas instancias de estructuras en una parte diferente del programa</p>
</li>
<li>
<p>Trabajando en el nivel de interfaz en lugar de con implementaciones concretas</p>
</li>
<li>
<p>Agrupar familias de objetos para obtener un creador de objetos familiares</p>
</li>
</ul>
</div>
<h4 id="the-example---a-factory-of-payment-methods-for-a-shop">El ejemplo: una fábrica de métodos de pago para una tienda</h4>
<div class="hBody-4">
<p>Para nuestro ejemplo, vamos a implementar un método de pago Factory,
que nos proporcionará diferentes formas de pago en una tienda. Al
principio, tendremos dos métodos de pago: efectivo y tarjeta de crédito.
 También tendremos una interfaz con el método, <code>Pay</code> que debe implementar cada estructura que desee usar como método de pago.</p>
</div>
<h4 id="acceptance-criteria">Criterios de aceptación</h4>
<div class="hBody-4">
<p>Usando la descripción anterior, los requisitos para los criterios de aceptación son los siguientes:</p>
<ul>
<li>
<p>Tener un método común para cada método de pago llamado Pago</p>
</li>
<li>
<p>Para poder delegar la creación de métodos de pago a la fábrica</p>
</li>
<li>
<p>Para poder agregar más métodos de pago a la biblioteca simplemente agregándolo al método de fábrica</p>
</li>
</ul>
</div>
<h4 id="first-unit-test">Prueba de la primera unidad</h4>
<div class="hBody-4">
<p>Un método de Fábrica tiene una estructura muy simple; solo
necesitamos identificar cuántas implementaciones de nuestra interfaz
estamos almacenando, y luego proporcionar un método <code>GetPaymentMethod</code>, donde puede pasar un tipo de pago como argumento:</p>
<pre class="code"><code class="go">type PaymentMethod interface {
  Pay(amount float32) string
}
</code></pre>
<p>Las líneas anteriores definen la interfaz del método de pago. Definen
 una forma de hacer un pago en la tienda. El método Factory devolverá
instancias de tipos que implementan esta interfaz:</p>
<pre class="code"><code class="go">const (
  Cash      = 1
  DebitCard = 2
)
</code></pre>
<p>Tenemos que definir los métodos de pago identificados de la fábrica
como constantes para que podamos llamar y verificar los posibles métodos
 de pago desde fuera del paquete.</p>
<pre class="code"><code class="go">func GetPaymentMethod(m int) (PaymentMethod, error) {
  return nil, errors.New("Not implemented yet")
}
</code></pre>
<p>El código anterior es la función que creará los objetos para
nosotros. Devuelve un puntero, que debe tener un objeto que implementa
la interfaz <code>PaymentMethod</code>, y un error si se le solicita un método que no está registrado.</p>
<pre class="code"><code class="go">type CashPM struct{}
type DebitCardPM struct{}

func (c *CashPM) Pay(amount float32) string {
  return ""
}

func (c *DebitCardPM) Pay(amount float32) string {
  return ""
}
</code></pre>
<p>Para finalizar la declaración de fábrica, creamos los dos métodos de pago. Como se puede ver, el <code>CashPM</code>y estructuras <code>DebitCardPM</code> implementar la interfaz <code>PaymentMethod</code> por la que se declara un método, <code>Pay(amount float32) string</code>. La cadena devuelta contendrá información sobre el pago.</p>
<p>Con esta declaración, comenzaremos por escribir las pruebas para los
primeros criterios de aceptación: tener un método común para recuperar
los objetos que implementan la interfaz <code>PaymentMethod</code>:</p>
<pre class="code"><code class="go">package creational
import (
  "strings"
  "testing"
)

func TestCreatePaymentMethodCash(t *testing.T) {
  payment, err := GetPaymentMethod(Cash)
  if err != nil {
    t.Fatal("A payment method of type 'Cash' must exist")
  }

  msg := payment.Pay(10.30)
  if !strings.Contains(msg, "paid using cash") {
    t.Error("The cash payment method message wasn't correct")
  }
  t.Log("LOG:", msg)
}
</code></pre>
<p>Ahora tendremos que separar las pruebas entre algunas de las funciones de prueba. <code>GetPaymentMethod</code> es un método común para recuperar métodos de pago. Usamos la constante <code>Cash</code>,
 que hemos definido en el archivo de implementación (si usáramos esta
constante fuera del alcance del paquete, la llamaríamos usando el nombre
 del paquete como el prefijo, por lo que la sintaxis sería <code>creational.Cash</code>).
 También verificamos que no hayamos recibido un error al solicitar un
método de pago. Observe que si recibimos el error al solicitar un método
 de pago, llamamos <code>t.Fatal</code> para detener la ejecución de las pruebas; si llamamos al <code>t.Error</code> igual que en las pruebas anteriores, tendríamos un problema en las siguientes líneas cuando intentemos acceder al método <code>Pay</code> de un objeto nulo, y nuestras pruebas colapsarían la ejecución. Continuamos usando elmétodo <code>Pay</code> de la interfaz pasando 10.30 como la cantidad. El mensaje devuelto deberá contener el texto <code>paid using cash</code>. El método <code>t.Log(string)</code>
 es un método especial en las pruebas. Esta estructura nos permite
escribir algunos registros cuando ejecutamos las pruebas si pasamos el
indicador <code>-v</code>.</p>
<pre class="code"><code class="go">func TestGetPaymentMethodDebitCard(t *testing.T) {
  payment, err = GetPaymentMethod(Debit9Card)

  if err != nil {
    t.Error("A payment method of type 'DebitCard' must exist")
  }

  msg = payment.Pay(22.30)

  if !strings.Contains(msg, "paid using debit card") {
    t.Error("The debit card payment method message wasn't correct")
  }

  t.Log("LOG:", msg)
}
</code></pre>
<p>Repetimos la misma operación con el método de la tarjeta de débito. Solicitamos el método de pago definido con la constante <code>DebitCard</code>, y el mensaje devuelto, al pagar con tarjeta de débito, debe contener la cadena <code>paid using debit card</code>.</p>
<pre class="code"><code class="go">func TestGetPaymentMethodNonExistent(t *testing.T) {
  payment, err = GetPaymentMethod(20)

  if err == nil {
    t.Error("A payment method with ID 20 must return an error")
  }
  t.Log("LOG:", err)
}
</code></pre>
<p>Finalmente, vamos a probar la situación cuando solicitamos un método
de pago que no existe (representado por el número 20, que no coincide
con ninguna constante reconocida en la fábrica). Comprobaremos si se
devuelve un mensaje de error (alguno) al solicitar un método de pago
desconocido.</p>
<p>Comprobemos si todas las pruebas están fallando:</p>
<pre class="srci"><code class="sh"><span class="in"><span class="prompt">&gt; </span>go test -v -run=GetPaymentMethod .
</span><span class="out">=== RUN   TestGetPaymentMethodCash
--- FAIL: TestGetPaymentMethodCash (0.00s)
        factory_test.go:11: A payment method of type 'Cash'
must exist
=== RUN   TestGetPaymentMethodDebitCard
--- FAIL: TestGetPaymentMethodDebitCard (0.00s)
        factory_test.go:24: A payment method of type
'DebitCard' must exist
=== RUN   TestGetPaymentMethodNonExistent
--- PASS: TestGetPaymentMethodNonExistent (0.00s)
        factory_test.go:38: LOG: Not implemented yet
FAIL
exit status 1
FAIL
</span></code></pre>
<p>Como puede ver en este ejemplo, solo podemos ver pruebas que devuelven el <code>PaymentMethod</code>
 error a las interfaces. En este caso, tendremos que implementar solo
una parte del código, y luego probar nuevamente antes de continuar.</p>
</div>
<h4 id="implementation">Implementación</h4>
<div class="hBody-4">
<p>Comenzaremos con el método <code>GetPaymentMethod</code>. Debe
recibir un número entero que coincida con una de las constantes
definidas del mismo archivo para saber qué implementación debe devolver.</p>
<pre class="code"><code class="go">package creational

import (
  "errors"
  "fmt"
)

type PaymentMethod interface {
  Pay(amount float32) string
}

const (
  Cash      = 1
  DebitCard = 2
)
type CashPM struct{}
type DebitCardPM struct{}

func GetPaymentMethod(m int) (PaymentMethod, error) {
  switch m {
  case Cash:
    return new(CashPM), nil
  case DebitCard:
    return new(DebitCardPM), nil
  default:
    return nil, errors.New(fmt.Sprintf("Payment method %d not recognized\n", m))
  }
}
</code></pre>
<p>Usamos un interruptor simple para verificar el contenido del argumento <code>m</code>(método).
 Si coincide con alguno de los métodos conocidos - efectivo o tarjeta de
 débito, devuelve una nueva instancia de ellos. De lo contrario,
devolverá un cero y un error que indica que el método de pago no ha sido
 reconocido. Ahora podemos ejecutar nuestras pruebas nuevamente para
verificar la segunda parte de las pruebas unitarias:</p>
<pre class="srci"><code class="sh"><span class="in"><span class="prompt">&gt; </span>go test -v -run=GetPaymentMethod .
</span><span class="out">=== RUN   TestGetPaymentMethodCash
--- FAIL: TestGetPaymentMethodCash (0.00s)
        factory_test.go:16: The cash payment method message
wasn't correct
        factory_test.go:18: LOG:
=== RUN   TestGetPaymentMethodDebitCard
--- FAIL: TestGetPaymentMethodDebitCard (0.00s)
        factory_test.go:28: The debit card payment method
message wasn't correct
        factory_test.go:30: LOG:
=== RUN   TestGetPaymentMethodNonExistent
--- PASS: TestGetPaymentMethodNonExistent (0.00s)
        factory_test.go:38: LOG: Payment method 20 not
recognized
FAIL
exit status 1
FAIL
</span></code></pre>
<p>Ahora no obtenemos los errores que dicen que no pudo encontrar el tipo de métodos de pago. En cambio, recibimos un <code>message not correct</code> error cuando intenta utilizar cualquiera de los métodos que cubre. También <code>Not implemented</code> eliminamos el mensaje que se devolvía cuando solicitamos un método de pago desconocido. Implementemos las estructuras ahora:</p>
<pre class="code"><code class="go">type CashPM struct{}
type DebitCardPM struct{}

func (c *CashPM) Pay(amount float32) string {
  return fmt.Sprintf("%0.2f paid using cash\n", amount)
}

func (c *DebitCardPM) Pay(amount float32) string {
  return fmt.Sprintf("%#0.2f paid using debit card\n", amount)
}
</code></pre>
<p>Acabamos de obtener la cantidad, imprimiéndola en un mensaje muy
formateado. Con esta implementación, todas las pruebas pasarán ahora:</p>
<pre class="srci"><code class="sh"><span class="in"><span class="prompt">&gt; </span>go test -v -run=GetPaymentMethod .
</span><span class="out">=== RUN   TestGetPaymentMethodCash
--- PASS: TestGetPaymentMethodCash (0.00s)
        factory_test.go:18: LOG: 10.30 paid using cash
=== RUN   TestGetPaymentMethodDebitCard
--- PASS: TestGetPaymentMethodDebitCard (0.00s)
        factory_test.go:30: LOG: 22.30 paid using debit card
=== RUN   TestGetPaymentMethodNonExistent
--- PASS: TestGetPaymentMethodNonExistent (0.00s)
        factory_test.go:38: LOG: Payment method 20 not
recognized
PASS
ok
</span></code></pre>
<p>¿Ves los <code>LOG:</code> mensajes? No son errores, solo imprimimos
cierta información que recibimos cuando usamos el paquete bajo prueba.
Estos mensajes se pueden omitir a menos que pase el indicador <code>-v</code> al comando de prueba:</p>
<pre class="srci"><code class="sh"><span class="in"><span class="prompt">&gt; </span>go test -run=GetPaymentMethod .
</span><span class="out">ok
</span></code></pre>
</div>
<h4 id="upgrading-the-debitcard-method-to-a-new-platform">Actualización del método de tarjeta de débito a una nueva plataforma</h4>
<div class="hBody-4">
<p>Ahora imagine que su método <code>DebitCard</code> de pago ha
cambiado por algún motivo, y necesita una nueva estructura para ello.
Para lograr este escenario, solo necesitará crear la nueva estructura y
reemplazar la anterior cuando el usuario solicite el método <code>DebitCard</code> de pago:</p>
<pre class="code"><code class="go">type CreditCardPM struct {}
func (d *CreditCardPM) Pay(amount float32) string {
  return fmt.Sprintf("%#0.2f paid using new credit card implementation\n", amount)
}
</code></pre>
<p>Este es nuestro nuevo tipo que reemplazará la estructura <code>DebitCardPM</code>. El <code>CreditCardPM</code> implementa la misma interfaz <code>PaymentMethod</code>
 que la tarjeta de débito. No hemos eliminado el anterior en caso de que
 lo necesitemos en el futuro. La única diferencia radica en el mensaje
devuelto que ahora contiene la información sobre el nuevo tipo. También
tenemos que modificar el método para recuperar los métodos de pago:</p>
<pre class="code"><code class="go">func GetPaymentMethod(m int) (PaymentMethod, error) {
  switch m {
  case Cash:
    return new(CashPM), nil
  case DebitCard:
    return new(CreditCardPM), nil
  default:
    return nil, errors.New(fmt.Sprintf("Payment method %d not recognized\n", m))
  }
}
</code></pre>
<p>La única modificación se encuentra en la línea donde creamos la nueva
 tarjeta de débito que ahora apunta a la estructura recién creada. Vamos
 a ejecutar las pruebas para ver si todo sigue siendo correcto:</p>
<pre class="srci"><code class="sh"><span class="in"><span class="prompt">&gt; </span>go test -v -run=GetPaymentMethod .
</span><span class="out">=== RUN   TestGetPaymentMethodCash
--- PASS: TestGetPaymentMethodCash (0.00s)
        factory_test.go:18: LOG: 10.30 paid using cash
=== RUN   TestGetPaymentMethodDebitCard
--- FAIL: TestGetPaymentMethodDebitCard (0.00s)
        factory_test.go:28: The debit card payment method
message wasn't correct
        factory_test.go:30: LOG: 22.30 paid using new debit
card implementation
=== RUN   TestGetPaymentMethodNonExistent
--- PASS: TestGetPaymentMethodNonExistent (0.00s)
        factory_test.go:38: LOG: Payment method 20 not
recognized
FAIL
exit status 1
FAIL
</span></code></pre>
<p>¡UH oh! Algo ha ido mal. El mensaje esperado al pagar con una tarjeta
 de crédito no coincide con el mensaje devuelto. ¿Significa que nuestro
código no es correcto? En términos generales, sí, no debe modificar sus
pruebas para que su programa funcione. Al definir las pruebas, también
debe saber que no las define demasiado porque podría lograr algún
acoplamiento en las pruebas que no tenía en su código. Con la
restricción del mensaje, tenemos algunas posibilidades gramaticalmente
correctas para el mensaje, por lo que lo cambiaremos a lo siguiente:</p>
<pre class="code"><code class="go">return fmt.Sprintf("%#0.2f paid using debit card (new)\n", amount)
</code></pre>
<p>Ejecutamos las pruebas nuevamente ahora:</p>
<pre class="srci"><code class="sh"><span class="in"><span class="prompt">&gt; </span>go test -v -run=GetPaymentMethod .
</span><span class="out">=== RUN   TestGetPaymentMethodCash
--- PASS: TestGetPaymentMethodCash (0.00s)
        factory_test.go:18: LOG: 10.30 paid using cash
=== RUN   TestGetPaymentMethodDebitCard
--- PASS: TestGetPaymentMethodDebitCard (0.00s)
        factory_test.go:30: LOG: 22.30 paid using debit card
(new)
=== RUN   TestGetPaymentMethodNonExistent
--- PASS: TestGetPaymentMethodNonExistent (0.00s)
        factory_test.go:38: LOG: Payment method 20 not
recognized
PASS
ok
</span></code></pre>
<p>Todo está bien nuevamente. Este fue solo un pequeño ejemplo de cómo
escribir buenas pruebas unitarias también. Cuando quisimos comprobar que
 un método de pago con tarjeta de débito devuelve un mensaje que
contiene <code>paid using debit card</code> la secuencia, que estábamos
siendo probablemente un poco restrictivo, y que sería mejor para
comprobar si esas palabras por separado o definir un mejor formato para
los mensajes devueltos.</p>
</div>
<h4 id="what-we-learned-about-the-factory-method">Lo que aprendimos sobre el método de Fábrica</h4>
<div class="hBody-4">
<p>Con el patrón de método de Fábrica, hemos aprendido cómo agrupar
familias de objetos para que su implementación esté fuera de nuestro
alcance. También hemos aprendido qué hacer cuando necesitamos actualizar
 una implementación de una estructura utilizada. Finalmente, hemos visto
 que las pruebas deben escribirse con cuidado si no desea vincularse a
ciertas implementaciones que no tienen nada que ver con las pruebas
directamente.</p>
</div>
<h3 id="abstract-factory---a-factory-of-factories">Fábrica abstracta - una fábrica de fábricas</h3>
<div class="hBody-3">
<p>Después de aprender sobre el patrón de diseño de la fábrica, donde
agrupamos una familia de objetos relacionados en nuestros métodos de
pago de casos, uno puede pensar rápidamente: ¿y si agrupo familias de
objetos en una jerarquía de familias más estructurada?</p>
</div>
<h4 id="description">Descripción</h4>
<div class="hBody-4">
<p>El patrón de diseño Abstract Factory es una nueva capa de
agrupamiento para lograr un objeto compuesto más grande (y más
complejo), que se utiliza a través de sus interfaces. La idea detrás de
agrupar objetos en familias y agrupar familias es tener grandes fábricas
 que puedan intercambiarse y crecer más fácilmente. En las primeras
etapas de desarrollo, también es más fácil trabajar con fábricas y
fábricas abstractas que esperar hasta que se realicen todas las
implementaciones concretas para iniciar su código. Además, no va a
escribir una fábrica abstracta desde el principio a menos que sepa que
el inventario de su objeto para un campo en particular va a ser muy
grande y se puede agrupar fácilmente en familias.</p>
</div>
<h4 id="the-objectives">Los objetivos</h4>
<div class="hBody-4">
<p>Agrupar familias de objetos relacionadas es muy conveniente cuando su
 número de objeto está creciendo tanto que la creación de un punto único
 para obtenerlos a todos parece ser la única forma de obtener la
flexibilidad de la creación de objetos en tiempo de ejecución. Los
siguientes objetivos del método Abstract Factory deben ser claros para
usted:</p>
<ul>
<li>
<p>Proporcione una nueva capa de encapsulación para los métodos Factory que devuelven una interfaz común para todas las fábricas</p>
</li>
<li>
<p>Agrupe fábricas comunes en una <i>fábrica súper</i> (también llamada fábrica de fábricas)</p>
</li>
</ul>
</div>
<h4 id="the-vehicle-factory-example,-again?">El ejemplo de la fábrica de vehículos, otra vez?</h4>
<div class="hBody-4">
<p>Para nuestro ejemplo, vamos a reutilizar la fábrica que creamos en el
 patrón de diseño de Builder. Queremos mostrar las similitudes para
resolver el mismo problema utilizando un enfoque diferente para que
pueda ver las fortalezas y debilidades de cada enfoque. Esto le mostrará
 el poder de las interfaces implícitas en Go, ya que no tendremos que
tocar casi nada. Finalmente, vamos a crear una fábrica nueva para crear
pedidos de envío.</p>
</div>
<h4 id="acceptance-criteria">Criterios de aceptación</h4>
<div class="hBody-4">
<p>Los siguientes son los criterios de aceptación para usar el método Factory de los objetos del vehículo:</p>
<ul>
<li>
<p>Debemos recuperar un objeto <code>Vehicle</code> utilizando una fábrica devuelta por la fábrica abstracta.</p>
</li>
<li>
<p>El vehículo debe ser una implementación concreta de a <code>Motorbike</code>o un <code>Car</code> que implemente ambas interfaces ( <code>Vehicle</code>y <code>Car</code>o <code>Vehicle</code>y <code>Motorbike</code>).</p>
</li>
</ul>
</div>
<h4 id="unit-test">Prueba de unidad</h4>
<div class="hBody-4">
<p>Este va a ser un largo ejemplo, así que presta atención, por favor. Tendremos las siguientes entidades:</p>
<ul>
<li>
<p><code>Vehicle</code>: La interfaz que todos los objetos en nuestras fábricas deben implementar:</p>
<ul>
<li>
<p><code>Motorbike</code>: Una interfaz para motos de los tipos deportivo (un asiento) y crucero (dos asientos).</p>
</li>
<li>
<p><code>Car</code>: Una interfaz para autos de lujo (con cuatro puertas) y familiar (con cinco puertas).</p>
</li>
</ul>
</li>
<li>
<p><code>VehicleFactory</code>: Una interfaz (la fábrica abstracta) para recuperar las fábricas que implementan el método <code>VehicleFactory</code>:</p>
<ul>
<li>
<p><code>Motorbike</code>Fábrica: Una fábrica que implementa la interfaz <code>VehicleFactory</code> para volver vehículo que implementa el <code>Vehicle</code>e <code>Motorbike</code> interfaces.</p>
</li>
<li>
<p><code>Car</code>Fábrica: otra fábrica que implementa la interfaz <code>VehicleFactory</code> para devolver vehículos que implementan <code>Vehicle</code>e <code>Car</code> interfaces.</p>
</li>
</ul>
</li>
</ul>
<p>Para mayor claridad, vamos a separar cada entidad en un archivo diferente. Comenzaremos con la interfaz <code>Vehicle</code>, que estará en el archivo <span class="file">vehicle.go</span> :</p>
<pre class="code"><code class="go">package abstract_factory

type Vehicle interface {
  NumWheels() int
  NumSeats() int
}
</code></pre>
<p>Las interfaces <code>Car</code>y <code>Motorbike</code> estarán en los archivos <span class="file">car.go</span> y <span class="file">motorbike.go</span>, respectivamente:</p>
<pre class="code"><code class="go">// Package abstract_factory file: car.go
package abstract_factory

type Car interface {
  NumDoors() int
}
// Package abstract_factory file: motorbike.go
package abstract_factory

type Motorbike interface {
  GetMotorbikeType() int
}
</code></pre>
<p>Tenemos una última interfaz, la que debe implementar cada fábrica. Esto estará en el archivo <span class="file">vehicle_factory.go</span> :</p>
<pre class="code"><code class="go">package abstract_factory

type VehicleFactory interface {
  NewVehicle(v int) (Vehicle, error)
}
</code></pre>
<p>Entonces, ahora vamos a declarar la fábrica de automóviles. Debe implementar la interfaz <code>VehicleFactory</code> definida anteriormente para devolver <code>Vehicles</code> instancias:</p>
<pre class="code"><code class="go">const (
  LuxuryCarType = 1
  FamilyCarType = 2
)

type CarFactory struct{}
func (c *CarFactory) NewVehicle(v int) (Vehicle, error) {
  switch v {
  case LuxuryCarType:
    return new(LuxuryCar), nil
  case FamilyCarType:
    return new(FamilyCar), nil
  default:
    return nil, errors.New(fmt.Sprintf("Vehicle of type %d not recognized\n", v))
  }
}
</code></pre>
<p>Hemos definido dos tipos de automóviles: lujo y familia. La fábrica
de automóviles tendrá que devolver los automóviles que implementan <code>Car</code> las <code>Vehicle</code> interfaces y, por lo tanto, necesitamos dos implementaciones concretas:</p>
<pre class="code"><code class="go">// luxury_car.go
package abstract_factory

type LuxuryCar struct{}

func (*LuxuryCar) NumDoors() int {
  return 4
}
func (*LuxuryCar) NumWheels() int {
  return 4
}
func (*LuxuryCar) NumSeats() int {
  return 5
}
</code></pre>
<pre class="code"><code class="go">package abstract_factory

type FamilyCar struct{}

func (*FamilyCar) NumDoors() int {
  return 5
}
func (*FamilyCar) NumWheels() int {
  return 4
}
func (*FamilyCar) NumSeats() int {
  return 5
}
</code></pre>
<p>Eso es todo por autos. Ahora necesitamos la fábrica de motocicletas,
que, al igual que la fábrica de automóviles, debe implementar la
interfaz <code>VehicleFactory</code>:</p>
<pre class="code"><code class="go">const (
  SportMotorbikeType = 1
  CruiseMotorbikeType = 2
)

type MotorbikeFactory struct{}

func (m *MotorbikeFactory) Build(v int) (Vehicle, error) {
  switch v {
  case SportMotorbikeType:
    return new(SportMotorbike), nil
  case CruiseMotorbikeType:
    return new(CruiseMotorbike), nil
  default:
    return nil, errors.New(fmt.Sprintf("Vehicle of type %d not recognized\n", v))
  }
}
</code></pre>
<p>Para la fábrica de motos, también hemos definido dos tipos de motos utilizando las palabras clave <code>const</code>: <code>SportMotorbikeType</code>y <code>CruiseMotorbikeType</code>. Cambiaremos el argumento v en el método <code>Build</code> para saber qué tipo se devolverá. Escribamos las dos motos de concreto:</p>
<pre class="code"><code class="go">// sport_motorbike.go
package abstract_factory

type SportMotorbike struct{}

func (s *SportMotorbike) NumWheels() int {
  return 2
}
func (s *SportMotorbike) NumSeats() int {
  return 1
}
func (s *SportMotorbike) GetMotorbikeType() int {
  return SportMotorbikeType
}
</code></pre>
<pre class="code"><code class="go">// cruise_motorbike.go
package abstract_factory

type CruiseMotorbike struct{}

func (c *CruiseMotorbike) NumWheels() int {
  return 2
}
func (c *CruiseMotorbike) NumSeats() int {
  return 2
}
func (c *CruiseMotorbike) GetMotorbikeType() int {
  return CruiseMotorbikeType
}
</code></pre>
<p>Para finalizar, necesitamos la fábrica abstracta en sí misma, que pondremos en el archivo <span class="file">vehicle_factory.go</span> previamente creado :</p>
<pre class="code"><code class="go">package abstract_factory

import (
  "fmt"
  "errors"
)

type VehicleFactory interface {
  Build(v int) (Vehicle, error)
}

const (
  CarFactoryType = 1
  MotorbikeFactoryType = 2
)

func BuildFactory(f int) (VehicleFactory, error) {
  switch f {
  default:
    return nil, errors.New(fmt.Sprintf("Factory with id %d not recognized\n", f))
  }
}
</code></pre>
<p>Vamos a escribir suficientes pruebas para hacer un control confiable
ya que el alcance del libro no cubre el 100% de las declaraciones. Será
un buen ejercicio para el lector terminar estas pruebas. Primero, una
prueba <code>motorbike</code> de fábrica:</p>
<pre class="code"><code class="go">package abstract_factory

import "testing"

func TestMotorbikeFactory(t *testing.T) {
  motorbikeF, err := BuildFactory(MotorbikeFactoryType)
  if err != nil {
    t.Fatal(err)
  }

  motorbikeVehicle, err :=
    motorbikeF.Build(SportMotorbikeType)
  if err != nil {
    t.Fatal(err)
  }

  t.Logf("Motorbike vehicle has %d wheels\n", motorbikeVehicle.NumWheels())

  sportBike, ok := motorbikeVehicle.(Motorbike)
  if !ok {
    t.Fatal("Struct assertion has failed")
  }
  t.Logf("Sport motorbike has type %d\n", sportBike.GetMotorbikeType())
}
</code></pre>
<p>Utilizamos el método de paquete,, <code>BuildFactory</code> para recuperar una fábrica de motocicletas (pasando la <code>MotorbikeFactory</code>
 ID en los parámetros), y verificamos si obtenemos algún error. Luego,
ya con la fábrica de motocicletas, solicitamos un vehículo del tipo <code>SportMotorbikeType</code>y verificamos si hay errores nuevamente. Con el vehículo devuelto, podemos solicitar los métodos de la interfaz del vehículo ( <code>NumWheels</code>y <code>NumSeats</code>).
 Sabemos que es una moto, pero no podemos preguntar por el tipo de moto
sin usar la afirmación de tipo. Utilizamos la afirmación de tipo en el
vehículo para recuperar la moto que <code>motorbikeVehicle</code> representa en la línea de código sportBike <code>found := motorbikeVehicle.(Motorbike)</code>, y debemos verificar que el tipo que hemos recibido sea el correcto.</p>
<p>Finalmente, ahora tenemos una instancia de moto, podemos preguntar por el tipo de bicicleta usando el método <code>GetMotorbikeType</code>. Ahora vamos a escribir una prueba que verifique la fábrica de automóviles de la misma manera:</p>
<pre class="code"><code class="go">func TestCarFactory(t *testing.T) {
  carF, err := BuildFactory(CarFactoryType)
  if err != nil {
    t.Fatal(err)
  }

  carVehicle, err := carF.Build(LuxuryCarType)
  if err != nil {
    t.Fatal(err)
  }

  t.Logf("Car vehicle has %d seats\n",
    carVehicle.NumWheels())

  luxuryCar, ok := carVehicle.(Car)
  if !ok {
    t.Fatal("Struct assertion has failed")
  }
  t.Logf("Luxury car has %d doors.\n", luxuryCar.NumDoors())
}
</code></pre>
<p>Nuevamente, usamos el método <code>BuildFactory</code> para recuperar una <code>Car</code>Fábrica usando el <code>CarFactoryType</code> en los parámetros. Con esta fábrica, queremos un automóvil del tipo <code>Luxury</code> para que devuelva una <code>vehicle</code>
 instancia. Nuevamente hacemos la aserción de tipo para señalar una
instancia de automóvil para poder preguntar el número de puertas que
usan el método <code>NumDoors</code>.</p>
<p>Vamos a ejecutar las pruebas unitarias:</p>
<pre class="srci"><code class="sh"><span class="in"><span class="prompt">&gt; </span>go test -v -run=Factory .
</span><span class="out">=== RUN   TestMotorbikeFactory
--- FAIL: TestMotorbikeFactory (0.00s)
        vehicle_factory_test.go:8: Factory with id 2 not
recognized
=== RUN   TestCarFactory
--- FAIL: TestCarFactory (0.00s)
        vehicle_factory_test.go:28: Factory with id 1 not recognized
FAIL
exit status 1
FAIL
</span></code></pre>
<ol class="alpha">
<li>
<p>No puede reconocer ninguna fábrica ya que su implementación todavía no es</p>
</li>
</ol>
<p>hecho.</p>
</div>
<h4 id="implementation">Implementación</h4>
<div class="hBody-4">
<p>La implementación de cada fábrica ya está hecha en aras de la
brevedad. Son muy similares al método Factory, con la única diferencia
de que en el método Factory, no usamos una instancia del método Factory
porque utilizamos las funciones del paquete directamente. La
implementación de la <code>vehicle</code>fábrica es la siguiente:</p>
<pre class="code"><code class="go">func BuildFactory(f int) (VehicleFactory, error) {
  switch f {
  case CarFactoryType:
    return new(CarFactory), nil
  case MotorbikeFactoryType:
    return new(MotorbikeFactory), nil
  default:
    return nil, errors.New(fmt.Sprintf("Factory with id %d not recognized\n", f))
  }
}
</code></pre>
<p>Como en cualquier fábrica, cambiamos entre las posibilidades de la
fábrica para devolver la que se exigía. Como ya hemos implementado todos
 los vehículos de concreto, las pruebas también deben ejecutarse:</p>
<pre class="srci"><code class="sh"><span class="in"><span class="prompt">&gt; </span>go test -v -run=Factory -cover .
</span><span class="out">=== RUN   TestMotorbikeFactory
--- PASS: TestMotorbikeFactory (0.00s)
        vehicle_factory_test.go:16: Motorbike vehicle has 2
wheels
        vehicle_factory_test.go:22: Sport motorbike has type 1
=== RUN   TestCarFactory
--- PASS: TestCarFactory (0.00s)
        vehicle_factory_test.go:36: Car vehicle has 4 seats
        vehicle_factory_test.go:42: Luxury car has 4 doors.
PASS
coverage: 45.8% of statements
ok
</span></code></pre>
<p>Todos ellos pasaron. Eche un vistazo de cerca y tenga en cuenta que hemos utilizado la bandera <code>cover</code>
 cuando ejecutamos las pruebas para devolver un porcentaje de cobertura
del paquete: 45.8%. Lo que esto nos dice es que el 45.8% de las líneas
están cubiertas por las pruebas que hemos escrito, pero el 54.2% todavía
 no están bajo las pruebas. Esto se debe a que no hemos cubierto la
motocicleta de crucero y el automóvil familiar con las pruebas. Si
escribe esas pruebas, el resultado debería aumentar a alrededor del
70.8%.</p>
<div class="about">
<div class="about-dt">Tip</div>
<div class="about-dd">
<p>La aserción de tipo también se conoce como <b>conversión</b> en otros
 idiomas. Cuando tienes una instancia de interfaz, que es esencialmente
un puntero a una estructura, solo tienes acceso a los métodos de
interfaz. Con la aserción de tipo, puede decirle al compilador el tipo
de estructura apuntada, para que pueda acceder a todos los campos y
métodos de la estructura.</p>
</div>
</div>
</div>
<h4 id="a-few-lines-about-the-abstract-factory-method">Algunas líneas sobre el método Abstract Factory</h4>
<div class="hBody-4">
<p>Hemos aprendido a escribir una fábrica de fábricas que nos
proporciona un objeto muy genérico de tipo de vehículo. Este patrón se
usa comúnmente en muchas aplicaciones y bibliotecas, como las
bibliotecas de GUI multiplataforma. Piense en un botón, un objeto
genérico y una fábrica de botones que le proporcione una fábrica para
los botones de Microsoft Windows, mientras que usted tiene otra fábrica
para los botones de Mac OS X. No desea tratar los detalles de
implementación de cada plataforma, pero solo desea implementar las
acciones para un comportamiento específico generado por un botón.</p>
<p>Además, hemos visto las diferencias al abordar el mismo problema con
dos soluciones diferentes: la fábrica Abstract y el patrón Builder. Como
 has visto, con el patrón Builder, teníamos una lista desestructurada de
 objetos (automóviles con motos en la misma fábrica). Además, alentamos a
 reutilizar el algoritmo de construcción en el patrón de Constructor. En
 la fábrica de Abstract, tenemos una lista muy estructurada de vehículos
 (la fábrica de motos y una fábrica de automóviles). Tampoco combinamos
la creación de automóviles con motos, lo que proporciona más
flexibilidad en el proceso de creación. Los patrones Abstract factory y
Builder pueden resolver el mismo problema, pero sus necesidades
particulares lo ayudarán a encontrar las pequeñas diferencias que lo
llevarán a tomar una u otra solución.</p>
</div>
<h3 id="prototype-design-pattern">Patrón de diseño del prototipo</h3>
<div class="hBody-3">
<p>El último patrón que veremos en este capítulo es el <b>Prototipo</b>
patrón . Al igual que todos los patrones creacionales, esto también es
útil cuando se crean objetos, y es muy común ver el patrón Prototype
rodeado de más patrones.</p>
<p>Mientras que con el patrón Builder, estamos lidiando con algoritmos
de construcción repetitivos y con las fábricas estamos simplificando la
creación de muchos tipos de objetos; con el patrón Prototipo, usaremos
una instancia ya creada de algún tipo para clonarla y completarla con
las necesidades particulares de cada contexto. Veámoslo en detalle.</p>
</div>
<h4 id="description">Descripción</h4>
<div class="hBody-4">
<p>El objetivo del patrón Prototype es tener un objeto o un conjunto de
objetos que ya se haya creado en el momento de la compilación, pero que
puede clonar tantas veces como desee en tiempo de ejecución. Esto es
útil, por ejemplo, como una plantilla predeterminada para un usuario que
 acaba de registrarse en su página web o un plan de precios
predeterminado en algún servicio. La diferencia clave entre esto y un
patrón de Builder es que los objetos se clonan para el usuario en lugar
de compilarlos en tiempo de ejecución. También puede construir una
solución similar a un caché, almacenando información usando un
prototipo.</p>
</div>
<h4 id="objective">Objetivo</h4>
<div class="hBody-4">
<p>El objetivo principal del patrón de diseño del Prototipo es evitar la
 creación de objetos repetitivos. Imagine un objeto predeterminado
compuesto por docenas de campos y tipos incrustados. No queremos
escribir todo lo que se necesita de este tipo cada vez que usamos el
objeto, especialmente si lo podemos crear creando instancias con
diferentes <i>fundamentos</i> :</p>
<ul>
<li>
<p>Mantener un conjunto de objetos que se clonarán para crear nuevas instancias</p>
</li>
<li>
<p>Proporcione un valor predeterminado de algún tipo para comenzar a trabajar encima de él</p>
</li>
<li>
<p>CPU libre de inicialización de objetos complejos para tomar más recursos de memoria</p>
</li>
</ul>
</div>
<h3 id="example">Ejemplo</h3>
<div class="hBody-3">
<p>Construiremos un pequeño componente de una tienda de camisas
imaginarias personalizadas que tendrá algunas camisas con sus colores y
precios predeterminados. Cada camiseta también tendrá una <b>Unidad de Stock Keeping</b> ( <span class="acronym">SKU</span> ), un sistema para identificar elementos almacenados en una ubicación específica, que necesitará una actualización.</p>
</div>
<h4 id="acceptance-criteria">Criterios de aceptación</h4>
<div class="hBody-4">
<p>Para lograr lo que se describe en el ejemplo, usaremos un prototipo
de camisas. Cada vez que necesitamos una camisa nueva tomaremos este
prototipo, lo clonaremos y trabajaremos con él. En particular, esos son
los criterios de aceptación para usar el método de diseño de patrón
Prototipo en este ejemplo:</p>
<ul>
<li>
<p>Tener un objeto e interfaz de clonador de camisa para pedir
diferentes tipos de camisetas (blanco, negro y azul a las 15.00, 16.00 y
 17.00 dólares, respectivamente)</p>
</li>
<li>
<p>Cuando solicite una camisa blanca, se debe hacer una clonación de la
camisa blanca, y la nueva instancia debe ser diferente de la original.</p>
</li>
<li>
<p>La SKU del objeto creado no debe afectar la creación de un nuevo objeto</p>
</li>
<li>
<p>Un método de información debe proporcionarme toda la información
disponible en los campos de instancia, incluida la SKU actualizada.</p>
</li>
</ul>
</div>
<h4 id="unit-test">Prueba de unidad</h4>
<div class="hBody-4">
<p>Primero, necesitaremos una interfaz <code>ShirtCloner</code> y un objeto que la implemente. Además, necesitamos una función a nivel de paquete llamada <code>GetShirtsCloner</code> para recuperar una nueva instancia del clonador:</p>
<pre class="code"><code class="go">type ShirtCloner interface {
  GetClone(s int) (ItemInfoGetter, error)
}

const (
  White = 1
  Black = 2
  Blue  = 3
)

func GetShirtsCloner() ShirtCloner {
  return nil
}

type ShirtsCache struct {}
func (s *ShirtsCache)GetClone(s int) (ItemInfoGetter, error) {
  return nil, errors.New("Not implemented yet")
}
</code></pre>
<p>Ahora necesitamos una estructura de objetos para clonar, que
implemente una interfaz para recuperar la información de sus campos.
Llamaremos al objeto <code>Shirt</code>y la interfaz <code>ItemInfoGetter</code>:</p>
<pre class="code"><code class="go">type ItemInfoGetter interface {
  GetInfo() string
}

type ShirtColor byte

type Shirt struct {
  Price float32
  SKU   string
  Color ShirtColor
}
func (s *Shirt) GetInfo()string {
  return ""
}

func GetShirtsCloner() ShirtCloner {
  return nil
}

var whitePrototype *Shirt = &amp;Shirt{
  Price: 15.00,
  SKU:   "empty",
  Color: White,
}

func (i *Shirt) GetPrice() float32 {
  return i.Price
}
</code></pre>
<div class="about">
<div class="about-dt">Tip</div>
<div class="about-dd">
<p>¿Te has dado cuenta de que el tipo llamado <code>ShirtColor</code> que definimos es solo un tipo <code>byte</code>? Quizás te estés preguntando por qué no hemos usado simplemente el byte <code>type</code>.
 Podríamos, pero de esta manera creamos una estructura fácil de leer,
que podemos actualizar con algunos métodos en el futuro si es necesario.
 Por ejemplo, podríamos escribir un método <code>String()</code> que devuelva el color en el formato de cadena ( <code>White</code> para el tipo 1, <code>Black</code> para el tipo 2 y <code>Blue</code> para el tipo 3).</p>
</div>
</div>
<p>Con este código, ya podemos escribir nuestras primeras pruebas:</p>
<pre class="code"><code class="go">func TestClone(t *testing.T) {
  shirtCache := GetShirtsCloner()
  if shirtCache == nil {
    t.Fatal("Received cache was nil")
  }

  item1, err := shirtCache.GetClone(White)
  if err != nil {
    t.Error(err)
  }

  // more code continues here...
</code></pre>
<p>Cubriremos el primer caso de nuestro escenario, donde necesitamos un
objeto clonador que podamos usar para pedir diferentes colores de
camisa.</p>
<p>Para el segundo caso, tomaremos el objeto original (al que podemos
acceder porque estamos dentro del alcance del paquete) y lo compararemos
 con nuestra <code>shirt1</code> instancia.</p>
<pre class="code"><code class="go">if item1 == whitePrototype {
  t.Error("item1 cannot be equal to the white prototype");
}
</code></pre>
<p>Ahora, para el tercer caso. Primero, escribiremos assert <code>item1</code>
 en una camisa para que podamos establecer un SKU. Crearemos una segunda
 camisa, también de color blanco, y la haremos también para verificar
que los SKU sean diferentes:</p>
<pre class="code"><code class="go">shirt1, ok := item1.(*Shirt)
if !ok {
  t.Fatal("Type assertion for shirt1 couldn't be done successfully")
}
shirt1.SKU = "abbcc"

item2, err := shirtCache.GetClone(White)
if err != nil {
  t.Fatal(err)
}

shirt2, ok := item2.(*Shirt)
if !ok {
  t.Fatal("Type assertion for shirt1 couldn't be done successfully")
}

if shirt1.SKU == shirt2.SKU {
  t.Error("SKU's of shirt1 and shirt2 must be different")
}

if shirt1 == shirt2 {
  t.Error("Shirt 1 cannot be equal to Shirt 2")
}
</code></pre>
<p>Finalmente, para el cuarto caso, registramos la información de la primera y segunda camisetas:</p>
<pre class="code"><code class="go">t.Logf("LOG: %s", shirt1.GetInfo())
t.Logf("LOG: %s", shirt2.GetInfo())
</code></pre>
<p>Imprimiremos las posiciones de memoria de ambas camisetas, por lo que hacemos esta afirmación en un nivel más físico:</p>
<pre class="code"><code class="go">t.Logf("LOG: The memory positions of the shirts are different %p != %p \n\n", &amp;shirt1, &amp;shirt2)
</code></pre>
<p>Finalmente, ejecutamos las pruebas para que podamos verificar si fallan:</p>
<pre class="srci"><code class="sh"><span class="in"><span class="prompt">&gt; </span>go test -run=TestClone .
</span><span class="out">--- FAIL: TestClone (0.00s)
prototype_test.go:10: Not implemented yet
FAIL
FAIL
</span></code></pre>
<p>Tenemos que detenernos allí para que las pruebas no entren en pánico
si tratamos de usar un objeto nil que sea devuelto por la función <code>GetShirtsCloner</code>.</p>
</div>
<h4 id="implementation">Implementación</h4>
<div class="hBody-4">
<p>Comenzaremos con el método <code>GetClone</code>. Este método debería devolver un artículo del tipo especificado y tenemos tres tipos: blanco, negro y azul:</p>
<pre class="code"><code class="go">var whitePrototype *Shirt = &amp;Shirt{
  Price: 15.00,
  SKU:   "empty",
  Color: White,
}

var blackPrototype *Shirt = &amp;Shirt{
  Price: 16.00,
  SKU:   "empty",
  Color: Black,
}

var bluePrototype *Shirt = &amp;Shirt{
  Price: 17.00,
  SKU:   "empty",
  Color: Blue,
}
</code></pre>
<p>Entonces, ahora que tenemos los tres prototipos para trabajar, podemos implementar el método <code>GetClone(s int)</code>:</p>
<pre class="code"><code class="go">type ShirtsCache struct {}
func (s *ShirtsCache)GetClone(s int) (ItemInfoGetter, error) {
  switch m {
  case White:
    newItem := *whitePrototype
    return &amp;newItem, nil
  case Black:
    newItem := *blackPrototype
    return &amp;newItem, nil
  case Blue:
    newItem := *bluePrototype
    return &amp;newItem, nil
  default:
    return nil, errors.New("Shirt model not recognized")
  }
}
</code></pre>
<p>La estructura <code>Shirt</code> también necesita una <code>GetInfo</code> implementación para imprimir el contenido de las instancias.</p>
<pre class="code"><code class="go">type ShirtColor byte

type Shirt struct {
  Price float32
  SKU   string
  Color ShirtColor
}
func (s *Shirt) GetInfo() string {
  return fmt.Sprintf("Shirt with SKU '%s' and Color id %d that costs %f\n",
    s.SKU, s.Color, s.Price)
}
</code></pre>
<p>Finalmente, hagamos las pruebas para ver que todo está funcionando:</p>
<pre class="srci"><code class="sh"><span class="in"><span class="prompt">&gt; </span>go test -run=TestClone -v .
</span><span class="out">=== RUN   TestClone
--- PASS: TestClone (0.00s)
prototype_test.go:41: LOG: Shirt with SKU 'abbcc' and Color id
1 that costs 15.000000
prototype_test.go:42: LOG: Shirt with SKU 'empty' and Color id
1 that costs 15.000000
prototype_test.go:44: LOG: The memory positions of the shirts
are different 0xc42002c038 != 0xc42002c040

PASS
ok
</span></code></pre>
<p>En el registro, (recuerde establecer el indicador <code>-v</code> al ejecutar las pruebas) puede verificarlo <code>shirt1</code>y <code>shirt2</code>
 tener SKU diferentes. Además, podemos ver las posiciones de memoria de
ambos objetos. Tenga en cuenta que las posiciones que se muestran en su
computadora probablemente serán diferentes.</p>
</div>
<h4 id="what-we-learned-about-the-prototype-design-pattern">Lo que aprendimos sobre el patrón de diseño del Prototipo</h4>
<div class="hBody-4">
<p>El patrón Prototype es una herramienta poderosa para construir cachés
 y objetos por defecto. Probablemente también se haya dado cuenta de que
 algunos patrones pueden superponerse un poco, pero tienen pequeñas
diferencias que los hacen más apropiados en algunos casos y no tanto en
otros.</p>
</div>
<h3 id="summary">Resumen</h3>
<div class="hBody-3">
<p>Hemos visto los cinco principales patrones de diseño creacional
comúnmente utilizados en la industria del software. Su propósito es
abstraer al usuario de la creación de objetos para fines de complejidad o
 mantenimiento. Han sido la base de miles de aplicaciones y bibliotecas
desde la década de 1990, y la mayoría del software que utilizamos hoy en
 día tiene muchos de estos patrones creacionales bajo el capó.</p>
<p>Vale la pena mencionar que estos patrones no son libres de hilos. En
un capítulo más avanzado, veremos programación concurrente en Go, y cómo
 crear algunos de los patrones de diseño más críticos usando un enfoque
concurrente.</p>
</div>
<h3 id="chapter-3.-structural-patterns---composite,-adapter,-and-bridge-design-patterns">Capítulo 3. Patrones estructurales: patrones de diseño compuesto, de adaptador y de puente</h3>
<div class="hBody-3">
<p>Vamos a comenzar nuestro viaje a través del mundo de los patrones
estructurales. Los patrones estructurales, como su nombre lo indica, nos
 ayudan a dar forma a nuestras aplicaciones con estructuras y relaciones
 de uso común.</p>
<p>El lenguaje Go, por naturaleza, fomenta el uso de la composición casi
 exclusivamente por su falta de herencia. Debido a esto, hemos estado
utilizando el patrón de diseño <b>compuesto</b> extensivamente hasta ahora, así que comencemos definiendo el patrón de diseño compuesto.</p>
</div>
<h4 id="composite-design-pattern">Patrón de diseño compuesto</h4>
<div class="hBody-4">
<p>El patrón de diseño compuesto favorece la composición (comúnmente definida como <i>una</i> relación) sobre la herencia (una <i>es una</i> relación). El enfoque de la <i>omisión sobre la herencia</i>
 ha sido una fuente de discusiones entre los ingenieros desde los años
noventa. Aprenderemos cómo crear estructuras de objetos usando a <i>tiene un</i> enfoque. ¡En general, Go no tiene herencia porque no la necesita!</p>
</div>
<h4 id="description">Descripción</h4>
<div class="hBody-4">
<p>En el patrón de diseño Compuesto, creará jerarquías y árboles de
objetos. Los objetos tienen diferentes objetos con sus propios campos y
métodos dentro de ellos. Este enfoque es muy poderoso y resuelve muchos
problemas de herencia y herencias múltiples. Por ejemplo, un problema
típico de herencia es cuando tienes una entidad que hereda de dos clases
 completamente diferentes, que no tienen absolutamente ninguna relación
entre ellas. Imagine a un atleta que entrena, y que es un nadador que
nada:</p>
<ul>
<li>
<p>La clase <code>Athlete</code> tiene un método <code>Train()</code></p>
</li>
<li>
<p>La clase <code>Swimmer</code> tiene un método <code>Swim()</code></p>
</li>
</ul>
<p>La clase <code>Swimmer</code> hereda de la clase <code>Athlete</code>, por lo que hereda su método <code>Train</code> y declara su propio método <code>Swim</code>. También podría tener un ciclista que también sea atleta y declarar un método <code>Ride</code>.</p>
<p>Pero ahora imagine un animal que come, como un perro que también ladra:</p>
<ul>
<li>
<p>La clase <code>Cyclist</code> tiene un método <code>Ride()</code></p>
</li>
<li>
<p>La clase <code>Animal</code> tiene <code>Eat()</code>, <code>Dog()</code>y métodos <code>Bark()</code></p>
</li>
</ul>
<p>Nada sofisticado. ¡También podrías tener un pez que sea un animal, y
sí, nada! Entonces, ¿cómo lo resuelves? Un pez no puede ser un nadador
que también entrene. Los peces no se entrenan (¡hasta donde yo sé!).
Podría hacer una interfaz <code>Swimmer</code> con un método <code>Swim</code> y hacer que el atleta nadador y el pez lo implementen. Este sería el mejor enfoque, pero aún tendría que implementar el método <code>swim</code>
 dos veces, por lo que la reutilización del código se vería afectada.
¿Qué tal un triatleta? Son atletas que nadan, corren y andan. Con
herencias múltiples, podría tener una especie de solución, pero se
volverá compleja y no se podrá mantener muy pronto.</p>
</div>
<h4 id="objectives">Objetivos</h4>
<div class="hBody-4">
<p>Como probablemente ya hayas imaginado, el objetivo de la composición
es evitar este tipo de infierno jerárquico donde la complejidad de una
aplicación puede crecer demasiado y la claridad del código se ve
afectada.</p>
</div>
<h4 id="the-swimmer-and-the-fish">El nadador y el pez</h4>
<div class="hBody-4">
<p>Resolveremos el problema descrito del atleta y el pez que nada de
manera muy idiomática. Con Go, podemos usar dos tipos de composición: la
 composición <b>directa</b> y la composición <b>incrustada</b>. Primero
resolveremos este problema usando la composición directa que tiene todo
lo que se necesita como campos dentro de la estructura.</p>
</div>
<h4 id="requirements-and-acceptance-criteria">Requisitos y criterios de aceptación</h4>
<div class="hBody-4">
<p>Los requisitos son como los descritos anteriormente. Tendremos un atleta y un nadador. También tendremos un animal y un pez. El <code>Swimmer</code>y los métodos <code>Fish</code> deben compartir el código. El atleta debe entrenar, y el animal debe comer:</p>
<ul>
<li>
<p>Debemos tener una estructura <code>Athlete</code> con un método <code>Train</code></p>
</li>
<li>
<p>Debemos tener un <code>Swimmer</code> con un método <code>Swim</code></p>
</li>
<li>
<p>Debemos tener una estructura <code>Animal</code> con un método <code>Eat</code></p>
</li>
<li>
<p>Debemos tener una estructura <code>Fish</code> con un método <code>Swim</code> que se comparte con el <code>Swimmer</code>, y no tener problemas de herencia o jerarquía</p>
</li>
</ul>
</div>
<h4 id="creating-compositions">Creando composiciones</h4>
<div class="hBody-4">
<p>El patrón de diseño compuesto es un patrón estructural puro, y no
tiene mucho que probar aparte de la estructura en sí. No escribiremos
pruebas unitarias en este caso, y simplemente describiremos las formas
de crear esas composiciones en Go.</p>
<p>Primero, comenzaremos con la estructura <code>Athlete</code> y su método <code>Train</code>:</p>
<pre class="code"><code class="go">type Athlete struct{}

func (a *Athlete) Train() {
  fmt.Println("Training")
}
</code></pre>
<p>El código anterior es bastante sencillo. Su método <code>Train</code> imprime la palabra <code>Training</code>y una nueva línea. Crearemos un nadador compuesto que tenga una estructura <code>Athlete</code> dentro:</p>
<pre class="code"><code class="go">type CompositeSwimmerA struct{
  MyAthlete Athlete
  MySwim func()
}
</code></pre>
<p>El tipo <code>CompositeSwimmerA</code> tiene un campo <code>MyAthlete</code> de tipo <code>Athlete</code>. También almacena un tipo <code>func()</code>.
 Recuerde que en Go, las funciones son ciudadanos de primera clase y se
pueden usar como parámetros, campos o argumentos como cualquier
variable. Entonces <code>CompositeSwimmerA</code> tiene un campo <code>MySwim</code> que almacena un <b>cierre</b>, que no toma argumentos y no devuelve nada. ¿Cómo puedo asignarle una función? Bueno, creemos una función que coincida con la <code>func()</code> firma (sin argumentos, sin retorno):</p>
<pre class="code"><code class="go">func Swim(){
  fmt.Println("Swimming!")
}
</code></pre>
<p>¡Eso es todo! La función <code>Swim()</code> no toma argumentos y no devuelve nada, por lo que puede usarse como el campo <code>MySwim</code> en la estructura <code>CompositeSwimmerA</code>:</p>
<pre class="code"><code class="go">swimmer := CompositeSwimmerA{
  MySwim: Swim,
}
swimmer.MyAthlete.Train()
swimmer.MySwim()
</code></pre>
<p>Como tenemos una función llamada <code>Swim()</code>, podemos asignarla al campo <code>MySwim</code>. Tenga en cuenta que el tipo <code>Swim</code> no tiene el paréntesis que ejecutará su contenido. De esta forma tomamos toda la función y la copiamos al método <code>MySwim</code>.</p>
<p>Pero espera. ¡No hemos pasado ningún atleta al campo <code>MyAthlete</code> y lo estamos usando! ¡Va a fallar! Veamos qué sucede cuando ejecutamos este fragmento:</p>
<pre class="srci"><code class="sh"><span class="in"><span class="prompt">&gt; </span>go run main.go
</span><span class="out">Training
Swimming!
</span></code></pre>
<p>Eso es raro, ¿no? No realmente debido a la naturaleza de la inicialización cero en Go. Si no pasa una estructura <code>Athlete</code> al tipo <code>CompositeSwimmerA</code>, el compilador creará una con sus valores cero inicializados, es decir, una estructura <code>Athlete</code> con sus campos inicializados a cero. Mira el <a href="https://nasciiboy.github.io/book4all/Go%20Design%20Patterns.html#chapter-1">Capítulo 1</a>, <i>Listo ... Firme ... ¡Vete! </i>para recordar la inicialización cero si esto parece confuso. Considere el código de la estructura <code>CompositeSwimmerA</code> de nuevo:</p>
<pre class="code"><code class="go">type CompositeSwimmerA struct{
  MyAthlete Athlete
  MySwim    func()
}
</code></pre>
<p>Ahora tenemos un puntero a una función almacenada en el campo <code>MySwim</code>. Podemos asignar la función <code>Swim</code> de la misma manera, pero con un paso adicional:</p>
<pre class="code"><code class="go">localSwim := Swim

swimmer := CompositeSwimmerA{
  MySwim: localSwim,
}

swimmer.MyAthlete.Train()
swimmer.MySwim ()
</code></pre>
<p>Primero, necesitamos una variable que contenga la función <code>Swim</code>. Esto se debe a que una función no tiene una dirección para pasarla al <code>CompositeSwimmerA</code> tipo. Luego, para usar esta función dentro de la estructura, tenemos que hacer una llamada de dos pasos.</p>
<p>¿Qué pasa con nuestro problema con los peces? Con nuestra función <code>Swim</code>, ya no es un problema. Primero, creamos la estructura <code>Animal</code>:</p>
<pre class="code"><code class="go">type Animal struct{}

func (r *Animal)Eat() {
  println("Eating")
}
</code></pre>
<p>Luego crearemos un objeto Shark que incruste el objeto <code>Animal</code>:</p>
<pre class="code"><code class="go">type Shark struct{
  Animal
  Swim func()
}
</code></pre>
<p>¡Espera un segundo! ¿Dónde está el nombre del campo del tipo <code>Animal</code>? ¿Te diste cuenta de que utilicé la palabra <i>incrustación</i>
 en el párrafo anterior? Esto se debe a que, en Ir, también puede
insertar objetos dentro de objetos para que se parezca mucho a la
herencia. Es decir, no tendremos que llamar explícitamente el nombre del
 campo para tener acceso a sus campos y a su método porque serán parte
de nosotros. Entonces el siguiente código estará perfectamente bien:</p>
<pre class="code"><code class="go">fish := Shark{
  Swim: Swim,
}

fish.Eat()
fish.Swim()
</code></pre>
<p>Ahora tenemos un tipo <code>Animal</code>, que se inicializa y se incrusta cero. Es por eso que puedo llamar al método <code>Eat</code> de la estructura <code>Animal</code> sin crearlo o usar el nombre de campo intermedio. El resultado de este fragmento es el siguiente:</p>
<pre class="srci"><code class="sh"><span class="in"><span class="prompt">&gt; </span>go run main.go
</span><span class="out">Eating
Swimming!
</span></code></pre>
<p>Finalmente, hay un tercer método para usar el patrón Compuesto. Podríamos crear una interfaz <code>Swimmer</code> con un método <code>Swim</code> y un tipo <code>SwimmerImpl</code> para incrustarlo en el nadador deportista:</p>
<pre class="code"><code class="go">type Swimmer interface {
  Swim()
}
type Trainer interface {
  Train()
}

type SwimmerImpl struct{}
func (s *SwimmerImpl) Swim(){
  println("Swimming!")
}

type CompositeSwimmerB struct{
  Trainer
  Swimmer
}
</code></pre>
<p>Con este método, tienes un control más explícito sobre la creación de objetos. El campo <code>Swimmer</code>
 está incrustado, pero no se inicializará en cero, ya que es un puntero a
 una interfaz. El uso correcto de este enfoque será el siguiente:</p>
<pre class="code"><code class="go">swimmer := CompositeSwimmerB{
  &amp;Athlete{},
  &amp;SwimmerImpl{},
}

swimmer.Train()
swimmer.Swim()
</code></pre>
<p>Y la salida para <code>CompositeSwimmerB</code> es la siguiente, como se esperaba:</p>
<pre class="srci"><code class="sh"><span class="in"><span class="prompt">&gt; </span>go run main.go
</span><span class="out">Training
Swimming!
</span></code></pre>
<p>¿Qué enfoque es mejor? Bueno, tengo una preferencia personal, que no
debe considerarse la regla general. En mi opinión, el enfoque de <i>interfaces</i>
 es el mejor por varias razones, pero principalmente por su carácter
explícito. En primer lugar, está trabajando con interfaces preferidas en
 lugar de estructuras. En segundo lugar, no está dejando partes de su
código en la característica de inicialización cero del compilador. Es
una característica realmente poderosa, pero que debe usarse con cuidado,
 ya que puede ocasionar problemas de tiempo de ejecución que se
encuentran en tiempo de compilación cuando se trabaja con interfaces. En
 diferentes situaciones, la inicialización cero lo salvará en el tiempo
de ejecución, de hecho! Pero prefiero trabajar con interfaces tanto como
 sea posible, por lo que esta no es realmente una de las opciones.</p>
</div>
<h4 id="binary-tree-compositions">Composiciones de árbol binario</h4>
<div class="hBody-4">
<p>Otro enfoque muy común para el patrón compuesto es cuando se trabaja
con estructuras de árbol binario. En un árbol binario, necesita
almacenar instancias de sí mismo en un campo:</p>
<pre class="code"><code class="go">type Tree struct {
  LeafValue int
  Right     *Tree
  Left      *Tree
}
</code></pre>
<p>Este es un tipo de composición recursiva y, debido a la naturaleza de
 la recursividad, debemos usar punteros para que el compilador sepa
cuánta memoria debe reservar para esta estructura. Nuestra estructura <code>Tree</code> almacenó un objeto <code>LeafValue</code> para cada instancia y una nueva <code>Tree</code> en sus campos <code>Right</code>y <code>Left</code>.</p>
<p>Con esta estructura, podríamos crear un objeto como este:</p>
<pre class="code"><code class="go">root := Tree{
  LeafValue: 0,
  Right:&amp;Tree{
    LeafValue: 5,
    Right: &amp;1Tree{ 6, nil, nil },
    Left: nil,
  },
  Left:&amp;Tree{ 4, nil, nil },
}
</code></pre>
<p>Podemos imprimir los contenidos de su rama más profunda de esta manera:</p>
<pre class="code"><code class="go">fmt.Println(root.Right.Right.LeafValue)
</code></pre>
<pre class="srci"><code class="sh"><span class="in"><span class="prompt">&gt; </span>go run main.go
</span><span class="out">6
</span></code></pre>
</div>
<h4 id="composite-pattern-versus-inheritance">Patrón compuesto versus herencia</h4>
<div class="hBody-4">
<p>Al utilizar el patrón de diseño compuesto en Go, debe tener mucho
cuidado de no confundirlo con la herencia. Por ejemplo, cuando incrusta
una estructura <code>Parent</code> dentro de una estructura <code>Son</code>, como en el siguiente ejemplo:</p>
<pre class="code"><code class="go">type Parent struct {
  SomeField int
}

type Son struct {
  Parent
}
</code></pre>
<p>No se puede considerar que la estructura <code>Son</code> también es la estructura <code>Parent</code>. Lo que esto significa es que no puede pasar una instancia de la estructura <code>Son</code> a una función que está esperando una estructura <code>Parent</code> como la siguiente:</p>
<pre class="code"><code class="go">func GetParentField(p *Parent) int{
  fmt.Println(p.SomeField)
}
</code></pre>
<p>Cuando intenta pasar una instancia de Son al método GetParentField, recibirá el siguiente mensaje de error:</p>
<pre class="srci"><code class="sh"><span class="out">cannot use son (type Son) as type Parent in argument to
GetParentField
</span></code></pre>
<p>Esto, de hecho, tiene mucho sentido. ¿Cuál es la solución para esto? Bueno, simplemente puede componer la estructura <code>Son</code> con el elemento primario sin incrustación para que pueda acceder a la instancia <code>Parent</code> más adelante:</p>
<pre class="code"><code class="go">type Son struct {
  P Parent
}
</code></pre>
<p>Entonces, ahora puedes usar el campo P para pasarlo al método <code>GetParentField</code>:</p>
<pre class="code"><code class="go">son := Son{}
GetParentField(son.P)
</code></pre>
</div>
<h4 id="final-words-on-the-composite-pattern">Palabras finales en el patrón compuesto</h4>
<div class="hBody-4">
<p>En este punto, debería sentirse realmente cómodo usando el patrón de
diseño compuesto. Es una característica Go muy idiomática, y el cambio
de un lenguaje puro orientado a objetos no es muy doloroso. El patrón de
 diseño compuesto hace que nuestras estructuras sean predecibles, pero
también nos permite crear la mayoría de los patrones de diseño, como
veremos en capítulos posteriores.</p>
</div>
<h3 id="adapter-design-pattern">Patrón de diseño del adaptador</h3>
<div class="hBody-3">
<p>Uno de los patrones estructurales más comúnmente utilizados es el patrón del <b>adaptador</b>.
 Al igual que en la vida real, donde tiene adaptadores de enchufe y
adaptadores de pernos, en Go, un adaptador nos permitirá usar algo que
no se creó para una tarea específica al principio.</p>
</div>
<h4 id="description">Descripción</h4>
<div class="hBody-4">
<p>El patrón de Adaptador es muy útil cuando, por ejemplo, una interfaz
se desactualiza y no es posible reemplazarla de manera fácil o rápida.
En su lugar, creas una nueva interfaz para lidiar con las necesidades
actuales de tu aplicación, que bajo el capó usa implementaciones de la
interfaz anterior.</p>
<p>El adaptador también nos ayuda a mantener el <i>principio de apertura / cierre</i>
 en nuestras aplicaciones, haciéndolo más predecible también. También
nos permiten escribir código que usa alguna base que no podemos
modificar.</p>
<div class="about">
<div class="about-dt">Nota</div>
<div class="about-dd">
<p>El principio de apertura / cierre fue declarado por primera vez por Bertrand Meyer en su libro <i>Object-Oriented Software Construction</i>.
 Dijo que el código debería estar abierto a nuevas funcionalidades, pero
 cerrado a modificaciones. Qué significa eso? Bueno, implica algunas
cosas. Por un lado, deberíamos tratar de escribir código extensible y no
 solo uno que funcione. Al mismo tiempo, debemos tratar de no modificar
el código fuente (el suyo o de otras personas) tanto como podamos,
porque no siempre somos conscientes de las implicaciones de esta
modificación. Solo tenga en cuenta que la extensibilidad en el código
solo es posible mediante el uso de patrones de diseño y programación
orientada a la interfaz.</p>
</div>
</div>
</div>
<h4 id="objectives">Objetivos</h4>
<div class="hBody-4">
<p>El patrón de diseño del Adaptador lo ayudará a satisfacer las
necesidades de dos partes del código que son incompatibles al principio.
 Esta es la clave que se debe tener en cuenta al decidir si el patrón
del Adaptador es un buen diseño para su problema: dos interfaces que son
 incompatibles, pero que deben funcionar juntas, son buenas candidatas
para un patrón de Adaptador (pero también podrían usar el patrón de
fachada, por ejemplo).</p>
</div>
<h4 id="using-an-incompatible-interface-with-an-adapter-object">Usar una interfaz incompatible con un objeto Adaptador</h4>
<div class="hBody-4">
<p>Para nuestro ejemplo, tendremos una interfaz <code>Printer</code>
antigua y una nueva. Los usuarios de la nueva interfaz no esperan la
firma que tiene la antigua, y necesitamos un Adaptador para que los
usuarios puedan seguir usando implementaciones antiguas si es necesario
(para trabajar con algún código heredado, por ejemplo).</p>
</div>
<h4 id="requirements-and-acceptance-criteria">Requisitos y criterios de aceptación</h4>
<div class="hBody-4">
<p>Cuando se llama a una interfaz antigua <code>LegacyPrinter</code>y se llama a una nueva <code>ModernPrinter</code>, se crea una estructura que implementa la interfaz <code>ModernPrinter</code> y puede usar la interfaz <code>LegacyPrinter</code> como se describe en los siguientes pasos:</p>
<ol class="num">
<li>
<p>Cree un objeto Adaptador que implemente la interfaz <code>ModernPrinter</code>.</p>
</li>
<li>
<p>El nuevo objeto Adapter debe contener una instancia de la interfaz <code>LegacyPrinter</code>.</p>
</li>
<li>
<p>Cuando se usa <code>ModernPrinter</code>, debe llamar a la interfaz <code>LegacyPrinter</code> debajo del capó, prefijándolo con el texto <code>Adapter</code>.</p>
</li>
</ol>
</div>
<h4 id="unit-testing-our-printer-adapter">Prueba de unidad de nuestro adaptador de impresora</h4>
<div class="hBody-4">
<p>Primero escribiremos el código heredado, pero no lo probaremos, ya que deberíamos imaginar que no es nuestro código:</p>
<pre class="code"><code class="go">type LegacyPrinter interface {
  Print(s string) string
}
type MyLegacyPrinter struct {}

func (l *MyLegacyPrinter) Print(s string) (newMsg string) {
  newMsg = fmt.Sprintf("Legacy Printer: %s\n", s)
  println(newMsg)
  return
}
</code></pre>
<p>La interfaz heredada llamada <code>LegacyPrinter</code> tiene un método <code>Print</code> que acepta una cadena y devuelve un mensaje. Nuestra estructura <code>MyLegacyPrinter</code> implementa la interfaz <code>LegacyPrinter</code> y modifica la cadena pasada mediante el prefijo del texto <code>Legacy Printer:</code>. Después de modificar el texto, la estructura <code>MyLegacyPrinter</code> imprime el texto en la consola y luego lo devuelve.</p>
<p>Ahora declararemos la nueva interfaz que tendremos que adaptar:</p>
<pre class="code"><code class="go">type ModernPrinter interface {
  PrintStored() string
}
</code></pre>
<p>En este caso, el nuevo método <code>PrintStored</code> no acepta
ninguna cadena como argumento, ya que deberá almacenarse previamente en
los implementadores. Llamaremos a la interfaz <code>PrinterAdapter</code> de nuestro patrón de adaptador :</p>
<pre class="code"><code class="go">type PrinterAdapter struct{
  OldPrinter LegacyPrinter
  Msg        string
}
func(p *PrinterAdapter) PrintStored() (newMsg string) {
  return
}
</code></pre>
<p>Como se mencionó anteriormente, el <code>PrinterAdapter</code>
adaptador debe tener un campo para almacenar la cadena para imprimir.
También debe tener un campo para almacenar una instancia del <code>LegacyPrinter</code> adaptador. Así que vamos a escribir las pruebas unitarias:</p>
<pre class="code"><code class="go">func TestAdapter(t *testing.T){
  msg := "Hello World!"
</code></pre>
<p>Usaremos el mensaje <code>Hello World!</code> para nuestro adaptador. Al usar este mensaje con una instancia de la estructura <code>MyLegacyPrinter</code>, imprime el texto <code>Legacy Printer: Hello World!</code>:</p>
<pre class="code"><code class="go">adapter := PrinterAdapter{OldPrinter: &amp;MyLegacyPrinter{}, Msg: msg}
</code></pre>
<p>Creamos una instancia de la interfaz <code>PrinterAdapter</code> llamada <code>adapter</code>. Pasamos una instancia de la estructura <code>MyLegacyPrinter</code> como el campo <code>LegacyPrinter</code> llamado <code>OldPrinter</code>. Además, configuramos el mensaje que queremos imprimir en el campo <code>Msg</code>:</p>
<pre class="code"><code class="go">returnedMsg := adapter.PrintStored()
if returnedMsg != "Legacy Printer: Adapter: Hello World!\n" {
  t.Errorf("Message didn't match: %s\n", returnedMsg)
}
</code></pre>
<p>Luego usamos el método <code>PrintStored</code> de la interfaz <code>ModernPrinter</code>; este método no acepta ningún argumento y debe devolver la cadena modificada. Sabemos que la estructura <code>MyLegacyPrinter</code> devuelve la cadena pasada precedida del texto <code>LegacyPrinter</code>:, y el adaptador la antepondrá con el texto <code>Adapter:</code> Entonces, al final, debemos tener el texto <code>Legacy Printer: Adapter: Hello World!\n</code>.</p>
<p>Como estamos almacenando una instancia de una interfaz, también
debemos verificar que manejemos la situación donde el puntero es nulo.
Esto se hace con la siguiente prueba:</p>
<pre class="code"><code class="go">adapter = PrinterAdapter{OldPrinter: nil, Msg: msg}
returnedMsg = adapter.PrintStored()
if returnedMsg != "Hello World!" {
  t.Errorf("Message didn't match: %s\n", returnedMsg)
}
</code></pre>
<p>Si no pasamos una instancia de la interfaz <code>LegacyPrinter</code>,
 el Adaptador debe ignorar su naturaleza de adaptación e imprimir y
devolver el mensaje original. Hora de ejecutar nuestras pruebas;
considera lo siguiente:</p>
<pre class="srci"><code class="sh"><span class="in"><span class="prompt">&gt; </span>go test -v .
</span><span class="out">=== RUN   TestAdapter
--- FAIL: TestAdapter (0.00s)
        adapter_test.go:11: Message didn't match:
        adapter_test.go:17: Message didn't match:
FAIL
exit status 1
FAIL
</span></code></pre>
</div>
<h3 id="implementation">Implementación</h3>
<div class="hBody-3">
<p>Para hacer que nuestra prueba única pase, debemos reutilizar la anterior <code>MyLegacyPrinter</code> que está almacenada en <code>PrinterAdapter</code> struct:</p>
<pre class="code"><code class="go">type PrinterAdapter struct{
  OldPrinter LegacyPrinter
  Msg        string
}

func(p *PrinterAdapter) PrintStored() (newMsg string) {
  if p.OldPrinter != nil {
    newMsg = fmt.Sprintf("Adapter: %s", p.Msg)
    newMsg = p.OldPrinter.Print(newMsg)
  }
  else {
    newMsg = p.Msg
  }
  return
}
</code></pre>
<p>En el método <code>PrintStored</code>, verificamos si realmente tenemos una instancia de a <code>LegacyPrinter</code>. En este caso, redactamos una nueva cadena con el mensaje almacenado y el prefijo <code>Adapter</code> para almacenarla en la variable de devolución (llamada <code>newMsg</code>). Luego usamos el puntero a la estructura <code>MyLegacyPrinter</code> para imprimir el mensaje compuesto usando la interfaz <code>LegacyPrinter</code>.</p>
<p>En caso de que no haya ninguna instancia <code>LegacyPrinter</code> almacenada en el campo <code>OldPrinter</code>, simplemente asignamos el mensaje almacenado a la variable de retorno <code>newMsg</code> y devolvemos el método. Esto debería ser suficiente para pasar nuestras pruebas:</p>
<pre class="srci"><code class="sh"><span class="in"><span class="prompt">&gt; </span>go test -v .
</span><span class="out">=== RUN   TestAdapter
Legacy Printer: Adapter: Hello World!
--- PASS: TestAdapter (0.00s)
PASS
ok
</span></code></pre>
<p>¡Perfecto! Ahora todavía podemos usar la interfaz <code>LegacyPrinter</code> anterior al usar esto <code>Adapter</code> mientras usamos la interfaz <code>ModernPrinter</code>
 para implementaciones futuras. Solo tenga en cuenta que el patrón del
Adaptador idealmente debe proporcionar la manera de usar el viejo <code>LegacyPrinter</code>y nada más. De esta forma, su alcance estará más encapsulado y será más fácil de mantener en el futuro.</p>
</div>
<h4 id="examples-of-the-adapter-pattern-in-go's-source-code">Ejemplos del patrón de adaptador en el código fuente de Go</h4>
<div class="hBody-4">
<p>Puede encontrar implementaciones de Adapter en muchos lugares en el código fuente del idioma Go. La famosa interfaz <code>http.Handler</code> tiene una implementación de adaptador muy interesante. Un <code>Hello World</code> servidor muy simple en Go generalmente se hace así:</p>
<pre class="code"><code class="go">package main

import (
  "fmt"
  "log"
  "net/http"
)
type MyServer struct{
  Msg string
}
func (m *MyServer) ServeHTTP(w http.ResponseWriter,r
  *http.Request){
  fmt.Fprintf(w, "Hello, World")
}

func main() {
  server := &amp;MyServer{
    Msg:"Hello, World",
  }

  http.Handle("/", server)
  log.Fatal(http.ListenAndServe(":8080", nil))
}
</code></pre>
<p>El paquete HTTP tiene una función llamada <code>Handle</code>(como un método <code>static</code> en Java) que acepta dos parámetros: una cadena para representar la ruta y una interfaz <code>Handler</code>. La interfaz <code>Handler</code> es como la siguiente:</p>
<pre class="code"><code class="go">type Handler interface {
  ServeHTTP(ResponseWriter, *Request)
}
</code></pre>
<p>Necesitamos implementar un método <code>ServeHTTP</code> que el lado del servidor de una conexión HTTP use para ejecutar su contexto. Pero también hay una función <code>HandlerFunc</code> que le permite definir un comportamiento de punto final:</p>
<pre class="code"><code class="go">func main() {
  http.HandleFunc("/", func(w http.ResponseWriter, r
    *http.Request) {
      fmt.Fprintf(w, "Hello, World")
    })

  log.Fatal(http.ListenAndServe(":8080", nil))
}
</code></pre>
<p>La función <code>HandleFunc</code> es en realidad parte de un adaptador para usar funciones directamente como implementaciones <code>ServeHTTP</code>. Lee la última oración lentamente otra vez, ¿puedes adivinar cómo se hace?</p>
<pre class="code"><code class="go">type HandlerFunc func(ResponseWriter, *Request)

func (f HandlerFunc) ServeHTTP(w ResponseWriter, r *Request) {
  f(w, r)
}
</code></pre>
<p>Podemos definir un tipo que sea una función de la misma manera que
definimos una estructura. Hacemos este tipo de función para implementar
el método <code>ServeHTTP</code>. Finalmente, desde la función <code>ServeHTTP</code>, llamamos al receptor mismo <code>f(w, r)</code>.</p>
<p>Debe pensar en la implementación implícita de la interfaz de Go. Cuando definimos una función como <code>func(ResponseWriter, *Request)</code>, se reconoce implícitamente como <code>HandlerFunc</code>. Y debido a que la función <code>HandleFunc</code> implementa la interfaz <code>Handler</code>, nuestra función también implementa la interfaz <code>Handler</code> implícitamente. ¿Esto te suena familiar? Si <i>A = B</i> y <i>B = C</i>, entonces <i>A = C</i>.
 La implementación implícita brinda mucha flexibilidad y potencia a Go,
pero también debe tener cuidado, porque no sabe si un método o función
podría estar implementando alguna interfaz que podría provocar
comportamientos indeseables.</p>
<p>Podemos encontrar más ejemplos en el código fuente de Go. El paquete <code>io</code>
 tiene otro poderoso ejemplo con el uso de tuberías. Un conducto en
Linux es un mecanismo de flujo que toma algo en la entrada y genera algo
 más en la salida. El paquete io tiene dos interfaces, que se usan en
todas partes en el código fuente de Go: el <code>io.Reader</code>y la interfaz <code>io.Writer</code>:</p>
<pre class="code"><code class="go">type Reader interface {
  Read(p []byte) (n int, err error)
}

type Writer interface {
  Write(p []byte) (n int, err error)
}
</code></pre>
<p>Usamos en <code>io.Reader</code> todas partes, por ejemplo, cuando abre un archivo usando <code>os.OpenFile</code>, devuelve un archivo, que, de hecho, implementa la interfaz <code>io.Reader</code>. ¿Por qué es útil? Imagine que escribe una estructura <code>Counter</code> que cuenta desde el número que proporciona a cero:</p>
<pre class="code"><code class="go">type Counter struct {}
func (f *Counter) Count(n uint64) uint64 {
  if n == 0 {
    println(strconv.Itoa(0))
    return 0
  }

  cur := n
  println(strconv.FormatUint(cur, 10))
  return f.Count(n - 1)
}
</code></pre>
<p>Si proporciona el número 3 en este pequeño fragmento, imprimirá lo siguiente:</p>
<pre class="srci"><code class="sh"><span class="out">3
2
1
</span></code></pre>
<p>Bueno, ¡no realmente impresionante! ¿Qué pasa si quiero escribir en
un archivo en lugar de imprimir? Podemos implementar este método
también. ¿Qué sucede si quiero imprimir en un archivo y en la consola?
Bien, podemos implementar este método también. Debemos modularlo un poco
 más usando la interfaz <code>io.Writer</code>:</p>
<pre class="code"><code class="go">type Counter struct {
  Writer io.Writer
}
func (f *Counter) Count(n uint64) uint64 {
  if n == 0 {
    f.Writer.Write([]byte(strconv.Itoa(0) + "\n"))
    return 0
  }

  cur := n
  f.Writer.Write([]byte(strconv.FormatUint(cur, 10) + "\n"))
  return f.Count(n - 1)
}
</code></pre>
<p>Ahora proporcionamos un <code>io.Writer</code> en el campo <code>Writer</code>. De esta forma, podríamos crear el contador así: <code>c := Counter{os.Stdout}</code>y obtendremos una consola <code>Writer</code>. Pero espere un segundo, no hemos resuelto el problema donde queríamos llevar el conteo a muchas <code>Writer</code> consolas. Pero podemos escribir una nueva <code>Adapter</code> con an <code>io.Writer</code>y, usando a <code>Pipe()</code>
 para conectar un lector con un escritor, podemos leer en el extremo
opuesto. De esta forma, puede resolver el problema donde estas dos
interfaces, <code>Reader</code>y las <code>Writer</code> cuales son incompatibles, se pueden usar juntas.</p>
<p>De hecho, no necesitamos escribir el Adaptador, la biblioteca <code>io</code> de Go tiene uno para nosotros <code>io.Pipe()</code>. La tubería nos permitirá convertir una interfaz <code>Reader</code> de Writer. El método <code>io.Pipe()</code> nos proporcionará una <code>Writer</code>(la entrada de la tubería) y una <code>Reader</code>(la salida) para jugar. Así que creemos un conducto y asignemos el escritor proporcionado al <code>Counter</code> ejemplo anterior:</p>
<pre class="code"><code class="go">pipeReader, pipeWriter := io.Pipe()
defer pw.Close()
defer pr.Close()

counter := Counter{
  Writer: pipeWriter,
}
</code></pre>
<p>Ahora tenemos una interfaz <code>Reader</code> donde anteriormente teníamos una <code>Writer</code>. Donde podemos usar el <code>Reader</code>? La función <code>io.TeeReader</code> nos ayuda a copiar la secuencia de datos de una interfaz <code>Reader</code> a la interfaz <code>Writer</code> y devuelve una nueva <code>Reader</code>
 que aún puede usar para transmitir datos nuevamente a un segundo
escritor. Entonces transmitiremos los datos del mismo lector a dos
escritores: el <code>file</code>y el <code>Stdout</code>.</p>
<pre class="code"><code class="go">tee := io.TeeReader(pipeReader, file)
</code></pre>
<p>Entonces ahora sabemos que estamos escribiendo en un archivo que hemos pasado a la función <code>TeeReader</code>. Todavía tenemos que imprimir en la consola. El adaptador <code>io.Copy</code> se puede utilizar como <code>TeeReader</code>- toma un lector y escribe su contenido a un escritor:</p>
<pre class="code"><code class="go">go func(){
  io.Copy(os.Stdout, tee)
}()
</code></pre>
<p>Tenemos que iniciar la función <code>Copy</code> en una rutina
diferente de Go para que las escrituras se realicen simultáneamente, y
una lectura / escritura no bloquea una lectura / escritura diferente.
Modifiquemos la variable <code>counter</code> para que vuelva a contar hasta 5:</p>
<pre class="code"><code class="go">counter.Count(5)
</code></pre>
<p>Con esta modificación del código, obtenemos el siguiente resultado:</p>
<pre class="srci"><code class="sh"><span class="in"><span class="prompt">&gt; </span>go run counter.go
</span><span class="out">5
4
3
2
1
0
</span></code></pre>
<p>De acuerdo, el recuento se ha impreso en la consola. ¿Qué hay del archivo?</p>
<pre class="srci"><code class="sh"><span class="in"><span class="prompt">&gt; </span>cat /tmp/pipe
</span><span class="out">5
4
3
2
1
0
</span></code></pre>
<p>¡Increíble! Al usar el adaptador <code>io.Pipe()</code> proporcionado en la biblioteca nativa Go, hemos desacoplado nuestro contador de su salida, y hemos adaptado una interfaz <code>Writer</code> a una <code>Reader</code>.</p>
</div>
<h4 id="what-the-go-source-code-tells-us-about-the-adapter-pattern">Qué dice el código fuente de Go sobre el patrón del Adaptador</h4>
<div class="hBody-4">
<p>Con el patrón de diseño del Adaptador, ha aprendido una forma rápida
de alcanzar el principio de apertura / cierre en sus aplicaciones. En
lugar de modificar su antiguo código fuente (algo que no podría ser
posible en algunas situaciones), ha creado una forma de utilizar la
funcionalidad anterior con una nueva firma.</p>
</div>
<h3 id="bridge-design-pattern">Patrón de diseño de puente</h3>
<div class="hBody-3">
<p>El patrón <b>Bridge</b> es un diseño con una definición ligeramente críptica <i>del</i> libro original de <i>Gang of Four</i>.
 Desacopla una abstracción de su implementación para que las dos puedan
variar de forma independiente. Esta explicación críptica solo significa
que podrías desacoplar la forma más básica de funcionalidad: desacoplar
un objeto de lo que hace.</p>
</div>
<h4 id="description">Descripción</h4>
<div class="hBody-4">
<p>El patrón Bridge intenta desacoplar las cosas como de costumbre con
los patrones de diseño. Desvincula la abstracción (un objeto) de su
implementación (lo que hace el objeto). De esta manera, podemos cambiar
lo que un objeto hace tanto como queremos. También nos permite cambiar
el objeto abstraído al reutilizar la misma implementación.</p>
</div>
<h4 id="objectives">Objetivos</h4>
<div class="hBody-4">
<p>El objetivo del patrón Bridge es brindar flexibilidad a una
estructura que cambia con frecuencia. Al conocer las entradas y salidas
de un método, nos permite cambiar el código sin saber demasiado al
respecto y dejando que la libertad de ambos lados se modifique más
fácilmente.</p>
</div>
<h4 id="two-printers-and-two-ways-of-printing-for-each">Dos impresoras y dos formas de imprimir para cada</h4>
<div class="hBody-4">
<p>Para nuestro ejemplo, vamos a ir a una abstracción de impresora de
consola para mantenerlo simple. Tendremos dos implementaciones. El
primero escribirá en la consola. Después de haber aprendido sobre la
interfaz <code>io.Writer</code> en la sección anterior, realizaremos la segunda escritura en una interfaz <code>io.Writer</code>
 para proporcionar más flexibilidad a la solución. También tendremos dos
 usuarios de objetos abstraídos de las implementaciones: un objeto <code>Normal</code>, que usará cada implementación de manera directa, y una implementación <code>Packt</code>, que agregará la frase <code>Message from Packt</code>: al mensaje de impresión.</p>
<p>Al final de esta sección, tendremos dos objetos de abstracción, que
tienen dos implementaciones diferentes de su funcionalidad. Entonces, en
 realidad, tendremos 2² combinaciones posibles de funcionalidad de
objeto.</p>
</div>
<h4 id="requirements-and-acceptance-criteria">Requisitos y criterios de aceptación</h4>
<div class="hBody-4">
<p>Como mencionamos anteriormente, tendremos dos objetos ( <code>Packt</code>e impresora <code>Normal</code>) y dos implementaciones ( <code>PrinterImpl1</code>y <code>PrinterImpl2</code>)
 que uniremos utilizando el patrón de diseño de Puente. Más o menos,
tendremos los siguientes requisitos y criterios de aceptación:</p>
<ul>
<li>
<p>A <code>PrinterAPI</code> que acepta un mensaje para imprimir</p>
</li>
<li>
<p>Una implementación de la API que simplemente imprime el mensaje en la consola</p>
</li>
<li>
<p>Una implementación de la API que se imprime en una interfaz io.Writer</p>
</li>
<li>
<p>Una abstracción <code>Printer</code> con un método <code>Print</code> para implementar en tipos de impresión</p>
</li>
<li>
<p>Un objeto <code>normal</code> de impresora, que implementará la impresora y la interfaz <code>PrinterAPI</code></p>
</li>
<li>
<p>La impresora <code>normal</code> reenviará el mensaje directamente a la implementación</p>
</li>
<li>
<p>Una impresora <code>Packt</code>, que implementará la abstracción <code>Printer</code> y la interfaz <code>PrinterAPI</code></p>
</li>
<li>
<p>La impresora <code>Packt</code> adjuntará el mensaje <code>Message from Packt</code>: a todas las impresiones</p>
</li>
</ul>
</div>
<h4 id="unit-testing-the-bridge-pattern">Unidad probando el patrón Bridge</h4>
<div class="hBody-4">
<p>Comencemos con los <i>criterios de aceptación 1</i>, la interfaz <code>PrinterAPI</code>. Los implementadores de esta interfaz deben proporcionar un método <code>PrintMessage(string)</code> que imprima el mensaje pasado como argumento:</p>
<pre class="code"><code class="go">type PrinterAPI interface {
  PrintMessage(string) error
}
</code></pre>
<p>Pasaremos a los <i>criterios de aceptación 2</i> con una implementación de la API anterior:</p>
<pre class="code"><code class="go">type PrinterImpl1 struct{}

func (p *PrinterImpl1) PrintMessage(msg string) error {
  return errors.New("Not implemented yet")
}
</code></pre>
<p>Nuestro <code>PrinterImpl1</code> es un tipo que implementa la interfaz <code>PrinterAPI</code> al proporcionar una implementación del método <code>PrintMessage</code>. El método <code>PrintMessage</code> aún no está implementado y devuelve un error. Esto es suficiente para escribir nuestra primera prueba unitaria para cubrir <code>PrinterImpl1</code>:</p>
<pre class="code"><code class="go">func TestPrintAPI1(t *testing.T){
  api1 := PrinterImpl1{}

  err := api1.PrintMessage("Hello")
  if err != nil {
    t.Errorf("Error trying to use the API1 implementation: Message: %s\n", err.Error())
  }
}
</code></pre>
<p>En nuestra prueba para cubrir <code>PrintAPI1</code>, creamos una instancia de tipo <code>PrinterImpl1</code>. Luego usamos su método <code>PrintMessage</code> para imprimir el mensaje <code>Hello</code>a la consola. Como aún no tenemos implementación, debe devolver el error srring <code>Not implemented yet</code>:</p>
<pre class="srci"><code class="sh"><span class="in"><span class="prompt">&gt; </span>go test -v -run=TestPrintAPI1 .
</span><span class="out">=== RUN   TestPrintAPI1
--- FAIL: TestPrintAPI1 (0.00s)
        bridge_test.go:14: Error trying to use the API1
implementation: Message: Not implemented yet
FAIL
exit status 1
FAIL    _/C_/Users/mario/Desktop/go-design-patterns/structural/bridge/traditional
</span></code></pre>
<ol class="alpha">
<li>
<p>Ahora tenemos que escribir la segunda prueba API que funcionará con un</p>
</li>
</ol>
<p>interfaz <code>io.Writer</code>:</p>
<pre class="code"><code class="go">type PrinterImpl2 struct{
  Writer io.Writer
}

func (d *PrinterImpl2) PrintMessage(msg string) error {
  return errors.New("Not implemented yet")
}
</code></pre>
<p>Como puede ver, nuestra estructura <code>PrinterImpl2</code> almacena un implementador de io.Writer. Además, nuestro método <code>PrintMessage</code> sigue la interfaz <code>PrinterAPI</code>.</p>
<p>Ahora que estamos familiarizados con la interfaz <code>io.Writer</code>,
 haremos un objeto de prueba que implemente esta interfaz y almacene lo
que esté escrito en un campo local. Esto nos ayudará a verificar los
contenidos que están siendo enviados por el escritor:</p>
<pre class="code"><code class="go">type TestWriter struct {
  Msg string
}

func (t *TestWriter) Write(p []byte) (n int, err error) {
  n = len(p)
  if n &gt; 0 {
    t.Msg = string(p)
    return n, nil
  }
  err = errors.New("Content received on Writer was empty")
  return
}
</code></pre>
<p>En nuestro objeto de prueba, verificamos que el contenido no esté
vacío antes de escribirlo en el campo local. Si está vacío, devolvemos
el error, y si no, escribimos el contenido de p en el campo <code>Msg</code>. Usaremos esta pequeña estructura en las siguientes pruebas para la segunda API:</p>
<pre class="code"><code class="go">func TestPrintAPI2(t *testing.T){
  api2 := PrinterImpl2{}

  err := api2.PrintMessage("Hello")
  if err != nil {
    expectedErrorMessage := "You need to pass an io.Writer to PrinterImpl2"
    if !strings.Contains(err.Error(), expectedErrorMessage) {
      t.Errorf("Error message was not correct.\n Actual: %s\nExpected: %s\n",
        err.Error(), expectedErrorMessage)
    }
  }
</code></pre>
<p>Vamos a detenernos por un segundo aquí. Creamos una instancia de <code>PrinterImpl2</code> llamada <code>api2</code> en la primera línea del código anterior. No hemos pasado ninguna instancia de <code>io.Writer</code> propósito, así que también verificamos que realmente recibimos un error primero. Luego tratamos de usar su método <code>PrintMessage</code>, pero debemos obtener un error porque no tiene ninguna instancia <code>io.Writer</code> almacenada en el campo <code>Writer</code>. El error debe ser <code>You need to pass an io.Writer to PrinterImpl2</code>e implícitamente verificamos el contenido del error. Continuemos con la prueba:</p>
<pre class="code"><code class="go">  testWriter := TestWriter{}
  api2 = PrinterImpl2{
    Writer: &amp;testWriter,
  }

  expectedMessage := "Hello"
  err = api2.PrintMessage(expectedMessage)
  if err != nil {
    t.Errorf("Error trying to use the API2 implementation: %s\n", err.Error())
  }

  if testWriter.Msg !=  expectedMessage {
    t.Fatalf("API2 did not write correctly on the io.Writer. \n Actual: %s\nExpected: %s\n",
      testWriter.Msg, expectedMessage)
  }
}
</code></pre>
<p>Para la segunda parte de esta prueba de unidad, utilizamos una instancia del objeto <code>TestWriter</code> como un interfaz <code>io.Writer</code>, <code>testWriter</code>. Pasamos el mensaje <code>Hello</code>a <code>api2</code>, y verificamos si recibimos algún error. Luego, verificamos el contenido del campo <code>testWriter.Msg</code>: recuerde que hemos escrito una interfaz <code>io.Writer</code> que almacenó los bytes pasados ​​a su método <code>Write</code> en el campo <code>Msg</code>. Si todo es correcto, el mensaje debe contener la palabra <code>Hello</code>.</p>
<p>Esas fueron nuestras pruebas para <code>PrinterImpl2</code>. Como todavía no tenemos implementaciones, debemos obtener algunos errores al ejecutar esta prueba:</p>
<pre class="srci"><code class="sh"><span class="in"><span class="prompt">&gt; </span>go test -v -run=TestPrintAPI2 .
</span><span class="out">=== RUN   TestPrintAPI2
--- FAIL: TestPrintAPI2 (0.00s)
bridge_test.go:39: Error message was not correct.
Actual: Not implemented yet
Expected: You need to pass an io.Writer to PrinterImpl2
bridge_test.go:52: Error trying to use the API2 implementation:
Not
implemented yet
bridge_test.go:57: API2 did not write correctly on the
io.Writer.
Actual:
Expected: Hello
FAIL
exit status 1
FAIL
</span></code></pre>
<p>Al menos una prueba pasa, la que verifica que se devuelve un mensaje de error (cualquiera) cuando se utiliza <code>PrintMessage</code> sin <code>io.Writer</code> estar almacenado. Todo lo demás falla, como se espera en esta etapa.</p>
<p>Ahora necesitamos una abstracción de impresora para objetos que puedan usar <code>PrinterAPI</code> implementadores. Definiremos esto como la interfaz <code>PrinterAbstraction</code> con un método <code>Print</code>. Esto cubre los <i>criterios de aceptación 4</i> :</p>
<pre class="code"><code class="go">type PrinterAbstraction interface {
  Print() error
}
</code></pre>
<p>Para los <i>criterios de aceptación 5</i>, necesitamos una impresora normal. Una abstracción <code>Printer</code> necesitará un campo para almacenar a <code>PrinterAPI</code>. Entonces nuestro <code>NormalPrinter</code> podría verse así:</p>
<pre class="code"><code class="go">type NormalPrinter struct {
  Msg     string
  Printer PrinterAPI
}

func (c *NormalPrinter) Print() error {
  return errors.New("Not implemented yet")
}
</code></pre>
<p>Esto es suficiente para escribir una prueba unitaria para el método <code>Print()</code>:</p>
<pre class="code"><code class="go">func TestNormalPrinter_Print(t *testing.T) {
  expectedMessage := "Hello io.Writer"

  normal := NormalPrinter{
    Msg:expectedMessage,
    Printer: &amp;PrinterImpl1{},
  }

  err := normal.Print()
  if err != nil {
    t.Errorf(err.Error())
  }
}
</code></pre>
<p>La primera parte de la prueba comprueba que el método <code>Print()</code> aún no está implementado cuando se usa la interfaz <code>PrinterImpl1 PrinterAPI</code>. El mensaje que usaremos a lo largo de esta prueba es <code>Hello io.Writer</code>. Con el <code>PrinterImpl1</code>,
 no tenemos una manera fácil de verificar el contenido del mensaje, ya
que imprimimos directamente en la consola. La comprobación, en este
caso, es visual, por lo que podemos verificar los <i>criterios de aceptación 6:</i></p>
<pre class="code"><code class="go">  testWriter := TestWriter{}
  normal = NormalPrinter{
    Msg: expectedMessage,
    Printer: &amp;PrinterImpl2{
      Writer:&amp;testWriter,
    },
  }

  err = normal.Print()
  if err != nil {
    t.Error(err.Error())
  }

  if testWriter.Msg != expectedMessage {
    t.Errorf("The expected message on the io.Writer doesn't match actual.\n  Actual: %s\nExpected: %s\n",
      testWriter.Msg, expectedMessage)
  }
}
</code></pre>
<p>La segunda parte de los <code>NormalPrinter</code> usos de las pruebas <code>PrinterImpl2</code>, la que necesita un <code>io.Writer</code> implementador de interfaz. Reutilizamos nuestra estructura <code>TestWriter</code> aquí para verificar el contenido del mensaje. Entonces, en resumen, queremos una estructura <code>NormalPrinter</code> que acepte un tipo <code>Msg</code> de cadena y una impresora de tipo <code>PrinterAPI</code>. En este punto, si uso el método <code>Print</code>, no debería obtener ningún error, y el campo <code>Msg</code> activado <code>TestWriter</code> debe contener el mensaje que le pasamos <code>NormalPrinter</code> en su inicialización.</p>
<p>Vamos a ejecutar las pruebas:</p>
<pre class="srci"><code class="sh"><span class="in"><span class="prompt">&gt; </span>go test -v -run=TestNormalPrinter_Print .
</span><span class="out">=== RUN   TestNormalPrinter_Print
--- FAIL: TestNormalPrinter_Print (0.00s)
    bridge_test.go:72: Not implemented yet
    bridge_test.go:85: Not implemented yet
    bridge_test.go:89: The expected message on the io.Writer
doesn't match actual.
             Actual:
             Expected: Hello io.Writer
FAIL
exit status 1
FAIL
</span></code></pre>
<p>Hay un truco para verificar rápidamente la validez de una prueba unitaria: la cantidad de veces que llamamos <code>t.Error</code>o <code>t.Errorf</code>
 debe coincidir con la cantidad de mensajes de error en la consola y las
 líneas donde se produjeron. En los resultados de las pruebas
anteriores, hay tres errores en las <i>líneas 72</i>, <i>85</i> y <i>89</i>, que coinciden exactamente con los controles que escribimos.</p>
<p>Nuestra estructura <code>PacktPrinter</code> tendrá una definición muy similar a <code>NormalPrinter</code> en este punto:</p>
<pre class="code"><code class="go">type PacktPrinter struct {
  Msg     string
  Printer PrinterAPI
}

func (c *PacktPrinter) Print() error {
  return errors.New("Not implemented yet")
}
</code></pre>
<p>Esto cubre los <i>criterios de aceptación 7</i>. Y casi podemos copiar y pegar el contenido de la prueba anterior con algunos cambios:</p>
<pre class="code"><code class="go">func TestPacktPrinter_Print(t *testing.T) {
  passedMessage := "Hello io.Writer"
  expectedMessage := "Message from Packt: Hello io.Writer"

  packt := PacktPrinter{
    Msg:passedMessage,
    Printer: &amp;PrinterImpl1{},
  }

  err := packt.Print()
  if err != nil {
    t.Errorf(err.Error())
  }

  testWriter := TestWriter{}
  packt = PacktPrinter{
    Msg: passedMessage,
    Printer:&amp;PrinterImpl2{
      Writer:&amp;testWriter,
    },
  }

  err = packt.Print()
  if err != nil {
    t.Error(err.Error())
  }

  if testWriter.Msg != expectedMessage {
    t.Errorf("The expected message on the io.Writer doesn't match actual.\n  Actual: %s\nExpected: %s\n",
      testWriter.Msg,expectedMessage)
  }
}
</code></pre>
<p>¿Qué hemos cambiado aquí? Ahora tenemos <code>passedMessage</code>, que representa el mensaje al que estamos pasando <code>PackPrinter</code>. También tenemos un mensaje esperado que contiene el mensaje con prefijo de <code>Packt</code>. Si recuerda los <i>criterios de aceptación 8</i>, esta abstracción debe anteponer el texto <code>Message from Packt</code>: a cualquier mensaje que se le pase y, al mismo tiempo, debe poder utilizar cualquier implementación de una interfaz <code>PrinterAPI</code>.</p>
<p>El segundo cambio es que realmente creamos estructuras <code>PacktPrinter</code> en lugar de las estructuras <code>NormalPrinter</code>; Todo lo demás es lo mismo:</p>
<pre class="srci"><code class="sh"><span class="in"><span class="prompt">&gt; </span>go test -v -run=TestPacktPrinter_Print .
</span><span class="out">=== RUN   TestPacktPrinter_Print
--- FAIL: TestPacktPrinter_Print (0.00s)
    bridge_test.go:104: Not implemented yet
    bridge_test.go:117: Not implemented yet
    bridge_test.go:121: The expected message on the io.Writer d
oesn't match actual.
        Actual:
        Expected: Message from Packt: Hello io.Writer
FAIL
exit status 1
FAIL
</span></code></pre>
<p>Tres controles, tres errores. Todas las pruebas han sido cubiertas, y finalmente podemos pasar a la implementación.</p>
</div>
<h4 id="implementation">Implementación</h4>
<div class="hBody-4">
<p>Comenzaremos a implementar en el mismo orden en que creamos nuestras pruebas, primero con la <code>PrinterImpl1</code> definición:</p>
<pre class="code"><code class="go">type PrinterImpl1 struct{}
func (d *PrinterImpl1) PrintMessage(msg string) error {
  fmt.Printf("%s\n", msg)
  return nil
}
</code></pre>
<p>Nuestra primera API toma el mensaje <code>msg</code>y lo imprime en
la consola. En el caso de una cadena vacía, no se imprimirá nada. Esto
es suficiente para pasar la primera prueba:</p>
<pre class="srci"><code class="sh"><span class="in"><span class="prompt">&gt; </span>go test -v -run=TestPrintAPI1 .
</span><span class="out">=== RUN   TestPrintAPI1
Hello
--- PASS: TestPrintAPI1 (0.00s)
PASS
ok
</span></code></pre>
<p>Puede ver el <code>Hello</code> mensaje en la segunda línea de la salida de la prueba, justo después del <code>RUN</code> mensaje.</p>
<p>La estructura <code>PrinterImpl2</code> tampoco es muy compleja. La diferencia es que en lugar de imprimir en la consola, vamos a escribir en una interfaz <code>io.Writer</code>, que debe estar almacenada en la estructura:</p>
<pre class="code"><code class="go">type PrinterImpl2 struct {
  Writer io.Writer
}

func (d *PrinterImpl2) PrintMessage(msg string) error {
  if d.Writer == nil {
    return errors.New("You need to pass an io.Writer to PrinterImpl2")
  }

  fmt.Fprintf(d.Writer, "%s", msg)
  return nil
}
</code></pre>
<p>Como se definió en nuestras pruebas, <code>Writer</code> primero verificamos el contenido del campo y le <b>devolvimos el</b> mensaje de error esperado. <b>Debe pasar un io.Writer a PrinterImpl2</b>, si no se almacena nada. Este es el mensaje que revisaremos más adelante en la prueba. Luego, el método <code>fmt.Fprintf</code> toma una interfaz <code>io.Writer</code> como el primer campo y un mensaje formateado como el resto, por lo que simplemente reenviamos el contenido del argumento <code>msg</code> al <code>io.Writer</code> proporcionado:</p>
<pre class="srci"><code class="sh"><span class="in"><span class="prompt">&gt; </span>go test -v -run=TestPrintAPI2 .
</span><span class="out">=== RUN   TestPrintAPI2
--- PASS: TestPrintAPI2 (0.00s)
PASS
ok
</span></code></pre>
<p>Ahora continuaremos con la impresora normal. Esta impresora simplemente debe reenviar el mensaje a la interfaz <code>PrinterAPI</code> almacenada sin ninguna modificación. En nuestra prueba, estamos usando dos implementaciones de <code>PrinterAPI</code>--una que se imprime en la consola y otra que se escribe en una interfaz <code>io.Writer</code>:</p>
<pre class="code"><code class="go">type NormalPrinter struct {
  Msg     string
  Printer PrinterAPI
}

func (c *NormalPrinter) Print() error {
  c.Printer.PrintMessage(c.Msg)
  return nil
}
</code></pre>
<p>Devolvimos cero ya que no se ha producido ningún error. Esto debería ser suficiente para pasar las pruebas unitarias:</p>
<pre class="srci"><code class="sh"><span class="in"><span class="prompt">&gt; </span>go test -v -run=TestNormalPrinter_Print .
</span><span class="out">=== RUN   TestNormalPrinter_Print
Hello io.Writer
--- PASS: TestNormalPrinter_Print (0.00s)
PASS
ok
</span></code></pre>
<p>En el resultado anterior, puede ver el <code>Hello io.Writer</code> mensaje al que la estructura <code>PrinterImpl1</code> escribe <code>stdout</code>. Podemos considerar que este control ha pasado:</p>
<p>Finalmente, el método <code>PackPrinter</code> es similar a <code>NormalPrinter</code>, pero simplemente prefija cada mensaje con el texto <code>Message from Packt:</code>:</p>
<pre class="code"><code class="go">type PacktPrinter struct {
  Msg     string
  Printer PrinterAPI
}

func (c *PacktPrinter) Print() error {
  c.Printer.PrintMessage(fmt.Sprintf("Message from Packt: %s",
    c.Msg))
  return nil
}
</code></pre>
<p>Al igual que en el método <code>NormalPrinter</code>, aceptamos una cadena <code>Msg</code> y una implementación <code>PrinterAPI</code> en el campo <code>Printer</code>. Luego usamos el método <code>fmt.Sprintf</code> para componer una nueva cadena con el texto <code>Message from Packt</code>: y el mensaje proporcionado. Tomamos el texto compuesto y lo pasamos al método <code>PrintMessage</code> de <code>PrinterAPI</code> almacenamiento en el campo <code>Printer</code> de la estructura <code>PacktPrinter</code>:</p>
<pre class="srci"><code class="sh"><span class="in"><span class="prompt">&gt; </span>go test -v -run=TestPacktPrinter_Print .
</span><span class="out">=== RUN   TestPacktPrinter_Print
Message from Packt: Hello io.Writer
--- PASS: TestPacktPrinter_Print (0.00s)
PASS
ok
</span></code></pre>
<p>De nuevo, puede ver los resultados de usar <code>PrinterImpl1</code> para escribir <code>stdout</code> con el texto <code>Message from Packt: Hello io.Writer</code>.
 Esta última prueba debe cubrir todo nuestro código en el patrón Bridge.
 Como lo ha visto anteriormente, puede verificar la cobertura usando la
bandera <code>-cover</code>:</p>
<pre class="srci"><code class="sh"><span class="in"><span class="prompt">&gt; </span>go test -cover .
</span><span class="out">ok
2.622s  coverage: 100.0% of statements
</span></code></pre>
<p>¡Guauu! 100% de cobertura: esto se ve bien. Sin embargo, esto no
significa que el código sea perfecto. No hemos comprobado que el
contenido de los mensajes no esté vacío, tal vez algo que debería
evitarse, pero no es parte de nuestros requisitos, que también es un
punto importante. El hecho de que alguna característica no esté en los
requisitos o en los criterios de aceptación no significa que no deba
cubrirse.</p>
</div>
<h4 id="reuse-everything-with-the-bridge-pattern">Reutiliza todo con el patrón Bridge</h4>
<div class="hBody-4">
<p>Con el patrón Bridge, hemos aprendido cómo desacoplar un objeto y su implementación para el método <code>PrintMessage</code>.
 De esta forma, podemos reutilizar sus abstracciones y sus
implementaciones. Podemos intercambiar las abstracciones de la impresora
 y las API de la impresora tanto como queramos sin afectar el código de
usuario.</p>
<p>También hemos tratado de mantener las cosas lo más simples posible,
pero estoy seguro de que se ha dado cuenta de que todas las
implementaciones de la interfaz <code>PrinterAPI</code> podrían haberse
creado utilizando una fábrica. Esto sería muy natural, y podría
encontrar muchas implementaciones que han seguido este enfoque. Sin
embargo, no deberíamos involucrarnos en la sobre-ingeniería, sino que
deberíamos analizar cada problema para hacer un diseño preciso de sus
necesidades y encontrar la mejor manera de crear un código fuente
reutilizable, mantenible y <i>legible</i>. El código legible es
comúnmente olvidado, pero un código fuente robusto y desacoplado es
inútil si nadie puede entenderlo para mantenerlo. Es como un libro del
siglo X, podría ser una historia preciosa pero bastante frustrante si
tenemos dificultades para entender su gramática.</p>
</div>
<h3 id="summary">Resumen</h3>
<div class="hBody-3">
<p>Hemos visto el poder de la composición en este capítulo y muchas de
las formas en que Go lo aprovecha por su propia naturaleza. Hemos visto
que el patrón de Adaptador puede ayudarnos a hacer que dos interfaces
incompatibles funcionen juntas mediante el uso de un objeto <code>Adapter</code>
 intermedio. Al mismo tiempo, hemos visto algunos ejemplos de la vida
real en el código fuente de Go, donde los creadores del lenguaje
utilizaron este patrón de diseño para mejorar las posibilidades de
alguna pieza particular de la biblioteca estándar. Finalmente, hemos
visto el patrón Bridge y sus posibilidades, lo que nos permite crear
estructuras de intercambio con una reutilización completa entre los
objetos y sus implementaciones.</p>
<p>Además, hemos utilizado el patrón de diseño compuesto en todo el
capítulo, no solo al explicarlo. Lo hemos mencionado antes, pero los
patrones de diseño se usan mucho entre sí. Hemos usado composición pura
en lugar de incrustación para aumentar la legibilidad, pero, como ha
aprendido, puede usar ambos de manera intercambiable de acuerdo con sus
necesidades. Seguiremos utilizando el patrón compuesto en los siguientes
 capítulos, ya que es la base para establecer relaciones en el lenguaje
de programación Go.</p>
</div>
<h3 id="chapter-4.-structural-patterns---proxy,-facade,-decorator,-and-flyweight-design-patterns">Capítulo 4. Patrones estructurales: patrones de diseño Proxy, Fachada, Decorador y Flyweight</h3>
<div class="hBody-3">
<p>Con este capítulo, terminaremos con los patrones estructurales. Hemos
 dejado algunos de los más complejos hasta el final para que se
acostumbre a la mecánica de los patrones de diseño y las características
 del lenguaje Go.</p>
<p>En este capítulo, trabajaremos escribiendo un caché para acceder a
una base de datos, una biblioteca para recopilar datos meteorológicos,
un servidor con middleware de tiempo de ejecución y discutiremos una
forma de ahorrar memoria guardando estados compartibles entre los
valores de los tipos.</p>
</div>
<h4 id="proxy-design-pattern">Patrón de diseño de proxy</h4>
<div class="hBody-4">
<p>Comenzaremos el último capítulo sobre patrones estructurales con el
patrón Proxy. Es un patrón simple que ofrece características y
posibilidades interesantes con muy poco esfuerzo.</p>
</div>
<h4 id="description">Descripción</h4>
<div class="hBody-4">
<p>El patrón Proxy generalmente envuelve un objeto para ocultar algunas
de sus características. Estas características podrían ser el hecho de
que es un objeto remoto (proxy remoto), un objeto muy pesado como una
imagen muy grande o el volcado de una base de datos de terabytes (proxy
virtual) o un objeto de acceso restringido (proxy de protección).</p>
</div>
<h4 id="objectives">Objetivos</h4>
<div class="hBody-4">
<p>Las posibilidades del patrón Proxy son muchas, pero en general, todas
 intentan proporcionar las mismas funcionalidades siguientes:</p>
<ul>
<li>
<p>Ocultar un objeto detrás del proxy para que las funciones se puedan ocultar, restringir, etc.</p>
</li>
<li>
<p>Proporcione una nueva capa de abstracción con la que sea fácil trabajar y se pueda cambiar fácilmente</p>
</li>
</ul>
</div>
<h4 id="example">Ejemplo</h4>
<div class="hBody-4">
<p>Para nuestro ejemplo, vamos a crear un proxy remoto, que va a ser un
caché de objetos antes de acceder a una base de datos. Imaginemos que
tenemos una base de datos con muchos usuarios, pero en lugar de acceder a
 la base de datos cada vez que queremos información sobre un usuario,
tendremos una pila de usuarios <b>Primero en</b> entrar <b>primero en salir</b> ( <span class="acronym">FIFO</span>
 ) en un patrón Proxy (FIFO es una forma de diciendo que cuando el caché
 necesita ser vaciado, eliminará el primer objeto que ingresó primero).</p>
</div>
<h4 id="acceptance-criteria">Criterios de aceptación</h4>
<div class="hBody-4">
<p>Vamos a envolver una base de datos imaginaria, representada por una
porción, con nuestro patrón Proxy. Luego, el patrón deberá ajustarse a
los siguientes criterios de aceptación:</p>
<ol class="num">
<li>
<p>Todos los accesos a la base de datos de usuarios se realizarán a través del tipo Proxy.</p>
</li>
<li>
<p>Se mantendrá una pila de n usuarios recientes en el Proxy.</p>
</li>
<li>
<p>Si un usuario ya existe en la pila, no consultará la base de datos y devolverá la almacenada</p>
</li>
<li>
<p>Si el usuario consultado no existe en la pila, consultará la base de
datos, eliminará al usuario más antiguo de la pila si está lleno,
guardará la nueva y la devolverá.</p>
</li>
</ol>
</div>
<h4 id="unit-test">Prueba de unidad</h4>
<div class="hBody-4">
<p>Desde la versión 1.7 de Go, podemos incrustar pruebas dentro de las
pruebas utilizando cierres para que podamos agruparlos de una manera más
 legible y reducir el número de funciones <code>Test_</code>. Consulte el <a href="https://nasciiboy.github.io/book4all/Go%20Design%20Patterns.html#chapter-1">Capítulo 1</a>, <i>Listo ... Firme ... ¡Adelante! </i>para aprender a instalar la nueva versión de Go si su versión actual es anterior a la versión 1.7.</p>
<p>Los tipos para este patrón serán las estructuras del usuario proxy y de la lista de usuarios, así como una interfaz <code>UserFinder</code>
 que la base de datos y el Proxy implementarán. Esto es clave porque el
Proxy debe implementar las mismas interfaces que las características del
 tipo que intenta envolver:</p>
<pre class="code"><code class="go">type UserFinder interface {
  FindUser(id int32) (User, error)
}
</code></pre>
<p>La <code>UserFinder</code> es la interfaz que la base de datos y el Proxy implementan. El <code>User</code> es un tipo con un miembro llamado <code>ID</code>, que es tipo <code>int32</code>:</p>
<pre class="code"><code class="go">type User struct {
  ID int32
}
</code></pre>
<p>Finalmente, el <code>UserList</code> es un tipo de porción de usuarios. Considere la siguiente sintaxis para eso:</p>
<pre class="code"><code class="go">type UserList []User
</code></pre>
<p>Si nos pregunta por qué no estamos usando un grupo de usuarios
directamente, la respuesta es que al declarar una secuencia de usuarios
de esta manera, podemos implementar la interfaz <code>UserFinder</code> pero con un segmento, no podemos.</p>
<p>Finalmente, el tipo Proxy, llamado <code>UserListProxy</code> se compondrá de una porción <code>UserList</code>, que será nuestra representación de base de datos. Los <code>StackCache</code> miembros que también serán de tipo <code>UserList</code> por simplicidad, <code>StackCapacity</code> para dar a nuestra pila el tamaño que queremos.</p>
<p>Haremos trampa un poco para el propósito de este tutorial y declararemos un estado booleano en un campo llamado <code>DidDidLastSearchUsedCache</code> que se mantendrá si la última búsqueda realizada ha usado el caché o ha accedido a la base de datos:</p>
<pre class="code"><code class="go">type UserListProxy struct {
  SomeDatabase UserList
  StackCache UserList
  StackCapacity int
  DidDidLastSearchUsedCache bool
}

func (u *UserListProxy) FindUser(id int32) (User, error) {
  return User{}, errors.New("Not implemented yet")
}
</code></pre>
<p>El tipo <code>UserListProxy</code> almacenará en caché un máximo de <code>StackCapacity</code> usuarios y rotará la memoria caché si alcanza este límite. Los <code>StackCache</code> miembros se llenarán de objetos del tipo <code>SomeDatabase</code>.</p>
<p>Se llama a la primera prueba <code>TestUserListProxy</code>y se enumera a continuación:</p>
<pre class="code"><code class="go">import (
  "math/rand"
  "testing"
)

func Test_UserListProxy(t *testing.T) {
  someDatabase := UserList{}

  rand.Seed(2342342)
  for i := 0; i &lt; 1000000; i++ {
    n := rand.Int31()
    someDatabase = append(someDatabase, User{ID: n})
  }
</code></pre>
<p>La prueba anterior crea una lista de usuarios de 1 millón de usuarios
 con nombres aleatorios. Para hacerlo, alimentamos el generador de
números aleatorios llamando a la función <code>Seed()</code> con una
semilla constante para que nuestros resultados aleatorios también sean
constantes; y los ID de usuario se generan a partir de él. Puede tener
algunos duplicados, pero sirve para nuestro propósito.</p>
<p>A continuación, necesitamos un proxy con una referencia a <code>someDatabase</code>, que acabamos de crear:</p>
<pre class="code"><code class="go">proxy := UserListProxy{
  SomeDatabase:  &amp;someDatabase,
  StackCapacity:  2,
  StackCache: UserList{},
}
</code></pre>
<p>En este punto, tenemos un objeto <code>proxy</code> compuesto por una
 base de datos simulada con 1 millón de usuarios y una memoria caché
implementada como una pila FIFO con un tamaño de 2. Ahora obtendremos
tres ID aleatorios <code>someDatabase</code> para usar en nuestra pila:</p>
<pre class="code"><code class="go">knownIDs := [3]int32 {someDatabase[3].ID,
someDatabase[4].ID,someDatabase[5].ID}
</code></pre>
<p>Tomamos los identificadores cuarto, quinto y sexto de la porción
(recuerde que las matrices y las divisiones comienzan con 0, por lo que
el índice 3 es en realidad la cuarta posición en la porción).</p>
<p>Este será nuestro punto de partida antes de lanzar las pruebas
integradas. Para crear una prueba incrustada, debemos llamar al método <code>Run</code> del <code>testing.T</code> puntero, con una descripción y un cierre con la <code>func(t *testing.T)</code> firma:</p>
<pre class="code"><code class="go">t.Run("FindUser - Empty cache", func(t *testing.T) {
  user, err := proxy.FindUser(knownIDs[0])
  if err != nil {
    t.Fatal(err)
  }
</code></pre>
<p>Por ejemplo, en el fragmento de código anterior, damos la descripción <code>FindUser - Empty cache</code>.
 Entonces definimos nuestro cierre. Primero trata de encontrar un
usuario con una identificación conocida y comprueba si hay errores. Como
 lo implica la descripción, la memoria caché está vacía en este momento y
 el usuario tendrá que ser recuperado de la matriz <code>someDatabase</code>:</p>
<pre class="code"><code class="go">  if user.ID != knownIDs[0] {
    t.Error("Returned user name doesn't match with expected")
  }
  if len(proxy.StackCache) != 1 {
    t.Error("After one successful search in an empty cache, the
  size of it must be one")
  }

  if proxy.DidLastSearchUsedCache {
    t.Error("No user can be returned from an empty cache")
  }
}
</code></pre>
<p>Finalmente, verificamos si el usuario devuelto tiene el mismo ID que el del usuario esperado en el índice 0 del sector <code>knownIDs</code>, y que el caché proxy ahora tiene un tamaño de 1. El estado del <code>DidLastSearchUsedCache</code> proxy miembro no debe ser <code>true</code>,
 o lo haremos no pasar la prueba Recuerde, este miembro nos dice si la
última búsqueda se recuperó del sector que representa una base de datos o
 de la memoria caché.</p>
<p>La segunda prueba integrada para el patrón Proxy es solicitar el
mismo usuario que antes, que ahora debe devolverse desde el caché. Es
muy similar a la prueba anterior, pero ahora debemos verificar si el
usuario regresó de la memoria caché:</p>
<pre class="code"><code class="go">t.Run("FindUser - One user, ask for the same user", func(t *testing.T) {
  user, err := proxy.FindUser(knownIDs[0])
  if err != nil {
    t.Fatal(err)
  }

  if user.ID != knownIDs[0] {
    t.Error("Returned user name doesn't match with expected")
  }

  if len(proxy.StackCache) != 1 {
    t.Error("Cache must not grow if we asked for an object that is stored on it")
  }

  if !proxy.DidLastSearchUsedCache {
    t.Error("The user should have been returned from the cache")
  }
})
</code></pre>
<p>Entonces, de nuevo, pedimos la primera identificación conocida. La
caché de proxy debe mantener un tamaño de 1 después de esta búsqueda, y
el <code>DidLastSearchUsedCache</code> miembro debe ser verdadero esta vez, o la prueba fallará.</p>
<p>La última prueba desbordará la matriz <code>StackCache</code> en el tipo <code>proxy</code>. Buscaremos dos nuevos usuarios que nuestro tipo <code>proxy</code>
 tendrá que recuperar de la base de datos. Nuestra pila tiene un tamaño
de 2, por lo que tendrá que eliminar al primer usuario para asignar
espacio para el segundo y tercer usuario:</p>
<pre class="code"><code class="go">user1, err := proxy.FindUser(knownIDs[0])
if err != nil {
  t.Fatal(err)
}

user2, _ := proxy.FindUser(knownIDs[1])
if proxy.DidLastSearchUsedCache {
  t.Error("The user wasn't stored on the proxy cache yet")
}

user3, _ := proxy.FindUser(knownIDs[2])
if proxy.DidLastSearchUsedCache {
  t.Error("The user wasn't stored on the proxy cache yet")
}
</code></pre>
<p>Hemos recuperado los primeros tres usuarios. No estamos buscando
errores porque ese era el propósito de las pruebas anteriores. Es
importante recordar que no hay necesidad de sobre-probar su código. Si
hay algún error aquí, surgirá en las pruebas anteriores. Además, hemos
comprobado que el <code>user2</code>y <code>user3</code> consultas no utilizan la caché; no deberían almacenarse allí todavía.</p>
<p>Ahora vamos a buscar la <code>user1</code> consulta en el Proxy. No debería existir, ya que la pila tiene un tamaño de 2, y <code>user1</code> fue la primera en entrar, por lo tanto, la primera en salir:</p>
<pre class="code"><code class="go">for i := 0; i &lt; len(proxy.StackCache); i++ {
  if proxy.StackCache[i].ID == user1.ID {
    t.Error("User that should be gone was found")
  }
}

if len(proxy.StackCache) != 2 {
  t.Error("After inserting 3 users the cache should not grow" +
    " more than to two")
}
</code></pre>
<p>No importa si preguntamos por mil usuarios; nuestro caché no puede ser más grande que nuestro tamaño configurado.</p>
<p>Finalmente, volveremos a ubicar los usuarios almacenados en el caché y
 los compararemos con los dos últimos que consultamos. De esta manera,
comprobaremos que solo esos usuarios están almacenados en la memoria
caché. Ambos deben encontrarse en él:</p>
<pre class="code"><code class="go">  for _, v := range proxy.StackCache {
    if v != user2 &amp;&amp; v != user3 {
      t.Error("A non expected user was found on the cache")
    }
  }
}
</code></pre>
<p>Ejecutar las pruebas ahora debería dar algunos errores, como de costumbre. Vamos a ejecutarlos ahora:</p>
<pre class="srci"><code class="sh"><span class="in"><span class="prompt">&gt; </span>go test -v .
</span><span class="out">=== RUN   Test_UserListProxy
=== RUN   Test_UserListProxy/FindUser_-_Empty_cache
=== RUN   Test_UserListProxy/FindUser_-
_One_user,_ask_for_the_same_user
=== RUN   Test_UserListProxy/FindUser_-_overflowing_the_stack
--- FAIL: Test_UserListProxy (0.06s)
    --- FAIL: Test_UserListProxy/FindUser_-_Empty_cache (0.00s)
        proxy_test.go:28: Not implemented yet
    --- FAIL: Test_UserListProxy/FindUser_-
_One_user,_ask_for_the_same_user (0.00s)
        proxy_test.go:47: Not implemented yet
    --- FAIL: Test_UserListProxy/FindUser_-
_overflowing_the_stack (0.00s)
        proxy_test.go:66: Not implemented yet
FAIL
exit status 1
FAIL
</span></code></pre>
<p>Entonces, implementemos el método <code>FindUser</code> para actuar como nuestro Proxy.</p>
</div>
<h4 id="implementation">Implementación</h4>
<div class="hBody-4">
<p>En nuestro Proxy, el método <code>FindUser</code> buscará una ID
especificada en la lista de caché. Si lo encuentra, devolverá la ID. Si
no, buscará en la base de datos. Finalmente, si no está en la lista de
la base de datos, devolverá un error.</p>
<p>Si lo recuerda, nuestro patrón Proxy está compuesto por dos tipos <code>UserList</code> (uno de ellos un puntero), que en realidad son segmentos de tipo <code>User</code>. Implementaremos también un método <code>FindUser</code> en tipo <code>User</code>, que, por cierto, tiene la misma firma que la interfaz <code>UserFinder</code>:</p>
<pre class="code"><code class="go">type UserList []User

func (t *UserList) FindUser(id int32) (User, error) {
  for i := 0; i &lt; len(*t); i++ {
    if (*t)[i].ID == id {
      return (*t)[i], nil
    }
  }
  return User{}, fmt.Errorf("User %s could not be found\n", id)
}
</code></pre>
<p>El método <code>FindUser</code> en el <code>UserList</code> segmento repetirá sobre la lista para tratar de encontrar un usuario con el mismo ID que el argumento <code>id</code>, o devolver un error si no puede encontrarlo.</p>
<p>Quizás te estés preguntando por qué el puntero <code>t</code> está
entre paréntesis. Esto es para eliminar la referencia del conjunto
subyacente antes de acceder a sus índices. Sin él, tendrá un error de
compilación, porque el compilador intenta buscar en el índice antes de
desreferenciar el puntero.</p>
<p>Entonces, la primera parte del método <code>FindUser</code> proxy puede escribirse de la siguiente manera:</p>
<pre class="code"><code class="go">func (u *UserListProxy) FindUser(id int32) (User, error) {
  user, err := u.StackCache.FindUser(id)
  if err == nil {
    fmt.Println("Returning user from cache")
    u.DidLastSearchUsedCache = true
    return user, nil
  }
</code></pre>
<p>Usamos el método anterior para buscar un usuario en el <code>StackCache</code>
 miembro. El error será nulo si puede encontrarlo, por lo tanto,
verificamos esto para imprimir un mensaje en la consola, cambiar el
estado de <code>DidLastSearchUsedCache</code>a <code>true</code> para que la prueba pueda verificar si el usuario fue recuperado de la memoria caché, y finalmente, devolver al usuario.</p>
<p>Entonces, si el error no fue nulo, significa que no pudo encontrar al
 usuario en la pila. Entonces, el siguiente paso es buscar en la base de
 datos:</p>
<pre class="code"><code class="go">user, err = u.SomeDatabase.FindUser(id)
if err != nil {
  return User{}, err
}
</code></pre>
<p>Podemos reutilizar el método <code>FindUser</code> que escribimos para la <code>UserList</code>
 base de datos en este caso, porque ambos tienen el mismo tipo para el
propósito de este ejemplo. De nuevo, busca al usuario en la base de
datos representada por el sector <code>UserList</code>, pero en este caso, si no se encuentra el usuario, devuelve el error generado en <code>UserList</code>.</p>
<p>Cuando se encuentra al usuario ( <code>err</code> es nulo), tenemos
que agregar al usuario a la pila. Para este propósito, escribimos un
método privado dedicado que recibe un puntero de tipo <code>UserListProxy</code>:</p>
<pre class="code"><code class="go">func (u *UserListProxy) addUserToStack(user User) {
  if len(u.StackCache) &gt;= u.StackCapacity {
    u.StackCache = append(u.StackCache[1:], user)
  }
  else {
    u.StackCache.addUser(user)
  }
}

func (t *UserList) addUser(newUser User) {
  *t = append(*t, newUser)
}
</code></pre>
<p>El método <code>addUserToStack</code> toma el argumento del usuario y
 lo agrega a la pila en su lugar. Si la pila está llena, elimina el
primer elemento antes de agregarla. También hemos escrito un método <code>addUser</code> <code>UserList</code> para ayudarnos en esto. Entonces, ahora en método <code>FindUser</code>, solo tenemos que agregar una línea:</p>
<pre class="code"><code class="go">u.addUserToStack(user)
</code></pre>
<p>Esto agrega al nuevo usuario a la pila, eliminando el último si es necesario.</p>
<p>Finalmente, solo tenemos que devolver el nuevo usuario de la pila y establecer el valor apropiado en la variable <code>DidLastSearchUsedCache</code>. También escribimos un mensaje a la consola para ayudar en el proceso de prueba:</p>
<pre class="code"><code class="go">  fmt.Println("Returning user from database")
  u.DidLastSearchUsedCache = false
  return user, nil
}
</code></pre>
<p>Con esto, tenemos suficiente para pasar nuestras pruebas:</p>
<pre class="srci"><code class="sh"><span class="in"><span class="prompt">&gt; </span>go test -v .
</span><span class="out">=== RUN   Test_UserListProxy
=== RUN   Test_UserListProxy/FindUser_-_Empty_cache
Returning user from database
=== RUN   Test_UserListProxy/FindUser_-
_One_user,_ask_for_the_same_user
Returning user from cache
=== RUN   Test_UserListProxy/FindUser_-_overflowing_the_stack
Returning user from cache
Returning user from database
Returning user from database
--- PASS: Test_UserListProxy (0.09s)
--- PASS: Test_UserListProxy/FindUser_-_Empty_cache (0.00s)
--- PASS: Test_UserListProxy/FindUser_-
_One_user,_ask_for_the_same_user (0.00s)
--- PASS: Test_UserListProxy/FindUser_-_overflowing_the_stack
(0.00s)
PASS
ok
</span></code></pre>
<p>Puede ver en los mensajes anteriores que nuestro Proxy ha funcionado
perfectamente. Ha devuelto la primera búsqueda de la base de datos.
Luego, cuando buscamos al mismo usuario nuevamente, usa la caché.
Finalmente, realizamos una nueva prueba que llama a tres usuarios
diferentes y podemos observar, mirando la salida de la consola, que solo
 el primero fue devuelto de la memoria caché y que los otros dos fueron
extraídos de la base de datos.</p>
</div>
<h4 id="proxying-around-actions">Proxing alrededor de acciones</h4>
<div class="hBody-4">
<p>Envuelva proxies alrededor de los tipos que necesitan alguna acción
intermedia, como dar autorización al usuario o proporcionar acceso a una
 base de datos, como en nuestro ejemplo.</p>
<p>Nuestro ejemplo es una buena manera de separar las necesidades de las
 aplicaciones de las necesidades de la base de datos. Si nuestra
aplicación accede a la base de datos demasiado, una solución para esto
no está en su base de datos. Recuerde que el Proxy usa la misma interfaz
 que el tipo que envuelve y, para el usuario, no debe haber ninguna
diferencia entre los dos.</p>
</div>
<h3 id="decorator-design-pattern">Patrón de diseño de decorador</h3>
<div class="hBody-3">
<p>Continuaremos este capítulo con el hermano mayor del patrón Proxy, y
tal vez, uno de los patrones de diseño más potentes de todos. El patrón <b>Decorator</b> es bastante simple, pero, por ejemplo, proporciona muchos beneficios cuando se trabaja con código heredado.</p>
</div>
<h4 id="description">Descripción</h4>
<div class="hBody-4">
<p>El patrón de diseño del Decorador le permite decorar un tipo ya
existente con más características funcionales sin tocarlo realmente.
¿Como es posible? Bueno, usa un enfoque similar a las <i>muñecas matryoshka</i>, donde tienes una pequeña muñeca que puedes poner dentro de una muñeca de la misma forma pero más grande, y así sucesivamente.</p>
<p>El tipo Decorator implementa la misma interfaz del tipo que decora, y
 almacena una instancia de ese tipo en sus miembros. De esta forma,
puedes apilar tantos decoradores (muñecas) como quieras simplemente
almacenando el antiguo decorador en un campo del nuevo decorador.</p>
</div>
<h4 id="objectives">Objetivos</h4>
<div class="hBody-4">
<p>Cuando piense en extender el código heredado sin riesgo de romper
algo, primero debe pensar en el patrón Decorator. Es un enfoque
realmente poderoso para lidiar con este problema en particular.</p>
<p>Un campo diferente donde Decorator es muy poderoso puede no ser tan
obvio aunque se revela a sí mismo cuando se crean tipos con muchas
características basadas en las entradas de usuario, preferencias o
entradas similares. Al igual que en una navaja suiza, tienes un tipo de
base (el armazón de la navaja), y desde allí despliegas sus
funcionalidades.</p>
<p>Entonces, ¿cuándo vamos a usar el patrón Decorator? Responde a esta pregunta:</p>
<ul>
<li>
<p>Cuando necesite agregar funcionalidad a algún código al que no tenga
acceso, o no desee modificarlo para evitar un efecto negativo en el
código, y siga el principio de abrir / cerrar (como el código heredado)</p>
</li>
<li>
<p>Cuando desea que la funcionalidad de un objeto se cree o modifique
dinámicamente, y se desconoce el número de características y podría
crecer rápidamente</p>
</li>
</ul>
</div>
<h4 id="example">Ejemplo</h4>
<div class="hBody-4">
<p>En nuestro ejemplo, prepararemos un tipo <code>Pizza</code>, donde el
 núcleo es la pizza y los ingredientes son los tipos de decoración.
Tendremos un par de ingredientes para nuestra pizza-cebolla y carne.</p>
</div>
<h4 id="acceptance-criteria">Criterios de aceptación</h4>
<div class="hBody-4">
<p>El criterio de aceptación para un patrón Decorator es tener una
interfaz común y un tipo de núcleo, sobre el que se construirán todas
las capas:</p>
<ul>
<li>
<p>Debemos tener la interfaz principal que todos los decoradores implementarán. Se llamará a esta interfaz <code>IngredientAdd</code>y tendrá el método <code>AddIngredient() string</code>.</p>
</li>
<li>
<p>Debemos tener un tipo <code>PizzaDecorator</code> de núcleo (el decorador) al que agregaremos ingredientes.</p>
</li>
<li>
<p>Debemos tener un ingrediente "cebolla" que implemente la misma interfaz <code>IngredientAdd</code> que agregará la cadena <code>onion</code>a la pizza devuelta.</p>
</li>
<li>
<p>Debemos tener un ingrediente "carne" que implemente la interfaz <code>IngredientAdd</code> que agregará la cadena <code>meat</code>a la pizza devuelta.</p>
</li>
<li>
<p>Cuando se llama al método <code>AddIngredient</code> en el objeto superior, debe devolver una decoración completa <code>pizza</code> con el texto <code>Pizza with the following ingredients: meat, onion</code>.</p>
</li>
</ul>
</div>
<h4 id="unit-test">Prueba de unidad</h4>
<div class="hBody-4">
<p>Para iniciar nuestras pruebas unitarias, primero debemos crear las
estructuras básicas descritas de acuerdo con los criterios de
aceptación. Para empezar, la interfaz que todos los tipos de decoración
deben implementar es la siguiente:</p>
<pre class="code"><code class="go">type IngredientAdd interface {
  AddIngredient() (string, error)
}
</code></pre>
<p>El siguiente código define el tipo <code>PizzaDecorator</code>, que debe tener <code>IngredientAdd</code> dentro, y que <code>IngredientAdd</code> también se implementa :</p>
<pre class="code"><code class="go">type PizzaDecorator struct{
  Ingredient IngredientAdd
}

func (p *PizzaDecorator) AddIngredient() (string, error) {
  return "", errors.New("Not implemented yet")
}
</code></pre>
<p>La definición del tipo <code>Meat</code> será muy similar a la de la estructura <code>PizzaDecorator</code>:</p>
<pre class="code"><code class="go">type Meat struct {
  Ingredient IngredientAdd
}

func (m *Meat) AddIngredient() (string, error) {
  return "", errors.New("Not implemented yet")
}
</code></pre>
<p>Ahora definimos la estructura <code>Onion</code> de una manera similar:</p>
<pre class="code"><code class="go">type Onion struct {
  Ingredient IngredientAdd
}

func (o *Onion) AddIngredient() (string, error) {
  return "", errors.New("Not implemented yet")
}
</code></pre>
<p>Esto es suficiente para implementar la primera prueba unitaria y
permitir que el compilador los ejecute sin ningún error de compilación:</p>
<pre class="code"><code class="go">func TestPizzaDecorator_AddIngredient(t *testing.T) {
  pizza := &amp;PizzaDecorator{}
  pizzaResult, _ := pizza.AddIngredient()
  expectedText := "Pizza with the following ingredients:"
  if !strings.Contains(pizzaResult, expectedText) {
    t.Errorf("When calling the add ingredient of the pizza decorator it must return the text %sthe expected text, not '%s'",
      pizzaResult, expectedText)
  }
}
</code></pre>
<p>Ahora debe compilarse sin problemas, por lo que podemos verificar que la prueba falle:</p>
<pre class="srci"><code class="sh"><span class="in"><span class="prompt">&gt; </span>go test -v -run=TestPizzaDecorator .
</span><span class="out">=== RUN   TestPizzaDecorator_AddIngredient
--- FAIL: TestPizzaDecorator_AddIngredient (0.00s)
decorator_test.go:29: Not implemented yet
decorator_test.go:34: When the the AddIngredient method of the
pizza decorator object is called, it must return the text
Pizza with the following ingredients:
FAIL
exit status 1
FAIL
</span></code></pre>
<p>Nuestra primera prueba está hecha, y podemos ver que la estructura <code>PizzaDecorator</code> no está devolviendo nada aún, es por eso que falla. Ahora podemos pasar al tipo <code>Onion</code>. La prueba del tipo <code>Onion</code> es bastante similar a la del <code>Pizza</code> decorador, pero también debemos asegurarnos de que realmente agreguemos el ingrediente al método <code>IngredientAdd</code> y no a un puntero nulo:</p>
<pre class="code"><code class="go">func TestOnion_AddIngredient(t *testing.T) {
  onion := &amp;Onion{}
  onionResult, err := onion.AddIngredient()
  if err == nil {
    t.Errorf("When calling AddIngredient on the onion decorator without" +
      "an IngredientAdd on its Ingredient field must return an error, not a string with '%s'",
      onionResult)
  }
</code></pre>
<p>La primera mitad de la prueba anterior examina el error de retorno cuando no <code>IngredientAdd</code> se pasa ningún método al <code>Onion</code> inicializador de la estructura. Como no hay pizza disponible para agregar el ingrediente, se debe devolver un error:</p>
<pre class="code"><code class="go">  onion = &amp;Onion{&amp;PizzaDecorator{}}
  onionResult, err = onion.AddIngredient()
  if err != nil {
    t.Error(err)
  }
  if !strings.Contains(onionResult, "onion") {
    t.Errorf("When calling the add ingredient of the onion decorator it" +
    "must return a text with the word 'onion', not '%s'",
    onionResult)
  }
}
</code></pre>
<p>La segunda parte de la prueba <code>Onion</code> de tipo en realidad pasa la estructura <code>PizzaDecorator</code> al inicializador. Luego, verificamos si no se devuelve ningún error, y también si la cadena que regresa contiene la palabra <code>onion</code> en él. De esta manera, podemos asegurarnos de que la cebolla se haya agregado a la pizza.</p>
<p>Finalmente para el tipo <code>Onion</code>, la salida de la consola de esta prueba con nuestra implementación actual será la siguiente:</p>
<pre class="srci"><code class="sh"><span class="in"><span class="prompt">&gt; </span>go test -v -run=TestOnion_AddIngredient .
</span><span class="out">=== RUN   TestOnion_AddIngredient
--- FAIL: TestOnion_AddIngredient (0.00s)
decorator_test.go:48: Not implemented yet
decorator_test.go:52: When calling the add ingredient of the
onion decorator it must return a text with the word 'onion',
not ''
FAIL
exit status 1
FAIL
</span></code></pre>
<p>El <code>meat</code> ingrediente es exactamente el mismo, pero cambiamos el tipo a carne en lugar de cebolla:</p>
<pre class="code"><code class="go">func TestMeat_AddIngredient(t *testing.T) {
  meat := &amp;Meat{}
  meatResult, err := meat.AddIngredient()
  if err == nil {
    t.Errorf("When calling AddIngredient on the meat decorator without" +
      "an IngredientAdd in its Ingredient field must return an error," +
      "not a string with '%s'", meatResult)
  }

  meat = &amp;Meat{&amp;PizzaDecorator{}}
  meatResult, err = meat.AddIngredient()
  if err != nil {
    t.Error(err)
  }
  if !strings.Contains(meatResult, "meat") {
    t.Errorf("When calling the add ingredient of the meat decorator it" +
      "must return a text with the word 'meat', not '%s'", meatResult)
  }
}
</code></pre>
<p>Entonces, el resultado de las pruebas será similar:</p>
<pre class="srci"><code class="sh"><span class="in"><span class="prompt">&gt; </span>go test -v -run=TestMeat_AddIngredient .
</span><span class="out">=== RUN   TestMeat_AddIngredient
--- FAIL: TestMeat_AddIngredient (0.00s)
decorator_test.go:68: Not implemented yet
decorator_test.go:72: When calling the add ingredient of the
meat decorator it must return a text with the word 'meat', not
''
FAIL
exit status 1
FAIL
</span></code></pre>
<p>Finalmente, debemos verificar la prueba de pila completa. Crear una pizza con cebolla y carne debe devolver el texto <code>Pizza with the following ingredients: meat, onion</code>:</p>
<pre class="code"><code class="go">func TestPizzaDecorator_FullStack(t *testing.T) {
  pizza := &amp;Onion{&amp;Meat{&amp;PizzaDecorator{}}}
  pizzaResult, err := pizza.AddIngredient()
  if err != nil {
    t.Error(err)
  }

  expectedText := "Pizza with the following ingredients: meat, onion"
  if !strings.Contains(pizzaResult, expectedText){
    t.Errorf("When asking for a pizza with onion and meat the returned " +
      "string must contain the text '%s' but '%s' didn't have it",
      expectedText,pizzaResult)
  }

  t.Log(pizzaResult)
}
</code></pre>
<p>Nuestra prueba crea una variable llamada <code>pizza</code> que, al igual que las <i>muñecas matryoshka</i>, integra los tipos del método <code>IngredientAdd</code> en varios niveles.</p>
<p>Llamar al método <code>AddIngredient</code> ejecuta el método en el nivel de "cebolla", que ejecuta el de "carne", que, finalmente, ejecuta el de la estructura <code>PizzaDecorator</code>. Después de verificar que no se ha devuelto ningún error, verificamos si el texto devuelto sigue las necesidades de los <i>criterios de aceptación 5</i>. Las pruebas se ejecutan con el siguiente comando:</p>
<pre class="srci"><code class="sh"><span class="in"><span class="prompt">&gt; </span>go test -v -run=TestPizzaDecorator_FullStack .
</span><span class="out">=== RUN   TestPizzaDecorator_FullStack
--- FAIL: TestPizzaDecorator_FullStack (0.
decorator_test.go:80: Not implemented yet
decorator_test.go:87: When asking for a pizza with onion and
meat the returned string must contain the text 'Pizza with the
following ingredients: meat, onion' but '' didn't have it
FAIL
exit status 1
FAIL
</span></code></pre>
<p>Del resultado anterior, podemos ver que las pruebas ahora devuelven
una cadena vacía para nuestro tipo decorado. Esto es, por supuesto,
porque aún no se ha implementado. Esta fue la última prueba para
verificar la implementación totalmente decorada. Miremos de cerca la
implementación entonces.</p>
</div>
<h4 id="implementation">Implementación</h4>
<div class="hBody-4">
<p>Vamos a comenzar a implementar el tipo <code>PizzaDecorator</code>. Su función es proporcionar el texto inicial de la pizza completa:</p>
<pre class="code"><code class="go">type PizzaDecorator struct {
  Ingredient IngredientAdd
}

func (p *PizzaDecorator) AddIngredient() (string, error) {
  return "Pizza with the following ingredients:", nil
}
</code></pre>
<p>Un cambio de línea único en el retorno del método <code>AddIngredient</code> fue suficiente para pasar la prueba:</p>
<pre class="srci"><code class="sh"><span class="in"><span class="prompt">&gt; </span>go test -v -run=TestPizzaDecorator_Add .
</span><span class="out">=== RUN   TestPizzaDecorator_AddIngredient
--- PASS: TestPizzaDecorator_AddIngredient (0.00s)
PASS
ok
</span></code></pre>
<p>Pasando a la implementación <code>Onion</code> de la estructura, debemos tomar el comienzo de nuestra cadena <code>IngredientAdd</code> devuelta y agregar la palabra <code>onion</code> al final para obtener una pizza compuesta a cambio:</p>
<pre class="code"><code class="go">type Onion struct {
  Ingredient IngredientAdd
}

func (o *Onion) AddIngredient() (string, error) {
  if o.Ingredient == nil {
    return "", errors.New("An IngredientAdd is needed in the Ingredient field of the Onion")
  }
  s, err := o.Ingredient.AddIngredient()
  if err != nil {
    return "", err
  }
  return fmt.Sprintf("%s %s,", s, "onion"), nil
}
</code></pre>
<p>Comprobando que en realidad tenemos un puntero al <code>IngredientAdd</code> primero, usamos los contenidos del interior <code>IngredientAdd</code>y
 verificamos si hay errores. Si no se producen errores, recibimos una
nueva cadena compuesta de este contenido, un espacio y la palabra <code>onion</code>(y no hay errores). Se ve lo suficientemente bien como para ejecutar las pruebas:</p>
<pre class="srci"><code class="sh"><span class="in"><span class="prompt">&gt; </span>go test -v -run=TestOnion_AddIngredient .
</span><span class="out">=== RUN   TestOnion_AddIngredient
--- PASS: TestOnion_AddIngredient (0.00s)
PASS
ok
</span></code></pre>
<p>La implementación de la estructura <code>Meat</code> es muy similar:</p>
<pre class="code"><code class="go">type Meat struct {
  Ingredient IngredientAdd
}

func (m *Meat) AddIngredient() (string, error) {
  if m.Ingredient == nil {
    return "", errors.New("An IngredientAdd is needed in the Ingredient field of the Meat")
  }
  s, err := m.Ingredient.AddIngredient()
  if err != nil {
    return "", err
  }
  return fmt.Sprintf("%s %s,", s, "meat"), nil
}
</code></pre>
<p>Y aquí va su ejecución de prueba:</p>
<pre class="srci"><code class="sh"><span class="in"><span class="prompt">&gt; </span>go test -v -run=TestMeat_AddIngredient .
</span><span class="out">=== RUN   TestMeat_AddIngredient
--- PASS: TestMeat_AddIngredient (0.00s)
PASS
ok
</span></code></pre>
<ol class="alpha">
<li>
<p>Entonces, ahora todas las piezas deben probarse por separado. Si todo es</p>
</li>
</ol>
<p>está bien, la prueba de la solución <i>completa apilada</i> debe pasar sin problemas:</p>
<pre class="srci"><code class="sh"><span class="in"><span class="prompt">&gt; </span>go test -v -run=TestPizzaDecorator_FullStack .
</span><span class="out">=== RUN   TestPizzaDecorator_FullStack
--- PASS: TestPizzaDecorator_FullStack (0.00s)
decorator_test.go:92: Pizza with the following ingredients:
meat, onion,
PASS
ok
</span></code></pre>
<p>¡Increíble! Con el patrón de decorador, podríamos mantener el apilamiento <code>IngredientAdds</code> que llame a su puntero interno para agregar funcionalidad <code>PizzaDecorator</code>.
 Tampoco estamos tocando el tipo de núcleo ni modificando o
implementando cosas nuevas. Todas las nuevas características son
implementadas por un tipo externo.</p>
</div>
<h4 id="a-real-life-example---server-middleware">Un ejemplo de la vida real: middleware de servidor</h4>
<div class="hBody-4">
<p>Por ahora, deberías haber entendido cómo funciona el patrón
Decorator. Ahora podemos probar un ejemplo más avanzado utilizando el
pequeño servidor HTTP que diseñamos en la sección Patrón de adaptador.
Aprendió que se puede crear un servidor HTTP utilizando el paquete <code>http</code> e implementando la interfaz <code>http.Handler</code>. Esta interfaz solo tiene un método llamado <code>ServeHTTP(http.ResponseWriter, http.Request)</code>. ¿Podemos usar el patrón Decorator para agregar más funcionalidad a un servidor? ¡Por supuesto!</p>
<p>Añadiremos un par de piezas a este servidor. Primero, vamos a registrar cada conexión hecha a la interfaz <code>io.Writer</code> (por simplicidad, usaremos la implementación <code>io.Writer</code> de la interfaz <code>os.Stdout</code>
 para que salga a la consola). La segunda pieza agregará autenticación
HTTP básica a cada solicitud hecha al servidor. Si se pasa la
autenticación, <code>Hello Decorator!</code> aparecerá un mensaje.
Finalmente, el usuario podrá seleccionar la cantidad de artículos de
decoración que desee en el servidor, y el servidor se estructurará y
creará en tiempo de ejecución.</p>
</div>
<h4 id="starting-with-the-common-interface,-http.handler">Comenzando con la interfaz común, http.Handler</h4>
<div class="hBody-4">
<p>Ya tenemos la interfaz común que decoraremos usando tipos anidados. Primero necesitamos crear nuestro tipo central, que será el <code>Handler</code> que devuelva la oración <code>Hello Decorator!</code>:</p>
<pre class="code"><code class="go">type MyServer struct{}

func (m *MyServer) ServeHTTP(w http.ResponseWriter, r *http.Request) {
  fmt.Fprintln(w, "Hello Decorator!")
}
</code></pre>
<p>Este controlador se puede atribuir al método <code>http.Handle</code>
 para definir nuestro primer punto final. Comprobemos esto ahora creando
 la función principal del paquete y enviándole una solicitud <code>GET</code>:</p>
<pre class="code"><code class="go">func main() {
  http.Handle("/", &amp;MyServer{})

  log.Fatal(http.ListenAndServe(":8080", nil))
}
</code></pre>
<p>Ejecute el servidor usando el Terminal para ejecutar el   comando <code class="command">go run main.go</code>. Luego, abre una nueva Terminal para hacer la solicitud <code>GET</code>. Usaremos el comando <code class="command">curl</code> para hacer nuestras solicitudes:</p>
<pre class="srci"><code class="sh"><span class="in"><span class="prompt">&gt; </span>curl http://localhost:8080
</span><span class="out">Hello Decorator!
</span></code></pre>
<p>Hemos cruzado el primer hito de nuestro servidor decorado. El
siguiente paso es decorarlo con capacidades de registro. Para hacerlo,
debemos implementar la interfaz <code>http.Handler</code>, en un nuevo tipo, de la siguiente manera:</p>
<pre class="code"><code class="go">type LoggerServer struct {
  Handler   http.Handler
  LogWriter io.Writer
}

func (s *LoggerServer) ServeHTTP(w http.ResponseWriter, r
  *http.Request) {
  fmt.Fprintf(s.LogWriter, "Request URI: %s\n", r.RequestURI)
  fmt.Fprintf(s.LogWriter, "Host: %s\n", r.Host)
  fmt.Fprintf(s.LogWriter, "Content Length: %d\n", r.ContentLength)
  fmt.Fprintf(s.LogWriter, "Method: %s\n", r.Method)
  fmt.Fprintf(s.LogWriter, "---------------------------- ----\n")

  s.Handler.ServeHTTP(w, r)
}
</code></pre>
<p>Llamamos a este tipo <code>LoggerServer</code>. Como puede ver, almacena no solo a <code>Handler</code>, sino también <code>io</code>.Writer para escribir la salida del registro. Nuestra implementación del método <code>ServeHTTP</code> imprime el URI de solicitud, el host, la longitud del contenido y el método utilizado <code>io.Writer</code>. Una vez que finaliza la impresión, llama a la función <code>ServeHTTP</code> de su campo <code>Handler</code> interno .</p>
<p>Podemos decorar <code>MyServer</code> con esto <code>LoggerMiddleware</code>:</p>
<pre class="code"><code class="go">func main() {
  http.Handle("/", &amp;LoggerServer{
    LogWriter:os.Stdout,
    Handler:&amp;MyServer{},
  })

  log.Fatal(http.ListenAndServe(":8080", nil))
}
</code></pre>
<p>Ahora ejecuta el comando <code class="command">curl</code>:</p>
<pre class="srci"><code class="sh"><span class="in"><span class="prompt">&gt; </span>curl http://localhost:8080
</span><span class="out">Hello Decorator!
</span></code></pre>
<p>Nuestro comando <code class="command">curl</code> devuelve el mismo mensaje, pero si observa la Terminal donde ejecutó la aplicación Go, puede ver el registro:</p>
<pre class="srci"><code class="sh"><span class="in"><span class="prompt">&gt; </span>go run server_decorator.go
</span><span class="out">Request URI: /
Host: localhost:8080
Content Length: 0
Method: GET
</span></code></pre>
<p>Hemos decorado <code>MyServer</code> con capacidades de registro sin
modificarlo realmente. ¿Podemos hacer lo mismo con la autenticación?
¡Por supuesto! Después de registrar la solicitud, la autenticaremos
mediante <b>la Autenticación básica HTTP de la</b> siguiente manera:</p>
<pre class="code"><code class="go">type BasicAuthMiddleware struct {
  Handler  http.Handler
  User     string
  Password string
}
</code></pre>
<p>El <code>BasicAuthMiddleware</code> middleware almacena tres campos:
un controlador para decorar como en los middleware anteriores, un
usuario y una contraseña, que será la única autorización para acceder a
los contenidos en el servidor. La implementación del método (de
decoración) procederá de la siguiente manera:</p>
<pre class="code"><code class="go">func (s *BasicAuthMiddleware) ServeHTTP(w http.ResponseWriter, r *http.Request) {
  user, pass, ok := r.BasicAuth()

  if ok {
    if user == s.User &amp;&amp; pass == s.Password {
      s.Handler.ServeHTTP(w, r)
    }
    else {
      fmt.Fprintf(w, "User or password incorrect\n")
    }
  }
  else {
    fmt.Fprintln(w, "Error trying to retrieve data from Basic auth")
  }
}
</code></pre>
<p>En la implementación anterior, utilizamos el método <code>BasicAuth</code> de <code>http.Request</code> para recuperar automáticamente el usuario y la contraseña de la solicitud, más una <code>ok/ko</code>
 de la acción de análisis. Luego, verificamos si el análisis sintáctico
es correcto (devolviendo un mensaje al solicitante si es incorrecto y
terminando la solicitud). Si no se detectaron problemas durante el
análisis, verificamos si el nombre de usuario y la contraseña coinciden
con los almacenados en <code>BasicAuthMiddleware</code>. Si las
credenciales son válidas, llamaremos al tipo decorado (nuestro
servidor), pero si las credenciales no son válidas, recibimos el <code>User or password incorrect</code> mensaje a cambio y la solicitud finaliza.</p>
<p>Ahora, debemos proporcionarle al usuario una forma de elegir entre
diferentes tipos de servidores. Recuperaremos los datos de entrada del
usuario en la función principal. Tendremos tres opciones para elegir:</p>
<ul>
<li>
<p>Servidor simple</p>
</li>
<li>
<p>Servidor con registro</p>
</li>
<li>
<p>Servidor con registro y autenticación</p>
</li>
</ul>
<p>Tenemos que usar la función <code>Fscanf</code> para recuperar la entrada del usuario:</p>
<pre class="code"><code class="go">func main() {
  fmt.Println("Enter the type number of server you want to launch from the  following:")
  fmt.Println("1.- Plain server")
  fmt.Println("2.- Server with logging")
  fmt.Println("3.- Server with logging and authentication")

  var selection int
  fmt.Fscanf(os.Stdin, "%d", &amp;selection)
}
</code></pre>
<p>La función <code>Fscanf</code> necesita un <code>io.Reader</code>
implementador como primer argumento (que será la entrada en la consola) y
 toma el servidor seleccionado por el usuario. Pasaremos <code>os.Stdin</code> como la interfaz <code>io.Reader</code> para recuperar la entrada del usuario. Luego, escribiremos el tipo de datos que analizará. El <code>%d</code>
 especificador se refiere a un número entero. Finalmente, escribiremos
la dirección de la memoria para almacenar la entrada analizada, en este
caso, la posición de memoria de la variable <code>selection</code>.</p>
<p>Una vez que el usuario selecciona una opción, podemos tomar el
servidor básico y decorarlo en tiempo de ejecución, cambiando a la
opción seleccionada:</p>
<pre class="code"><code class="go">switch selection {
case 1:
  mySuperServer = new(MyServer)
case 2:
  mySuperServer = &amp;LoggerMiddleware{
    Handler:   new(MyServer),
    LogWriter: os.Stdout,
  }
case 3:
  var user, password string

  fmt.Println("Enter user and password separated by a space")
  fmt.Fscanf(os.Stdin, "%s %s", &amp;user, &amp;password)

  mySuperServer = &amp;LoggerMiddleware{
    Handler: &amp;SimpleAuthMiddleware{
      Handler:  new(MyServer),
      User:     user,
      Password: password,
    },
    LogWriter: os.Stdout,
  }
default:
  mySuperServer = new(MyServer)
}
</code></pre>
<p>La primera opción se manejará con la <code>switch</code> opción predeterminada : una simple <code>MyServer</code>.
 En el caso de la segunda opción, decoramos un servidor simple con
registro. La tercera opción está un poco más desarrollada: pedimos al
usuario un nombre de usuario y una contraseña usando<code>Fscanf</code>
volver a . Tenga en cuenta que puede escanear más de una entrada, como
lo estamos haciendo para recuperar el usuario y la contraseña. Luego,
tomamos el servidor básico, lo decoramos con autenticación y,
finalmente, con el registro.</p>
<p>Si sigue la sangría de los tipos anidados de la opción tres, la
solicitud pasa a través del registrador, luego el middleware de
autenticación y, finalmente, el argumento <code>MyServer</code> si todo está bien. Las solicitudes seguirán la misma ruta.</p>
<p>El final de la función principal toma el controlador decorado y ejecuta el servidor en el <code>8080</code> puerto:</p>
<pre class="code"><code class="go">http.Handle("/", mySuperServer)
log.Fatal(http.ListenAndServe(":8080", nil))
</code></pre>
<p>Entonces, vamos a lanzar el servidor con la tercera opción:</p>
<pre class="srci"><code class="sh"><span class="out">&gt;go run server_decorator.go
Enter the server type number you want to launch from the
following:
1.- Plain server
2.- Server with logging
3.- Server with logging and authentication

Enter user and password separated by a space
mario castro
</span></code></pre>
<p>Primero probaremos el servidor simple eligiendo la primera opción. Ejecute el servidor con el comando <code class="command">go run server_decorator.go</code>y seleccione la primera opción. Luego, en un Terminal diferente, ejecute la solicitud básica con <code class="command">curl</code>, de la siguiente manera:</p>
<pre class="srci"><code class="sh"><span class="in"><span class="prompt">&gt; </span>curl http://localhost:8080
</span><span class="out">Error trying to retrieve data from Basic auth
</span></code></pre>
<p>¡UH oh! No nos da acceso. No hemos pasado ningún usuario y
contraseña, por lo que nos dice que no podemos continuar. Probemos con
un usuario y contraseña aleatorios:</p>
<pre class="srci"><code class="sh"><span class="in"><span class="prompt">&gt; </span>curl -u no:correct http://localhost:8080
</span><span class="out">User or password incorrect
</span></code></pre>
<p>¡Sin acceso! También podemos verificar en la Terminal donde lanzamos el servidor y donde se registra cada solicitud:</p>
<pre class="srci"><code class="sh"><span class="out">Request URI: /
Host: localhost:8080
Content Length: 0
Method: GET
</span></code></pre>
<p>Finalmente, ingrese el nombre de usuario y la contraseña correctos:</p>
<pre class="srci"><code class="sh"><span class="in"><span class="prompt">&gt; </span>curl -u packt:publishing http://localhost:8080
</span><span class="out">Hello Decorator!
</span></code></pre>
<p>¡Aquí estamos! Nuestra solicitud también se ha registrado y el
servidor nos ha otorgado acceso. Ahora podemos mejorar nuestro servidor
tanto como queramos escribiendo más middlewares para decorar la
funcionalidad del servidor.</p>
</div>
<h4 id="a-few-words-about-go's-structural-typing">Algunas palabras sobre la tipificación estructural de Go</h4>
<div class="hBody-4">
<p>Go tiene una característica que a la mayoría de la gente le desagrada
 al principio: tipado estructural. Aquí es cuando su estructura define
su tipo sin escribirlo explícitamente. Por ejemplo, cuando implementa
una interfaz, no tiene que escribir explícitamente que realmente la está
 implementando, al contrario de los lenguajes como Java donde tiene que
escribir la palabra clave <code>implements</code>. Si su método sigue la
 firma de la interfaz, en realidad está implementando la interfaz. Esto
también puede llevar a implementaciones accidentales de la interfaz,
algo que podría provocar un error imposible de seguir, pero eso es muy
poco probable.</p>
<p>Sin embargo, la tipificación estructural también le permite definir
una interfaz después de definir sus implementadores. Imagine una
estructura MyPrinter de la siguiente manera:</p>
<pre class="code"><code class="go">type MyPrinter struct{}
func(m *MyPrinter)Print(){
  println("Hello")
}
</code></pre>
<p>Imagine que hemos estado trabajando con este tipo <code>MyPrinter</code>
 durante algunos meses, pero no implementó ninguna interfaz, por lo que
no puede ser un candidato posible para un patrón Decorator, ¿o tal vez
sí? ¿Qué pasa si escribimos una interfaz que coincide con su método <code>Print</code> después de unos meses? Considere el siguiente fragmento de código:</p>
<pre class="code"><code class="go">type Printer interface {
  Print()
}
</code></pre>
<p>En realidad implementa el interfaz <code>Printer</code>, y podemos usarla para crear una solución Decorator.</p>
<p>La tipificación estructural permite mucha flexibilidad al escribir
programas. Si no sabe si un tipo debe ser parte de una interfaz o no,
puede dejarlo y agregar la interfaz más adelante, cuando esté
completamente seguro de ello. De esta forma, puede decorar tipos muy
fácilmente y con pequeñas modificaciones en su código fuente.</p>
</div>
<h4 id="summarizing-the-decorator-design-pattern---proxy-versus-decorator">Resumiendo el patrón de diseño Decorator - Proxy versus Decorator</h4>
<div class="hBody-4">
<p>Tal vez se pregunte, ¿cuál es la diferencia entre el patrón Decorator
 y el patrón Proxy? En el patrón Decorator, decoramos un tipo
dinámicamente. Esto significa que la decoración puede o no estar allí, o
 puede estar compuesta por uno o varios tipos. Si lo recuerda, el patrón
 Proxy ajusta un tipo de manera similar, pero lo hace en tiempo de
compilación y es más como una forma de acceder a algún tipo.</p>
<p>Al mismo tiempo, un decorador podría implementar toda la interfaz que el tipo que decora también implemente <b>o no</b>.
 Entonces puedes tener una interfaz con 10 métodos y un decorador que
simplemente implementa uno de ellos y seguirá siendo válido. Una llamada
 en un método no implementado por el decorador se pasará al tipo
decorado. Esta es una característica muy poderosa pero también muy
propensa a comportamientos no deseados en tiempo de ejecución si olvida
implementar cualquier método de interfaz.</p>
<p>En este aspecto, puede pensar que el patrón de Proxy es menos
flexible, y lo es. Pero el patrón Decorator es más débil, ya que podría
tener errores en el tiempo de ejecución, que puede evitar en tiempo de
compilación utilizando el patrón Proxy. Solo tenga en cuenta que el
Decorador se usa comúnmente cuando desea agregar funcionalidad a un
objeto en tiempo de ejecución, como en nuestro servidor web. Es un
compromiso entre lo que necesita y lo que quiere sacrificar para
lograrlo.</p>
</div>
<h3 id="facade-design-pattern">Patrón de diseño de fachada</h3>
<div class="hBody-3">
<p>El siguiente patrón que veremos en este capítulo es el patrón
Fachada. Cuando discutimos el patrón de Proxy, debe saber que era una
forma de ajustar un tipo para ocultar algunas de las características de
complejidad del usuario. Imagine que agrupamos muchos proxies en un solo
 punto, como un archivo o una biblioteca. Esto podría ser un patrón de
Fachada.</p>
</div>
<h4 id="description">Descripción</h4>
<div class="hBody-4">
<p>Una fachada, en términos arquitectónicos, es la pared frontal que
oculta las habitaciones y los corredores de un edificio. Protege a sus
habitantes del frío y la lluvia, y les brinda privacidad. Ordena y
divide las viviendas.</p>
<p>El patrón de diseño de Fachada hace lo mismo, pero en nuestro código.
 Protege el código del acceso no deseado, ordena algunas llamadas y
oculta el alcance de la complejidad del usuario.</p>
</div>
<h4 id="objectives">Objetivos</h4>
<div class="hBody-4">
<p>Utiliza Facade cuando quiere ocultar la complejidad de algunas
tareas, especialmente cuando la mayoría de ellas comparten utilidades
(como la autenticación en una API). Una biblioteca es una forma de
fachada, donde alguien tiene que proporcionar algunos métodos para que
un desarrollador haga ciertas cosas de forma amigable. De esta forma, si
 un desarrollador necesita usar su biblioteca, no necesita conocer todas
 las tareas internas para recuperar el resultado que desea.</p>
<p>Por lo tanto, utiliza el patrón de diseño de fachada en los siguientes escenarios:</p>
<ul>
<li>
<p>Cuando desee disminuir la complejidad de algunas partes de nuestro
código. Ocultas esa complejidad detrás de la fachada al proporcionar un
método más fácil de usar.</p>
</li>
<li>
<p>Cuando desee agrupar acciones relacionadas entre sí en un solo lugar.</p>
</li>
<li>
<p>Cuando desee construir una biblioteca para que otros puedan usar sus productos sin preocuparse de cómo funciona todo.</p>
</li>
</ul>
</div>
<h3 id="example">Ejemplo</h3>
<div class="hBody-3">
<p>Como ejemplo, vamos a dar los primeros pasos para escribir nuestra propia biblioteca que accede al servicio <code>OpenWeatherMaps</code>. En caso de que no esté familiarizado con el servicio <code>OpenWeatherMap</code>, es un servicio HTTP que le proporciona información en tiempo real sobre el clima, así como datos históricos sobre él. La API <b>HTTP REST</b>
 es muy fácil de usar y será un buen ejemplo de cómo crear un patrón
Fachada para ocultar la complejidad de las conexiones de red detrás del
servicio REST.</p>
</div>
<h4 id="acceptance-criteria">Criterios de aceptación</h4>
<div class="hBody-4">
<p>La API <code>OpenWeatherMap</code> proporciona mucha información, por
 lo que nos enfocaremos en obtener datos meteorológicos en vivo en una
ciudad en algún lugar geográfico utilizando sus valores de latitud y
longitud. Los siguientes son los requisitos y criterios de aceptación
para este patrón de diseño:</p>
<ol class="num">
<li>
<p>Proporcione un solo tipo para acceder a los datos. Toda la información recuperada del servicio <code>OpenWeatherMap</code> pasará por ella.</p>
</li>
<li>
<p>Crea una forma de obtener los datos meteorológicos para alguna ciudad de algún país.</p>
</li>
<li>
<p>Crea una forma de obtener los datos meteorológicos de alguna posición de latitud y longitud.</p>
</li>
<li>
<p>Solo el segundo y el tercer punto deben estar visibles fuera del
paquete; todo lo demás debe estar oculto (incluidos todos los datos
relacionados con la conexión).</p>
</li>
</ol>
</div>
<h4 id="unit-test">Prueba de unidad</h4>
<div class="hBody-4">
<p>Para comenzar con nuestra API Facade, necesitaremos una interfaz con los métodos que se solicitan en los <i>criterios de aceptación 2</i> y los <i>criterios de aceptación 3</i> :</p>
<pre class="code"><code class="go">type CurrentWeatherDataRetriever interface {
  GetByCityAndCountryCode(city, countryCode string) (Weather, error)
  GetByGeoCoordinates(lat, lon float32) (Weather, error)
}
</code></pre>
<p>Llamaremos los <i>criterios de aceptación 2</i>
GetByCityAndCountryCode; también necesitaremos un nombre de ciudad y un
código de país en el formato de cadena. Un código de país es un código
de dos caracteres, que representa el nombre de <b>la Organización Internacional de Normalización</b> ( <span class="acronym">ISO</span> ) de los países del mundo. Devuelve un valor <code>Weather</code>, que definiremos más adelante, y un error si algo sale mal.</p>
<p>Se llamará a los <i>criterios de aceptación 3</i><code>GetByGeoCoordinates</code> y se necesitarán valores de latitud y longitud en el <code>float32</code> formato. También devolverá un valor <code>Weather</code> y un error. El valor <code>Weather</code> se va a definir de acuerdo con el JSON devuelto con el que funciona la API <code>OpenWeatherMap</code>. Puede encontrar la descripción de este JSON en la página web <a href="http://openweathermap.org/current#current_JSON">http://openweathermap.org/current#current_JSON</a>.</p>
<p>Si miras la definición de JSON, tiene el siguiente tipo:</p>
<pre class="code"><code class="go">type Weather struct {
  ID   int    `json:"id"`
  Name string `json:"name"`
  Cod  int    `json:"cod"`
  Coord struct {
    Lon float32 `json:"lon"`
    Lat float32 `json:"lat"`
  } `json:"coord"`

  Weather []struct {
    Id          int    `json:"id"`
    Main        string `json:"main"`
    Description string `json:"description"`
    Icon        string `json:"icon"`
  } `json:"weather"`
  Base string `json:"base"`
  Main struct {
    Temp     float32 `json:"temp"`
    Pressure float32 `json:"pressure"`
    Humidity float32 `json:"humidity"`
    TempMin  float32 `json:"temp_min"`
    TempMax  float32 `json:"temp_max"`
  } `json:"main"`
  Wind struct {
    Speed float32 `json:"speed"`
    Deg   float32 `json:"deg"`
  } `json:"wind"`
  Clouds struct {
    All int `json:"all"`
  } `json:"clouds"`

  Rain struct {
    ThreeHours float32 `json:"3h"`
  } `json:"rain"`

  Dt  uint32 `json:"dt"`
  Sys struct {
    Type    int     `json:"type"`
    ID      int     `json:"id"`
    Message float32 `json:"message"`
    Country string  `json:"country"`
    Sunrise int     `json:"sunrise"`
    Sunset  int     `json:"sunset"`
  }`json:"sys"`
}
</code></pre>
<p>Es una estructura bastante larga, pero tenemos todo lo que una respuesta podría incluir. La estructura se llama <code>Weather</code>, ya que se compone de una identificación, un nombre y un código (Cod), y algunas estructuras anónimas, que son: Coord, <code>Weather</code>, <code>Base</code>, <code>Main</code>, <code>Wind</code>, <code>Clouds</code>, <code>Rain</code>, <code>Dt</code>, y <code>Sys</code>. Podríamos escribir estas estructuras anónimas fuera de la estructura <code>Weather</code> dándoles un nombre, pero solo sería útil si tenemos que trabajar con ellas por separado.</p>
<p>Después de cada miembro y estructura dentro de nuestra estructura <code>Weather</code>, puede encontrar una línea <code>`json:"something"`</code>. Esto es útil al diferenciar entre el nombre de la clave JSON y su nombre de miembro. Si la clave JSON es <code>something</code>, no estamos obligados a llamar a nuestro miembro <code>something</code>. Por ejemplo, nuestro miembro de ID será llamado <code>id</code> en la respuesta JSON.</p>
<p>¿Por qué no le damos el nombre de las claves JSON a nuestros tipos? Bueno, si sus campos en su tipo son minúsculas, el paquete <code>encoding/json</code>
 no los analizará correctamente. Además, la última anotación nos
proporciona cierta flexibilidad, no solo en términos de cambiar los
nombres de los miembros, sino también de omitir alguna clave si no la
necesitamos, con la siguiente firma:</p>
<pre class="code"><code class="go">`json:"something,omitempty"
</code></pre>
<p>Con <code>omitempty</code> al final, el análisis no fallará si esta clave no está presente en la representación de bytes de la clave JSON.</p>
<p>Bien, nuestros criterios de aceptación 1 piden un único punto de acceso a la API. Esto se llamará <code>CurrentWeatherData</code>:</p>
<pre class="code"><code class="go">type CurrentWeatherData struct {
  APIkey string
}
</code></pre>
<p>El tipo <code>CurrentWeatherData</code> tiene una clave API como miembro público para funcionar. Esto se debe a que debe ser un usuario registrado <code>OpenWeatherMap</code> para disfrutar de sus servicios. Consulte la <code>OpenWeatherMap</code>página
 web de la API para obtener documentación sobre cómo obtener una clave
API. No lo necesitaremos en nuestro ejemplo, porque no vamos a hacer
pruebas de integración.</p>
<p>Necesitamos datos simulados para que podamos escribir una función <code>mock</code>
 para recuperar los datos. Al enviar una solicitud HTTP, la respuesta
está contenida en un miembro llamado cuerpo en forma de an <code>io.Reader</code>. Ya hemos trabajado con tipos que implementan la interfaz <code>io.Reader</code>, por lo que esto debería resultarle familiar. Nuestra función <code>mock</code> aparece así:</p>
<pre class="code"><code class="go">func getMockData() io.Reader {
  response := `{
      "coord":{"lon":-3.7,"lat":40.42},"weather :
  [{"id":803,"main":"Clouds","description":"broken clouds","icon":"04n"}],"base":"stations","main":
  {"temp":303.56,"pressure":1016.46,"humidity":26.8,"temp_min":300.95,"temp_max":305.93},"wind":
  {"speed":3.17,"deg":151.001},"rain":{"3h":0.0075},"clouds":
  {"all":68},"dt":1471295823,"sys":
  {"type":3,"id":1442829648,"message":0.0278,"country":"ES","sunrise":1471238808,"sunset":1471288232},"id":3117735,"name":"Madrid","cod":200}`

  r := bytes.NewReader([]byte(response))
  return r
}
</code></pre>
<p>Este precedente de datos falsificados fue producido haciendo una solicitud para <code>OpenWeatherMap</code> usar una clave API. La variable <code>response</code>
 es una cadena que contiene una respuesta JSON. Observe de cerca el
acento grave (`) utilizado para abrir y cerrar la cuerda. De esta forma,
 puede usar tantas comillas como desee sin ningún problema.</p>
<p>Más adelante, usamos una función especial en el paquete de bytes llamada <code>NewReader</code>, que acepta un segmento de bytes (que creamos al convertir el tipo de cadena), y devuelve un <code>io.Reader</code> implementador con los contenidos del segmento. Esto es perfecto para imitar al <code>Body</code> miembro de una respuesta HTTP.</p>
<p>Vamos a escribir una prueba para probar <code>response parser</code>. Ambos métodos devuelven el mismo tipo, por lo que podemos usar el mismo <code>JSON parser</code> para ambos:</p>
<pre class="code"><code class="go">func TestOpenWeatherMap_responseParser(t *testing.T) {
  r := getMockData()
  openWeatherMap := CurrentWeatherData{APIkey: ""}

  weather, err := openWeatherMap.responseParser(r)
  if err != nil {
    t.Fatal(err)
  }

  if weather.ID != 3117735 {
    t.Errorf("Madrid id is 3117735, not %d\n", weather.ID)
  }
}
</code></pre>
<p>En la prueba anterior, primero solicitamos algunos datos simulados, que almacenamos en la variable <code>r</code>. Más tarde, creamos un tipo de <code>CurrentWeatherData</code>, que llamamos <code>openWeatherMap</code>. Finalmente, solicitamos un valor meteorológico para la interfaz <code>io.Reader</code> proporcionada que almacenamos en la variable <code>weather</code>.
 Después de verificar si hay errores, nos aseguramos de que la ID sea la
 misma que la almacenada en los datos simulados que obtuvimos del método
 <code>getMockData</code>.</p>
<p>Tenemos que declarar el método <code>responseParser</code> antes de ejecutar las pruebas, o el código no se compilará:</p>
<pre class="code"><code class="go">func (p *CurrentWeatherData) responseParser(body io.Reader) (*Weather, error) {
  return nil, fmt.Errorf("Not implemented yet")
}
</code></pre>
<p>Con todo lo anterior, podemos ejecutar esta prueba:</p>
<pre class="srci"><code class="sh"><span class="in"><span class="prompt">&gt; </span>go test -v -run=responseParser .
</span><span class="out">=== RUN   TestOpenWeatherMap_responseParser
--- FAIL: TestOpenWeatherMap_responseParser (0.00s)
        facade_test.go:72: Not implemented yet
FAIL
exit status 1
FAIL
</span></code></pre>
<ol class="alpha">
<li>
<p>No escribiremos más pruebas, porque el resto sería meramente</p>
</li>
</ol>
<p>pruebas de integración, que están fuera del alcance de la explicación
 de un patrón estructural, y nos obligarán a tener una clave API, así
como una conexión a Internet. Si desea ver cómo son las pruebas de
integración para este ejemplo, consulte el código que viene incluido con
 el libro.</p>
</div>
<h4 id="implementation">Implementación</h4>
<div class="hBody-4">
<p>En primer lugar, implementaremos el analizador que nuestros métodos usarán para analizar la respuesta JSON de la API REST <code>OpenWeatherMap</code>:</p>
<pre class="code"><code class="go">func (p *CurrentWeatherData) responseParser(body io.Reader) (*Weather, error) {
  w := new(Weather)
  err := json.NewDecoder(body).Decode(w)
  if err != nil {
    return nil, err
  }

  return w, nil
}
</code></pre>
<p>Y esto debería ser suficiente para pasar la prueba ahora:</p>
<pre class="srci"><code class="sh"><span class="in"><span class="prompt">&gt; </span>go test -v -run=responseParser .
</span><span class="out">=== RUN   TestOpenWeatherMap_responseParser
--- PASS: TestOpenWeatherMap_responseParser (0.00s)
PASS
ok
</span></code></pre>
<p>Al menos tenemos nuestro analizador bien probado. Vamos a estructurar
 nuestro código para que parezca una biblioteca. Primero, crearemos los
métodos para recuperar el clima de una ciudad por su nombre y su código
de país, y el método que usa su latitud y longitud:</p>
<pre class="code"><code class="go">func (c *CurrentWeatherData) GetByGeoCoordinates(lat, lon
  float32) (weather *Weather, err error) {
  return c.doRequest(
    fmt.Sprintf("http://api.openweathermap.org/data/2.5/weather q=%s,%s&amp;APPID=%s",
      lat, lon, c.APIkey))
}

func (c *CurrentWeatherData) GetByCityAndCountryCode(city,
  countryCode string) (weather *Weather, err error) {
  return c.doRequest(
    fmt.Sprintf("http://api.openweathermap.org/data/2.5/weather? lat=%f&amp;lon=%f&amp;APPID=%s",
      city, countryCode, c.APIkey) )
}
</code></pre>
<p>¿Un pedazo de la torta? ¡Por supuesto! Todo debe ser lo más fácil
posible, y es un signo de un buen trabajo. La complejidad de esta
fachada es crear conexiones con la API <code>OpenWeatherMap</code> y
controlar los posibles errores. Este problema se comparte entre todos
los métodos de Fachada en nuestro ejemplo, por lo que no es necesario
que escriba más de una llamada de API en este momento.</p>
<p>Lo que hacemos es pasar la URL que necesita la API REST para devolver
 la información que deseamos. Esto se logra mediante la función <code>fmt.Sprintf</code>,
 que formatea las cadenas en cada caso. Por ejemplo, para recopilar los
datos usando un nombre de ciudad y un código de país, usamos la
siguiente cadena:</p>
<pre class="code"><code class="go">  fmt.Sprintf("http://api.openweathermap.org/data/2.5/weather?lat=%f&amp;lon=%f&amp;APPID=%s", city, countryCode, c.APIkey)
</code></pre>
<p>Esto toma la cadena preformateada <a href="https://openweathermap.org/api">https://openweathermap.org/api</a> y la formatea reemplazando cada <code>%s</code> especificador con la ciudad, la <code>countryCode</code> que presentamos en los argumentos y la clave API miembro del tipo <code>CurrentWeatherData</code>.</p>
<p>¡Pero no hemos configurado ninguna clave de API! Sí, porque es una
biblioteca y los usuarios de la biblioteca tendrán que usar sus propias
claves de API. Estamos ocultando la complejidad de crear los URI y
manejar los errores.</p>
<p>Finalmente, la función <code>doRequest</code> es un gran pez, por lo que lo veremos en detalle, paso a paso:</p>
<pre class="code"><code class="go">func (o *CurrentWeatherData) doRequest(uri string) (weather *Weather, err error) {
  client := &amp;http.Client{}
  req, err := http.NewRequest("GET", uri, nil)
  if err != nil {
    return
  }
  req.Header.Set("Content-Type", "application/json")
</code></pre>
<p>En primer lugar, la firma nos dice que el método <code>doRequest</code> acepta una cadena URI y devuelve un puntero a la variable <code>Weather</code> y un error. Comenzamos creando una clase <code>http.Client</code>, que hará las solicitudes. Luego, creamos un objeto de solicitud, que usará el método <code>GET</code>, como se describe en la <code>OpenWeatherMap</code>página
 web, y el URI que aprobamos. Si tuviéramos que usar un método
diferente, o más de uno, tendrían que ser provocados por argumentos en
la firma. Sin embargo, usaremos solo el método <code>GET</code>, entonces podríamos codificarlo allí.</p>
<p>Luego, verificamos si el objeto de solicitud se ha creado
correctamente y configuramos un encabezado que dice que el tipo de
contenido es un JSON:</p>
<pre class="code"><code class="go">resp, err := client.Do(req)
if err != nil {
  return
}

if resp.StatusCode != 200 {
  byt, errMsg := ioutil.ReadAll(resp.Body)
  if errMsg == nil {
    errMsg = fmt.Errorf("%s", string(byt))
  }
  err = fmt.Errorf("Status code was %d, aborting. Error message was:\n%s\n",
    resp.StatusCode, errMsg)

  return
}
</code></pre>
<p>Luego hacemos la solicitud y verificamos si hay errores. Debido a que
 hemos dado nombres a nuestros tipos de devolución, si ocurre algún
error, solo tenemos que devolver la función, y Go devolverá la variable <code>err</code>y la variable <code>weather</code> en el estado en que estaban en ese momento preciso.</p>
<p>Verificamos el código de estado de la respuesta, ya que solo
aceptamos 200 como una buena respuesta. Si no se devuelve 200, crearemos
 un mensaje de error con el contenido del cuerpo y el código de estado
devuelto:</p>
<pre class="code"><code class="go">  weather, err = o.responseParser(resp.Body)
  resp.Body.Close()

  return
}
</code></pre>
<p>Finalmente, si todo va bien, usamos la función <code>responseParser</code> que escribimos antes para analizar los contenidos de Body, que es una interfaz <code>io.Reader</code>. Quizás te estés preguntando por qué no controlamos <code>err</code> el método <code>response parser</code>. Es gracioso, porque en realidad lo estamos controlando. <code>responseParser</code>y <code>doRequest</code> tienen la misma firma de devolución. Ambos devuelven un <code>Weather</code> puntero y un error (si los hay), de modo que podemos devolver directamente cualquiera que sea el resultado.</p>
</div>
<h4 id="library-created-with-the-facade-pattern">Biblioteca creada con el patrón Fachada</h4>
<div class="hBody-4">
<p>Tenemos el primer hito para una biblioteca para la API <code>OpenWeatherMap</code> usando el patrón de fachada. Hemos ocultado la complejidad de acceder a la API REST <code>OpenWeatherMap</code> en las funciones <code>doRequest</code>y <code>responseParser</code>,
 y los usuarios de nuestra biblioteca tienen una sintaxis fácil de usar
para consultar la API. Por ejemplo, para recuperar el clima para Madrid,
 España, un usuario solo tendrá que introducir argumentos y una clave
API al principio:</p>
<pre class="code"><code class="go">weatherMap := CurrentWeatherData{*apiKey}

weather, err := weatherMap.GetByCityAndCountryCode("Madrid", "ES")
if err != nil {
  t.Fatal(err)
}

fmt.Printf("Temperature in Madrid is %f celsius\n", weather.Main.Temp-273.15)
</code></pre>
<p>La salida de la consola para el clima en Madrid en el momento de escribir este capítulo es la siguiente:</p>
<pre class="srci"><code class="sh"><span class="out">Temperature in Madrid is 30.600006 celsius
</span></code></pre>
<p>Un típico día de verano!</p>
</div>
<h3 id="flyweight-design-pattern">Patrón de diseño Flyweight</h3>
<div class="hBody-3">
<p>Nuestro próximo patrón es el patrón de diseño <b>Flyweight</b>. Se
usa muy comúnmente en gráficos de computadora y en la industria de los
videojuegos, pero no tanto en aplicaciones empresariales.</p>
</div>
<h4 id="description">Descripción</h4>
<div class="hBody-4">
<p>Flyweight es un patrón que permite compartir el estado de un objeto
pesado entre muchas instancias de algún tipo. Imagine que tiene que
crear y almacenar demasiados objetos de algún tipo pesado que sean
fundamentalmente iguales. Te quedarás sin memoria bastante rápido. Este
problema se puede resolver fácilmente con el patrón Flyweight, con ayuda
 adicional del patrón Factory. La fábrica generalmente se encarga de
encapsular la creación de objetos, como vimos anteriormente.</p>
</div>
<h4 id="objectives">Objetivos</h4>
<div class="hBody-4">
<p>Gracias al patrón Flyweight, podemos compartir todos los posibles
estados de objetos en un único objeto común, y así minimizar la creación
 de objetos mediante el uso de punteros a objetos ya creados.</p>
</div>
<h4 id="example">Ejemplo</h4>
<div class="hBody-4">
<p>Para dar un ejemplo, vamos a simular algo que encuentres en las
páginas web de apuestas. Imagine el partido final del campeonato
europeo, que es visto por millones de personas en todo el continente.
Ahora imagine que poseemos una página web de apuestas, donde
proporcionamos información histórica sobre cada equipo en Europa. Esta
es una gran cantidad de información, que generalmente se almacena en
alguna base de datos distribuida, y cada equipo tiene, literalmente,
megabytes de información sobre sus jugadores, partidos, campeonatos,
etc.</p>
<p>Si un millón de usuarios acceden a información sobre un equipo y se
crea una nueva instancia de la información para cada usuario que
consulta datos históricos, nos quedaremos sin memoria en un abrir y
cerrar de ojos. Con nuestra solución Proxy, podríamos hacer un caché de
las <i>n</i> búsquedas más recientes para acelerar las consultas, pero
si devolvemos un clon para cada equipo, todavía nos quedará corto de
memoria (pero más rápido gracias a nuestro caché). ¿Gracioso, verdad?</p>
<p>En cambio, almacenaremos la información de cada equipo solo una vez, y
 les enviaremos referencias a los usuarios. Entonces, si enfrentamos a
un millón de usuarios que intentan acceder a información sobre una
coincidencia, en realidad solo tendremos dos equipos en la memoria con
un millón de punteros en la misma dirección de memoria.</p>
</div>
<h4 id="acceptance-criteria">Criterios de aceptación</h4>
<div class="hBody-4">
<p>Los criterios de aceptación para un patrón Flyweight siempre deben
reducir la cantidad de memoria utilizada, y deben centrarse
principalmente en este objetivo:</p>
<ol class="num">
<li>
<p>Crearemos una estructura de equipo con información básica como el
nombre del equipo, los jugadores, los resultados históricos y una imagen
 que represente su escudo.</p>
</li>
<li>
<p>Debemos asegurar la creación correcta del equipo (tenga en cuenta la <i>creación de</i> palabras aquí, candidato para un patrón creacional) y no tener duplicados.</p>
</li>
<li>
<p>Al crear el mismo equipo dos veces, debemos tener dos punteros apuntando a la misma dirección de memoria.</p>
</li>
</ol>
</div>
<h4 id="basic-structs-and-tests">Estructuras y pruebas básicas</h4>
<div class="hBody-4">
<p>Nuestra estructura <code>Team</code> contendrá otras estructuras internas, por lo que se crearán un total de cuatro estructuras. La estructura <code>Team</code> tiene la siguiente firma:</p>
<pre class="code"><code class="go">type Team struct {
  ID             uint64
  Name           string
  Shield         []byte
  Players        []Player
  HistoricalData []HistoricalData
}
</code></pre>
<p>Cada equipo tiene una identificación, un nombre, alguna imagen en una
 porción de bytes que representa el escudo del equipo, una porción de
jugadores y una porción de datos históricos. De esta manera, tendremos
la identificación de dos equipos:</p>
<pre class="code"><code class="go">const (
  TEAM_A = iota
  TEAM_B
)
</code></pre>
<p>Declaramos dos constantes usando las palabras clave <code>const</code>y <code>iota</code>. La palabra clave <code>const</code> simplemente declara que las siguientes declaraciones son constantes. <code>iota</code> es un entero sin tipo que aumenta automáticamente su valor para cada nueva constante entre los paréntesis. El valor <code>iota</code> comienza a restablecerse a 0 cuando declaramos <code>TEAM_A</code>, por lo que <code>TEAM_A</code> es igual a 0. En la variable <code>TEAM_B</code>, <code>iota</code> se incrementa en uno, por <code>TEAM_B</code> lo que equivale a 1. La <code>iota</code>
 asignación es una forma elegante de guardar la escritura cuando se
declaran valores constantes que no necesitan especificación valor (como
la constante <i>Pi</i> en el paquete <code>math</code>).</p>
<p>Nuestro <code>Player</code>y <code>HistoricalData</code> son los siguientes:</p>
<pre class="code"><code class="go">type Player struct {
  Name    string
  Surname string
  PreviousTeam uint64
  Photo   []byte
}

type HistoricalData struct {
  Year          uint8
  LeagueResults []Match
}
</code></pre>
<p>Como puede ver, también necesitamos una estructura <code>Match</code>, que se almacena dentro de <code>HistoricalData</code> struct. Una estructura <code>Match</code>, en este contexto, representa el resultado histórico de un partido:</p>
<pre class="code"><code class="go">type Match struct {
  Date          time.Time
  VisitorID     uint64
  LocalID       uint64
  LocalScore    byte
  VisitorScore  byte
  LocalShoots   uint16
  VisitorShoots uint16
}
</code></pre>
<p>Esto es suficiente para representar a un equipo y cumplir los <i>Criterios de aceptación 1</i>.
 Probablemente haya adivinado que hay mucha información sobre cada
equipo, ya que algunos de los equipos europeos han existido por más de
100 años.</p>
<p>Para el <i>Criterio de aceptación 2,</i> la <i>creación de</i> la
palabra debería darnos alguna pista sobre cómo abordar este problema.
Construiremos una fábrica para crear y almacenar nuestros equipos.
Nuestra fábrica consistirá en un mapa de años, que incluirá punteros a
valores <code>Teams</code> y una función <code>GetTeam</code>. Usar un
mapa aumentará la búsqueda del equipo si conocemos sus nombres con
anticipación. También eliminaremos un método para devolver la cantidad
de objetos creados, que se denominará método <code>GetNumberOfObjects</code>:</p>
<pre class="code"><code class="go">type teamFlyweightFactory struct {
  createdTeams map[string]*Team
}

func (t *teamFlyweightFactory) GetTeam(name string) *Team {
  return nil
}

func (t *teamFlyweightFactory) GetNumberOfObjects() int {
  return 0
}
</code></pre>
<p>Esto es suficiente para escribir nuestra primera prueba unitaria:</p>
<pre class="code"><code class="go">func TestTeamFlyweightFactory_GetTeam(t *testing.T) {
  factory := teamFlyweightFactory{}

  teamA1 := factory.GetTeam(TEAM_A)
  if teamA1 == nil {
    t.Error("The pointer to the TEAM_A was nil")
  }

  teamA2 := factory.GetTeam(TEAM_A)
  if teamA2 == nil {
    t.Error("The pointer to the TEAM_A was nil")
  }

  if teamA1 != teamA2 {
    t.Error("TEAM_A pointers weren't the same")
  }

  if factory.GetNumberOfObjects() != 1 {
    t.Errorf("The number of objects created was not 1: %d\n",
      factory.GetNumberOfObjects())
  }
}
</code></pre>
<p>En nuestra prueba, verificamos todos los criterios de aceptación. Primero creamos una fábrica, y luego pedimos un puntero de <code>TEAM_A</code>. Este puntero no puede ser <code>nil</code>o la prueba fallará.</p>
<p>Luego pedimos un segundo puntero al mismo equipo. Este puntero
tampoco puede ser nulo, y debe apuntar a la misma dirección de memoria
que la anterior para que sepamos que no ha asignado una nueva memoria.</p>
<p>Finalmente, debemos verificar si el número de equipos creados es solo
 uno, porque hemos solicitado dos veces el mismo equipo. Tenemos dos
indicadores pero solo una instancia del equipo. Vamos a ejecutar las
pruebas:</p>
<pre class="srci"><code class="sh"><span class="in"><span class="prompt">&gt; </span>go test -v -run=GetTeam .
</span><span class="out">=== RUN   TestTeamFlyweightFactory_GetTeam
--- FAIL: TestTeamFlyweightFactory_GetTeam (0.00s)
flyweight_test.go:11: The pointer to the TEAM_A was nil
flyweight_test.go:21: The pointer to the TEAM_A was nil
flyweight_test.go:31: The number of objects created was not 1:
0
FAIL
exit status 1
FAIL
</span></code></pre>
<p>Bueno, falló. Ambos punteros eran nulos y no ha creado ningún objeto.
 Curiosamente, la función que compara los dos indicadores no falla; en
general, nada es igual a cero.</p>
</div>
<h4 id="implementation">Implementación</h4>
<div class="hBody-4">
<p>Nuestro método <code>GetTeam</code> necesitará escanear el campo <code>map</code> llamado <code>createdTeams</code>
 para asegurarse de que el equipo consultado ya está creado y devolverlo
 si es así. Si el equipo no fue creado, tendrá que crearlo y almacenarlo
 en el mapa antes de regresar:</p>
<pre class="code"><code class="go">func (t *teamFlyweightFactory) GetTeam(teamID int) *Team {
  if t.createdTeams[teamID] != nil {
    return t.createdTeams[teamID]
  }

  team := getTeamFactory(teamID)
  t.createdTeams[teamID] = &amp;team

  return t.createdTeams[teamID]
}
</code></pre>
<p>El código anterior es muy simple. Si el nombre del parámetro existe en el <code>createdTeams</code>
 mapa, devuelva el puntero. De lo contrario, llame a una fábrica para
crear un equipo. Esto es lo suficientemente interesante como para
detenerse por un segundo y analizar. Cuando utiliza el patrón Flyweight,
 es muy común tener una fábrica Flyweight, que utiliza otros tipos de
patrones creacionales para recuperar los objetos que necesita.</p>
<p>Entonces, el método <code>getTeamFactory</code> nos dará el equipo
que estamos buscando, lo almacenaremos en el mapa y lo devolveremos. La
fábrica del equipo será capaz de crear los dos equipos: <code>TEAM_A</code>y <code>TEAM_B</code>:</p>
<pre class="code"><code class="go">func getTeamFactory(team int) Team {
  switch team {
  case TEAM_B:
    return Team{
      ID:   2,
      Name: TEAM_B,
    }
  default:
    return Team{
      ID:   1,
      Name: TEAM_A,
    }
  }
}
</code></pre>
<p>Estamos simplificando el contenido de los objetos para que podamos
enfocarnos en la implementación del patrón Flyweight. De acuerdo,
entonces solo tenemos que definir la función para recuperar el número de
 objetos creados, lo cual se hace de la siguiente manera:</p>
<pre class="code"><code class="go">func (t *teamFlyweightFactory) GetNumberOfObjects() int {
  return len(t.createdTeams)
}
</code></pre>
<p>Esto fue bastante fácil. La función <code>len</code> devuelve la cantidad de elementos en una matriz o división, la cantidad de caracteres en a <code>string</code>, etc. Parece que todo está hecho, y podemos lanzar nuestras pruebas nuevamente:</p>
<pre class="srci"><code class="sh"><span class="in"><span class="prompt">&gt; </span>go test -v -run=GetTeam .
</span><span class="out">=== RUN   TestTeamFlyweightFactory_GetTeam
--- FAIL: TestTeamFlyweightFactory_GetTeam (0.00s)
panic: assignment to entry in nil map [recovered]
        panic: assignment to entry in nil map

goroutine 5 [running]:
panic(0x530900, 0xc0820025c0)
        /home/mcastro/Go/src/runtime/panic.go:481 +0x3f4
testing.tRunner.func1(0xc082068120)
        /home/mcastro/Go/src/testing/testing.go:467 +0x199
panic(0x530900, 0xc0820025c0)
        /home/mcastro/Go/src/runtime/panic.go:443 +0x4f7
/home/mcastro/go-design-patterns/structural/flyweight.
(*teamFlyweightFactory).GetTeam(0xc08202fec0, 0x0, 0x0)
        /home/mcastro/Desktop/go-design-
patterns/structural/flyweight/flyweight.go:71 +0x159
/home/mcastro/go-design-
patterns/structural/flyweight.TestTeamFlyweightFactory_GetTeam(
0xc082068120)
        /home/mcastro/Desktop/go-design-
patterns/structural/flyweight/flyweight_test.go:9 +0x61
testing.tRunner(0xc082068120, 0x666580)
        /home/mcastro/Go/src/testing/testing.go:473 +0x9f
created by testing.RunTests
        /home/mcastro/Go/src/testing/testing.go:582 +0x899
exit status 2
FAIL
</span></code></pre>
<p>¡Pánico! ¿Hemos olvidado algo? Al leer el seguimiento de la pila en
el mensaje de pánico, podemos ver algunas direcciones, algunos archivos,
 y parece que el método <code>GetTeam</code> está tratando de asignar una entrada a un mapa nulo en la <i>línea 71</i> del <code>flyweight.go</code> archivo. Miremos la <i>línea 71 de</i>
 cerca (recuerde, si está escribiendo código mientras sigue este
tutorial, que el error probablemente estará en una línea diferente, así
que observe detenidamente su propio rastro).</p>
<pre class="code"><code class="go">t.createdTeams[teamName] = &amp;team
</code></pre>
<p>De acuerdo, esta línea está en el método <code>GetTeam</code> y,
cuando el método pasa por aquí, significa que no encontró al equipo en
el mapa; lo ha creado (el equipo variable) y está intentando asignarlo
al mapa. . Pero el mapa es nulo, porque no lo hemos inicializado al
crear la fábrica. Esto tiene una solución rápida. En nuestra prueba,
inicialice el mapa donde hemos creado la fábrica:</p>
<pre class="code"><code class="go">factory := teamFlyweightFactory{
  createdTeams: make(map[int]*Team,0),
}
</code></pre>
<p>Estoy seguro de que ya has visto el problema aquí. Si no tenemos
acceso al paquete, podemos inicializar la variable. Bueno, podemos hacer
 que la variable sea pública, y eso es todo. Pero esto implicaría que
cada implementador necesariamente sepa que debe inicializar el mapa, y
su firma no es conveniente ni elegante. En cambio, vamos a crear un
constructor de fábrica simple para que lo haga por nosotros. Este es un
enfoque muy común en Go:</p>
<pre class="code"><code class="go">func NewTeamFactory() teamFlyweightFactory {
  return teamFlyweightFactory{
    createdTeams: make(map[int]*Team),
  }
}
</code></pre>
<p>Entonces, ahora, en la prueba, reemplazamos la creación de fábrica con una llamada a esta función:</p>
<pre class="code"><code class="go">func TestTeamFlyweightFactory_GetTeam(t *testing.T) {
  factory := NewTeamFactory()
  ...
}
</code></pre>
<p>Y corremos la prueba de nuevo:</p>
<pre class="srci"><code class="sh"><span class="in"><span class="prompt">&gt; </span>go test -v -run=GetTeam .
</span><span class="out">=== RUN   TestTeamFlyweightFactory_GetTeam
--- PASS: TestTeamFlyweightFactory_GetTeam (0.00s)
PASS
ok
</span></code></pre>
<p>¡Perfecto! Mejoremos la prueba agregando una segunda prueba, solo
para asegurarnos de que todo se ejecutará como se espera con más
volumen. Vamos a crear un millón de llamadas a la creación del equipo,
lo que representa un millón de llamadas de usuarios. Luego, simplemente
comprobaremos que la cantidad de equipos creados sea solo dos:</p>
<pre class="code"><code class="go">func Test_HighVolume(t *testing.T) {
  factory := NewTeamFactory()

  teams := make([]*Team, 500000*2)
  for i := 0; i &lt; 500000; i++ {
    teams[i] = factory.GetTeam(TEAM_A)
  }

  for i := 500000; i &lt; 2*500000; i++ {
    teams[i] = factory.GetTeam(TEAM_B)
  }

  if factory.GetNumberOfObjects() != 2 {
    t.Errorf("The number of objects created was not 2: %d\n",
      factory.GetNumberOfObjects())
  }
}
</code></pre>
<p>En esta prueba, recuperamos <code>TEAM_A</code>y <code>TEAM_B</code>500.000 veces cada uno para llegar a un millón de usuarios. Luego, nos aseguramos de que solo se crearon dos objetos:</p>
<pre class="srci"><code class="sh"><span class="in"><span class="prompt">&gt; </span>go test -v -run=Volume .
</span><span class="out">=== RUN   Test_HighVolume
--- PASS: Test_HighVolume (0.04s)
PASS
ok
</span></code></pre>
<p>¡Perfecto! Incluso podemos verificar hacia dónde apuntan los
apuntadores y dónde están ubicados. Comprobaremos con los tres primeros
como ejemplo. Agregue estas líneas al final de la última prueba y vuelva
 a ejecutarla:</p>
<pre class="code"><code class="go">for i:=0; i&lt;3; i++ {
  fmt.Printf("Pointer %d points to %p and is located in %p\n",
    i, teams[i], &amp;teams[i])
}
</code></pre>
<p>En la prueba anterior, usamos el método <code>Printf</code> para imprimir información sobre punteros. La bandera <code>%p</code>
 le proporciona la ubicación de la memoria del objeto al que apunta el
puntero. Si hace referencia al puntero pasando el símbolo &amp;, le dará
 la dirección del puntero.</p>
<p>Ejecute la prueba nuevamente con el mismo comando; verá tres líneas
nuevas en el resultado con información similar a la siguiente:</p>
<pre class="srci"><code class="sh"><span class="out">Pointer 0 points to 0xc082846000 and is located in 0xc082076000
Pointer 1 points to 0xc082846000 and is located in 0xc082076008
Pointer 2 points to 0xc082846000 and is located in 0xc082076010
</span></code></pre>
<p>Lo que nos dice es que las primeras tres posiciones en el mapa
apuntan a la misma ubicación, pero que en realidad tenemos tres punteros
 diferentes, que son, efectivamente, mucho más livianos que nuestro
objeto de equipo.</p>
</div>
<h4 id="what's-the-difference-between-singleton-and-flyweight-then?">¿Cuál es la diferencia entre Singleton y Flyweight entonces?</h4>
<div class="hBody-4">
<p>Bueno, la diferencia es sutil pero está ahí. Con el patrón de
Singleton, nos aseguramos de que el mismo tipo se cree solo una vez.
Además, el patrón de Singleton es un patrón de creación. Con Flyweight,
que es un patrón estructural, no nos preocupa cómo se crean los objetos,
 sino cómo estructurar un tipo para que contenga información pesada de
una manera ligera. La estructura de la que estamos hablando es la
estructura <code>map[int]*Team</code> en nuestro ejemplo. Aquí, realmente no nos importaba cómo creamos el objeto; simplemente hemos escrito un método <code>getTeamFactory</code>
 sencillo para ello. Dimos la mayor importancia a tener una estructura
ligera para contener un objeto (u objetos) compartibles, en este caso,
el mapa.</p>
</div>
<h3 id="summary">Resumen</h3>
<div class="hBody-3">
<p>Hemos visto varios patrones para organizar estructuras de código. Los
 patrones estructurales están preocupados acerca de cómo crear objetos, o
 cómo hacen su negocio (veremos esto en los patrones de comportamiento).</p>
<p>No se sienta confundido al mezclar varios patrones. Podría terminar
mezclando seis o siete con bastante facilidad si sigue estrictamente los
 objetivos de cada uno. Solo tenga en cuenta que la sobreingeniería es
tan mala como la falta de ingeniería. Recuerdo haber creado prototipos
de un equilibrador de carga una tarde, y después de dos horas de código
sobre-diseñado loco, tenía tanto lío en mi cabeza que preferí comenzar
todo de nuevo.</p>
<p>En el próximo capítulo, veremos patrones de comportamiento. Son un
poco más complejos, y a menudo usan patrones estructurales y de creación
 para sus objetivos, pero estoy seguro de que el lector los encontrará
bastante desafiantes e interesantes.</p>
</div>
<h3 id="chapter-5.-behavioral-patterns---strategy,-chain-of-responsibility,-and-command-design-patterns">Capítulo 5. Patrones de comportamiento: estrategia, cadena de responsabilidad y patrones de diseño de comando</h3>
<div class="hBody-3">
<p>El último grupo de patrones comunes que vamos a ver son los patrones
de comportamiento. Ahora, no vamos a definir estructuras ni a encapsular
 la creación de objetos, pero vamos a tratar con comportamientos.</p>
<p>¿Qué tiene que ver con los patrones de comportamiento? Bien, ahora
encapsularemos comportamientos, por ejemplo, algoritmos en el patrón de
Estrategia o ejecuciones en el patrón de comando.</p>
<p>El diseño del comportamiento correcto es el último paso después de
saber cómo lidiar con la creación y las estructuras del objeto. Definir
el comportamiento correctamente es el último paso del buen diseño de
software porque, en general, un buen diseño de software nos permite
mejorar los algoritmos y corregir errores fácilmente, mientras que la
mejor implementación de algoritmo no nos salvará del mal diseño del
software.</p>
</div>
<h4 id="strategy-design-pattern">Patrón de diseño de estrategia</h4>
<div class="hBody-4">
<p>El patrón de Estrategia es probablemente el más fácil de entender de
los patrones de Comportamiento. Lo hemos usado algunas veces mientras
desarrollamos los patrones anteriores, pero sin detenernos a hablar de
ello. Ahora lo haremos.</p>
</div>
<h4 id="description">Descripción</h4>
<div class="hBody-4">
<p>El patrón de Estrategia utiliza diferentes algoritmos para lograr
algunas funcionalidades específicas. Estos algoritmos están ocultos
detrás de una interfaz y, por supuesto, deben ser intercambiables. Todos
 los algoritmos logran la misma funcionalidad de una manera diferente.
Por ejemplo, podríamos tener una interfaz Sort y pocos algoritmos de
clasificación. El resultado es el mismo, algunas listas están ordenadas,
 pero podríamos haber usado la ordenación rápida, la clasificación por
fusión, etc.</p>
<p>¿Puedes adivinar cuándo utilizamos un patrón de Estrategia en los
capítulos anteriores? Tres, dos, uno ... Bueno, usamos mucho el patrón
de estrategia cuando usamos la interfaz <code>io.Writer</code>. La interfaz <code>io.Writer</code>
 define una estrategia para escribir, y la funcionalidad es siempre la
misma: escribir algo. Podríamos escribirlo en la salida estándar, en
algún archivo o en un tipo definido por el usuario, pero hacemos lo
mismo al final: para escribir. Simplemente cambiamos la estrategia para
escribir (en este caso, cambiamos el lugar donde escribimos).</p>
</div>
<h4 id="objectives">Objetivos</h4>
<div class="hBody-4">
<p>Los objetivos del patrón de Estrategia son muy claros. El patrón debería hacer lo siguiente:</p>
<ul>
<li>
<p>Proporcione algunos algoritmos para lograr alguna funcionalidad específica</p>
</li>
<li>
<p>Todos los tipos logran la misma funcionalidad de una manera diferente, pero el cliente de la estrategia no se ve afectado</p>
</li>
</ul>
<p>El problema es que esta definición cubre un amplio espectro de
posibilidades. Esto se debe a que el patrón de estrategia se usa
realmente para una variedad de escenarios y muchas soluciones de
ingeniería de software vienen con algún tipo de estrategia. Por lo
tanto, es mejor verlo en acción con un ejemplo real.</p>
</div>
<h4 id="rendering-images-or-text">Renderizar imágenes o texto</h4>
<div class="hBody-4">
<p>Vamos a hacer algo diferente para este ejemplo. En lugar de imprimir
texto solo en la consola, también vamos a pintar objetos en un archivo.</p>
<p>En este caso, tendremos dos estrategias: consola y archivo. Pero el
usuario de la biblioteca no tendrá que lidiar con la complejidad detrás
de ellos.</p>
<p>La característica clave es que el "que llama" no sabe cómo funciona
la biblioteca subyacente y simplemente conoce la información disponible
en la estrategia definida. Esto se ve muy bien en el siguiente diagrama:</p>
<figure>
<img src="Ir%20a%20patrones%20de%20dise%C3%B1o_files/229_1.jpg">
</figure>
<p>En este diagrama, hemos elegido imprimir en consola, pero no trataremos el tipo <code>ConsoleStrategy</code> directamente, siempre usaremos una interfaz que lo represente. El tipo <code>ConsoleStrategy</code> ocultará los detalles de implementación de la impresión a la consola a la persona que llama en la función <code>main</code>. <code>FileStrategy</code> oculta sus detalles de implementación así como cualquier estrategia futura.</p>
</div>
<h4 id="acceptance-criteria">Criterios de aceptación</h4>
<div class="hBody-4">
<p>Una estrategia debe tener un objetivo muy claro y tendremos dos formas de lograrlo. Nuestros objetivos serán los siguientes:</p>
<ul>
<li>
<p>Proporcione una forma de mostrarle al usuario un objeto (un cuadrado) en texto o imagen</p>
</li>
<li>
<p>El usuario debe elegir entre imagen o texto al iniciar la aplicación</p>
</li>
<li>
<p>La aplicación debe poder agregar más estrategias de visualización (audio, por ejemplo)</p>
</li>
<li>
<p>Si el usuario selecciona texto, la palabra <i>Square</i> debe estar impresa en la consola</p>
</li>
<li>
<p>Si el usuario selecciona la imagen, se imprimirá una imagen de un cuadrado blanco sobre un fondo negro en un archivo</p>
</li>
</ul>
</div>
<h4 id="implementation">Implementación</h4>
<div class="hBody-4">
<p>No vamos a escribir pruebas para este ejemplo, ya que será bastante
complicado comprobar que una imagen haya aparecido en la pantalla
(aunque no imposible utilizando <b>OpenCV</b>, una impresionante
biblioteca para visión por computadora). Comenzaremos definiendo
directamente nuestra interfaz de estrategia que cada estrategia de
impresión debe implementar (en nuestro caso, los tipos de archivo y
consola):</p>
<pre class="code"><code class="go">type PrintStrategy interface {
  Print() error
}
</code></pre>
<p>Eso es todo. Nuestra estrategia define un método <code>Print()</code> simple que devuelve un <code>error</code>(el
 tipo que devuelve errores es obligatorio cuando se trata de archivos,
por ejemplo). Los tipos que necesita para poner en práctica <code>PrintStrategy</code> serán llamados <code>ConsoleSquare</code>y un tipo <code>ImageSquare</code>:</p>
<pre class="code"><code class="go">type ConsoleSquare struct {}

type ImageSquare struct {
  DestinationFilePath string
}
</code></pre>
<p>La estructura <code>ConsoleSquare</code> no necesita ningún campo interno porque siempre imprimirá la palabra <code>Square</code> en la consola. La estructura <code>ImageSquare</code>
 almacenará un campo para el destino del archivo de imagen donde
imprimiremos el cuadrado. Comenzaremos con la implementación del tipo <code>ConsoleSquare</code> ya que es el más simple:</p>
<pre class="code"><code class="go">func(c *ConsoleSquare) Print() error {
  println("Square")
  return nil
}
</code></pre>
<p>Muy fácil, pero la imagen es más compleja. No dedicaremos demasiado tiempo a explicar en detalle cómo funciona el paquete <code>image</code> porque el código es fácilmente comprensible:</p>
<pre class="code"><code class="go">func (t *ImageSquare) Print() error {
  width := 800
  height := 600

  origin := image.Point{0, 0}

  bgImage := image.NewRGBA(image.Rectangle{
    Min: origin,
    Max: image.Point{X: width, Y: height},
  })

  bgColor := image.Uniform{color.RGBA{R: 70, G: 70, B: 70, A:0}}
  quality := &amp;jpeg.Options{Quality: 75}

  draw.Print(bgImage, bgImage.Bounds(), &amp;bgColor, origin, draw.Src)
</code></pre>
<p>Sin embargo, aquí hay una breve explicación:</p>
<ul>
<li>
<p>Definimos un tamaño para la imagen ( <code>width</code>y variables <code>height</code>)
 de 800 píxeles de ancho y 600 píxeles de alto. Esos serán los límites
de tamaño de nuestra imagen y todo lo que escribamos fuera de ese tamaño
 no será visible.</p>
</li>
<li>
<p>La variable <code>origin</code> almacena an <code>image.Point</code>, un tipo para representar una posición en cualquier espacio bidimensional. Establecemos la posición de este punto en ( <i>0, 0</i> ), la esquina superior izquierda de la imagen.</p>
</li>
<li>
<p>Necesitamos un mapa de bits que represente nuestros antecedentes, aquí lo llamamos <code>bgImage</code>. Tenemos una función muy útil en el paquete de imágenes para crear los tipos <code>image.RGBA</code> llamados <code>image.NewRGBA</code>.
 Necesitamos pasar un rectángulo a esta función para que conozca los
límites de la imagen. Un rectángulo está representado por dos tipos <code>image.Point</code>: su punto de esquina superior izquierdo (el campo <code>Min</code>) y su punto de esquina inferior derecha (el campo Máx). Usamos <code>origin</code> como la parte superior izquierda y un nuevo punto con los valores de <code>width</code>y <code>height</code> como el punto inferior derecho.</p>
</li>
<li>
<p>La imagen tendrá un color de fondo gris ( <code>bgColor</code>). Esto se hace instaurando un tipo de <code>image.Uniform</code>, que representa un color uniforme (de ahí el nombre). El tipo <code>image.Uniform</code> necesita una instancia de una interfaz <code>color.Color</code>. Un tipo <code>color.Color</code> es cualquier tipo que implementa la <code>RGBA()</code>( <code>r</code>, <code>g</code>, <code>b</code>, un método <code>uint32</code>) para devolver un valor <code>uint32</code> para los colores rojo, verde, azul y alfa (RGBA). Alpha es un valor para la transparencia de un píxel. El paquete <code>color</code> proporciona convenientemente un tipo llamado <code>color.RGBA</code> para este propósito (en caso de que no necesitemos implementar el nuestro, que es nuestro caso).</p>
</li>
<li>
<p>Al almacenar una imagen en ciertos formatos, debemos especificar la
calidad de la imagen. Afectará no solo la calidad sino también el tamaño
 del archivo, por supuesto. Aquí, se define como 75; 100 es la máxima
calidad posible que podemos establecer. Como puede ver, estamos usando
el paquete <code>jpeg</code> aquí para establecer el valor de un tipo llamado<code>Options</code> que simplemente almacena el valor de la calidad, no tiene más valores para aplicar.</p>
</li>
<li>
<p>Finalmente, la función <code>draw.Print</code> escribe los píxeles en la imagen suministrada ( <code>bgImage</code>) con las características que hemos definido en los límites definidos por la misma imagen. El primer argumento del método <code>draw.Print</code> toma la imagen de destino, donde utilizamos<code>bgImage</code>.
 El segundo argumento son los límites del objeto para dibujar en la
imagen de destino, utilizamos los mismos límites de la imagen pero
podríamos usar cualquier otro si quisiéramos un rectángulo más pequeño.
El tercer argumento es el color a usar para colorear los límites.</p>
</li>
<li>
<p>La variable <code>Origin</code> se usa para indicar dónde debe
colocarse la esquina superior izquierda del límite. En este caso, los
límites son del mismo tamaño que la imagen, por lo que debemos
establecerlo en el origen. El último argumento especificado es el tipo
de operación; solo déjalo en la <code>draw.Src</code> discusión.</p>
</li>
</ul>
<p>Ahora tenemos que dibujar el cuadrado. La operación es esencialmente
la misma que dibujar el fondo pero, en este caso, estamos dibujando un
cuadrado sobre el trazado anterior<code>bgImage</code> :</p>
<pre class="code"><code class="go">squareWidth := 200
squareHeight := 200
squareColor := image.Uniform{color.RGBA{R: 255, G: 0, B: 0, A: 1}}
square := image.Rect(0, 0, squareWidth, squareHeight)
square = square.Add(image.Point{
  X: (width / 2) - (squareWidth / 2),
  Y: (height / 2) - (squareHeight / 2),
})
squareImg := image.NewRGBA(square)

draw.Print(bgImage, squareImg.Bounds(), &amp;squareColor, origin, draw.Src)
</code></pre>
<p>El cuadrado será de 200 * 200 píxeles de color rojo. Al usar el método <code>Add</code>, el tipo <code>Rect</code> de origen se traduce al punto proporcionado; esto es para centrar el cuadrado en la imagen. Creamos una imagen con el cuadrado <code>Rect</code>y llamamos de nuevo a la función <code>Print</code> en la <code>bgImage</code> imagen para dibujar el cuadrado rojo sobre ella:</p>
<pre class="code"><code class="go">  w, err := os.Create(t.DestinationFilePath)
  if err != nil {
    return fmt.Errorf("Error opening image")
  }
  defer w.Close()

  if err = jpeg.Encode(w, bgImage, quality); err != nil {
    return fmt.Errorf("Error writing image to disk")
  }

  return nil
}
</code></pre>
<p>Finalmente, crearemos un archivo para almacenar el contenido de la
imagen. El archivo se almacenará en la ruta proporcionada en el campo <code>DestinationFilePath</code> de la estructura <code>ImageSquare</code>. Para crear un archivo, utilizamos <code>os.Create</code> que devuelve el <code>*os.File</code>. Al igual que con todos los archivos, debe cerrarse después de usarlo, así que no se olvide de usar elpalabra clave <code>defer</code> para asegurarse de cerrarla cuando finalice el método.</p>
<div class="about">
<div class="about-dt">Tip</div>
<div class="about-dd">
<p>¿Diferir, o no aplazar?</p>
<p>Algunas personas preguntan por qué el uso de <code>defer</code> todos? ¿No sería lo mismo simplemente escribirlo sin <code>defer</code>
 al final de la función? Bueno, en realidad no. Si se produce algún
error durante la ejecución del método y devuelve este error, el método <code>Close</code>
 no se ejecutará si está al final de la función. Puede cerrar el archivo
 antes de regresar, pero tendrá que hacerlo en cada comprobación de
error. Con <code>defer</code>, no tiene que preocuparse por esto porque
la función diferida se ejecuta siempre (con o sin error). De esta forma,
 nos aseguramos de que el archivo esté cerrado.</p>
</div>
</div>
<p>Para analizar los argumentos, usaremos el paquete <code>flag</code>.
Lo hemos usado antes, pero recordemos su uso. Una bandera es un comando
que el usuario puede pasar al ejecutar nuestra aplicación. Podemos
definir una bandera usando el <code>flag</code>. [tipo] métodos definidos en el paquete <code>flag</code>. Queremos leer el resultado que el usuario quiere usar desde la consola. Esta bandera se llamará <code>output</code>. Una bandera puede tener un valor predeterminado; en este caso, tendrá el valor <code>console</code> que se usará al imprimir en la consola. Entonces, si el usuario ejecuta el programa sin argumentos, lo imprime en la consola:</p>
<pre class="srci"><code class="sh"><span class="out">var output = flag.String("output", "console", "The output to use between 'console' and 'image' file")
</span></code></pre>
<p>Nuestro paso final es escribir la función principal:</p>
<pre class="code"><code class="go">func main(){
    flag.Parse()
</code></pre>
<p>Recuerde que lo primero que debe hacer en general cuando usa banderas es analizarlas utilizando el método <code>flag.Parse()</code>. Es muy común olvidar este paso:</p>
<pre class="code"><code class="go">var activeStrategy PrintStrategy

switch *output {
case "console":
  activeStrategy = &amp;TextSquare{}
case "image":
  activeStrategy = &amp;ImageSquare{"/tmp/image.jpg"}
default:
  activeStrategy = &amp;TextSquare{}
}
</code></pre>
<p>Definimos una variable para la estrategia que el usuario ha elegido, llamada <code>activeStrategy</code>. Pero compruebe que la variable <code>activeStrategy</code> tenga el tipo <code>PrintStrategy</code> para que pueda ser poblada con cualquier implementación de la variable <code>PrintStrategy</code>. Estableceremos <code>activeStrategy</code> una nueva instancia de <code>TextSquare</code> cuando el usuario escribe el   comando <code>--output=console</code> y un ImageSquare cuando escribamos el   comando <code>--output=image</code>. Finalmente, aquí está la ejecución del patrón de diseño:</p>
<pre class="code"><code class="go">  err := activeStrategy.Print()
  if err != nil {
    log.Fatal(err)
  }
}
</code></pre>
<p>Nuestra variable <code>activeStrategy</code> es un tipo que implementa <code>PrintStrategy</code>y o el <code>TextSquare</code>o<code>ImageSquare</code>
 las clases. El usuario elegirá en el tiempo de ejecución qué estrategia
 quiere usar para cada caso particular. Además, podríamos haber escrito
un patrón de método de fábrica para crear estrategias, de modo que la
creación de la estrategia también se desacople de la función principal y
 se abstraiga en un paquete independiente diferente. Piénselo: si
tenemos la creación de la estrategia en un paquete diferente, también
nos permitirá usar este proyecto como una biblioteca y no solo como una
aplicación independiente.</p>
<p>Ahora ejecutaremos ambas estrategias; la instancia <code>TextSquare</code> nos dará un cuadrado al imprimir la palabra <code>Square</code> en la consola:</p>
<pre class="srci"><code class="sh"><span class="in"><span class="prompt">&gt; </span>go run main.go --output=console
</span><span class="out">Square
</span></code></pre>
<p>Ha funcionado como se esperaba. Recordando cómo funcionan las banderas, tenemos que usar el <code>--</code>(doble guión) y la bandera definida, <code>output</code> en nuestro caso. Entonces tiene dos opciones: usar <code>=</code>(iguales) e inmediatamente escribir el valor de la bandera o escritura <code>&lt;space&gt;</code>y
 el valor de la bandera. En este caso, hemos definido el valor
predeterminado de salida para la consola, por lo que las siguientes tres
 ejecuciones son equivalentes:</p>
<pre class="srci"><code class="sh"><span class="in"><span class="prompt">&gt; </span>go run main.go --output=console
</span><span class="out">Square
</span><span class="in"><span class="prompt">&gt; </span>go run main.go --output console
</span><span class="out">Square
</span><span class="in"><span class="prompt">&gt; </span>go run main.go
</span><span class="out">Square
</span></code></pre>
<p>Ahora tenemos que probar la estrategia de archivos. Como se definió
anteriormente, la estrategia de archivo imprimirá un cuadrado rojo en un
 archivo como una imagen con fondo gris oscuro:</p>
<pre class="srci"><code class="sh"><span class="in"><span class="prompt">&gt; </span>go run main.go --output image
</span></code></pre>
<p>¿No pasó nada? Pero todo funcionó correctamente. Esto es realmente
una mala práctica. Los usuarios siempre deben tener algún tipo de
comentarios al usar su aplicación o su biblioteca. Además, si usan su
código como biblioteca, tal vez tengan un formato específico para la
salida, por lo que no sería bueno imprimirlo directamente en la consola.
 Resolveremos este problema más adelante. En este momento, abra la
carpeta <span class="file">/ tmp</span> con su explorador de archivos favorito y verá un archivo llamado <span class="file">image.jpg</span> con nuestro cuadrado rojo en un fondo gris oscuro.</p>
</div>
<h3 id="solving-small-issues-in-our-library">Resolviendo pequeños problemas en nuestra biblioteca</h3>
<div class="hBody-3">
<p>Tenemos algunos problemas en nuestro código:</p>
<ul>
<li>
<p>No puede ser usado como una biblioteca. Tenemos un código crítico escrito en el paquete <code>main</code> (creación de estrategia).</p>
<p><b>Solución</b>: Resumen de dos paquetes diferentes la creación de estrategias desde la aplicación de línea de comandos.</p>
</li>
<li>
<p>Ninguna de las estrategias está haciendo ningún registro para
archivar o consolar. Debemos proporcionar una forma de leer algunos
registros que un usuario externo puede integrar en sus estrategias o
formatos de registro.</p>
<p><b>Solución</b>: Inyecte una interfaz <code>io.Writer</code> como dependencia para actuar como un receptor de registro.</p>
</li>
<li>
<p>Nuestra clase <code>TextSquare</code> siempre está escribiendo en la consola (un implementador de la interfaz <code>io.Writer</code>) y <code>ImageSquare</code> siempre está escribiendo en el archivo (otro implementador de la interfaz <code>io.Writer</code>). Esto está muy acoplado.</p>
<p><b>Solución</b>: Inyectar una interfaz <code>io.Writer</code> para que el <code>TextSquare</code>y <code>ImageSquare</code> puede escribir en cualquiera de las implementaciones <code>io.Writer</code> que están disponibles (archivo y la consola, sino también bytes de memoria intermedia, codificadores binarios, <code>JSON</code> manipuladores ... decenas de paquetes).</p>
</li>
</ul>
<p>Entonces, para usarlo como una biblioteca y resolver el primer
problema, seguiremos un enfoque común en las estructuras de archivos Go
para aplicaciones y bibliotecas. Primero, ubicaremos nuestro paquete y
función principal fuera del paquete raíz; en este caso, en una carpeta
llamada <code>cli</code>. También es común llamar a esta carpeta cmd o incluso <code>app</code>. Luego, colocaremos nuestra interfaz <code>PrintStrategy</code> en el paquete raíz, que ahora se llamará paquete <code>strategy</code>. Finalmente, crearemos un paquete <code>shapes</code>
 en una carpeta con el mismo nombre donde colocaremos estrategias de
texto e imagen. Por lo tanto, nuestra estructura de archivos será así:</p>
<ul>
<li>
<p><b>Paquete raíz</b>: estrategia</p>
<p><b>Archivo</b>: <span class="file">print_strategy.go</span></p>
</li>
<li>
<p><b>SubPaquete</b>: formas</p>
<p><b>Archivos</b>: <span class="file">image.go</span>, <span class="file">text.go</span>, <span class="file">factory.go</span></p>
</li>
<li>
<p><b>SubPaquete</b>: cli</p>
<p><b>Archivo</b>: <span class="file">main.go</span></p>
</li>
</ul>
<p>Vamos a modificar un poco nuestra interfaz para adaptarla a las necesidades que hemos escrito anteriormente:</p>
<pre class="code"><code class="go">type PrintStrategy interface {
  Print() error
  SetLog(io.Writer)
  SetWriter(io.Writer)
}
</code></pre>
<p>Hemos agregado el método <code>SetLog(io.Writer)</code> para agregar
una estrategia de registrador a nuestros tipos; esto es para
proporcionar retroalimentación a los usuarios. Además, tiene un método <code>SetWriter</code> para establecer la <code>io.Writer</code> estrategia. Esta interfaz se ubicará en el paquete raíz en el archivo <span class="file">print_strategy.go</span>. Entonces el esquema final se ve así:</p>
<figure>
<img src="Ir%20a%20patrones%20de%20dise%C3%B1o_files/237_1.jpg">
</figure>
<p>Tanto el <code>TextSquare</code>y <code>ImageSquare</code> las estrategias tienen que satisfacer las <code>SetLog</code>y los métodos <code>SetWriter</code>
 que simplemente se almacenan algún objeto en sus campos así, en lugar
de aplicar el mismo dos veces, podemos crear una estructura que les
implementa e incrustar este struct en las estrategias. Por cierto, este
sería el patrón compuesto que hemos visto anteriormente:</p>
<pre class="code"><code class="go">type PrintOutput struct {
  Writer    io.Writer
  LogWriter io.Writer
}

func(d *PrintOutput) SetLog(w io.Writer) {
  d.LogWriter = w
}

func(d *PrintOutput) SetWriter(w io.Writer) {
  d.Writer = w
}
</code></pre>
<p>Entonces, cada estrategia debe tener la estructura <code>PrintOutput</code> incorporada si queremos modificar sus campos <code>Writer</code>y <code>logger</code>.</p>
<p>También necesitamos modificar nuestra implementación de estrategia.</p>
<p>La estructura <code>TextSquare</code> ahora necesita un campo para almacenar la salida <code>io.Writer</code>(el lugar donde va a escribir en lugar de escribir siempre a la consola) y el <code>log</code> escritor. Estos dos campos pueden proporcionarse incrustando la estructura <code>PrintOutput</code>. La estructura <code>TextSquare</code> también se almacena en el archivo <span class="file">text.go</span> dentro del paquete de formas. Entonces, la estructura ahora es así:</p>
<pre class="code"><code class="go">package shapes

type TextSquare struct {
  strategy.PrintOutput
}
</code></pre>
<p>Entonces, ahora el método <code>Print()</code> es ligeramente diferente porque, en lugar de escribir directamente a la consola usando la función <code>println</code>, tenemos que escribir cualquiera que <code>io.Writer</code> esté almacenado en el campo <code>Writer</code>:</p>
<pre class="code"><code class="go">func (t *TextSquare) Print() error {
  r := bytes.NewReader([]byte("Circle"))
  io.Copy(t.Writer, r)
  return nil
}
</code></pre>
<p>El <code>bytes.NewReader</code> es una función muy útil que toma una matriz de bytes y los convierte en una interfaz <code>io.Reader</code>. Necesitamos una interfaz <code>io.Reader</code> para usar la función <code>io.Copy</code>. La función <code>io.Copy</code> también es increíblemente útil ya que toma un <code>io.Reader</code>(como el segundo parámetro) y lo canaliza a un <code>io.Writer</code>(su
 primer parámetro). Por lo tanto, no devolveremos un error en ningún
caso. Sin embargo, es más fácil hacerlo usando directamente el método <code>Write</code> de <code>t.Writer</code>:</p>
<pre class="code"><code class="go">func (t *TextSquare) Print() error {
  t.Writer.Write([]byte("Circle"))
  return nil
}
</code></pre>
<p>Puedes usar el método que más te guste. Por lo general, utilizará el método Write, pero también es bueno conocer la función <code>bytes.NewReader</code>.</p>
<p>¿Te diste cuenta de que cuando usamos <code>t.Writer</code>, en realidad estamos accediendo <code>PrintOutput.Writer</code>? El tipo <code>TextSquare</code> tiene un campo <code>Writer</code> porque la estructura <code>PrintOutput</code> lo tiene y está incrustado en la estructura <code>TextSquare</code>.</p>
<div class="about">
<div class="about-dt">Tip</div>
<div class="about-dd">
<p>Incrustar no es herencia. Hemos incrustado la estructura <code>PrintOutput</code> en la estructura <code>TextSquare</code>. Ahora podemos acceder a los campos <code>PrintOutput</code> como si estuvieran en campos <code>TextSquare</code>. Esto se parece un poco a la herencia, pero aquí hay una diferencia muy importante:</p>
<p><code>TextSquare</code> no es un valor <code>PrintOutput</code> pero tiene una <code>PrintOutput</code> en su composición. Qué significa eso? Eso si tienes una función que espera una <code>PrintOutput</code>, no puedes pasar <code>TextSquare</code> solo porque tiene un <code>PrintOutput</code> incrustado.</p>
<p>Pero, si tiene una función que acepta una interfaz que <code>PrintOutput</code> implementa, puede pasar <code>TextSquare</code> si tiene una <code>PrintOutput</code> incrustada. Esto es lo que estamos haciendo en nuestro ejemplo.</p>
</div>
</div>
<p>La estructura <code>ImageSquare</code> ahora es como la <code>TextSquare</code>, con un <code>PrintOutput</code> incrustado:</p>
<pre class="code"><code class="go">type ImageSquare struct {
  strategy.PrintOutput
}
</code></pre>
<p>El método <code>Print</code> también necesita ser modificado. Ahora, no estamos creando un archivo del método <code>Print</code>, ya que estaba rompiendo el principio de responsabilidad única. Un archivo implementa una, <code>io.Writer</code> por lo que abriremos el archivo fuera de la estructura <code>ImageSquare</code> e lo inyectaremos en el campo <code>Writer</code>. Entonces, solo tenemos que modificar el final del método <code>Print()</code> donde escribimos el archivo:</p>
<pre class="code"><code class="go">draw.Print(bgImage, squareImg.Bounds(), &amp;squareColor, origin, draw.Src)

if i.Writer == nil {
  return fmt.Errorf("No writer stored on ImageSquare")
}
if err := jpeg.Encode(i.Writer, bgImage, quality); err != nil {
  return fmt.Errorf("Error writing image to disk")
}

if i.LogWriter != nil {
  io.Copy(i.LogWriter, "Image written in provided writer\n")
}

return nil
</code></pre>
<p>Si revisa nuestra implementación anterior, después de usarla <code>draw</code>, puede ver que usamos el método <code>Print</code>, creamos un archivo <code>os.Create</code>y lo pasamos a la función <code>jpeg.Encode</code>. Hemos eliminado esta parte sobre la creación del archivo y la hemos reemplazado con una comprobación que busca una <code>Writer</code> en los campos ( <code>if i.Writer != nil</code>). Luego, <code>jpeg.Encode</code> podemos reemplazar el valor del archivo que estábamos utilizando previamente con el contenido del campo <code>i.Writer</code>. Finalmente, estamos usando <code>io.Copy</code> nuevamente para registrar algún mensaje al <code>LogWriter</code> si se proporciona una estrategia de registro.</p>
<p>También tenemos que abstraer el conocimiento que necesita el usuario para crear instancias de implementadores <code>PrintStrategy</code> para las que vamos a usar un método de Fábrica:</p>
<pre class="code"><code class="go">const (
  TEXT_STRATEGY  = "text"
  IMAGE_STRATEGY = "image"
)

func NewPrinter(s string) (strategy.Output, error) {
  switch s {
  case TEXT_STRATEGY:
    return &amp;TextSquare{
      PrintOutput: strategy.PrintOutput{
        LogWriter: os.Stdout,
      },
    }, nil
  case IMAGE_STRATEGY:
    return &amp;ImageSquare{
      PrintOutput: strategy.PrintOutput{
        LogWriter: os.Stdout,
      },
    }, nil
  default:
    return nil, fmt.Errorf("Strategy '%s' not found\n", s)
  }
}
</code></pre>
<p>Tenemos dos constantes, una de cada una de nuestras estrategias: <code>TEXT_STRATEGY</code>y <code>IMAGE_STRATEGY</code>.
 Esas son las constantes que se deben proporcionar a la fábrica para
recuperar cada estrategia de cajón cuadrado. Nuestro método de fábrica
recibe un argumento <code>s</code>, que es una cadena con una de las constantes previas.</p>
<p>Cada estrategia tiene un tipo <code>PrintOutput</code> incrustado con un registrador predeterminado, <code>stdout</code> pero puede anularlo más tarde utilizando los métodos <code>SetLog(io.Writer)</code>.
 Este enfoque podría considerarse una fábrica de prototipos. Si no es
una estrategia reconocida, se devolverá un mensaje de error apropiado.</p>
<p>Lo que tenemos ahora es una biblioteca. Tenemos toda la funcionalidad que necesitamos entre el <code>strategy</code>y los paquetes <code>shapes</code>. Ahora escribiremos el paquete principal y la función en una nueva carpeta llamada <code>cli</code>:</p>
<pre class="code"><code class="go">var output = flag.String("output", "text", "The output to use between "+
  "'console' and 'image' file")

func main() {
  flag.Parse()
</code></pre>
<p>De nuevo, al igual que antes, la función <code>main</code> comienza
por analizar los argumentos de entrada en la consola para recopilar la
estrategia elegida. Podemos usar la salida variable ahora para crear una
 estrategia sin Factory:</p>
<pre class="code"><code class="go">activeStrategy, err := shapes.NewPrinter(*output)
if err != nil {
  log.Fatal(err)
}
</code></pre>
<p>Con este fragmento, tenemos nuestra estrategia o detenemos la ejecución del programa en el método <code>log.Fatal</code> si se encuentra algún error (como una estrategia no reconocida).</p>
<p>Ahora implementaremos las necesidades comerciales al usar nuestra biblioteca. Para el propósito de <code>TextStrategy</code>, queremos escribir, por ejemplo, stdout. Para el propósito de la imagen, escribiremos en <span class="file">/tmp/image.jpg</span>. Justo como antes. Entonces, siguiendo las declaraciones anteriores, podemos escribir:</p>
<pre class="code"><code class="go">switch *output {
case shapes.TEXT_STRATEGY:
  activeStrategy.SetWriter(os.Stdout)
case shapes.IMAGE_STRATEGY:
  w, err := os.Create("/tmp/image.jpg")
  if err != nil {
    log.Fatal("Error opening image")
  }
  defer w.Close()

  activeStrategy.SetWriter(w)
}
</code></pre>
<p>En el caso de <code>TEXT_STRATEGY</code>, usamos <code>SetWriter</code> para configurar el <code>io.Writer</code>a <code>os.Stdout</code>. En el caso de <code>IMAGE_STRATEGY</code>, creamos una imagen en cualquiera de nuestras carpetas y pasamos la variable del archivo al método <code>SetWriter</code>. Recuerde que <code>os.File</code> implementa los <code>io.Reader</code>y <code>io.Writer</code> las interfaces, por lo que es perfectamente legal para pasarlo como <code>io.Writer</code> el método <code>SetWriter</code>:</p>
<pre class="code"><code class="go">err = activeStrategy.Print()
if err != nil {
  log.Fatal(err)
}
</code></pre>
<p>Finalmente, llamamos al método <code>Print</code> de cualquier estrategia elegida por el usuario y verificamos posibles errores. Probemos el programa ahora:</p>
<pre class="srci"><code class="sh"><span class="in"><span class="prompt">&gt; </span>go run main.go --output text
</span><span class="out">Circle
</span></code></pre>
<p>Ha funcionado como se esperaba. ¿Y la estrategia de imagen?</p>
<pre class="srci"><code class="sh"><span class="in"><span class="prompt">&gt; </span>go run main.go --output image
</span><span class="out">Image written in provided writer
</span></code></pre>
<p>Si registramos <span class="file">/tmp/image.jpg</span>, podemos encontrar nuestro cuadrado rojo en el fondo oscuro.</p>
</div>
<h4 id="final-words-on-the-strategy-pattern">Palabras finales en el patrón de Estrategia</h4>
<div class="hBody-4">
<p>Hemos aprendido una forma poderosa de encapsular algoritmos en
diferentes estructuras. También hemos utilizado la incrustación en lugar
 de la herencia para proporcionar funcionalidad cruzada entre los tipos,
 que será muy útil en nuestras aplicaciones. Te encontrarás combinando
estrategias aquí y allá como hemos visto en el segundo ejemplo, donde
tenemos estrategias para registrar y escribir usando la interfaz <code>io.Writer</code>, una estrategia para operaciones de byte-streaming.</p>
</div>
<h3 id="chain-of-responsibility-design-pattern">Patrón de diseño de cadena de responsabilidad</h3>
<div class="hBody-3">
<p>Nuestro próximo patrón se llama <b>cadena de responsabilidad</b>.
Como su nombre lo indica, consiste en una cadena y, en nuestro caso,
cada enlace de la cadena sigue el principio de responsabilidad única.</p>
</div>
<h4 id="description">Descripción</h4>
<div class="hBody-4">
<p>El principio de responsabilidad única implica que un tipo, función,
método o cualquier abstracción similar debe tener una sola
responsabilidad única y debe hacerlo bastante bien. De esta forma,
podemos aplicar muchas funciones que logran una cosa específica para
cada estructura, sector, mapa, etc.</p>
<p>Cuando aplicamos muchas de estas abstracciones de forma lógica muy a
menudo, podemos encadenarlas para que se ejecuten en orden tal como, por
 ejemplo, una cadena de registro.</p>
<p>Una cadena de registro es un conjunto de tipos que registra la salida de algún programa a más de una interfaz <code>io.Writer</code>.
 Podríamos tener un tipo que se conecta a la consola, un tipo que se
conecta a un archivo y un tipo que se conecta a un servidor remoto.
Puedes hacer tres llamadas cada vez que quieras hacer un registro, pero
es más elegante crear solo una y provocar una reacción en cadena.</p>
<p>Pero también, podríamos tener una cadena de cheques y, en caso de que
 uno de ellos falle, romper la cadena y devolver algo. Este es el
middleware de autenticación y autorización que funciona.</p>
</div>
<h4 id="objectives">Objetivos</h4>
<div class="hBody-4">
<p>El objetivo de la cadena de responsabilidad es proporcionar al
desarrollador una forma de encadenar acciones en tiempo de ejecución.
Las acciones están encadenadas entre sí y cada enlace ejecutará alguna
acción y pasará la solicitud al siguiente enlace (o no). Los siguientes
son los objetivos seguidos por este patrón:</p>
<ul>
<li>
<p>Encadenar dinámicamente las acciones en tiempo de ejecución en función de alguna entrada</p>
</li>
<li>
<p>Pase una solicitud a través de una cadena de procesadores hasta que
uno de ellos pueda procesarla, en cuyo caso la cadena podría detenerse</p>
</li>
</ul>
</div>
<h4 id="a-multi-logger-chain">Una cadena multi-logger</h4>
<div class="hBody-4">
<p>Vamos a desarrollar una solución de registro múltiple que podamos
encadenar de la manera que deseamos. Utilizaremos dos registradores de
consola diferentes y un registrador de propósito general:</p>
<ol class="num">
<li>
<p>Necesitamos un registrador simple que registra el texto de una solicitud con un prefijo <i>First Logger</i> y lo pasa al siguiente enlace de la cadena.</p>
</li>
<li>
<p>Un segundo registrador escribirá en la consola si el texto entrante tiene la palabra <code>hello</code>y pasará la solicitud a un tercer registrador. Pero, si no, la cadena se romperá y volverá de inmediato.</p>
</li>
<li>
<p>Un tercer tipo de registrador es un registrador de propósito general llamado <code>WriterLogger</code> que usa una interfaz <code>io.Writer</code> para iniciar sesión.</p>
</li>
<li>
<p>Una implementación concreta de las <code>WriterLogger</code> escrituras en un archivo y representa el tercer enlace de la cadena.</p>
</li>
</ol>
<p>La implementación de estos pasos se describe en la siguiente figura:</p>
<figure>
<img src="Ir%20a%20patrones%20de%20dise%C3%B1o_files/245_1.jpg">
</figure>
</div>
<h4 id="unit-test">Prueba de unidad</h4>
<div class="hBody-4">
<p>Lo primero que debe hacer para la cadena es, como siempre, definir la
 interfaz. Una cadena de interfaz de responsabilidad generalmente
tendrá, al menos, un método <code>Next()</code>. El método <code>Next()</code> es el que ejecuta el siguiente enlace de la cadena, por supuesto:</p>
<pre class="code"><code class="go">type ChainLogger interface {
  Next(string)
}
</code></pre>
<p>El método <code>Next</code> en la interfaz de nuestro ejemplo toma el
 mensaje que queremos registrar y lo pasa al siguiente enlace de la
cadena. Como está escrito en los criterios de aceptación, necesitamos
tres registradores:</p>
<pre class="code"><code class="go">type FirstLogger struct {
  NextChain ChainLogger
}

func (f *FirstLogger) Next(s string) {}

type SecondLogger struct {
  NextChain ChainLogger
}

func (f *SecondLogger) Next(s string) {}

type WriterLogger struct {
  NextChain ChainLogger
  Writer    io.Writer
}

func (w *WriterLogger) Next(s string) {}
</code></pre>
<p>Los <code>FirstLogger</code>y los tipos <code>SecondLogger</code> tienen exactamente la misma estructura: ambos implementan <code>ChainLogger</code>y tienen un campo <code>NextChain</code> que apunta al siguiente <code>ChainLogger</code>. El tipo <code>WriterLogger</code> es igual a <code>FirstLogger</code>y tipos <code>SecondLogger</code>, pero también tiene un campo para escribir sus datos, por lo que puede pasarle cualquier interfaz <code>io.Writer</code>.</p>
<p>Como lo hemos hecho antes, implementaremos una estructura <code>io.Writer</code> para usar en nuestras pruebas. En nuestro archivo de prueba, definimos la siguiente estructura:</p>
<pre class="code"><code class="go">type myTestWriter struct {
  receivedMessage string
}

func (m *myTestWriter) Write(p []byte) (int, error) {
  m.receivedMessage += string(p)
  return len(p), nil
}

func(m *myTestWriter) Next(s string){
  m.Write([]byte(s))
}
</code></pre>
<p>Pasaremos una instancia de la estructura <code>myTestWriter</code> para <code>WriterLogger</code> que podamos rastrear lo que se está registrando en las pruebas. La clase <code>myTestWriter</code> implementa el método <code>Write([]byte) (int, error)</code> común desde la interfaz <code>io.Writer</code>. Recuerde, si tiene el método <code>Write</code>, puede usarse como <code>io.Writer</code>. El método <code>Write</code> simplemente almacena el argumento de cadena en el campo <code>receivedMessage</code> para que podamos verificar más tarde su valor en las pruebas.</p>
<p>Este es el comienzo de la primera función de prueba:</p>
<pre class="code"><code class="go">func TestCreateDefaultChain(t *testing.T) {
  // Our test ChainLogger
  myWriter := myTestWriter{}

  writerLogger := WriterLogger{Writer: &amp;myWriter}
  second := SecondLogger{NextChain: &amp;writerLogger}
  chain := FirstLogger{NextChain: &amp;second}
</code></pre>
<p>Vamos a describir estas pocas líneas un poco, ya que son bastante importantes. Creamos una variable con un tipo <code>myTestWriter</code> predeterminado que usaremos como interfaz <code>io.Writer</code> en el último enlace de nuestra cadena. Luego creamos la última parte de la cadena de enlaces, la interfaz <code>writerLogger</code>. Al implementar la cadena, generalmente comienza con la última pieza del enlace y, en nuestro caso, es a <code>WriterLogger</code>. El <code>WriterLogger</code> escribe en un <code>io.Writer</code> modo que pasamos <code>myWriter</code> como interfaz <code>io.Writer</code>.</p>
<p>Entonces hemos creado un <code>SecondLogger</code>, el enlace del medio en nuestra cadena, con un puntero al <code>writerLogger</code>. Como mencionamos anteriormente, <code>SecondLogger</code> simplemente registra y pasa el mensaje en caso de que contenga la palabra <code>hello</code>. En una aplicación de producción, podría ser un registrador de solo error.</p>
<p>Finalmente, el primer enlace de la cadena tiene la cadena de nombre
de la variable. Apunta al segundo registrador. Por lo tanto, para
reanudar, nuestra cadena tiene el siguiente aspecto: <code>FirstLogger | SecondLogger | WriterLogger</code>.</p>
<p>Esta será nuestra configuración predeterminada para nuestras pruebas:</p>
<pre class="code"><code class="go">t.Run("3 loggers, 2 of them writes to console, second only if it founds " +
  "the word 'hello', third writes to some variable if second found 'hello'",
  func(t *testing.T){
    chain.Next("message that breaks the chain\n")

    if myWriter.receivedMessage != "" {
      t.Fatal("Last link should not receive any message")
    }

    chain.Next("Hello\n")

    if !strings.Contains(myWriter.receivedMessage, "Hello") {
      t.Fatal("Last link didn't received expected message")
    }
})
</code></pre>
<p>Continuando con las firmas de prueba Go 1.7 o posteriores, definimos una prueba interna con la siguiente descripción: <i>tres
 registradores, dos de ellos escriben en consola, el segundo solo si
encuentra la palabra 'hola', el tercero escribe en alguna variable si el
 segundo encontrado 'hola'</i>. Es bastante descriptivo y muy fácil de entender si alguien más tiene que mantener este código.</p>
<p>Primero, usamos un mensaje sobre el método <code>Next</code> que no llegará al tercer enlace de la cadena ya que no contiene la palabra <code>hello</code>. Verificamos el contenido de la variable <code>receivedMessage</code>, que por defecto está vacía, para ver si ha cambiado porque no debería.</p>
<p>A continuación, usamos nuevamente la variable de cadena, nuestro primer enlace en la cadena, y pasamos el mensaje <code>"Hello\n"</code>. De acuerdo con la descripción de la prueba, debe registrar usando <code>FirstLogger</code>, luego en <code>SecondLogger</code>y finalmente en WriterLogger porque contiene la palabra <code>hello</code>y la <code>SecondLogger</code> dejará pasar.</p>
<p>La prueba comprueba que <code>myWriter</code>, el último enlace de la cadena que almacenó el mensaje pasado en una variable llamada <code>receivedMessage</code>, tiene la palabra que pasamos primero en la cadena: hola. Vamos a ejecutarlo para que falle:</p>
<pre class="srci"><code class="sh"><span class="in"><span class="prompt">&gt; </span>go test -v .
</span><span class="out">=== RUN   TestCreateDefaultChain
=== RUN
TestCreateDefaultChain/3_loggers,_2_of_them_writes_to_console,_
second_only_if_it_founds_the_word_'hello',_third_writes_to_some
_variable_if_second_found_'hello'
--- FAIL: TestCreateDefaultChain (0.00s)
--- FAIL:
TestCreateDefaultChain/3_loggers,_2_of_them_writes_to_console,_
second_only_if_it_founds_the_word_'hello',_third_writes_to_some
_variable_if_second_found_'hello' (0.00s)
        chain_test.go:33: Last message didn't received expected
message
FAIL
exit status 1
FAIL
</span></code></pre>
<p>La prueba pasó para el primer control de la prueba y no para el
segundo control. Bueno ... idealmente no debería pasar ningún control
antes de que se realice cualquier implementación. Recuerde que en el
desarrollo basado en pruebas, las pruebas deben fallar en el primer
lanzamiento porque el código que están probando aún no está
implementado. Go zero-initialization nos lleva a error con esta
verificación aprobada en la prueba. Podemos resolver esto de dos
maneras:</p>
<ul>
<li>
<p>Hacer la firma del <code>ChainLogger</code> para devolver un error: <code>Next(string)</code>
 error. De esta forma, romperíamos la cadena devolviendo un error. Esta
es una forma mucho más conveniente en general, pero introducirá bastante
 repetición en este momento.</p>
</li>
<li>
<p>Cambiar el campo <code>receivedMessage</code> a un puntero. Un valor predeterminado de un puntero es nulo, en lugar de una cadena vacía.</p>
</li>
</ul>
<p>Utilizaremos la segunda opción ahora, ya que es mucho más simple y
bastante efectiva también. Así que cambiemos la firma de la estructura <code>myTestWriter</code> a lo siguiente:</p>
<pre class="code"><code class="go">type myTestWriter struct {
  receivedMessage *string
}

func (m *myTestWriter) Write(p []byte) (int, error) {
  if m.receivedMessage == nil {
         m.receivedMessage = new(string)
}
  tempMessage := fmt.Sprintf("%s%s", m.receivedMessage, p)
  m.receivedMessage = &amp;tempMessage
  return len(p), nil
}

func (m *myTestWriter) Next(s string) {
  m.Write([]byte(s))
}
</code></pre>
<p>Compruebe que el tipo de <code>receivedMessage</code> tiene el asterisco ( <code>*</code>) ahora para indicar que es un puntero a una cadena. La función <code>Write</code> necesitaba cambiar también. Ahora tenemos que verificar el contenido del campo <code>receivedMessage</code>
 porque, como cada puntero, se inicializa a cero. Luego, primero tenemos
 que almacenar el mensaje en una variable, de modo que podamos tomar la
dirección en la siguiente línea de la asignación ( <code>m.receivedMessage = &amp;tempMessage</code>).</p>
<p>Entonces, nuestro código de prueba también debería cambiar un poco:</p>
<pre class="code"><code class="go">t.Run("3 loggers, 2 of them writes to console, second only if it founds "+
  "the word 'hello', third writes to some variable if second found 'hello'",
  func(t *testing.T) {
    chain.Next("message that breaks the chain\n")

    if myWriter.receivedMessage != nil {
      t.Error("Last link should not receive any message")
    }

    chain.Next("Hello\n")

    if myWriter.receivedMessage == "" ||
      !strings.Contains(*myWriter.receivedMessage, "Hello") {
      t.Fatal("Last link didn't received expected message")
    }
  })
</code></pre>
<p>Ahora estamos comprobando que <code>myWriter.receivedMessage</code> es en realidad <code>nil</code>,
 por lo que no se ha escrito contenido seguro sobre la variable. Además,
 tenemos que cambiar el segundo si primero verificamos que el miembro no
 es nulo antes de verificar su contenido o puede generar un pánico en la
 prueba. Vamos a probarlo de nuevo:</p>
<pre class="srci"><code class="sh"><span class="in"><span class="prompt">&gt; </span>go test -v .
</span><span class="out">=== RUN   TestCreateDefaultChain
=== RUN
TestCreateDefaultChain/3_loggers,_2_of_them_writes_to_console,_
second_only_if_it_founds_the_word_'hello',_third_writes_to_some
_variable_if_second_found_'hello'
--- FAIL: TestCreateDefaultChain (0.00s)
--- FAIL:
TestCreateDefaultChain/3_loggers,_2_of_them_writes_to_console,_
second_only_if_it_founds_the_word_'hello',_third_writes_to_some
_variable_if_second_found_'hello' (0.00s)
        chain_test.go:40: Last link didn't received expected
message
FAIL
exit status 1
FAIL
</span></code></pre>
<p>Falla de nuevo y, de nuevo, la primera mitad de la prueba pasa
correctamente sin código implementado. ¿Entonces que debemos hacer
ahora? Hemos cambiado la firma del tipo <code>myWriter</code> para hacer
 que la prueba falle en ambos controles y, nuevamente, simplemente
fallamos en el segundo. Bueno, en este caso podemos pasar este pequeño
problema. Al escribir pruebas, debemos ser muy cuidadosos para no
enloquecer con ellas; las pruebas unitarias son herramientas que nos
ayudan a escribir y mantener el código, pero nuestro objetivo es
escribir funcionalidad, no pruebas. Es importante tener esto en cuenta
ya que puede obtener pruebas realmente locas de la unidad de ingeniería.</p>
</div>
<h4 id="implementation">Implementación</h4>
<div class="hBody-4">
<p>Ahora tenemos que aplicar el primer, segundo y tercer registradores llamados <code>FirstLogger</code>, <code>SecondLogger</code>y <code>WriterLogger</code> respectivamente. El <code>FirstLogger</code> registrador es el más fácil como se describe en el primer criterio de aceptación: <i>necesitamos
 un registrador simple que registra el texto de una solicitud con un
prefijo Primer registrador: y lo pasa al siguiente enlace de la cadena</i>. Hagamoslo:</p>
<pre class="code"><code class="go">type FirstLogger struct {
  NextChain ChainLogger
}

func (f *FirstLogger) Next(s string) {
  fmt.Printf("First logger: %s\n", s)

  if f.NextChain != nil {
    f.NextChain.Next(s)
  }
}
</code></pre>
<p>La implementación es bastante fácil. Usando el método <code>fmt.Printf</code> para formatear e imprimir la cadena entrante, agregamos el texto <code>FirstLogger</code>: texto. Luego, comprobamos que el tipo <code>NextChain</code> tiene realmente algún contenido y le pasamos el control llamando a su método <code>Next(string)</code>. La prueba no debería pasar todavía, así que continuaremos con el <code>SecondLogger</code> registrador:</p>
<pre class="code"><code class="go">type SecondLogger struct {
  NextChain ChainLogger
}

func (se *SecondLogger) Next(s string) {
  if strings.Contains(strings.ToLower(s), "hello") {
    fmt.Printf("Second logger: %s\n", s)

    if se.NextChain != nil {
      se.NextChain.Next(s)
    }

    return
  }

  fmt.Printf("Finishing in second logging\n\n")
}
</code></pre>
<p>Como se menciona en el segundo criterio de aceptación, la <code>SecondLogger</code> descripción es: <i>Un
 segundo registrador escribirá en la consola si el texto entrante tiene
la palabra "hola" y pasará la solicitud a un tercer registrador</i>. En primer lugar, verifica si el texto entrante contiene el texto <code>hello</code>. Si es verdadero, imprime el mensaje en la consola, agregando el texto <code>SecondLogger</code>: y pasa el mensaje al siguiente enlace de la cadena (verifique la instancia anterior de que existe un tercer enlace).</p>
<p>Pero si no contiene el texto <code>hello</code>, la cadena se rompe e imprime el mensaje <code>Finishing in second logging</code>.</p>
<p>Terminaremos con el tipo <code>WriterLogger</code>:</p>
<pre class="code"><code class="go">type WriterLogger struct {
  NextChain ChainLogger
  Writer    io.Writer
}

func (w *WriterLogger) Next(s string) {
  if w.Writer != nil {
    w.Writer.Write([]byte("WriterLogger: " + s))
  }

  if w.NextChain != nil {
    w.NextChain.Next(s)
  }
}
</code></pre>
<p>El método de <code>WriterLogger</code> la estructura <code>Next</code> comprueba que haya una interfaz <code>io.Writer</code> existente almacenada en el <code>Writer</code> miembro y escribe allí el mensaje entrante que agrega el texto <code>WriterLogger</code>: a ella. Luego, al igual que los enlaces anteriores, verifique que haya más enlaces para pasar el mensaje.</p>
<p>Ahora las pruebas pasarán con éxito:</p>
<pre class="srci"><code class="sh"><span class="in"><span class="prompt">&gt; </span>go test -v .
</span><span class="out">=== RUN   TestCreateDefaultChain
=== RUN
TestCreateDefaultChain/3_loggers,_2_of_them_writes_to_console,_
second_only_if_it_founds_the_word_'hello',_third_writes_to_some
_variable_if_second_found_'hello'
First logger: message that breaks the chain
Finishing in second logging
First logger: Hello
Second logger: Hello
--- PASS: TestCreateDefaultChain (0.00s)
    --- PASS:
TestCreateDefaultChain/3_loggers,_2_of_them_writes_to_console,_
second_only_if_it_founds_the_word_'hello',_third_writes_to_some
_variable_if_second_found_'hello' (0.00s)
PASS
ok
</span></code></pre>
<p>La primera mitad de la prueba imprime dos mensajes: el <code>First logger</code> mensaje que rompe la cadena, que es el mensaje esperado para el <code>FirstLogger</code>. Pero se detiene en el <code>SecondLogger</code> porque no se ha encontrado una palabra hello en el mensaje entrante; es por eso que imprime la <code>Finishing in second logging</code> cuerda.</p>
<p>La segunda mitad de la prueba recibe el mensaje <code>Hello</code>. Entonces las <code>FirstLogger</code> impresiones y las <code>SecondLogger</code> impresiones también. El tercer registrador no se imprime en la consola en absoluto, sino en nuestra línea <code>myWriter.receivedMessage</code> definida en la prueba.</p>
</div>
<h4 id="what-about-a-closure?">¿Qué tal un cierre?</h4>
<div class="hBody-4">
<p>A veces puede ser útil definir un enlace aún más flexible en la
cadena para la depuración rápida. Podemos usar cierres para esto, de
modo que la función de enlace esté definida por la persona que llama.
¿Cómo se ve un enlace de cierre? Similar al <code>WriterLogger</code> registrador:</p>
<pre class="code"><code class="go">type ClosureChain struct {
  NextChain ChainLogger
  Closure   func(string)
}

func (c *ClosureChain) Next(s string) {
  if c.Closure != nil {
    c.Closure(s)
  }

  if c.NextChain != nil {
    c.Next(s)
  }
}
</code></pre>
<p>El tipo <code>ClosureChain</code> tiene <code>NextChain</code>, como es habitual, y un miembro de cierre. Mira la firma del <code>Closure</code>: <code>func(string)</code>. Esto significa que es una función que toma a <code>string</code>y no devuelve nada.</p>
<p>El método <code>Next(string)</code> para <code>ClosureChain</code> comprobar que el <code>Closure</code>
 miembro está almacenado y lo ejecuta con la cadena entrante. Como de
costumbre, el enlace busca más enlaces para pasar el mensaje como todos
los enlaces de la cadena.</p>
<p>Entonces, ¿cómo lo usamos ahora? Definiremos una nueva prueba para mostrar su funcionalidad:</p>
<pre class="code"><code class="go">t.Run("2 loggers, second uses the closure implementation",
  func(t *testing.T) {
    myWriter = myTestWriter{}
    closureLogger := ClosureChain{
      Closure: func(s string) {
        fmt.Printf("My closure logger! Message: %s\n", s)
        myWriter.receivedMessage = &amp;s
      },
    }

    writerLogger.NextChain = &amp;closureLogger

    chain.Next("Hello closure logger")

    if *myWriter.receivedMessage != "Hello closure logger" {
      t.Fatal("Expected message wasn't received in myWriter")
    }
  })
</code></pre>
<p>La descripción de esta prueba deja claro: <code>"2 loggers, second uses the closure implementation"</code>. Simplemente utilizamos dos implementaciones <code>ChainLogger</code> y usamos el <code>closureLogger</code> en el segundo enlace. Hemos creado una nueva <code>myTestWriter</code> para almacenar el contenido del mensaje. Al definir el <code>ClosureChain</code>, definimos una función anónima directamente en el <code>Closure</code> miembro al crear <code>closureLogger</code>. Se imprime <code>"My closure logger! Message: %s\n"</code> con el reemplazo del mensaje entrante <code>"%s"</code>. Luego, almacenamos el mensaje entrante <code>myWriter</code>, para verificar más tarde.</p>
<p>Después de definir este nuevo enlace, utilizamos el tercer enlace de
la prueba anterior, agregamos el cierre como el cuarto enlace y pasamos
el mensaje <code>Hello closure logger</code>. Usamos la palabra <code>Hello</code> al principio para asegurarnos de que el mensaje pase el <code>SecondLogger</code>.</p>
<p>Por último, el contenido de <code>myWriter.receivedMessage</code> deben contener el texto pased: <code>Hello closure logger</code>.
 Este es un enfoque bastante flexible con un inconveniente: al definir
un cierre como este, no podemos probar sus contenidos de una manera muy
elegante. Vamos a ejecutar las pruebas de nuevo:</p>
<pre class="srci"><code class="sh"><span class="in"><span class="prompt">&gt; </span>go test -v .
</span><span class="out">=== RUN   TestCreateDefaultChain
=== RUN
TestCreateDefaultChain/3_loggers,_2_of_them_writes_to_console,_
second_only_if_it_founds_the_word_'hello',_third_writes_to_some
_variable_if_second_found_'hello'
First logger: message that breaks the chain
Finishing in second logging

First logger: Hello
Second logger: Hello
=== RUN
TestCreateDefaultChain/2_loggers,_second_uses_the_closure_imple
mentation
First logger: Hello closure logger
Second logger: Hello closure logger
My closure logger! Message: Hello closure logger
--- PASS: TestCreateDefaultChain (0.00s)
    --- PASS:
TestCreateDefaultChain/3_loggers,_2_of_them_writes_to_console,_
second_only_if_it_founds_the_word_'hello',_third_writes_to_some
_variable_if_second_found_'hello' (0.00s)
    --- PASS:
TestCreateDefaultChain/2_loggers,_second_uses_the_closure_imple
mentation (0.00s)
PASS
ok
</span></code></pre>
<p>Mire la tercera RUN: el mensaje pasa correctamente a través del
primero, segundo y tercer enlaces para llegar al cierre que imprime el <code>My closure logger! Message: Hello closure logger</code> mensaje esperado .</p>
<p>Es muy útil agregar una implementación de método de cierre a algunas
interfaces, ya que proporciona bastante flexibilidad al usar la
biblioteca. Puede encontrar este enfoque muy a menudo en el código Go,
siendo el más conocido el del paquete <code>net/http</code>. La función <code>HandleFunc</code> que utilizamos anteriormente en los patrones estructurales para definir un controlador para una solicitud HTTP.</p>
</div>
<h4 id="putting-it-together">Poniendo todo junto</h4>
<div class="hBody-4">
<p>Aprendimos una poderosa herramienta para lograr el procesamiento
dinámico de acciones y el manejo del estado. El patrón de cadena de
responsabilidad es ampliamente utilizado, también para crear <b>máquinas de estados finitos</b> ( <span class="acronym">FSM</span>
 ). También se usa indistintamente con el patrón Decorator con la
diferencia de que cuando decora, cambia la estructura de un objeto,
mientras que con la cadena define un comportamiento para cada enlace en
la cadena que también puede romperlo.</p>
</div>
<h3 id="command-design-pattern">Patrón de diseño de comando</h3>
<div class="hBody-3">
<p>Para finalizar con este capítulo, veremos también el patrón de <b>Comando</b>:
 un patrón de diseño pequeño pero que todavía se usa con frecuencia.
¿Necesita una forma de conectar tipos que realmente no están
relacionados? Así que diseña un comando para ellos.</p>
</div>
<h4 id="description">Descripción</h4>
<div class="hBody-4">
<p>El patrón de diseño del comando es bastante similar al patrón de
diseño de estrategia, pero con diferencias clave. Mientras que en el
patrón de estrategia nos enfocamos en cambiar los algoritmos, en el
patrón Comando, nos enfocamos en la invocación de algo o en la
abstracción de algún tipo.</p>
<p>Un patrón de comando se ve comúnmente como un contenedor. Pones algo
así como la información para la interacción del usuario en una interfaz
de usuario que podría ser <code>click on login</code>y lo pasas como un comando. No necesita tener la complejidad relacionada con la <code>click on login</code> acción en el comando, sino simplemente la acción en sí misma.</p>
<p>Un ejemplo para el mundo orgánico sería una caja para una empresa de
entregas. Podemos ponerle cualquier cosa pero, como empresa de entregas,
 estamos interesados ​​en administrar la caja en lugar de sus contenidos
 directamente.</p>
<p>El patrón de comando se usará en gran medida cuando se trate de
canales. Con los canales puede enviar cualquier mensaje a través de él,
pero, si necesitamos una respuesta del lado receptor del canal, un
enfoque común es crear un comando que tenga un segundo canal de
respuesta adjunto en el que estamos escuchando.</p>
<p>Del mismo modo, un buen ejemplo sería un videojuego multijugador,
donde cada golpe de cada usuario puede enviarse como comandos al resto
de los usuarios a través de la red.</p>
</div>
<h4 id="objectives">Objetivos</h4>
<div class="hBody-4">
<p>Al usar el patrón de diseño de comando, estamos tratando de encapsular</p>
<p>algún tipo de acción o información en un paquete ligero que debe
procesarse en otro lugar. Es similar al patrón de Estrategia pero, de
hecho, un Comando podría desencadenar una Estrategia preconfigurada en
otro lugar, por lo que no son lo mismo. Los siguientes son los objetivos
 para este patrón de diseño:</p>
<ul>
<li>
<p>Pon algo de información en una caja. Solo el receptor abrirá la caja y conocerá su contenido.</p>
</li>
<li>
<p>Delegue alguna acción en otro lugar.</p>
</li>
</ul>
<p>El comportamiento también se explica en el siguiente diagrama:</p>
<figure>
<img src="Ir%20a%20patrones%20de%20dise%C3%B1o_files/259_1.jpg">
</figure>
<p>Allí tenemos una interfaz de <b>comando</b> con un método <b>Get () interface {}</b>. Tenemos un tipo <b>A</b> y un tipo <b>B</b>. La idea es que <b>A</b> y <b>B</b> implementen la interfaz de <b>comando</b> para regresar a sí mismos como un <code>interface{}</code>. Como ahora implementan <b>Command</b>, se pueden usar en un <b>controlador de comandos</b> que no se preocupa demasiado por el tipo subyacente. Ahora <b>A</b> y <b>B</b> pueden viajar a través de funciones que manejan comandos o almacenan Comandos libremente. Pero <b>B</b> handler puede tomar un objeto de cualquier contenido <b>Command </b> manejador de para "desenvolverlo" y tomar su<b>B</b>, así como <b>A</b> controlador de comandos con su contenido A.</p>
<p>Ponemos la información en un recuadro (el <b>Comando</b> ) y delegamos qué hacer con los manejadores de los Comandos.</p>
</div>
<h4 id="a-simple-queue">Una cola simple</h4>
<div class="hBody-4">
<p>Nuestro primer ejemplo va a ser bastante pequeño. Pondremos algo de
información en un implementador de Comandos y tendremos una cola.
Crearemos muchas instancias de un tipo que implemente un patrón de
comando y las pasaremos a una cola que almacenará los comandos hasta que
 tres de ellos estén en la cola, y en ese momento los procesará.</p>
</div>
<h4 id="acceptance-criteria">Criterios de aceptación</h4>
<div class="hBody-4">
<p>Entonces, el criterio de aceptación ideal para comprender bien las
implicaciones del Comando debería reflejar de algún modo la creación de
un recuadro que pueda aceptar tipos no relacionados y la ejecución del
Comando mismo:</p>
<ul>
<li>
<p>Necesitamos un constructor de comandos de impresión de consola. Al usar este constructor con a <code>string</code>,
 devolverá un comando que lo imprimirá. En este caso, el controlador
está dentro del comando que actúa como un cuadro y como un controlador.</p>
</li>
<li>
<p>Necesitamos una estructura de datos que almacene los comandos
entrantes en una cola y los imprima una vez que la cola alcance la
longitud de tres.</p>
</li>
</ul>
</div>
<h4 id="implementation">Implementación</h4>
<div class="hBody-4">
<p>Este patrón es bastante simple y vamos a escribir algunos ejemplos
diferentes, por lo que implementaremos la biblioteca directamente para
mantener las cosas cortas y livianas. El patrón de diseño de comando
clásico generalmente tiene una estructura de tipo común con un método <code>Execute</code>. También vamos a utilizar esta estructura, ya que es bastante flexible y simple:</p>
<pre class="code"><code class="go">type Command interface {
  Execute()
}
</code></pre>
<p>¡Esto es lo suficientemente genérico como para llenar una gran
cantidad de tipos no relacionados! Piénselo: vamos a crear un tipo que
se imprima en la consola cuando se usa el método <code>Execute()</code>,
 pero podría imprimir un número o ¡lanzar un cohete también! La clave
aquí es centrarse en las invocaciones porque los controladores también
están en Comando. Necesitamos algún tipo que implemente esta interfaz e
imprima en la consola algún tipo de mensaje:</p>
<pre class="code"><code class="go">type ConsoleOutput struct {
  message string
}

func (c *ConsoleOutput) Execute() {
  fmt.Println(c.message)
}
</code></pre>
<p>El tipo <code>ConsoleOutput</code> implementa la interfaz <code>Command</code> e imprime en la consola a la que llamó el miembro <code>message</code>.</p>
<p>Tal como se define en el primer criterio de aceptación, necesitamos un constructor <code>Command</code> que acepte una cadena de mensaje y devuelva la interfaz <code>Command</code>. Tendrá la firma <code>func CreateCommand(s string) Command</code>:</p>
<pre class="code"><code class="go">func CreateCommand(s string) Command {
  fmt.Println("Creating command")

  return &amp;ConsoleOutput{
    message: s,
  }
}
</code></pre>
<p>Para el comando <code>queue</code>, definiremos un tipo muy simple llamado <code>CommandQueue</code>a almacenar en una cola de cualquier tipo que implemente la interfaz <code>Command</code>:</p>
<pre class="code"><code class="go">type CommandQueue struct {
  queue []Command
}

func (p *CommandQueue) AddCommand(c Command) {
  p.queue = append(p.queue, c)

  if len(p.queue) == 3 {
    for _, command := range p.queue {
      command.Execute()
    }

    p.queue = make([]Command, 3)
  }
}
</code></pre>
<p>El tipo <code>CommandQueue</code> almacena una matriz de la interfaz <code>Commands</code>.
 Cuando la matriz de cola alcanza tres elementos, ejecuta todos los
comandos almacenados en el campo de la cola. Si aún no ha alcanzado la
longitud requerida, simplemente almacena el comando.</p>
<p>Creamos cinco comandos, suficientes para activar el mecanismo de cola
 de comandos y agregarlos a la cola. Cada vez que se crea un comando, el
 mensaje <code>Creating command</code> se imprimirá en la consola.
Cuando creamos el tercer comando, se iniciará el ejecutor automático de
comandos e imprimirá los tres primeros mensajes. Creamos y agregamos dos
 comandos más, pero como no hemos llegado al tercer comando nuevamente,
no se imprimirán y solo se imprimirán los <code>Creating command</code> mensajes:</p>
<pre class="code"><code class="go">func main() {
  queue := CommandQueue{}

  queue.AddCommand(CreateCommand("First message"))
  queue.AddCommand(CreateCommand("Second message"))
  queue.AddCommand(CreateCommand("Third message"))

  queue.AddCommand(CreateCommand("Fourth message"))
  queue.AddCommand(CreateCommand("Fifth message"))
}
</code></pre>
<p>Vamos a ejecutar el <code>main</code> programa. Nuestra definición
dice que los comandos se procesan una vez cada tres mensajes y crearemos
 un total de cinco mensajes. Los primeros tres mensajes deben estar
impresos pero no el cuarto y el quinto porque no alcanzamos un sexto
mensaje para activar el procesamiento del comando:</p>
<pre class="srci"><code class="sh"><span class="in"><span class="prompt">&gt; </span>go run command.go
</span><span class="out">Creating command
Creating command
Creating command
First message
Second message
Third message
Creating command
Creating command
</span></code></pre>
<p>Como puede ver, los mensajes cuarto y quinto no se imprimen, como se
esperaba, pero sabemos que los comandos se crearon y almacenaron en la
matriz. Simplemente no se procesaron porque la cola estaba esperando un
comando más para activar el procesador.</p>
</div>
<h4 id="more-examples">Más ejemplos</h4>
<div class="hBody-4">
<p>El ejemplo anterior muestra cómo usar un controlador de comandos que
ejecuta el contenido del comando. Pero una forma común de usar un patrón
 de comando es delegar la información, en lugar de la ejecución, en un
objeto diferente.</p>
<p>Por ejemplo, en lugar de imprimir en la consola, crearemos un comando que extrae información:</p>
<pre class="code"><code class="go">type Command interface {
  Info() string
}
</code></pre>
<p>En este caso, nuestra interfaz <code>Command</code> tendrá un método llamado <code>Info</code>
 que recuperará cierta información de su implementador. Crearemos dos
implementaciones; uno devolverá el tiempo transcurrido desde la creación
 del comando a su ejecución:</p>
<pre class="code"><code class="go">type TimePassed struct {
  start time.Time
}

func (t *TimePassed) Info() string {
  return time.Since(t.start).String()
}
</code></pre>
<p>La función <code>time.Since</code> devuelve el tiempo transcurrido
desde el tiempo almacenado en el parámetro proporcionado. Devolvimos la
representación de cadena del tiempo transcurrido llamando al método <code>String()</code> en el tipo <code>time.Time</code>. La segunda implementación de nuestro nuevo <code>Command</code> devolverá el mensaje <code>Hello World!</code>:</p>
<pre class="code"><code class="go">type HelloMessage struct{}

func (h HelloMessage) Info() string {
  return "Hello world!"
}
</code></pre>
<p>Y nuestra función <code>main</code> simplemente creará una instancia de cada tipo, luego esperará un segundo e imprimirá la información devuelta por cada uno <code>Command</code>:</p>
<pre class="code"><code class="go">func main() {
  var timeCommand Command
  timeCommand = &amp;TimePassed{time.Now()}

  var helloCommand Command
  helloCommand = &amp;HelloMessage{}

  time.Sleep(time.Second)

  fmt.Println(timeCommand.Info())
  fmt.Println(helloCommand.Info())
}
</code></pre>
<p>La función <code>time.Sleep</code> detiene la ejecución de la rutina actual para el período especificado (un segundo). Por lo tanto, para recordar, la variable <code>timeCommand</code> almacena el momento en que se inició el programa y su método <code>Info()</code>
 devuelve una representación de cadena del tiempo transcurrido, ya que
le damos un valor al tipo al momento en que llamamos al método <code>Info()</code>. La variable <code>helloCommand</code> devuelve el mensaje <code>Hello World!</code> cuando llamamos a su método <code>Info()</code>. Aquí no hemos implementado un <code>Command</code>
 controlador de nuevo para mantener las cosas simples, pero podemos
considerar la consola como el controlador porque solo podemos imprimir
caracteres ASCII en él como los recuperados por el<code>Info()</code> método.</p>
<p>Vamos a ejecutar la función <code>main</code>:</p>
<pre class="srci"><code class="sh"><span class="in"><span class="prompt">&gt; </span>go run command.go
</span><span class="out">1.000216755s
Hello world!
</span></code></pre>
<p>Aquí estamos. En este caso, recuperamos cierta información usando el
patrón Command. Un tipo almacena información de tiempo mientras que el
otro no almacena nada y simplemente devuelve la misma cadena simple.
Cada vez que ejecutamos la función <code>main</code> le devolveremos un tiempo transcurrido diferente, así que no se preocupe si la hora no coincide con la del ejemplo.</p>
</div>
<h4 id="chain-of-responsibility-of-commands">Cadena de responsabilidad de los comandos</h4>
<div class="hBody-4">
<p>¿Recuerdas el patrón de diseño de la cadena de responsabilidad? Estábamos pasando un<code>string</code>
 mensaje entre los enlaces para imprimir sus contenidos. Pero podríamos
estar usando el comando anterior para recuperar información para iniciar
 sesión en la consola. Reutilizaremos principalmente el código que ya
hemos escrito.</p>
<p>La interfaz <code>Command</code> será desde la interfaz de tipo que devuelve a <code>string</code> desde el ejemplo anterior:</p>
<pre class="code"><code class="go">type Command interface {
  Info() string
}
</code></pre>
<p>Utilizaremos la implementación <code>Command</code> del tipo <code>TimePassed</code> también:</p>
<pre class="code"><code class="go">type TimePassed struct {
  start time.Time
}

func (t *TimePassed) Info() string {
  return time.Since(t.start).String()
}
</code></pre>
<p>Recuerde que este tipo devuelve el tiempo transcurrido desde la creación del objeto en su método <code>Info() string</code>. También necesitamos la interfaz <code>ChainLogger</code> de la sección del <i>patrón de diseño de Cadena de responsabilidad</i> de este capítulo, pero esta vez, aprobará Comandos en su método <code>Next</code> en lugar de <code>string</code>:</p>
<pre class="code"><code class="go">type ChainLogger interface {
  Next(Command)
}
</code></pre>
<p>Utilizaremos el mismo tipo para dos enlaces en la cadena por simplicidad. Este enlace es muy similar al tipo <code>FirstLogger</code> del ejemplo de cadena de responsabilidad, pero esta vez adjuntará el mensaje <code>Elapsed time from creation</code>: y esperará 1 segundo antes de imprimir. Lo llamaremos en <code>Logger</code> lugar de <code>FirstLogger</code>:</p>
<pre class="code"><code class="go">type Logger struct {
  NextChain ChainLogger
}

func (f *Logger) Next(c Command) {
  time.Sleep(time.Second)

  fmt.Printf("Elapsed time from creation: %s\n", c.Info())

  if f.NextChain != nil {
    f.NextChain.Next(c)
  }
}
</code></pre>
<p>Finalmente, necesitamos una función <code>main</code> para ejecutar la cadena que toma <code>Command</code> punteros:</p>
<pre class="code"><code class="go">func main() {
  second := new(Logger)
  first := Logger{NextChain: second}

  command := &amp;TimePassed{start: time.Now()}

  first.Next(command)
}
</code></pre>
<p>Línea por línea, creamos una variable llamada <code>second</code> con un puntero a a <code>Logger</code>; este va a ser el segundo eslabón de nuestra cadena. Luego creamos una variable llamada <code>first</code>, que será el primer enlace de la cadena. El primer enlace apunta a la variable <code>second</code>, el segundo enlace de la cadena.</p>
<p>Luego, creamos una instancia de <code>TimePassed</code> para usarla como el tipo <code>Command</code>. La hora de inicio de este comando es el tiempo de ejecución (el método <code>time.Now()</code> devuelve la hora en el momento de la ejecución).</p>
<p>Finalmente, pasamos la interfaz <code>Command</code> a la cadena en la declaración <code>first.Next(command)</code>. El resultado de este programa es el siguiente:</p>
<pre class="srci"><code class="sh"><span class="in"><span class="prompt">&gt; </span>go run chain_command.go
</span><span class="out">Elapsed time from creation: 1.0003419s
Elapsed time from creation: 2.000682s
</span></code></pre>
<p>El resultado resultante se refleja en el siguiente diagrama: El
comando con el campo de tiempo se envía al primer enlace que sabe cómo
ejecutar Comandos de cualquier tipo. Luego pasa el comando al segundo
enlace que también sabe cómo ejecutar comandos:</p>
<p>Este enfoque oculta la complejidad detrás de cada <code>Command</code>
 ejecución de los controladores de comandos en cada enlace. La
funcionalidad oculta detrás de un comando puede ser simple o
increíblemente compleja, pero la idea aquí es reutilizar el controlador
para administrar muchos tipos de implementaciones no relacionadas.</p>
</div>
<h4 id="rounding-up-the-command-pattern-up">Redondeando el patrón Command up</h4>
<div class="hBody-4">
<p>El comando es un patrón de diseño muy pequeño; su funcionalidad es
bastante fácil de entender pero es ampliamente utilizada por su
simplicidad. Se ve muy similar al patrón de Estrategia, pero recuerde
que la Estrategia se trata de tener muchos algoritmos para lograr una
tarea específica, pero todos logran la misma tarea. En el patrón
Comando, tiene muchas tareas para ejecutar, y no todas necesitan ser
iguales.</p>
<p>Entonces, en resumen, el patrón de Comando se trata de encapsulación y
 delegación de ejecución para que solo el receptor o los receptores
activen esa ejecución.</p>
</div>
<h3 id="summary">Resumen</h3>
<div class="hBody-3">
<p>Hemos dado nuestros primeros pasos en los patrones de comportamiento.
 El objetivo de este capítulo fue presentar al lector el concepto de
algoritmo y encapsulación de ejecución utilizando interfaces y
estructuras adecuadas. Con la estrategia, hemos encapsulado algoritmos,
con la cadena de controladores de responsabilidad y con las ejecuciones
del patrón de diseño del comando.</p>
<p>Ahora, con el conocimiento que hemos adquirido sobre el patrón de
estrategia, podemos desacoplar en gran medida nuestras aplicaciones de
sus algoritmos, solo para probar, esta es una característica muy útil
para inyectar mocks en diferentes tipos que serían casi imposibles de
probar. Pero también para cualquier cosa que pueda necesitar diferentes
enfoques basados ​​en algún contexto (como el cortocircuito en una
lista, algunos algoritmos funcionan mejor dependiendo de la distribución
 de la lista).</p>
<p>El patrón de Cadena de responsabilidad abre la puerta del middleware
de cualquier tipo y las bibliotecas tipo plugin para mejorar la
funcionalidad de alguna parte. Muchos proyectos de código abierto
utilizan una Cadena de responsabilidad para gestionar las solicitudes
HTTP y las respuestas para extraer información al usuario final (como la
 información de cookies) o verificar los detalles de autenticación (le
dejaré pasar al siguiente enlace solo si lo tengo en mi base de datos).</p>
<p>Finalmente, el patrón Command es el patrón más común para el manejo
de UI, pero también es muy útil en muchos otros escenarios donde
necesitamos algún tipo de manejo entre muchos tipos no relacionados que
viajan a través del código (como un mensaje pasado por un canal).</p>
</div>
<h3 id="chapter-6.-behavioral-patterns---template,-memento,-and-interpreter-design-patterns">Capítulo 6. Patrones de comportamiento: patrones de diseño de plantilla, recuerdo e intérprete</h3>
<div class="hBody-3">
<p>En este capítulo, veremos los siguientes tres patrones de diseño de
comportamiento. La dificultad se está planteando ya que ahora
utilizaremos combinaciones de patrones estructurales y de creación para
resolver mejor el objetivo de algunos de los patrones de comportamiento.</p>
<p>Comenzaremos con el patrón de diseño de Plantilla, un patrón que se
ve muy similar al patrón de Estrategia pero que proporciona una mayor
flexibilidad. El patrón de diseño de Memento se usa en el 99% de las
aplicaciones que utilizamos todos los días para lograr funciones de
deshacer y operaciones transaccionales. Finalmente, escribiremos un
intérprete de notación polaca inversa para realizar operaciones
matemáticas simples.</p>
<p>Comencemos con el patrón de diseño de la plantilla.</p>
</div>
<h4 id="template-design-pattern">Patrón de diseño de plantilla</h4>
<div class="hBody-4">
<p>El patrón de <b>Plantilla</b> es uno de esos patrones ampliamente
utilizados que son increíblemente útiles, especialmente al escribir
bibliotecas y marcos. La idea es proporcionar a un usuario una forma de
ejecutar código dentro de un algoritmo. En esta sección, veremos cómo
escribir patrones idiomáticos de Go Template y ver algún código fuente
de Go donde se use sabiamente. Escribiremos un algoritmo de tres pasos
donde el segundo paso se delega al usuario, mientras que el primero y el
 tercero no. El primer y el tercer paso en el algoritmo representan la
plantilla.</p>
</div>
<h4 id="description">Descripción</h4>
<div class="hBody-4">
<p>Mientras que con el patrón de Estrategia encapsulamos la
implementación de algoritmos en diferentes estrategias, con el patrón de
 Plantilla trataremos de lograr algo similar pero con solo una parte del
 algoritmo.</p>
<p>El patrón de diseño de plantilla permite al usuario escribir una
parte de un algoritmo mientras que el resto se ejecuta mediante la
abstracción. Esto es común cuando se crean bibliotecas para facilitar en
 algunas tareas complejas o cuando la reutilización de algún algoritmo
se ve comprometida solo por una parte.</p>
<p>Imagine, por ejemplo, que tenemos una transacción larga de solicitudes HTTP. Tenemos que realizar los siguientes pasos:</p>
<ol class="num">
<li>
<p>Autentica usuario</p>
</li>
<li>
<p>Autorízalo.</p>
</li>
<li>
<p>Recupere algunos detalles de una base de datos.</p>
</li>
<li>
<p>Haz alguna modificación.</p>
</li>
<li>
<p>Envíe los detalles en una nueva solicitud.</p>
</li>
</ol>
<p>No tendría sentido repetir los pasos 1 a 5 en el código del usuario
cada vez que necesite modificar algo en la base de datos. En cambio, los
 pasos 1, 2, 3 y 5 se resumirán en el mismo algoritmo que recibe una
interfaz con lo que el quinto paso necesita para finalizar la
transacción. No necesita ser una interfaz tampoco, podría ser una
devolución de llamada.</p>
</div>
<h4 id="objectives">Objetivos</h4>
<div class="hBody-4">
<p>El patrón de diseño de la plantilla tiene que ver con la
reutilización y con las responsabilidades del usuario. Entonces los
objetivos para este patrón son los siguientes:</p>
<ul>
<li>
<p>Diferir una parte de un algoritmo de la biblioteca a un usuario</p>
</li>
<li>
<p>Mejore la reutilización al abstraer las partes del código que no son comunes entre las ejecuciones</p>
</li>
</ul>
</div>
<h4 id="example---a-simple-algorithm-with-a-deferred-step">Ejemplo: un algoritmo simple con un paso diferido</h4>
<div class="hBody-4">
<p>En nuestro primer ejemplo, vamos a escribir un algoritmo que se
compone de tres pasos y cada uno de ellos devuelve un mensaje. El primer
 y el tercer paso están controlados por la plantilla y solo el segundo
paso se difiere para el usuario.</p>
</div>
<h4 id="requirements-and-acceptance-criteria">Requisitos y criterios de aceptación</h4>
<div class="hBody-4">
<p>Una breve descripción de lo que tiene que hacer el patrón de
Plantilla es definir una plantilla para un algoritmo de tres pasos que
difiere la implementación del segundo paso para el usuario:</p>
<ol class="num">
<li>
<p>Cada paso en el algoritmo debe devolver una cadena.</p>
</li>
<li>
<p>El primer paso es un método llamado <code>first()</code>y devuelve la cadena <code>hello</code>.</p>
</li>
<li>
<p>El tercer paso es un método llamado <code>third()</code>y devuelve la cadena <code>template</code>.</p>
</li>
<li>
<p>El segundo paso es cualquier cadena que el usuario quiera devolver, pero está definida por la interfaz <code>MessageRetriever</code> que tiene un método <code>Message() string</code>.</p>
</li>
<li>
<p>El algoritmo se ejecuta secuencialmente mediante un método llamado <code>ExecuteAlgorithm</code>y devuelve las cadenas devueltas por cada paso unido en una sola cadena por un espacio.</p>
</li>
</ol>
</div>
<h4 id="unit-tests-for-the-simple-algorithm">Pruebas unitarias para el algoritmo simple</h4>
<div class="hBody-4">
<p>Nos enfocaremos en probar solo los métodos públicos. Este es un
enfoque muy común. Con todo, si sus métodos privados no son llamados
desde algún nivel de los públicos, no se llaman en absoluto. Necesitamos
 dos interfaces aquí, una para los implementadores de plantillas y otra
para el paso abstracto del algoritmo:</p>
<pre class="code"><code class="go">type MessageRetriever interface {
  Message()string
}
type Template interface {
   first() string
   third() string
   ExecuteAlgorithm(MessageRetriever) string
}
</code></pre>
<p>Un implementador de plantillas aceptará una interfaz <code>MessageRetriever</code>
 para ejecutar como parte de su algoritmo de ejecución. Necesitamos un
tipo que implemente esta interfaz llamada Template, lo llamaremos <code>TemplateImpl</code>:</p>
<pre class="code"><code class="go">type TemplateImpl struct{}

func (t *TemplateImpl) first() string {
  return ""
}

func (t *TemplateImpl) third() string {
  return ""
}

func (t *TemplateImpl) ExecuteAlgorithm(m MessageRetriever) string {
  return ""
}
</code></pre>
<p>Entonces, nuestra primera prueba verifica los criterios de aceptación cuarto y quinto. Crearemos el tipo <code>TestStruct</code> que implementa la interfaz <code>MessageRetriever</code> que devuelve la cadena <code>world</code>y ha incorporado la plantilla para que pueda invocar el método <code>ExecuteAlgorithm</code>. Actuará como la Plantilla y la abstracción:</p>
<pre class="code"><code class="go">type TestStruct struct {
  Template
}

func (m *TestStruct) Message() string {
  return "world"
}
</code></pre>
<p>Primero, definiremos el tipo <code>TestStruct</code>. En este caso, la parte del algoritmo que se nos ha diferido devolverá el <code>world</code> texto. Esta es la cadena que buscaremos más adelante en la prueba haciendo una comprobación de tipo "es la palabra<code>world</code> presente en esta cadena?".</p>
<p>Eche un vistazo de cerca, las <code>TestStruct</code> incrustaciones un tipo llamado<code>Template</code> que representa el patrón de la Plantilla de nuestro algoritmo.</p>
<p>Cuando implementamos el método <code>Message()</code>, implementamos implícitamente la interfaz <code>MessageRetriever</code>. Entonces ahora podemos usar el tipo <code>TestStruct</code> como un puntero a una interfaz <code>MessageRetriever</code>:</p>
<pre class="code"><code class="go">func TestTemplate_ExecuteAlgorithm(t *testing.T) {
  t.Run("Using interfaces", func(t *testing.T){
    s := &amp;TestStruct{}
    res := s.ExecuteAlgorithm(s)
    expected := "world"

    if !strings.Contains(res, expected) {
      t.Errorf("Expected string '%s' wasn't found on returned string\n", expected)
    }
  })
}
</code></pre>
<p>En la prueba, usaremos el tipo que acabamos de crear. Cuando llamamos al método <code>ExecuteAlgorithm</code>, tenemos que pasar la interfaz <code>MessageRetriever</code>. Como el tipo <code>TestStruct</code> también implementa la interfaz <code>MessageRetriever</code>, podemos pasarlo como argumento, pero esto no es obligatorio, por supuesto.</p>
<p>El resultado del método <code>ExecuteAlgorithm</code>, según se define en el quinto criterio de aceptación, debe devolver una cadena que contenga el valor devuelto del método <code>first()</code>, el valor devuelto de <code>TestStruct</code>(la cadena <code>world</code>) y el valor devuelto del método <code>third()</code>
 separado por un espacio. Nuestra implementación está en el segundo
lugar; es por eso que verificamos que un espacio tenga un prefijo y un
sufijo en la cadena <code>world</code>.</p>
<p>Entonces, si la cadena devuelta, al llamar al método <code>ExecuteAlgorithm</code>, no contiene la cadena <code>world</code>, la prueba falla.</p>
<p>Esto es suficiente para que el proyecto compile y ejecute las pruebas que deberían fallar:</p>
<pre class="srci"><code class="sh"><span class="in"><span class="prompt">&gt; </span>go test -v .
</span><span class="out">=== RUN   TestTemplate_ExecuteAlgorithm
=== RUN   TestTemplate_ExecuteAlgorithm/Using_interfaces
--- FAIL: TestTemplate_ExecuteAlgorithm (0.00s)
    --- FAIL: TestTemplate_ExecuteAlgorithm/Using_interfaces
(0.00s)
      template_test.go:47: Expected string ' world ' was not
found on returned string
FAIL
exit status 1
FAIL
</span></code></pre>
<p>Tiempo para pasar a la implementación de este patrón.</p>
</div>
<h4 id="implementing-the-template-pattern">Implementando el patrón de Plantilla</h4>
<div class="hBody-4">
<p>Tal como se define en los criterios de aceptación, debemos devolver la cadena hola en el método <code>first()</code> y la cadena <code>template</code> en el método <code>third()</code>. Eso es bastante fácil de implementar:</p>
<pre class="code"><code class="go">type Template struct{}

func (t *Template) first() string {
  return "hello"
}

func (t *Template) third() string {
  return "template"
}
</code></pre>
<p>Con esta implementación, deberíamos cubrir los criterios de aceptación <i>segundo</i> y <i>tercero</i> y cubrir parcialmente el <i>primer</i> criterio (cada paso en el algoritmo debe devolver una cadena).</p>
<p>Para cubrir el <i>quinto</i> criterio de aceptación, definimos un método <code>ExecuteAlgorithm</code> que acepta la interfaz <code>MessageRetriever</code> como argumento y devuelve el algoritmo completo: una sola cuerda hecho uniendo las cadenas devueltas por los <code>first()</code>, <code>Message()</code> cuerda y métodos <code>third()</code>:</p>
<pre class="code"><code class="go">func (t *Template) ExecuteAlgorithm(m MessageRetriever) string {
  return strings.Join([]string{t.first(), m.Message(), t.third()},  " ")
}
</code></pre>
<p>La función <code>strings.Join</code> tiene la siguiente firma:</p>
<pre class="code"><code class="go">func Join([]string,string) string
</code></pre>
<p>Toma una serie de cadenas y las une, colocando el segundo argumento
entre cada elemento de la matriz. En nuestro caso, creamos una matriz de
 cadenas sobre la marcha para pasarla como primer argumento. Luego
pasamos un espacio en blanco como segundo argumento.</p>
<p>Con esta implementación, las pruebas deben estar pasando ya:</p>
<pre class="srci"><code class="sh"><span class="in"><span class="prompt">&gt; </span>go test -v .
</span><span class="out">=== RUN   TestTemplate_ExecuteAlgorithm
=== RUN   TestTemplate_ExecuteAlgorithm/Using_interfaces
--- PASS: TestTemplate_ExecuteAlgorithm (0.00s)
    --- PASS: TestTemplate_ExecuteAlgorithm/Using_interfaces
(0.00s)
PASS
ok
</span></code></pre>
<p>Las pruebas pasaron La prueba ha verificado que la cadena <code>world</code> está presente en el resultado devuelto, que es el <code>hello world template</code> mensaje. El <code>hello</code> texto fue la cadena devuelta por el método <code>first()</code>, la cadena <code>world</code> fue devuelta por nuestra implementación <code>MessageRetriever</code> y <code>template</code> fue la cadena devuelta por el método <code>third()</code>. Los espacios en blanco se insertan mediante la función <code>strings.Join</code> de Go . Pero cualquier uso del tipo <code>TemplateImpl.ExecuteAlgorithm</code> siempre devolverá "hello [algo] plantilla" en su resultado.</p>
</div>
<h4 id="anonymous-functions">Funciones anónimas</h4>
<div class="hBody-4">
<p>Esta no es la única forma de lograr el patrón de diseño de Plantilla.
 También podemos usar una función anónima para dar nuestra
implementación al<code>ExecuteAlgorithm</code> método.</p>
<p>Vamos a escribir una prueba en el mismo método que se utilizó anteriormente justo después de la prueba:</p>
<pre class="code"><code class="go">func TestTemplate_ExecuteAlgorithm(t *testing.T) {
  t.Run("Using interfaces", func(t *testing.T){
    s := &amp;TestStruct{}
    res := s.ExecuteAlgorithm(s)

    expectedOrError(res, " world ", t)
  })

  t.Run("Using anonymous functions", func(t *testing.T) {

    m := new(AnonymousTemplate)

    res := m.ExecuteAlgorithm(func() string {
      return "world"
    })

    expectedOrError(res, " world ", t)
  })
}

func expectedOrError(res string, expected string, t *testing.T) {
  if !strings.Contains(res, expected) {
    t.Errorf("Expected string '%s' was not found on returned string\n", expected)
  }
}
</code></pre>
<p>Nuestra nueva prueba se llama <i>Usar funciones anónimas</i>. También
 hemos extraído la verificación de la prueba a una función externa para
reutilizarla en esta prueba. Hemos llamado a esta función <code>expectedOrError</code> porque fallará con un error si no se recibe el valor esperado.</p>
<p>En nuestra prueba, crearemos un tipo llamado <code>AnonymousTemplate</code> que reemplaza al tipo <code>Template</code> anterior . El método <code>ExecuteAlgorithm</code> de este nuevo tipo acepta el tipo de método <code>func()</code> <code>string</code> que podemos implementar directamente en la prueba para devolver la cadena <code>world</code>.</p>
<p>El tipo <code>AnonymousTemplate</code> tendrá la siguiente estructura:</p>
<pre class="code"><code class="go">type AnonymousTemplate struct{}

func (a *AnonymousTemplate) first() string {
  return ""
}

func (a *AnonymousTemplate) third() string {
  return ""
}

func (a *AnonymousTemplate) ExecuteAlgorithm(f func() string) string {
  return ""
}
</code></pre>
<p>La única diferencia con el tipo <code>Template</code> es que el método <code>ExecuteAlgorithm</code> acepta una función que devuelve una cadena en lugar de una interfaz <code>MessageRetriever</code>. Vamos a ejecutar la nueva prueba:</p>
<pre class="srci"><code class="sh"><span class="in"><span class="prompt">&gt; </span>go test -v .
</span><span class="out">=== RUN   TestTemplate_ExecuteAlgorithm
=== RUN   TestTemplate_ExecuteAlgorithm/Using_interfaces
=== RUN
TestTemplate_ExecuteAlgorithm/Using_anonymous_functions
--- FAIL: TestTemplate_ExecuteAlgorithm (0.00s)
    --- PASS: TestTemplate_ExecuteAlgorithm/Using_interfaces
(0.00s)
    --- FAIL:
TestTemplate_ExecuteAlgorithm/Using_anonymous_functions (0.00s)
      template_test.go:47: Expected string ' world ' was not
found on returned string
FAIL
exit status 1
FAIL
</span></code></pre>
<p>Como puede leer en el resultado de la ejecución de la prueba, se genera el error en la prueba <i>Uso de funciones anónimas</i>, que es lo que esperábamos. Ahora escribiremos la implementación de la siguiente manera:</p>
<pre class="code"><code class="go">type AnonymousTemplate struct{}

func (a *AnonymousTemplate) first() string {
  return "hello"
}

func (a *AnonymousTemplate) third() string {
  return "template"
}

func (a *AnonymousTemplate) ExecuteAlgorithm(f func() string) string {
  return strings.Join([]string{a.first(), f(), a.third()}, " ")
}
</code></pre>
<p>La implementación es bastante similar a la del tipo <code>Template</code>. Sin embargo, ahora hemos pasado una función llamada <code>f</code> que usaremos como el segundo elemento en la matriz de cadenas que usamos en la función <code>Join</code>. Como <code>f</code>
 simplemente es una función que devuelve una cadena, lo único que
tenemos que hacer con ella es ejecutarla en el lugar correcto (la
segunda posición en la matriz). Ejecute las pruebas nuevamente:</p>
<pre class="srci"><code class="sh"><span class="in"><span class="prompt">&gt; </span>go test -v .
</span><span class="out">=== RUN   TestTemplate_ExecuteAlgorithm
=== RUN   TestTemplate_ExecuteAlgorithm/Using_interfaces
=== RUN
TestTemplate_ExecuteAlgorithm/Using_anonymous_functions
--- PASS: TestTemplate_ExecuteAlgorithm (0.00s)
    --- PASS: TestTemplate_ExecuteAlgorithm/Using_interfaces
(0.00s)
    --- PASS:
TestTemplate_ExecuteAlgorithm/Using_anonymous_functions (0.00s)
PASS
ok
</span></code></pre>
<p>¡Increíble! Ahora sabemos dos formas de implementar el patrón de diseño de la plantilla.</p>
</div>
<h4 id="how-to-avoid-modifications-on-the-interface">Cómo evitar modificaciones en la interfaz</h4>
<div class="hBody-4">
<p>El problema del enfoque anterior es que ahora tenemos dos plantillas
para mantener y podríamos terminar la duplicación del código. ¿Qué
podemos hacer en la situación de que no podemos cambiar la interfaz que
estamos usando? Nuestra interfaz era <code>MessageRetriever</code> pero queremos usar una función anónima ahora.</p>
<p>Bueno, ¿recuerdas el patrón de diseño del Adaptador? Solo tenemos que crear un tipo <code>Adapter</code> que, al aceptar un <code>func() string</code> tipo, devuelva una implementación de la interfaz <code>MessageRetriever</code>. Llamaremos a este tipo <code>TemplateAdapter</code>:</p>
<pre class="code"><code class="go">type TemplateAdapter struct {
  myFunc func() string
}

func (a *TemplateAdapter) Message() string {
  return ""
}

func MessageRetrieverAdapter(f func() string) MessageRetriever {
  return nil
}
</code></pre>
<p>Como puede ver, el tipo <code>TemplateAdapter</code> tiene un campo llamado <code>myFunc</code> que es de tipo <code>func() string</code>. También hemos definido el adaptador como privado porque no debe usarse sin una función definida en el campo <code>myFunc</code>. Hemos creado una función pública llamada the <code>MessageRetrieverAdapter</code> para lograr esto. Nuestra prueba debería verse más o menos así:</p>
<pre class="code"><code class="go">t.Run("Using anonymous functions adapted to an interface",
  func(t *testing.T){
    messageRetriever := MessageRetrieverAdapter(func() string {
      return "world"
    })

    if messageRetriever == nil {
      t.Fatal("Can not continue with a nil MessageRetriever")
    }

    template := Template{}
    res := template.ExecuteAlgorithm(messageRetriever)

    expectedOrError(res, " world ", t)
  })
</code></pre>
<p>Mire la declaración donde llamamos el método <code>MessageRetrieverAdapter</code>. Pasamos una función anónima como argumento definido como cadena <code>func()</code>. Luego, reutilizamos el tipo <code>Template</code> previamente definido de nuestra primera prueba para pasar la variable <code>messageRetriever</code>. Finalmente, volvimos a verificar con el método <code>expectedOrError</code>. Eche un vistazo al método <code>MessageRetrieverAdapter</code>,
 devolverá una función que tiene valor nulo. Si seguimos estrictamente
las reglas de desarrollo impulsadas por pruebas, primero debemos hacer
las pruebas y no deben pasar antes de que se complete la implementación.
 Es por eso que devolvimos nada a la función <code>MessageRetrieverAdapter</code>.</p>
<p>Entonces, hagamos las pruebas:</p>
<pre class="srci"><code class="sh"><span class="in"><span class="prompt">&gt; </span>go test -v .
</span><span class="out">=== RUN   TestTemplate_ExecuteAlgorithm
=== RUN   TestTemplate_ExecuteAlgorithm/Using_interfaces
=== RUN
TestTemplate_ExecuteAlgorithm/Using_anonymous_functions
=== RUN
TestTemplate_ExecuteAlgorithm/Using_anonymous_functions_adapted
_to_an_interface
--- FAIL: TestTemplate_ExecuteAlgorithm (0.00s)
    --- PASS: TestTemplate_ExecuteAlgorithm/Using_interfaces
(0.00s)
    --- PASS:
TestTemplate_ExecuteAlgorithm/Using_anonymous_functions (0.00s)
    --- FAIL:
TestTemplate_ExecuteAlgorithm/Using_anonymous_functions_adapted
_to_an_interface (0.00s)
      template_test.go:39: Can not continue with a nil
MessageRetriever
FAIL
exit status 1
FAIL
</span></code></pre>
<p>La prueba falla en la <i>línea 39</i> del código y no continúa
(nuevamente, dependiendo de cómo haya escrito su código, la línea que
representa su error podría estar en otro lugar). Paramos la ejecución de
 la prueba porque necesitaremos una interfaz <code>MessageRetriever</code> válida cuando llamemos al<code>ExecuteAlgorithm</code> método.</p>
<p>Para la implementación del adaptador para nuestro patrón de Plantilla, comenzaremos con el método <code>MessageRetrieverAdapter</code>:</p>
<pre class="code"><code class="go">func MessageRetrieverAdapter(f func() string) MessageRetriever
{
  return &amp;adapter{myFunc: f}
}
</code></pre>
<p>Es muy fácil, ¿verdad? Se podría estar preguntando qué sucede si le damos valor <code>nil</code> al argumento <code>f</code>. Bueno, cubriremos este problema llamando alfunción <code>myFunc</code>.</p>
<p>El tipo <code>adapter</code> está terminado con esta implementación:</p>
<pre class="code"><code class="go">type adapter struct {
  myFunc func() string
}

func (a *adapter) Message() string {
  if a.myFunc != nil {
    return a.myFunc()
  }

  return ""
}
</code></pre>
<p>Cuando <code>Message()</code> llamamos a la función, comprobamos que en realidad tenemos algo almacenado en la función <code>myFunc</code> antes de llamar. Si no se almacenó nada, devolvemos una cadena vacía.</p>
<p>Ahora, nuestra tercera implementación del tipo <code>Template</code>, usando el patrón Adapter, está hecha:</p>
<pre class="srci"><code class="sh"><span class="in"><span class="prompt">&gt; </span>go test -v .
</span><span class="out">=== RUN   TestTemplate_ExecuteAlgorithm
=== RUN   TestTemplate_ExecuteAlgorithm/Using_interfaces
=== RUN
TestTemplate_ExecuteAlgorithm/Using_anonymous_functions
=== RUN
TestTemplate_ExecuteAlgorithm/Using_anonymous_functions_adapted
_to_an_interface
--- PASS: TestTemplate_ExecuteAlgorithm (0.00s)
    --- PASS: TestTemplate_ExecuteAlgorithm/Using_interfaces
(0.00s)
    --- PASS:
TestTemplate_ExecuteAlgorithm/Using_anonymous_functions (0.00s)
    --- PASS:
TestTemplate_ExecuteAlgorithm/Using_anonymous_functions_adapted
_to_an_interface (0.00s)
PASS
ok
</span></code></pre>
</div>
<h4 id="looking-for-the-template-pattern-in-go's-source-code">Buscando el patrón de Plantilla en el código fuente de Go</h4>
<div class="hBody-4">
<p>El paquete <code>sort</code> en el código fuente de Go se puede
considerar una implementación de Plantilla de un algoritmo de
ordenación. Tal como se define en el paquete en sí, el paquete <code>sort</code> proporciona primitivas para clasificar sectores y colecciones definidas por el usuario.</p>
<p>Aquí, también podemos encontrar un buen ejemplo de por qué los
autores de Go no están preocupados por la implementación de genéricos.
Ordenar las listas es quizás el mejor ejemplo de uso genérico en otros
idiomas. La forma en que Go trata con esto también es muy elegante:
trata este problema con una interfaz:</p>
<pre class="code"><code class="go">type Interface interface {
  Len() int
  Less(i, j int) bool
  Swap(i, j int)
}
</code></pre>
<p>Esta es la interfaz para las listas que deben ordenarse utilizando el
 paquete de clasificación. En palabras de los autores de Go:</p>
<blockquote>
<p><i>"Un tipo, típicamente, es una colección que satisface el género.
La interfaz se puede ordenar por las rutinas en este paquete. Los
métodos requieren que los elementos de la colección se enumeren por un
índice entero".</i></p>
</blockquote>
<p>En otras palabras, escriba un tipo que implemente esto <code>Interface</code> para que el paquete <code>sort</code>
 se pueda usar para ordenar cualquier porción. El algoritmo de
clasificación es la plantilla y debemos definir cómo recuperar los
valores en nuestro sector.</p>
<p>Si echamos un vistazo al paquete <code>sort</code>, también podemos encontrar un ejemplo de cómo usar la plantilla de clasificación, pero crearemos nuestro propio ejemplo:</p>
<pre class="code"><code class="go">package main

import (
  "sort"
  "fmt"
)

type MyList []int

func (m MyList) Len() int {
  return len(m)
}

func (m MyList) Swap(i, j int) {
  m[i], m[j] = m[j], m[i]
}

func (m MyList) Less(i, j int) bool {
  return m[i] &lt; m[j]
}
</code></pre>
<p>Primero, hemos hecho un tipo muy simple que almacena una lista int.
Esto podría ser cualquier tipo de lista, generalmente una lista de algún
 tipo de estructura. A continuación, hemos implementado la interfaz <code>sort.Interface</code> mediante la definición de los <code>Len</code>, <code>Swap</code>y métodos <code>Less</code>.</p>
<p>Finalmente, la función <code>main</code> crea una lista desordenada de números del tipo <code>MyList</code>:</p>
<pre class="code"><code class="go">func main() {
  var myList MyList = []int{6,4,2,8,1}

  fmt.Println(myList)
  sort.Sort(myList)
  fmt.Println(myList)
}
</code></pre>
<p>Imprimimos la lista que creamos (desordenada) y luego la ordenamos (el método <code>sort.Sort</code>
 realmente modifica nuestra variable en lugar de devolver una nueva
lista, ¡así que ten cuidado!). Finalmente, imprimimos nuevamente la
lista resultante. La salida de la consola de este método <code>main</code> es la siguiente:</p>
<pre class="srci"><code class="sh"><span class="in"><span class="prompt">&gt; </span>go run sort_example.go
</span><span class="out">[6 4 2 8 1]
[1 2 4 6 8]
</span></code></pre>
<p>La función <code>sort.Sort</code> ha ordenado nuestra lista de forma transparente. Tiene muchos códigos escritos y delegados <code>Len</code>, <code>Swap</code>y métodos <code>Less</code> para una interfaz, como hicimos en nuestra plantilla al delegar en la interfaz <code>MessageRetriever</code>.</p>
</div>
<h4 id="summarizing-the-template-design-pattern">Resumiendo el patrón de diseño de la plantilla</h4>
<div class="hBody-4">
<p>Queríamos concentrarnos mucho en este patrón porque es muy importante
 cuando se desarrollan bibliotecas y marcos, y permite mucha
flexibilidad y control a los usuarios de nuestra biblioteca.</p>
<p>También hemos visto nuevamente que es muy común mezclar patrones para
 proporcionar flexibilidad a los usuarios, no solo de forma conductual
sino también estructural. Esto será muy útil cuando trabaje con
aplicaciones simultáneas en las que tengamos que restringir el acceso a
partes de nuestro código para evitar carreras.</p>
</div>
<h3 id="memento-design-pattern">Patrón de diseño de recuerdo</h3>
<div class="hBody-3">
<p>Veamos ahora un patrón con un nombre elegante. Si revisamos un diccionario para ver el significado del <i>recuerdo</i>, encontraremos la siguiente descripción:</p>
<blockquote>
<p><i>"Un objeto mantenido como un recordatorio de una persona o evento".</i></p>
</blockquote>
<p>Aquí, la palabra clave es <b>recordatorio,</b> ya que recordaremos las acciones con este patrón de diseño.</p>
</div>
<h4 id="description">Descripción</h4>
<div class="hBody-4">
<p>El significado de memento es muy similar a la funcionalidad que
proporciona en los patrones de diseño. Básicamente, tendremos un tipo
con algún estado y queremos poder guardar hitos de su estado. Con una
cantidad limitada de estados guardados, podemos recuperarlos si es
necesario para una variedad de tareas: deshacer operaciones, histórico,
etc.</p>
<p>El patrón de diseño de Memento generalmente tiene tres jugadores (generalmente llamados <b>actores</b> ):</p>
<ul>
<li>
<p><b>Memento</b>: un tipo que almacena el tipo que queremos guardar.
Por lo general, no almacenaremos el tipo de negocio directamente y
proporcionamos una capa adicional de abstracción a través de este tipo.</p>
</li>
<li>
<p><b>Originador</b>: un tipo que se encarga de crear recuerdos y
almacenar el estado activo actual. Dijimos que el tipo Memento ajusta
los estados del tipo de negocio y utilizamos el originador como el
creador de los recuerdos.</p>
</li>
<li>
<p><b>Care Taker</b>: un tipo que almacena la lista de recuerdos que
puede tener la lógica para almacenarlos en una base de datos o para no
almacenar más de un número específico de ellos.</p>
</li>
</ul>
</div>
<h4 id="objectives">Objetivos</h4>
<div class="hBody-4">
<p>Memento se trata de una secuencia de acciones a lo largo del tiempo,
digamos para deshacer una o dos operaciones o para proporcionar algún
tipo de transaccionalidad a alguna aplicación.</p>
<p>Memento proporciona las bases para muchas tareas, pero sus principales objetivos se pueden definir de la siguiente manera:</p>
<ul>
<li>
<p>Capture un estado de objeto sin modificar el objeto en sí</p>
</li>
<li>
<p>Guarde una cantidad limitada de estados para que podamos recuperarlos más tarde</p>
</li>
</ul>
</div>
<h4 id="a-simple-example-with-strings">Un simple ejemplo con cadenas</h4>
<div class="hBody-4">
<p>Desarrollaremos un ejemplo simple usando una cadena como el estado
que queremos guardar. De esta manera, nos enfocaremos en las
implementaciones de patrones comunes de Memento antes de hacerlo un poco
 más complejo con un nuevo ejemplo.</p>
<p>La cadena, almacenada en un campo de una instancia <code>State</code>, se modificará y podremos deshacer las operaciones realizadas en este estado.</p>
</div>
<h4 id="requirements-and-acceptance-criteria">Requisitos y criterios de aceptación</h4>
<div class="hBody-4">
<p>Estamos constantemente hablando de estado; en general, el patrón
Memento se trata de almacenar y recuperar estados. Nuestros criterios de
 aceptación deben ser todos acerca de los estados:</p>
<ol class="num">
<li>
<p>Necesitamos almacenar una cantidad finita de estados de tipo cadena.</p>
</li>
<li>
<p>Necesitamos una forma de restaurar el estado almacenado actual a uno de la lista de estados.</p>
</li>
</ol>
<p>Con estos dos requisitos simples, ya podemos comenzar a escribir algunas pruebas para este ejemplo.</p>
</div>
<h4 id="unit-test">Prueba de unidad</h4>
<div class="hBody-4">
<p>Como se mencionó anteriormente, el patrón de diseño de Memento
generalmente se compone de tres actores: estado, recuerdo y autor.
Entonces, necesitaremos tres tipos para representar a estos actores:</p>
<pre class="code"><code class="go">type State struct {
  Description string
}
</code></pre>
<p>El tipo <code>State</code> es el objeto comercial central que usaremos durante este ejemplo. Es cualquier tipo de objeto que queremos rastrear:</p>
<pre class="code"><code class="go">type memento struct {
  state State
}
</code></pre>
<p>El tipo <code>memento</code> tiene un campo llamado <code>state</code> representar un solo valor de un tipo <code>State</code>. Nuestro <code>states</code> contenedor estará dentro de este tipo antes de almacenarlos en el tipo <code>care taker</code>. Podría estarse preguntando por qué no almacenamos instancias <code>State</code> directamente . Básicamente, porque unirá el <code>originator</code>y el objeto <code>careTaker</code> comercial y queremos tener el menor acoplamiento posible. También será menos flexible, como veremos en el segundo ejemplo:</p>
<pre class="code"><code class="go">type originator struct {
  state State
}

func (o *originator) NewMemento() memento {
  return memento{}
}

func (o *originator) ExtractAndStoreState(m memento) {
  // Does nothing
}
</code></pre>
<p>El tipo <code>originator</code> también almacena un estado. Los objetos <code>originator</code> de la estructura tomarán estados de los recuerdos y crearán nuevos recuerdos con su estado almacenado.</p>
<div class="about">
<div class="about-dt">Tip</div>
<div class="about-dd">
<p>¿Cuál es la diferencia entre el objeto originador y el patrón
Memento? ¿Por qué no usamos el objeto del patrón Originator
directamente? Bueno, si el Memento contiene un estado específico, el
tipo <code>originator</code> contiene el estado que está actualmente
cargado. Además, guardar el estado de algo podría ser tan simple como
tomar algún valor o ser tan complejo como para mantener el estado de
alguna aplicación distribuida.</p>
</div>
</div>
<p>El Originador tendrá dos métodos públicos: el método <code>NewMemento</code> () y el método <code>ExtractAndStoreState(m memento)</code>. El método <code>NewMemento</code> devolverá un nuevo Memento construido con el valor <code>originator</code> actual <code>State</code>. El método <code>ExtractAndStoreState</code> tomará el estado de un Memento y lo almacenará en el campo de estado del Originador:</p>
<pre class="code"><code class="go">type careTaker struct {
  mementoList []memento
}

func (c *careTaker) Add(m memento) {
  // Does nothing
}

func (c *careTaker) Memento(i int) (memento, error) {
  return memento{}, fmt.Errorf("Not implemented yet")
}
</code></pre>
<p>El tipo <code>careTaker</code> almacena la lista Memento con todos los estados que necesitamos guardar. También almacena una<code>Add</code> método para insertar un nuevo Memento en la lista y un Memento retriever que toma un índice en la lista Memento.</p>
<p>Comencemos con el método <code>Add</code> del tipo <code>careTaker</code>. El método Add debe tomar un objeto <code>memento</code> y agregarlo a la <code>careTaker</code> lista de Mementos del objeto:</p>
<pre class="code"><code class="go">func TestCareTaker_Add(t *testing.T) {
  originator := originator{}
  originator.state = State{Description:"Idle"}

  careTaker := careTaker{}
  mem := originator.NewMemento()
  if mem.state.Description != "Idle" {
    t.Error("Expected state was not found")
  }
</code></pre>
<p>Al comienzo de nuestra prueba, creamos dos actores básicos para el recuerdo: el <code>originator</code>y el <code>careTaker</code>. Establecemos un primer estado en el originador con la descripción <code>Idle</code>.</p>
<p>Luego, creamos el primer Memento llamando al método <code>NewMemento</code>. Esto debería ajustar el estado del originador actual en un tipo <code>memento</code>.
 Nuestro primer cheque es muy simple: la descripción del estado del
Memento devuelto debe ser como la descripción del estado que le pasamos
al autor, es decir, la <code>Idle</code> descripción.</p>
<p>El último paso para verificar si el método <code>Add</code> de Memento funciona correctamente es ver si la lista Memento ha crecido después de agregar un elemento:</p>
<pre class="code"><code class="go">currentLen := len(careTaker.mementoList)
careTaker.Add(mem)

if len(careTaker.mementoList) != currentLen+1 {
  t.Error("No new elements were added on the list")
}
</code></pre>
<p>También tenemos que probar el método <code>Memento(int) memento</code>. Esto debería tomar un valor <code>memento</code> de la <code>careTaker</code>
 lista. Toma el índice que desea recuperar de la lista, así que, como es
 habitual con las listas, debemos verificar que se comporte
correctamente contra números negativos y fuera de valores de índice:</p>
<pre class="code"><code class="go">func TestCareTaker_Memento(t *testing.T) {
  originator := originator{}
  careTaker := careTaker{}

  originator.state = State{"Idle"}
  careTaker.Add(originator.NewMemento())
</code></pre>
<p>Tenemos que empezar como lo hicimos en nuestra prueba anterior - la creación de una <code>originator</code>y objetos <code>careTaker</code> y la adición de la primera a la Memento <code>caretaker</code>:</p>
<pre class="code"><code class="go">mem, err := careTaker.Memento(0)
if err != nil {
  t.Fatal(err)
}

if mem.state.Description != "Idle" {
  t.Error("Unexpected state")
}
</code></pre>
<p>Una vez que tenemos el primer objeto en el objeto <code>careTaker</code>, podemos pedirlo usando <code>careTaker.Memento(0)</code>. El índice <code>0</code> del método <code>Memento(int)</code> recupera el primer elemento del sector (recuerde que los sectores comienzan con <code>0</code>). No se debe devolver ningún error porque ya hemos agregado un valor al objeto <code>caretaker</code>.</p>
<p>Luego, después de recuperar el primer recuerdo, verificamos que la
descripción coincida con la que aprobamos al comienzo de la prueba:</p>
<pre class="code"><code class="go">  mem, err = careTaker.Memento(-1)
  if err == nil {
    t.Fatal("An error is expected when asking for a negative number but no error was found")
  }
}
</code></pre>
<p>El último paso en esta prueba implica usar un número negativo para
recuperar algún valor. En este caso, se debe devolver un error que
demuestre que no se pueden usar números negativos. También es posible
devolver el primer índice cuando pasa números negativos pero aquí
devolveremos un error.</p>
<p>La última función para verificar es el método <code>ExtractAndStoreState</code>. Esta función debe tomar un Memento y extraer toda su información de estado para establecerlo en el objeto <code>Originator</code>:</p>
<pre class="code"><code class="go">func TestOriginator_ExtractAndStoreState(t *testing.T) {
  originator := originator{state:State{"Idle"}}
  idleMemento := originator.NewMemento()

  originator.ExtractAndStoreState(idleMemento)
  if originator.state.Description != "Idle" {
    t.Error("Unexpected state found")
  }
}
</code></pre>
<p>Esta prueba es simple. Creamos una variable <code>originator</code>
predeterminada con un estado Inactivo. Luego, recuperamos un nuevo
objeto Memento para usarlo más tarde. Cambiamos el estado de la variable
 <code>originator</code> al <code>Working</code> estado para asegurarnos de que se escriba el nuevo estado.</p>
<p>Finalmente, tenemos que llamar al método <code>ExtractAndStoreState</code> con la variable <code>idleMemento</code>. Esto debería restaurar el estado del originador al valor <code>idleMemento</code> del estado, algo que verificamos en la última instrucción if.</p>
<p>Ahora es el momento de ejecutar las pruebas:</p>
<pre class="srci"><code class="sh"><span class="in"><span class="prompt">&gt; </span>go test -v .
</span><span class="out">=== RUN   TestCareTaker_Add
--- FAIL: TestCareTaker_Add (0.00s)
  memento_test.go:13: Expected state was not found
  memento_test.go:20: No new elements were added on the list
=== RUN   TestCareTaker_Memento
--- FAIL: TestCareTaker_Memento (0.00s)
  memento_test.go:33: Not implemented yet
=== RUN   TestOriginator_ExtractAndStoreState
--- FAIL: TestOriginator_ExtractAndStoreState (0.00s)
  memento_test.go:54: Unexpected state found
FAIL
exit status 1
FAIL
</span></code></pre>
<p>Debido a que las tres pruebas fallan, podemos continuar con la implementación.</p>
</div>
<h4 id="implementing-the-memento-pattern">Implementando el patrón Memento</h4>
<div class="hBody-4">
<p>La implementación del patrón Memento es generalmente muy simple si no te vuelves loco. Los tres actores ( <code>memento</code>, <code>originator</code>y <code>care taker</code>) tienen un papel muy definido en el patrón y su implementación es muy sencilla:</p>
<pre class="code"><code class="go">type originator struct {
  state State
}

func (o *originator) NewMemento() memento {
  return memento{state: o.state}
}

func (o *originator) ExtractAndStoreState(m memento) {
  o.state = m.state
}
</code></pre>
<p>El objeto <code>Originator</code> necesita devolver un nuevo valor de tipo Memento cuando llama al método <code>NewMemento</code>. También necesita almacenar el valor de un objeto <code>memento</code> en el campo de estado de la estructura, según sea necesario para el método <code>ExtractAndStoreState</code>:</p>
<pre class="code"><code class="go">type careTaker struct {
  mementoList []memento
}

func (c *careTaker) Push(m memento) {
  c.mementoList = append(c.mementoList, m)
}

func (c *careTaker) Memento(i int) (memento, error) {
  if len(c.mementoList) &lt; i || i &lt; 0 {
    return memento{}, fmt.Errorf("Index not found\n")
  }
  return c.mementoList[i], nil
}
</code></pre>
<p>El tipo <code>careTaker</code> también es directo. Cuando llamamos al método <code>Add</code>, sobrescribimos el campo <code>mementoList</code> llamando al método <code>append</code> con el valor pasado en el argumento. Esto crea una nueva lista con el nuevo valor incluido.</p>
<p>Al llamar al método <code>Memento</code>, tenemos que hacer un par de
 comprobaciones de antemano. En este caso, verificamos que el índice no
esté fuera del rango del segmento y que el índice no sea negativo en el
enunciado if, en cuyo caso devolveremos un error. Si todo va bien, solo
devuelve el objeto <code>memento</code> especificado y no hay errores.</p>
<div class="about">
<div class="about-dt">Tip</div>
<div class="about-dd">
<p>Una nota sobre las convenciones de nombres de métodos y funciones.
Puede encontrar algunas personas a las que les gusta dar nombres
ligeramente más descriptivos a métodos como <code>Memento</code>. Un ejemplo sería usar un nombre como método <code>MementoOrError</code>, que muestre claramente que devuelve dos objetos al llamar a esta función o incluso a un método <code>GetMementoOrError</code>.
 Este podría ser un enfoque muy explícito para nombrar y no es
necesariamente malo, pero no lo encontrarás muy común en el código
fuente de Go.</p>
</div>
</div>
<p>Hora de verificar los resultados de la prueba:</p>
<pre class="srci"><code class="sh"><span class="in"><span class="prompt">&gt; </span>go test -v .
</span><span class="out">=== RUN   TestCareTaker_Add
--- PASS: TestCareTaker_Add (0.00s)
=== RUN   TestCareTaker_Memento
--- PASS: TestCareTaker_Memento (0.00s)
=== RUN   TestOriginator_ExtractAndStoreState
--- PASS: TestOriginator_ExtractAndStoreState (0.00s)
PASS
ok
</span></code></pre>
<p>Eso fue suficiente para alcanzar el 100% de la cobertura. Si bien
esto está lejos de ser una métrica perfecta, al menos sabemos que
estamos llegando a todos los rincones de nuestro código fuente y que no
hemos hecho trampa en nuestras pruebas para lograrlo.</p>
</div>
<h4 id="another-example-using-the-command-and-facade-patterns">Otro ejemplo usando los patrones de Comando y Fachada</h4>
<div class="hBody-4">
<p>El ejemplo anterior es lo suficientemente bueno y simple como para
comprender la funcionalidad del patrón Memento. Sin embargo, se usa más
comúnmente junto con el patrón de Comando y un patrón simple de Fachada.</p>
<p>La idea es utilizar un patrón de comando para encapsular un conjunto
de diferentes tipos de estados (aquellos que implementan una interfaz <code>Command</code>) y proporcionar una pequeña fachada para automatizar la inserción en el objeto <code>caretaker</code>.</p>
<p>Vamos a desarrollar un pequeño ejemplo de un hipotético mezclador de
audio. Vamos a usar el mismo patrón Memento para guardar dos tipos de
estados: <code>Volume</code>y <code>Mute</code>. El <code>Volume</code> estado va a ser de tipo byte y el <code>Mute</code>
 estado de tipo booleano. Utilizaremos dos tipos completamente
diferentes para mostrar la flexibilidad de este enfoque (y sus
inconvenientes).</p>
<p>Como nota al margen, también podemos enviar cada interfaz <code>Command</code>
 con sus propios métodos de serialización en la interfaz. De esta forma,
 podemos otorgarle al cuidador la capacidad de almacenar estados en
algún tipo de almacenamiento sin saber realmente qué es lo que se
almacena.</p>
<p>Nuestra interfaz <code>Command</code> tendrá un método para devolver
el valor de su implementador. Es muy simple, cada comando en nuestro
mezclador de audio que queremos deshacer tendrá que implementar esta
interfaz:</p>
<pre class="code"><code class="go">type Command interface {
  GetValue() interface{}
}
</code></pre>
<p>Hay algo interesante en esta interfaz. El método <code>GetValue</code>
 devuelve una interfaz a un valor. Esto también significa que el tipo de
 devolución de este método es ... bueno ... sin tipo? En realidad no,
pero devuelve una interfaz que puede ser una representación de cualquier
 tipo y tendremos que volver a escribirla más tarde si queremos usar su
tipo específico. Ahora tenemos que definir <code>Volume</code>y <code>Mute</code> escribir e implementar la interfaz <code>Command</code>:</p>
<pre class="code"><code class="go">type Volume byte

func (v Volume) GetValue() interface{} {
  return v
}

type Mute bool

func (m Mute) GetValue() interface{} {
  return m
}
</code></pre>
<p>Ambas son implementaciones bastante sencillas. Sin embargo, el tipo <code>Mute</code> devolverá un tipo <code>bool</code> en el método <code>GetValue</code> () y <code>Volume</code> devolverá un tipo <code>byte</code>.</p>
<p>Como en el ejemplo anterior, necesitaremos un tipo <code>Memento</code> que contendrá a <code>Command</code>. En otras palabras, almacenará un puntero a un tipo Mute o Volume:</p>
<pre class="code"><code class="go">type Memento struct {
  memento Command
}
</code></pre>
<p>El tipo <code>originator</code> funciona como en el ejemplo anterior pero usa la palabra clave <code>Command</code> en lugar de la palabra clave <code>state</code>:</p>
<pre class="code"><code class="go">type originator struct {
  Command Command
}

func (o *originator) NewMemento() Memento {
  return Memento{memento: o.Command}
}

func (o *originator) ExtractAndStoreCommand(m Memento) {
  o.Command = m.memento
}
</code></pre>
<p>Y el objeto <code>caretaker</code> es casi el mismo, pero esta vez
usaremos una pila en lugar de una lista simple y almacenaremos un
comando en lugar de un estado:</p>
<pre class="code"><code class="go">type careTaker struct {
  mementoList []Memento
}

func (c *careTaker) Add(m Memento) {
  c.mementoList = append(c.mementoList, m)
}

func (c *careTaker) Pop() Memento {
  if len(c.mementoStack) &gt; 0 {
    tempMemento := c.mementoStack[len(c.mementoStack)-1]
    c.mementoStack = c.mementoStack[0:len(c.mementoStack)-1]
    return tempMemento
  }

  return Memento{}
}
</code></pre>
<p>Sin embargo, nuestra lista <code>Memento</code> es reemplazada por un método <code>Pop</code>. También devuelve un objeto <code>memento</code>
 pero lo devolverá actuando como una pila (último para entrar, primero
para salir). Entonces, tomamos el último elemento en la pila y lo
almacenamos en la variable <code>tempMemento</code>. Luego reemplazamos
la pila con una nueva versión que no contiene el último elemento en la
siguiente línea. Finalmente, devolvemos la variable <code>tempMemento</code>.</p>
<p>Hasta ahora, todo se ve casi como en el ejemplo anterior. También
hablamos sobre la automatización de algunas tareas mediante el uso del
patrón Fachada, así que hagámoslo. Esto se llamará tipo <code>MementoFacade</code> y tendrá los métodos <code>SaveSettings</code>y <code>RestoreSettings</code>. El método <code>SaveSettings</code> toma a <code>Command</code>, lo almacena en un originador interno y lo guarda en un campo <code>careTaker</code> interno . El método <code>RestoreSettings</code> realiza el flujo opuesto: restaura un índice de <code>careTaker</code>y devuelve el <code>Command</code> interior del objeto <code>Memento</code>:</p>
<pre class="code"><code class="go">type MementoFacade struct {
  originator originator
  careTaker  careTaker
}

func (m *MementoFacade) SaveSettings(s Command) {
  m.originator.Command = s
  m.careTaker.Add(m.originator.NewMemento())
}

func (m *MementoFacade) RestoreSettings(i int) Command {
  m.originator.ExtractAndStoreCommand(m.careTaker.Memento(i))
  return m.originator.Command
}
</code></pre>
<p>Nuestro patrón de fachada contendrá los contenidos del creador y el
cuidador y proporcionará esos dos métodos fáciles de usar para guardar y
 restaurar la configuración.</p>
<p>Entonces, ¿cómo usamos esto?</p>
<pre class="code"><code class="go">func main(){
  m := MementoFacade{}

  m.SaveSettings(Volume(4))
  m.SaveSettings(Mute(false))
</code></pre>
<p>Primero, obtenemos una variable con un patrón Fachada. La inicialización de valor cero nos dará objetos <code>originator</code>y valores cero <code>caretaker</code>.
 No tienen ningún campo inesperado, por lo que todo se inicializará
correctamente (si alguno de ellos tiene un puntero, por ejemplo, se
inicializaría <code>nil</code> como se menciona en la sección de <i>inicialización cero</i> del <a href="https://nasciiboy.github.io/book4all/Go%20Design%20Patterns.html#chapter-1">Capítulo 1</a>, <i>Listo ... Constante ... Vaya !</i> ).</p>
<p>Creamos un valor <code>Volume</code> con <code>Volume(4)</code>y, sí, hemos usado paréntesis. El tipo <code>Volume</code>
 no tiene ningún campo interno como las estructuras, por lo que no
podemos usar llaves para establecer su valor. La forma de establecerlo
es usar paréntesis (o crear un puntero al tipo <code>Volume</code>y luego establecer el valor del espacio señalado). También guardamos un valor del tipo <code>Mute</code> usando el patrón Fachada.</p>
<p>No sabemos qué tipo <code>Command</code> se devuelve aquí, por lo que
 debemos hacer una aserción de tipo. Haremos una pequeña función para
ayudarnos con esto que verifica el tipo e imprime un valor apropiado:</p>
<pre class="code"><code class="go">func assertAndPrint(c Command){
  switch cast := c.(type) {
  case Volume:
    fmt.Printf("Volume:\t%d\n", cast)
  case Mute:
    fmt.Printf("Mute:\t%t\n", cast)
  }
}
</code></pre>
<p>El método <code>assertAndPrint</code> toma un tipo <code>Command</code> y lo arroja a los dos tipos posibles - <code>Volume</code>o <code>Mute</code>. En cada caso, imprime un mensaje a la consola con un mensaje personalizado. Ahora podemos continuar y finalizar la función <code>main</code>, que se verá así:</p>
<pre class="code"><code class="go">func main() {
  m := MementoFacade{}

  m.SaveSettings(Volume(4))
  m.SaveSettings(Mute(false))

  assertAndPrint(m.RestoreSettings(0))

  assertAndPrint(m.RestoreSettings(1))
}
</code></pre>
<p>La parte resaltada en negrita muestra los nuevos cambios dentro de la función principal. Tomamos el índice 0 del objeto <code>careTaker</code> y lo pasamos a la nueva función y lo mismo con el índice <code>1</code>. Al ejecutar este pequeño programa, debemos obtener los valores <code>Volume</code>y <code>Mute</code> en la consola:</p>
<pre class="srci"><code class="sh"><span class="in"><span class="prompt">&gt; </span>go run memento_command.go
</span><span class="out">Mute:   false
Volume: 4
</span></code></pre>
<p>¡Estupendo! En este pequeño ejemplo, hemos combinado tres patrones de
 diseño diferentes para seguir sintiéndonos cómodos usando varios
patrones. Tenga en cuenta que podríamos haber abstraído la creación de <code>Volume</code>y <code>Mute</code> establecer un patrón de Fábrica también así que no es donde se detendría.</p>
</div>
<h4 id="last-words-on-the-memento-pattern">Últimas palabras en el patrón Memento</h4>
<div class="hBody-4">
<p>Con el patrón Memento, hemos aprendido una forma poderosa de crear
operaciones intercambiables que son muy útiles cuando se escriben
aplicaciones de interfaz de usuario, pero también cuando se deben
desarrollar operaciones transaccionales. En cualquier caso, la situación
 es la misma: necesitas a <code>Memento</code>, an <code>Originator</code>y un <code>caretaker</code> actor.</p>
<div class="about">
<div class="about-dt">Tip</div>
<div class="about-dd">
<p>Una <b>operación de transacción</b> es un conjunto de operaciones
atómicas que deben realizarse o fallar. En otras palabras, si tiene una
transacción compuesta por cinco operaciones y solo una de ellas falla,
la transacción no puede completarse y cada modificación realizada por
las otras cuatro debe deshacerse.</p>
</div>
</div>
</div>
<h3 id="interpreter-design-pattern">Patrón de diseño de intérprete</h3>
<div class="hBody-3">
<p>Ahora vamos a profundizar en un patrón bastante complejo. El patrón del <b>intérprete</b>
 es, de hecho, ampliamente utilizado para resolver casos comerciales en
los que es útil tener un lenguaje para realizar operaciones comunes.
Veamos a qué nos referimos con el lenguaje.</p>
</div>
<h4 id="description">Descripción</h4>
<div class="hBody-4">
<p>El intérprete más famoso del que podemos hablar es probablemente SQL.
 Se define como un lenguaje de programación de propósito especial para
administrar datos contenidos en bases de datos relacionales. SQL es
bastante complejo y grande, pero, en definitiva, es un conjunto de
palabras y operadores que nos permiten realizar operaciones como
insertar, seleccionar o eliminar.</p>
<p>Otro ejemplo típico es la notación musical. Es un lenguaje en sí
mismo y el intérprete es el músico que conoce la conexión entre una nota
 y su representación en el instrumento que están tocando.</p>
<p>En informática, puede ser útil diseñar un lenguaje pequeño por una
variedad de razones: tareas repetitivas, lenguajes de nivel superior
para no desarrolladores o <b>Lenguajes de definición de interfaz</b> ( <span class="acronym">IDL</span> ), como <b>búferes de protocolo</b> o <b>Apache Thrift</b>.</p>
</div>
<h4 id="objectives">Objetivos</h4>
<div class="hBody-4">
<p>Diseñar un nuevo idioma, grande o pequeño, puede ser una tarea que
consume tiempo, por lo que es muy importante tener claros los objetivos
antes de invertir tiempo y recursos en escribir un intérprete de este:</p>
<ul>
<li>
<p>Proporcione sintaxis para operaciones muy comunes en algún ámbito (como tocar notas).</p>
</li>
<li>
<p>Tener un lenguaje intermedio para traducir acciones entre dos sistemas. Por ejemplo, las aplicaciones que generan el <b>Gcode</b> necesitan para imprimir con impresoras 3D.</p>
</li>
<li>
<p>Facilite el uso de algunas operaciones en una sintaxis más fácil de usar.</p>
</li>
</ul>
<p>SQL permite el uso de bases de datos relacionales en una sintaxis muy
 fácil de usar (que también puede llegar a ser increíblemente compleja),
 pero la idea es no tener que escribir sus propias funciones para
realizar inserciones y búsquedas.</p>
</div>
<h4 id="example---a-polish-notation-calculator">Ejemplo: una calculadora de notación polaca</h4>
<div class="hBody-4">
<p>Un ejemplo muy típico de un intérprete es crear una calculadora de
notación polaca inversa. Para aquellos que no saben qué es la notación
polaca, es una notación matemática para hacer operaciones donde primero
escribes tu operación (suma) y luego los valores (3 4), por lo que <span class="math">+ 3 4</span> es equivalente a los más comunes <span class="math">3 + 4</span> y su resultado sería <span class="math">7</span>. Por lo tanto, para una notación polaca inversa, primero coloca los valores y luego la operación, por lo que <i>3 4 +</i> también sería <span class="math">7</span>.</p>
</div>
<h4 id="acceptance-criteria-for-the-calculator">Criterios de aceptación para la calculadora</h4>
<div class="hBody-4">
<p>Para nuestra calculadora, los criterios de aceptación que debemos aprobar para considerarlo realizado son los siguientes:</p>
<ol class="num">
<li>
<p>Cree un lenguaje que permita realizar operaciones aritméticas comunes
 (sumas, restas, multiplicaciones y divisiones). La sintaxis es <code>sum</code> para sumas, <code>mul</code> multiplicaciones, <code>sub</code> sustracciones y <code>div</code> divisiones.</p>
</li>
<li>
<p>Debe hacerse usando notación polaca inversa.</p>
</li>
<li>
<p>El usuario debe poder escribir tantas operaciones en una fila como lo desee.</p>
</li>
<li>
<p>Las operaciones se deben realizar de izquierda a derecha.</p>
</li>
</ol>
<p>Entonces, la notación @c(3 4 sum 2 sub) es la misma que <span class="math">(3 + 4) - 2</span> y el resultado sería <i>5</i>.</p>
</div>
<h4 id="unit-test-of-some-operations">Prueba unitaria de algunas operaciones</h4>
<div class="hBody-4">
<p>En este caso, solo tendremos un método público llamado <code>Calculate</code> que toma una operación con sus valores definidos como una cadena y devolverá un valor o un error:</p>
<pre class="code"><code class="go">func Calculate(o string) (int, error) {
  return 0, fmt.Errorf("Not implemented yet")
}
</code></pre>
<p>Entonces, enviaremos una cadena de caracteres similar <q><code>3 4 +</code></q>al método <code>Calculate</code> y debería devolver <i>7, nada</i>. Dos pruebas más verificarán la implementación correcta:</p>
<pre class="code"><code class="go">func TestCalculate(t *testing.T) {
  tempOperation = "3 4 sum 2 sub"
  res, err = Calculate(tempOperation)
  if err != nil {
    t.Error(err)
  }

  if res != 5 {
    t.Errorf("Expected result not found: %d != %d\n", 5, res)
  }
</code></pre>
<p>Primero, vamos a hacer la operación que hemos usado como ejemplo. La <code>3 4 sum 2 sub</code> notación es parte de nuestro lenguaje y lo usamos en la función <code>Calculate</code>. Si se devuelve un error, la prueba falla. Finalmente, el resultado debe ser igual <code>5</code>y
 lo comprobamos en las últimas líneas. La siguiente prueba verifica el
resto de los operadores en operaciones ligeramente más complejas:</p>
<pre class="code"><code class="go">  tempOperation := "5 3 sub 8 mul 4 sum 5 div"
  res, err := Calculate(tempOperation)
  if err != nil {
    t.Error(err)
  }

  if res != 4 {
    t.Errorf("Expected result not found: %d != %d\n", 4, res)
  }
}
</code></pre>
<p>Aquí, repetimos el proceso anterior con una operación más larga, la notación <i>((((5 - 3) * 8) + 4) / 5</i> que es igual a <i>4</i>. De izquierda a derecha, sería de la siguiente manera:</p>
<div class="example-block">
<pre class="example">(((5 - 3) * 8) + 4) / 5
  ((2 * 8) + 4) / 5
    (16 + 4) / 5
      20/5
        4
</pre>
</div>
<p>¡La prueba debe fallar, por supuesto!</p>
<pre class="srci"><code class="sh"><span class="in"><span class="prompt">&gt; </span>go test -v .
</span><span class="out">  interpreter_test.go:9: Not implemented yet
  interpreter_test.go:13: Expected result not found: 4 != 0
  interpreter_test.go:19: Not implemented yet
  interpreter_test.go:23: Expected result not found: 5 != 0
exit status 1
FAIL
</span></code></pre>
</div>
<h4 id="implementation">Implementación</h4>
<div class="hBody-4">
<p>La implementación va a ser más larga que la prueba esta vez. Para
comenzar, definiremos nuestros posibles operadores en constantes:</p>
<pre class="code"><code class="go">const (
  SUM = "sum"
  SUB = "sub"
  MUL = "mul"
  DIV = "div"
)
</code></pre>
<p>Los patrones de intérprete generalmente se implementan usando un
árbol de sintaxis abstracta, algo que comúnmente se logra usando una
pila. Hemos creado montones antes durante el libro, por lo que esto ya
debería ser familiar para los lectores:</p>
<pre class="code"><code class="go">type polishNotationStack []int

func (p *polishNotationStack) Push(s int) {
  *p = append(*p, s)
}

func (p *polishNotationStack) Pop() int {
  length := len(*p)

  if length &gt; 0 {
    temp := (*p)[length-1]
    *p = (*p)[:length-1]
    return temp
  }

  return 0
}
</code></pre>
<p>Tenemos dos métodos: el método <code>Push</code> para agregar elementos a la parte superior de la pila y el método <code>Pop</code> para eliminar elementos y devolverlos. En caso de que piense que la línea <code>*p = (*p)[:length-1]</code> es un poco críptica, lo explicaremos.</p>
<p>El valor almacenado en la dirección de <code>p</code> será anulado con el valor real en la dirección de, <code>p (*p)</code> pero tomando solo los elementos desde el principio hasta el penúltimo elemento de la matriz <code>(:length-1)</code>.</p>
<p>Entonces, ahora vamos a ir paso a paso con la función <code>Calculate</code>, creando más funciones en la medida en que las necesitemos:</p>
<pre class="code"><code class="go">func Calculate(o string) (int, error) {
  stack := polishNotationStack{}
  operators := strings.Split(o, " ")
</code></pre>
<p>Las dos primeras cosas que debemos hacer es crear la pila y obtener
todos los símbolos diferentes de la operación entrante (en este caso, no
 estamos verificando que no esté vacía). Dividimos las operaciones de
cadena entrantes por el espacio para obtener una buena porción de
símbolos (valores y operadores).</p>
<p>A continuación, iteraremos sobre cada símbolo mediante el uso del
rango, pero necesitamos una función para saber si el símbolo entrante es
 un valor o un operador:</p>
<pre class="code"><code class="go">func isOperator(o string) bool {
  if o == SUM || o == SUB || o == MUL || o == DIV {
    return true
  }

  return false
}
</code></pre>
<p>Si el símbolo entrante es alguno de los definidos en nuestras constantes, el símbolo entrante es un operador:</p>
<pre class="code"><code class="go">func Calculate(o string) (int, error) {
  stack := polishNotationStack{}
  operators := strings.Split(o, " ")

  for _, operatorString := range operators {

    if isOperator(operatorString) {
      right := stack.Pop()
      left  := stack.Pop()
    } else {
      // Is a value
    }
  }
</code></pre>
<p>Si es un operador, consideramos que ya hemos pasado dos valores,
entonces lo que tenemos que hacer es tomar esos dos valores de la pila.
El primer valor tomado sería el más a la derecha y el segundo a la
izquierda (recuerde que en las restas y divisiones, el orden de los
operandos es importante). Entonces, necesitamos alguna función para
obtener la operación que queremos realizar:</p>
<pre class="code"><code class="go">func getOperationFunc(o string) func(a, b int) int {
  switch o {
  case SUM:
    return func(a, b int) int {
      return a + b
    }
  case SUB:
    return func(a, b int) int {
      return a - b
    }
  case MUL:
    return func(a, b int) int {
      return a * b
    }
  case DIV:
    return func(a, b int) int {
      return a / b
    }
  }
  return nil
}
</code></pre>
<p>Las funciones <code>getOperationFunc</code> devuelven una función de
dos argumentos que devuelve un número entero. Comprobamos el operador
entrante y devolvemos una función anónima que realiza la operación
especificada. Entonces, ahora nuestro <code>for range</code> sigue así:</p>
<pre class="code"><code class="go">func Calculate(o string) (int, error) {
  stack := polishNotationStack{}
  operators := strings.Split(o, " ")

  for _, operatorString := range operators {
    if isOperator(operatorString) {
      right := stack.Pop()
      left := stack.Pop()
      mathFunc := getOperationFunc(operatorString)
      res := mathFunc(left, right)
      stack.Push(res)
    } else {
      // Is a value
    }
  }
</code></pre>
<p>La variable <code>mathFunc</code> es devuelta por la función. Lo
usamos inmediatamente para realizar la operación en los valores
izquierdo y derecho tomados de la pila y almacenamos su resultado en una
 nueva variable llamada <code>res</code>. Finalmente, necesitamos impulsar este nuevo valor a la pila para seguir trabajando con ella más adelante.</p>
<p>Ahora, aquí está la implementación cuando el símbolo entrante es un valor:</p>
<pre class="code"><code class="go">func Calculate(o string) (int, error) {
  stack := polishNotationStack{}
  operators := strings.Split(o, " ")

  for _, operatorString := range operators {
    if isOperator(operatorString) {
      right := stack.Pop()
      left := stack.Pop()
      mathFunc := getOperationFunc(operatorString)
      res := mathFunc(left, right)
      stack.Push(res)
    } else {
      val, err := strconv.Atoi(operatorString)

      if err != nil {
        return 0, err
      }

      stack.Push(val)
    }
  }
</code></pre>
<p>Lo que tenemos que hacer cada vez que obtenemos un símbolo es
empujarlo a la pila. Tenemos que analizar el símbolo de cadena a un tipo
 <code>int</code> utilizable . Esto se hace comúnmente con el paquete <code>strconv</code> al usar su función <code>Atoi</code>. La función <code>Atoi</code> toma una cadena y devuelve un entero de ella o un error. Si todo va bien, el valor se empuja a la pila.</p>
<p>Al final del <code>range</code> enunciado, solo debe almacenarse un valor en él, de modo que solo debemos devolverlo y la función está lista:</p>
<pre class="code"><code class="go">func Calculate(o string) (int, error) {
  stack := polishNotationStack{}
  operators := strings.Split(o, " ")

  for _, operatorString := range operators {
    if isOperator(operatorString) {
      right := stack.Pop()
      left := stack.Pop()
      mathFunc := getOperationFunc(operatorString)
      res := mathFunc(left, right)
      stack.Push(res)
    } else {
      val, err := strconv.Atoi(operatorString)
      if err != nil {
        return 0, err
      }

      stack.Push(val)
    }
  }
  return int(stack.Pop()), nil
}
</code></pre>
<p>Hora de volver a ejecutar las pruebas:</p>
<pre class="srci"><code class="sh"><span class="in"><span class="prompt">&gt; </span>go test -v .
</span><span class="out">ok
</span></code></pre>
<p>¡Estupendo! Acabamos de crear un intérprete de notación polaca
inversa de una manera muy simple y fácil (todavía nos falta el
analizador sintáctico, pero esa es otra historia).</p>
</div>
<h4 id="complexity-with-the-interpreter-design-pattern">Complejidad con el patrón de diseño del intérprete</h4>
<div class="hBody-4">
<p>En este ejemplo, no hemos usado ninguna interfaz. Esta no es
exactamente la forma en que se define el patrón de diseño del Intérprete
 en más lenguajes orientados a objetos. Sin embargo, este ejemplo es el
ejemplo más simple posible para comprender los objetivos del lenguaje y
el siguiente nivel es inevitablemente mucho más complejo y no está
destinado a usuarios principiantes.</p>
<p>Con un ejemplo más complejo, tendremos que definir un tipo que
contenga más tipos de sí mismo, un valor o nada. Con un analizador, crea
 este árbol de sintaxis abstracta para interpretarlo más tarde.</p>
<p>El mismo ejemplo, hecho mediante el uso de interfaces, sería como en la siguiente sección de descripción.</p>
</div>
<h4 id="interpreter-pattern-again---now-using-interfaces">Patrón de intérprete nuevamente - ahora usando interfaces</h4>
<div class="hBody-4">
<p>La interfaz principal que vamos a usar se llama interfaz <code>Interpreter</code>. Esta interfaz tiene un método <code>Read()</code> que cada símbolo (valor u operador) debe implementar:</p>
<pre class="code"><code class="go">type Interpreter interface {
  Read() int
}
</code></pre>
<p>Implementaremos solo la suma y la resta de los operadores y un tipo llamado <code>Value</code> para los números:</p>
<pre class="code"><code class="go">type value int

func (v *value) Read() int {
  return int(*v)
}
</code></pre>
<p>El <code>Value</code> es un tipo <code>int</code> que, al implementar el método <code>Read</code>, simplemente devuelve su valor:</p>
<pre class="code"><code class="go">type operationSum struct {
  Left  Interpreter
  Right Interpreter
}

func (a *operationSum) Read() int {
  return a.Left.Read() + a.Right.Read()
}
</code></pre>
<p>La estructura <code>operationSum</code> tiene las <code>Left</code>y los campos <code>Right</code> y su método <code>Read</code> devuelve la suma de cada uno de sus métodos <code>Read</code>. La estructura <code>operationSubtract</code> es la misma pero resta:</p>
<pre class="code"><code class="go">type operationSubtract struct {
  Left  Interpreter
  Right Interpreter
}

func (s *operationSubtract) Read() int {
  return s.Left.Read() - s.Right.Read()
}
</code></pre>
<p>También necesitamos un patrón Factory para crear operadores; lo llamaremos el método <code>operatorFactory</code>. La diferencia ahora es que no solo acepta el símbolo sino también los valores <code>Left</code>y <code>Right</code> tomados de la pila:</p>
<pre class="code"><code class="go">func operatorFactory(o string, left, right Interpreter) Interpreter {
  switch o {
  case SUM:
    return &amp;operationSum{
      Left: left,
      Right: right,
    }
  case SUB:
    return &amp;operationSubtract{
      Left: left,
      Right: right,
    }
  }

  return nil
}
</code></pre>
<p>Como acabamos de mencionar, también necesitamos una pila. Podemos reutilizar el del ejemplo anterior cambiando su tipo:</p>
<pre class="code"><code class="go">type polishNotationStack []Interpreter

func (p *polishNotationStack) Push(s Interpreter) {
  *p = append(*p, s)
}

func (p *polishNotationStack) Pop() Interpreter {
  length := len(*p)

  if length &gt; 0 {
    temp := (*p)[length-1]
    *p = (*p)[:length-1]
    return temp
  }

  return nil
}
</code></pre>
<p>Ahora la pila funciona con punteros de Intérprete en lugar de <code>int</code> pero su funcionalidad es la misma. Finalmente, nuestro método <code>main</code> también se ve similar a nuestro ejemplo anterior:</p>
<pre class="code"><code class="go">func main() {
  stack := polishNotationStack{}
  operators := strings.Split("3 4 sum 2 sub", " ")

  for _, operatorString := range operators {
    if operatorString == SUM || operatorString == SUB {
      right := stack.Pop()
      left := stack.Pop()
      mathFunc := operatorFactory(operatorString, left, right)
      res := value(mathFunc.Read())
      stack.Push(&amp;res)
    } else {
      val, err := strconv.Atoi(operatorString)
      if err != nil {
        panic(err)
      }

      temp := value(val)
      stack.Push(&amp;temp)
    }
  }

  println(int(stack.Pop().Read()))
}
</code></pre>
<p>Al igual que antes, comprobamos si el símbolo es primero el operador o el valor. Cuando es un valor, lo empuja a la pila.</p>
<p>Cuando el símbolo es un operador, también tomamos los valores de la
pila de derecha e izquierda, llamamos el patrón de Fábrica usando el
operador actual y los valores de izquierda y derecha que acabamos de
tomar de la pila. Una vez que tenemos el tipo de operador, solo
necesitamos llamar a su método <code>Read</code> para enviar el valor devuelto a la pila también.</p>
<p>Finalmente, solo debe quedar un ejemplo en la pila, así que lo imprimimos:</p>
<pre class="srci"><code class="sh"><span class="in"><span class="prompt">&gt; </span>go run interpreter.go
</span><span class="out">5
</span></code></pre>
</div>
<h4 id="the-power-of-the-interpreter-pattern">El poder del patrón de intérprete</h4>
<div class="hBody-4">
<p>Este patrón es extremadamente poderoso pero también debe usarse con
cuidado. Para crear un idioma, genera un fuerte acoplamiento entre sus
usuarios y la funcionalidad que proporciona. Uno puede caer en el error
de tratar de crear un lenguaje demasiado flexible que sea increíblemente
 complejo de usar y mantener. Además, uno puede crear un lenguaje
bastante pequeño y útil que no se interpreta correctamente a veces y
podría ser un problema para sus usuarios.</p>
<p>En nuestro ejemplo, hemos omitido una gran cantidad de comprobación
de errores para centrarnos en la implementación del intérprete. Sin
embargo, necesitará una gran cantidad de comprobación de errores y
salida detallada en los errores para ayudar al usuario a corregir sus
errores de sintaxis. Por lo tanto, diviértete escribiendo tu idioma,
pero sé amable con tus usuarios.</p>
</div>
<h3 id="summary">Resumen</h3>
<div class="hBody-3">
<p>Este capítulo ha tratado tres patrones extremadamente poderosos que
requieren mucha práctica antes de usarlos en el código de producción. Es
 una muy buena idea hacer algunos ejercicios simulando problemas típicos
 de producción:</p>
<ul>
<li>
<p>Cree un servidor REST simple que reutilice la mayor parte de la
funcionalidad de comprobación de errores y conexión para proporcionar
una interfaz fácil de usar para practicar el patrón de Plantilla</p>
</li>
<li>
<p>Cree una pequeña biblioteca que pueda escribir en diferentes bases de
 datos, pero solo en el caso de que todas las escrituras estén
correctas, o elimine las escrituras recién creadas para practicar
Memento por ejemplo</p>
</li>
<li>
<p>Escribe tu propio idioma, para hacer cosas simples como responder
preguntas simples, como suelen hacer los bots, para que puedas practicar
 un poco el patrón del intérprete.</p>
</li>
</ul>
<p>La idea es practicar la codificación y volver a leer cualquier sección hasta que te sientas cómodo con cada patrón.</p>
</div>
<h3 id="chapter-7.-behavioral-patterns---visitor,-state,-mediator,-and-observer-design-patterns">Capítulo 7. Patrones de comportamiento: patrones de diseño de visitante, estado, mediador y observador</h3>
<div class="hBody-3">
<p>Este es el último capítulo sobre patrones de comportamiento y también
 cierra la sección de este libro sobre patrones de diseño comunes y bien
 conocidos en el lenguaje Go.</p>
<p>En este capítulo, vamos a ver otros tres patrones de diseño. El
patrón de visitante es muy útil cuando desea abstraer algunas
funcionalidades de un conjunto de objetos.</p>
<p>El estado se usa comúnmente para construir <b>máquinas de estados finitos</b> ( <span class="acronym">FSM</span> ) y, en esta sección, desarrollaremos un pequeño juego de <i>números</i>.</p>
<p>Finalmente, el patrón Observer se usa comúnmente en arquitecturas
basadas en eventos y está ganando mucha tracción nuevamente,
especialmente en el mundo de los microservicios.</p>
<p>Después de este capítulo, necesitaremos sentirnos muy cómodos con los
 patrones de diseño comunes antes de investigar la concurrencia y las
ventajas (y complejidad) que aporta a los patrones de diseño.</p>
</div>
<h4 id="visitor-design-pattern">Patrón de diseño de visitante</h4>
<div class="hBody-4">
<p>En el siguiente patrón de diseño, vamos a delegar alguna lógica del
tipo de un objeto a un tipo externo llamado el visitante que visitará
nuestro objeto para realizar operaciones en él.</p>
</div>
<h4 id="description">Descripción</h4>
<div class="hBody-4">
<p>En el patrón de diseño de visitante, estamos tratando de separar la
lógica necesaria para trabajar con un objeto específico fuera del objeto
 mismo. Entonces podríamos tener muchos visitantes diferentes que hacen
algunas cosas a tipos específicos.</p>
<p>Por ejemplo, imagine que tenemos un escritor de registro que escribe
en la consola. Podríamos hacer que el registrador sea "visitable" para
que pueda anteponer cualquier texto a cada registro. Podríamos escribir
un patrón de Visitante que prefiera la fecha, la hora y el nombre de
host a un campo almacenado en el objeto.</p>
</div>
<h4 id="objectives">Objetivos</h4>
<div class="hBody-4">
<p>Con los patrones de diseño de comportamiento, nos ocupamos
principalmente de algoritmos. Los patrones de visitantes no son una
excepción. Los objetivos que estamos tratando de lograr son los
siguientes:</p>
<ul>
<li>
<p>Para separar el algoritmo de algún tipo de su implementación dentro de otro tipo</p>
</li>
<li>
<p>Para mejorar la flexibilidad de algunos tipos utilizándolos con poca o
 ninguna lógica para que todas las nuevas funcionalidades puedan
agregarse sin alterar la estructura del objeto</p>
</li>
<li>
<p>Para arreglar una estructura o comportamiento que rompería el principio abierto / cerrado en un tipo</p>
</li>
</ul>
<p>Usted podría estar pensando cuál es el principio abierto / cerrado.
En ciencias de la computación, el principio de abierto / cerrado
establece que: las <i>entidades deben estar abiertas para la </i> <i>extensión, pero cerradas para su modificación</i>.
 Este estado simple tiene muchas implicaciones que permiten crear un
software más fácil de mantener y menos propenso a errores. Y el patrón
Visitor nos ayuda a delegar algunos algoritmos comúnmente cambiantes de
un tipo que necesitamos que sean "estables" a un tipo externo que puede
cambiar a menudo sin afectar nuestro original.</p>
</div>
<h4 id="a-log-appender">Un apéndice de registro</h4>
<div class="hBody-4">
<p>Vamos a desarrollar un apéndice de registro simple como un ejemplo
del patrón Visitor. Siguiendo el enfoque que hemos tenido en los
capítulos anteriores, comenzaremos con un ejemplo extremadamente simple
para comprender claramente cómo funciona el patrón de diseño del
Visitante antes de pasar a uno más complejo. Ya hemos desarrollado
ejemplos similares modificando textos también, pero de maneras
ligeramente diferentes.</p>
<p>Para este ejemplo en particular, crearemos un visitante que añada información diferente a los tipos que "visita".</p>
</div>
<h4 id="acceptance-criteria">Criterios de aceptación</h4>
<div class="hBody-4">
<p>Para utilizar efectivamente el patrón de diseño del visitante, debemos tener dos roles: un visitante y un visitante. El <code>Visitor</code> es el tipo que actuará dentro de un tipo <code>Visitable</code>. Entonces, una implementación <code>Visitable</code> de interfaz tiene un algoritmo separado para el tipo <code>Visitor</code>:</p>
<ol class="num">
<li>
<p>Necesitamos dos registradores de mensajes: <code>MessageA</code>y <code>MessageB</code> eso imprimirá un mensaje con un <code>A</code>: o a <code>B</code>: respectivamente antes del mensaje.</p>
</li>
<li>
<p>Necesitamos un Visitante capaz de modificar el mensaje para imprimir.
 Agregará el texto "Visitados A" o "Visitados B", respectivamente.</p>
</li>
</ol>
</div>
<h4 id="unit-tests">Pruebas unitarias</h4>
<div class="hBody-4">
<p>Como mencionamos anteriormente, necesitaremos un rol para el <code>Visitor</code>y las <code>Visitable</code> interfaces. Ellos serán interfaces. También necesitamos el <code>MessageA</code>y estructuras <code>MessageB</code>:</p>
<pre class="code"><code class="go">package visitor

import (
  "io"
  "os"
  "fmt"
)

type MessageA struct {
  Msg string
  Output io.Writer
}

type MessageB struct {
  Msg string
  Output io.Writer
}

type Visitor interface {
  VisitA(*MessageA)
  VisitB(*MessageB)
}

type Visitable interface {
  Accept(Visitor)
}

type @c(MessageVisitor) struct {}
</code></pre>
<p>Los tipos <code>MessageA</code>y las estructuras <code>MessageB</code> tienen un campo <code>Msg</code> para almacenar el texto que van a imprimir. La salida <code>io.Writer</code> implementará la interfaz <code>os.Stdout</code> por defecto o una nuevainterfaz <code>io.Writer</code>, como la que usaremos para verificar que los contenidos sean correctos.</p>
<p>La interfaz <code>Visitor</code> tiene un método <code>Visit</code>, uno para cada interfaz <code>Visitable</code> <code>MessageA</code>y tipo <code>MessageB</code>. La interfaz <code>Visitable</code> tiene un método llamado <code>Accept(Visitor)</code> que ejecutará el algoritmo desacoplado.</p>
<p>Al igual que en los ejemplos anteriores, crearemos un tipo que implemente el paquete <code>io.Writer</code> para que podamos usarlo en las pruebas:</p>
<pre class="code"><code class="go">package visitor

import "testing"

type TestHelper struct {
  Received string
}

func (t *TestHelper) Write(p []byte) (int, error) {
  t.Received = string(p)
  return len(p), nil
}
</code></pre>
<p>La estructura <code>TestHelper</code> implementa la interfaz <code>io.Writer</code>.
 Su funcionalidad es bastante simple; almacena los bytes escritos en el
campo Recibido. Más tarde podemos verificar el contenido de <code>Received</code> para probar contra nuestro valor esperado.</p>
<p>Escribiremos una sola prueba que verificará la corrección general del
 código. Dentro de esta prueba, escribiremos dos pruebas secundarias:
una para <code>MessageA</code>y otra para tipos <code>MessageB</code>:</p>
<pre class="code"><code class="go">func Test_Overall(t *testing.T) {
  testHelper := &amp;TestHelper{}
  visitor := &amp;MessageVisitor{}
  ...
}
</code></pre>
<p>Usaremos una estructura <code>TestHelper</code> y una estructura <code>MessageVisitor</code> en cada prueba para cada tipo de mensaje. Primero, probaremos el tipo <code>MessageA</code>:</p>
<pre class="code"><code class="go">func Test_Overall(t *testing.T) {
  testHelper := &amp;TestHelper{}
  visitor := &amp;MessageVisitor{}

  t.Run("MessageA test", func(t *testing.T){
    msg := MessageA{
      Msg: "Hello World",
      Output: testHelper,
    }

    msg.Accept(visitor)
    msg.Print()

    expected := "A: Hello World (Visited A)"
    if testHelper.Received !=  expected {
      t.Errorf("Expected result was incorrect. %s != %s",
      testHelper.Received, expected)
    }
  })
  ...
}
</code></pre>
<p>Esta es la primera prueba completa. Creamos <code>MessageA</code> struct, dándole un valor <code>Hello World</code> para el campo <code>Msg</code> y el puntero a <code>TestHelper</code>, que creamos al comienzo de la prueba. Luego, ejecutamos su método Aceptar. Dentro del método <code>Accept(Visitor)</code> en la estructura <code>MessageA</code>, el método <code>VisitA(*MessageA)</code> se ejecuta para alterar el contenido del campo Msg (es por eso que pasamos el puntero al método <code>VisitA</code>, sin un puntero el contenido no se mantendrá).</p>
<p>Para comprobar si el tipo <code>Visitor</code> ha hecho su trabajo dentro del método <code>Accept</code>, debemos llamar al método <code>Print()</code> <code>MessageA</code>más tarde. De esta manera, la estructura <code>MessageA</code> debe escribir el contenido de <code>Msg</code> la interfaz <code>io.Writer</code> proporcionada (nuestra<code>TestHelper</code> ).</p>
<p>La última parte de la prueba es el cheque. De acuerdo con la descripción de los <i>criterios</i> de <i>aceptación 2</i>, el texto de salida de tipo <code>MessageA</code> debe ir precedido del texto A :, el mensaje almacenado y el texto <q><code>(Visited)</code></q>justo al final. Entonces, para el tipo <code>MessageA</code>, el texto esperado debe ser <q><code>A: Hello World (Visited)</code></q>, este es el cheque que hicimos en la <code>if</code> sección.</p>
<p>El tipo <code>MessageB</code> tiene una implementación muy similar:</p>
<pre class="code"><code class="go">  t.Run("MessageB test", func(t *testing.T){
    msg := MessageB {
      Msg: "Hello World",
      Output: testHelper,
    }

    msg.Accept(visitor)
    msg.Print()

    expected := "B: Hello World (Visited B)"
    if testHelper.Received !=  expected {
      t.Errorf("Expected result was incorrect. %s != %s",
        testHelper.Received, expected)
    }
  })
}
</code></pre>
<p>De hecho, acabamos de cambiar el tipo de <code>MessageA</code>a <code>MessageB</code>y el texto esperado ahora es <q><code>B: Hello World (Visited B)</code></q>. El campo <code>Msg</code> también es <q><code>Hello World</code></q>y también usamos el tipo <code>TestHelper</code>.</p>
<p>Todavía nos faltan las implementaciones correctas de las interfaces para compilar el código y ejecutar las pruebas. Las <code>MessageA</code>y las estructuras <code>MessageB</code> tienen que implementar el método <code>Accept(Visitor)</code>:</p>
<pre class="code"><code class="go">func (m *MessageA) Accept(v Visitor) {
  // Do nothing
}

func (m *MessageB) Accept(v Visitor) {
  // Do nothing
}
</code></pre>
<p>Necesitamos las implementaciones de los métodos <code>VisitA(*MessageA)</code>y <code>VisitB(*MessageB)</code> que están declarados en la interfaz <code>Visitor</code>. La interfaz <code>MessageVisitor</code> es el tipo que debe implementarlos:</p>
<pre class="code"><code class="go">func (mf *MessageVisitor) VisitA(m *MessageA){
  // Do nothing
}
func (mf *MessageVisitor) VisitB(m *MessageB){
  // Do nothing
}
</code></pre>
<p>Finalmente, crearemos un método <code>Print()</code> para cada tipo de mensaje. Este es el método que usaremos para probar el contenido del campo <code>Msg</code> en cada tipo:</p>
<pre class="code"><code class="go">func (m *MessageA) Print(){
  // Do nothing
}

func (m *MessageB) Print(){
  // Do nothing
}
</code></pre>
<p>Ahora podemos ejecutar las pruebas para comprobar realmente si todavía están fallando:</p>
<pre class="srci"><code class="sh"><span class="in"><span class="prompt">&gt; </span>go test -v .
</span><span class="out">=== RUN   Test_Overall
=== RUN   Test_Overall/MessageA_test
=== RUN   Test_Overall/MessageB_test
--- FAIL: Test_Overall (0.00s)
  --- FAIL: Test_Overall/MessageA_test (0.00s)
      visitor_test.go:30: Expected result was incorrect.  != A:
Hello World (Visited A)
  --- FAIL: Test_Overall/MessageB_test (0.00s)
      visitor_test.go:46: Expected result was incorrect.  != B:
Hello World (Visited B)
FAIL
exit status 1
FAIL
</span></code></pre>
<p>Los resultados de las pruebas son claros. Los mensajes esperados eran
 incorrectos porque los contenidos estaban vacíos. Es hora de crear las
implementaciones.</p>
</div>
<h3 id="implementation-of-visitor-pattern">Implementación del patrón de visitante</h3>
<div class="hBody-3">
<p>Comenzaremos a completar la implementación de VisitA (* MessageA) y los métodos <code>VisitB(*MessageB)</code>:</p>
<pre class="code"><code class="go">func (mf *MessageVisitor) VisitA(m *MessageA){
  m.Msg = fmt.Sprintf("%s %s", m.Msg, "(Visited A)")
}

func (mf *MessageVisitor) VisitB(m *MessageB){
  m.Msg = fmt.Sprintf("%s %s", m.Msg, "(Visited B)")
}
</code></pre>
<p>Su funcionalidad es bastante sencillo - el método <code>fmt.Sprintf</code> devuelve una cadena con formato con el contenido real de <code>m.Msg</code>, un espacio en blanco, y el mensaje, <code>Visited</code>. Esta cadena se almacenará en el campo <code>Msg</code>, anulando los contenidos anteriores.</p>
<p>Ahora desarrollaremos el método <code>Accept</code> para cada tipo de mensaje que debe ejecutar el visitante correspondiente:</p>
<pre class="code"><code class="go">func (m *MessageA) Accept(v Visitor) {
  v.VisitA(m)
}

func (m *MessageB) Accept(v Visitor) {
  v.VisitB(m)
}
</code></pre>
<p>Este pequeño código tiene algunas implicaciones en él. En ambos casos, estamos usando a <code>Visitor</code>, que en nuestro ejemplo es exactamente lo mismo que la interfaz <code>MessageVisitor</code>, pero podrían ser completamente diferentes. La clave es entender que el patrón Visitor ejecuta un algoritmo en su método <code>Visit</code> que trata con el objeto <code>Visitable</code>. ¿Qué podría <code>Visitor</code> estar haciendo? En este ejemplo, altera el objeto <code>Visitable</code>, pero podría ser simplemente obtener información de él. Por ejemplo, podríamos tener un tipo <code>Person</code>
 con muchos campos: nombre, apellido, edad, dirección, ciudad, código
postal, etc. Podríamos escribir un Visitante para obtener solo el nombre
 y el apellido de una persona como una cadena única, un visitante para
obtener la información de la dirección para una sección diferente de una
 aplicación, y así sucesivamente.</p>
<p>Finalmente, existe el método <code>Print()</code>, que nos ayudará a probar los tipos. Anteriormente mencionamos que debe imprimir a la llamada <code>Stdout</code> por defecto:</p>
<pre class="code"><code class="go">func (m *MessageA) Print() {
  if m.Output == nil {
    m.Output = os.Stdout
  }

  fmt.Fprintf(m.Output, "A: %s", m.Msg)
}

func (m *MessageB) Print() {
  if m.Output == nil {
    m.Output = os.Stdout
  }
  fmt.Fprintf(m.Output, "B: %s", m.Msg)
}
</code></pre>
<p>Primero verifica el contenido del campo <code>Output</code> para asignar la salida de la llamada <code>os.Stdout</code> en caso de que sea nula. En nuestras pruebas, estamos almacenando un puntero a nuestro tipo <code>TestHelper</code> por lo que esta línea nunca se ejecuta en nuestra prueba. Finalmente, cada tipo de mensaje se imprime en el campo <code>Output</code>, el mensaje completo almacenado en el campo <code>Msg</code>. Esto se hace utilizando el método <code>Fprintf</code>, que toma un paquete <code>io.Writer</code> como primer argumento y el texto para formatear como los siguientes argumentos.</p>
<p>Nuestra implementación ahora está completa y podemos ejecutar las pruebas nuevamente para ver si todas pasan ahora:</p>
<pre class="srci"><code class="sh"><span class="in"><span class="prompt">&gt; </span>go test -v .
</span><span class="out">=== RUN   Test_Overall
=== RUN   Test_Overall/MessageA_test
=== RUN   Test_Overall/MessageB_test
--- PASS: Test_Overall (0.00s)
  --- PASS: Test_Overall/MessageA_test (0.00s)
  --- PASS: Test_Overall/MessageB_test (0.00s)
PASS
ok
</span></code></pre>
<p>¡Todo está bien! El patrón de visitante ha hecho su trabajo sin
problemas y los contenidos del mensaje han sido alterados después de
llamar a sus métodos <code>Visit</code>. Lo más importante aquí es que podemos agregar más funcionalidad a las estructuras <code>MessageA</code>y <code>MessageB</code>, sin alterar sus tipos. Solo podemos crear un nuevo tipo de Visitante que haga todo lo posible <code>Visitable</code>, por ejemplo, podemos crear un <code>Visitor</code> para agregar un método que imprima los contenidos del campo <code>Msg</code>:</p>
<pre class="code"><code class="go">type MsgFieldVisitorPrinter struct {}

func (mf *MsgFieldVisitorPrinter) VisitA(m *MessageA){
  fmt.Printf(m.Msg)
}
func (mf *MsgFieldVisitorPrinter) VisitB(m *MessageB){
  fmt.Printf(m.Msg)
}
</code></pre>
<p>¡Hemos agregado algunas funcionalidades a ambos tipos sin alterar sus
 contenidos! Ese es el poder del patrón de diseño del visitante.</p>
</div>
<h4 id="another-example">Otro ejemplo</h4>
<div class="hBody-4">
<p>Desarrollaremos un segundo ejemplo, este un poco más complejo. En
este caso, emularemos una tienda en línea con algunos productos. Los
productos tendrán tipos simples, con solo campos y haremos un par de
visitantes para tratarlos en el grupo.</p>
<p>En primer lugar, desarrollaremos las interfaces. El tipo <code>ProductInfoRetriever</code> tiene un método para obtener el precio y el nombre del producto. La interfaz <code>Visitor</code>, como antes, tiene un método <code>Visit</code> que acepta el tipo <code>ProductInfoRetriever</code>. Finalmente, la interfaz <code>Visitable</code> es exactamente la misma; tiene un método <code>Accept</code> que toma un tipo <code>Visitor</code> como argumento:</p>
<pre class="code"><code class="go">type ProductInfoRetriever interface {
  GetPrice() float32
  GetName() string
}

type Visitor interface {
  Visit(ProductInfoRetriever)
}

type Visitable interface {
  Accept(Visitor)
}
</code></pre>
<p>Todos los productos de la tienda en línea deben implementar el tipo <code>ProductInfoRetriever</code>. Además, la mayoría de los productos tendrán algunos campos comunes, como el nombre o el precio (los definidos en la interfaz <code>ProductInfoRetriever</code>). Creamos el tipo <code>Product</code>, implementamos el <code>ProductInfoRetriever</code>y las <code>Visitable</code> interfaces, y lo incorporamos en cada producto:</p>
<pre class="code"><code class="go">type Product struct {
  Price float32
  Name  string
}

func (p *Product) GetPrice() float32 {
  return p.Price
}

func (p *Product) Accept(v Visitor) {
  v.Visit(p)
}

func (p *Product) GetName() string {
  return p.Name
}
</code></pre>
<p>Ahora tenemos un tipo <code>Product</code> muy genérico que puede almacenar la información sobre casi cualquier producto de la tienda. Por ejemplo, podríamos tener a <code>Rice</code>y un <code>Pasta</code> producto:</p>
<pre class="code"><code class="go">type Rice struct {
  Product
}

type Pasta struct {
  Product
}
</code></pre>
<p>Cada uno tiene el tipo <code>Product</code> incrustado. Ahora tenemos que crear un par de <code>Visitors</code> interfaces, una que suma el precio de todos los productos y otra que imprime el nombre de cada producto:</p>
<pre class="code"><code class="go">type PriceVisitor struct {
  Sum float32
}

func (pv *PriceVisitor) Visit(p ProductInfoRetriever) {
  pv.Sum += p.GetPrice()
}

type NamePrinter struct {
  ProductList string
}

func (n *NamePrinter) Visit(p ProductInfoRetriever) {
  n.Names = fmt.Sprintf("%s\n%s", p.GetName(), n.ProductList)
}
</code></pre>
<p>La estructura <code>PriceVisitor</code> toma el valor de la variable <code>Price</code> del tipo <code>ProductInfoRetriever</code>, pasado como argumento, y lo agrega al campo <code>Sum</code>. La estructura <code>NamePrinter</code> almacena el nombre del tipo <code>ProductInfoRetriever</code>, pasado como argumento, y lo agrega a una nueva línea en el campo <code>ProductList</code>.</p>
<p>Tiempo para la función <code>main</code>:</p>
<pre class="code"><code class="go">func main() {
  products := make([]Visitable, 2)
  products[0] = &amp;Rice{
    Product: Product{
      Price: 32.0,
      Name:  "Some rice",
    },
  }
  products[1] = &amp;Pasta{
    Product: Product{
      Price: 40.0,
      Name:  "Some pasta",
    },
  }

  // Print the sum of prices
  priceVisitor := &amp;PriceVisitor{}

  for _, p := range products {
    p.Accept(priceVisitor)
  }

  fmt.Printf("Total: %f\n", priceVisitor.Sum)

  // Print the products list
  nameVisitor := &amp;NamePrinter{}

  for _, p := range products {
    p.Accept(nameVisitor)
  }

  fmt.Printf("\nProduct list:\n-------------\n%s", nameVisitor.ProductList)
}
</code></pre>
<p>Creamos una porción de dos objetos <code>Visitable</code>: a <code>Rice</code>y un tipo <code>Pasta</code> con algunos nombres arbitrarios. Luego iteramos para cada uno de ellos usando una instancia <code>PriceVisitor</code> como argumento. Imprimimos el precio total después del rango para. Finalmente, repetimos esta operación con <code>NamePrinter</code>e imprimimos el resultado <code>ProductList</code>. La salida de esta función <code>main</code> es la siguiente:</p>
<pre class="srci"><code class="sh"><span class="in"><span class="prompt">&gt; </span>go run visitor.go
</span><span class="out">Total: 72.000000
Product list:
-------------
Some pasta
Some rice
</span></code></pre>
<p>Ok, este es un buen ejemplo del <code>Visitor</code> patrón, pero ...
 ¿y si hay consideraciones especiales sobre un producto? Por ejemplo,
¿qué pasa si necesitamos sumar 20 al precio total de un tipo de nevera?
OK, escribamos la estructura <code>Fridge</code>:</p>
<pre class="code"><code class="go">type Fridge struct {
  Product
}
</code></pre>
<p>La idea aquí es simplemente anular el método <code>GetPrice()</code> para devolver el precio del producto más 20:</p>
<pre class="code"><code class="go">type Fridge struct {
  Product
}

func (f *Fridge) GetPrice() float32 {
  return f.Product.Price + 20
}
</code></pre>
<p>Desafortunadamente, esto no es suficiente para nuestro ejemplo. La estructura <code>Fridge</code> no es de un   tipo <code>Visitable</code>. La estructura <code>Product</code> es de un tipo <code>Visitable</code> y la estructura <code>Fridge</code> tiene una estructura <code>Product</code>
 incrustada pero, como mencionamos en capítulos anteriores, un tipo que
incrusta un segundo tipo no puede considerarse de este último tipo,
incluso si tiene todos sus campos y métodos. La solución es implementar
también el método <code>Accept(Visitor)</code> para que se pueda considerar como Visitable:</p>
<pre class="code"><code class="go">type Fridge struct {
  Product
}

func (f *Fridge) GetPrice() float32 {
  return f.Product.Price + 20
}

func (f *Fridge) Accept(v Visitor) {
  v.Visit(f)
}
</code></pre>
<p>Vamos a reescribir la función <code>main</code> para agregar este nuevo <code>Fridge</code> producto al sector:</p>
<pre class="code"><code class="go">func main() {
  products := make([]Visitable, 3)
  products[0] = &amp;Rice{
    Product: Product{
      Price: 32.0,
      Name:  "Some rice",
    },
  }
  products[1] = &amp;Pasta{
    Product: Product{
      Price: 40.0,
      Name:  "Some pasta",
    },
  }
  products[2] = &amp;Fridge{
    Product: Product{
      Price: 50,
      Name:  "A fridge",
    },
  }
  ...
}
</code></pre>
<p>Todo lo demás continúa igual. La ejecución de esta nueva función principal produce el siguiente resultado:</p>
<pre class="srci"><code class="sh"><span class="in"><span class="prompt">&gt; </span>go run visitor.go
</span><span class="out">Total: 142.000000
Product list:
-------------
A fridge
Some pasta
Some rice
</span></code></pre>
<p>Como se esperaba, el precio total es más alto ahora, dando como
resultado la suma del arroz (32), la pasta (40) y el refrigerador (50
del producto más 20 del transporte, entonces 70). Podríamos agregar
visitantes para siempre a estos productos, pero la idea es clara:
desacoplamos algunos algoritmos fuera de los tipos para los visitantes.</p>
</div>
<h4 id="visitors-to-the-rescue!">¡Visitantes al rescate!</h4>
<div class="hBody-4">
<p>Hemos visto una poderosa abstracción para agregar nuevos algoritmos a
 algunos tipos. Sin embargo, debido a la falta de una sobrecarga en Go,
este patrón se podría limitar en algunos aspectos (lo hemos visto en el
primer ejemplo, donde tuvimos que crear los <code>VisitA</code>e implementaciones <code>VisitB</code>). En el segundo ejemplo, no hemos lidiado con esta limitación porque hemos utilizado una interfaz para el método <code>Visit</code> de la estructura <code>Visitor</code>, pero solo usamos un tipo de visitante ( <code>ProductInfoRetriever</code>) y tendríamos el mismo problema si implementamos un método <code>Visit</code> para un segundo tipo, que es uno de los objetivos de los patrones de diseño originales de la <i>Banda de los Cuatro</i>.</p>
</div>
<h3 id="state-design-pattern">Patrón de diseño del estado</h3>
<div class="hBody-3">
<p>Los patrones de estado están directamente relacionados con los FSM.
Un FSM, en términos muy simples, es algo que tiene uno o más estados y
viaja entre ellos para ejecutar algunos comportamientos. Veamos cómo el
patrón state nos ayuda a definir FSM.</p>
</div>
<h4 id="description">Descripción</h4>
<div class="hBody-4">
<p>Un interruptor de luz es un ejemplo común de un FSM. Tiene dos
estados: encendido y apagado. Un estado puede pasar al otro y viceversa.
 La forma en que funciona el patrón state es similar. Tenemos una
interfaz <code>State</code> y una implementación de cada estado que
queremos lograr. También suele haber un contexto que contiene
información cruzada entre los estados.</p>
<p>Con FSM, podemos lograr comportamientos muy complejos al dividir su
alcance entre estados. De esta forma, podemos modelar líneas de
ejecución basadas en cualquier tipo de entradas o crear un software
basado en eventos que responda a eventos particulares de formas
específicas.</p>
</div>
<h4 id="objectives">Objetivos</h4>
<div class="hBody-4">
<p>Los principales objetivos del patrón state para desarrollar FSM son los siguientes:</p>
<ul>
<li>
<p>Tener un tipo que altera su propio comportamiento cuando algunas cosas internas han cambiado</p>
</li>
<li>
<p>Los gráficos complejos y las tuberías del modelo pueden actualizarse
fácilmente agregando más estados y redirigiendo sus estados de salida</p>
</li>
</ul>
</div>
<h4 id="a-small-guess-the-number-game">Un pequeño adivinar el número del juego</h4>
<div class="hBody-4">
<p>Vamos a desarrollar un juego muy simple que usa FSM. Este juego es un
 juego de adivinar el número. La idea es simple: tendremos que adivinar
un número entre 0 y 10, y solo tenemos algunos intentos o perderemos.</p>
<p>Dejaremos que el jugador elija el nivel de dificultad preguntando
cuántos intentos tiene el usuario antes de perder. Luego, le pediremos
al jugador el número correcto y seguiremos preguntando si no lo adivinan
 o si el número de intentos llega a cero.</p>
</div>
<h4 id="acceptance-criteria">Criterios de aceptación</h4>
<div class="hBody-4">
<p>Para este juego simple, tenemos cinco criterios de aceptación que básicamente describen la mecánica del juego:</p>
<ol class="num">
<li>
<p>El juego le preguntará al jugador cuántos intentos tendrá antes de perder el juego.</p>
</li>
<li>
<p>El número para adivinar debe estar entre 0 y 10.</p>
</li>
<li>
<p>Cada vez que un jugador ingresa un número para adivinar, el número de intentos disminuye en uno.</p>
</li>
<li>
<p>Si el número de intentos vuelve a cero y el número sigue siendo incorrecto, el juego termina y el jugador ha perdido.</p>
</li>
<li>
<p>Si el jugador adivina el número, el jugador gana.</p>
</li>
</ol>
</div>
<h4 id="implementation-of-state-pattern">Implementación del patrón state</h4>
<div class="hBody-4">
<p>La idea de las pruebas unitarias es bastante sencilla en un patrón
state, por lo que dedicaremos más tiempo a explicar en detalle el
mecanismo para usarlo, que es un poco más complejo de lo habitual.</p>
<p>Antes que nada, necesitamos la interfaz para representar los
diferentes estados y un contexto de juego para almacenar la información
entre estados. Para este juego, el contexto necesita almacenar el número
 de reintentos, si el usuario ha ganado o no, el número secreto para
adivinar y el estado actual. El estado tendrá un método <code>executeState</code> que acepte uno de estos contextos y regrese <code>true</code> si el juego ha finalizado, o <code>false</code> si no:</p>
<pre class="code"><code class="go">type GameState interface {
  executeState(*GameContext) bool
}

type GameContext struct {
  SecretNumber int
  Retries int
  Won bool
  Next GameState
}
</code></pre>
<p>Como se describe en el <i>criterio de aceptación 1</i>, el jugador debe ser capaz de introducir la cantidad de reintentos que desea. Esto será logrado por un estado llamado <code>StartState</code>. Además, la estructura <code>StartState</code> debe preparar el juego, estableciendo el contexto en su valor inicial antes del jugador:</p>
<pre class="code"><code class="go">type StartState struct{}
func(s *StartState) executeState(c *GameContext) bool {
  c.Next = &amp;AskState{}

  rand.Seed(time.Now().UnixNano())
  c.SecretNumber = rand.Intn(10)

  fmt.Println("Introduce a number a number of retries to set the difficulty:")
  fmt.Fscanf(os.Stdin, "%d\n", &amp;c.Retries)

  return true
}
</code></pre>
<p>En primer lugar, la estructura <code>StartState</code> implementa la estructura <code>GameState</code> porque tiene el método <code>executeState(*Context)</code> de tipo <code>Boolean</code> en su estructura. Al comienzo de este estado, establece el único estado posible después de ejecutar este: el <code>AskState</code> estado. La estructura <code>AskState</code> aún no está declarada, pero será el estado donde le pediremos al jugador un número para adivinar.</p>
<p>En las siguientes dos líneas, usamos el paquete <code>Rand</code> de Ir para generar un número aleatorio. En la primera línea, alimentamos el generador aleatorio con el <code>int64</code>número
 de tipo devuelto por el momento actual, por lo que aseguramos una
alimentación aleatoria en cada ejecución (si coloca un número constante
aquí, el generador de números aleatorios también generará el mismo
número). El método <code>rand.Intn(int)</code> devuelve un número entero entre cero y el número especificado, por lo que aquí cubrimos los <i>criterios de aceptación 2</i>.</p>
<p>A continuación, un mensaje que solicita un número de reintentos para establecer precede al método <code>fmt.Fscanf</code>, una poderosa función donde puede pasarlo <code>io.Reader</code>(la
 entrada estándar de la consola), un formato (número) y una interfaz
para almacenar el contenido del lector. , en este caso, el campo <code>Retries</code> del contexto.</p>
<p>Finalmente, volvemos <code>true</code>a decirle al motor que el juego debe continuar. Veamos la estructura <code>AskState</code>, que hemos usado al principio de la función:</p>
<pre class="code"><code class="go">type AskState struct {}
func (a *AskState) executeState(c *GameContext) bool{
  fmt.Printf("Introduce a number between 0 and 10, you have %d tries left\n", c.Retries)

  var n int
  fmt.Fscanf(os.Stdin, "%d", &amp;n)
  c.Retries = c.Retries - 1

  if n == c.SecretNumber {
    c.Won = true
    c.Next = &amp;FinishState{}
  }

  if c.Retries == 0 {
    c.Next = &amp;FinishState{}
  }

  return true
}
</code></pre>
<p>La estructura <code>AskState</code> también implementa el estado <code>GameState</code>,
 como probablemente ya hayas adivinado. Este estado comienza con un
mensaje para el jugador, pidiéndole que inserte un nuevo número. En las
siguientes tres líneas, creamos una variable local para almacenar el
contenido del número que el jugador presentará. Usamos el método <code>fmt.Fscanf</code> de nuevo, como lo hicimos en <code>StartState</code>
 struct para capturar la entrada del jugador y almacenarlo en la
variable n. Entonces, tenemos un intento menos en nuestro contador, por
lo que tenemos que restar uno al número de reintentos representados en
el campo <code>Retries</code>.</p>
<p>Luego, hay dos comprobaciones: una que verifica si el usuario ingresó el número correcto, en cuyo caso el campo de contexto <code>Won</code> está configurado en <code>true</code>y el siguiente estado se establece enestructura <code>FinishState</code> (aún no declarado).</p>
<p>El segundo control es controlar que el número de reintentos no haya
llegado a cero, en cuyo caso no permitirá que el jugador vuelva a pedir
un número y enviará al jugador <code>FinishState</code> directamente a
la estructura. Después de todo, tenemos que decirle al motor del juego
de nuevo que el juego debe continuar regresando <code>true</code> en el método <code>executeState</code>.</p>
<p>Finalmente, definimos la estructura <code>FinishState</code>. Controla el estado de salida del juego, verificando el contenido del campo <code>Won</code> en el objeto de contexto:</p>
<pre class="code"><code class="go">type FinishState struct{}
func(f *FinishState) executeState(c *GameContext) bool {
  if c.Won {
    println("Congrats, you won")
  }
  else {
    println("You lose")
  }
  return false
}
</code></pre>
<p>La estructura <code>TheFinishState</code> también implementa el estado <code>GameState</code> teniendo un método <code>executeState</code>
 en su estructura. La idea aquí es muy simple: si el jugador ha ganado
(este campo está establecido previamente en la estructura <code>AskState</code>), la estructura <code>FinishState</code> imprimirá el mensaje <code>Congrats, you won</code>. Si el jugador no ganó (recuerde que el valor cero de la variable booleana es <code>false</code>), <code>FinishState</code> imprime el mensaje <code>You lose</code>.</p>
<p>En este caso, el juego se puede considerar terminado, por lo que volvemos <code>false</code>a decir que el juego no debe continuar.</p>
<p>Solo necesitamos el método <code>main</code> para jugar nuestro juego:</p>
<pre class="code"><code class="go">func main() {
  start := StartState{}
  game := GameContext{
    Next:&amp;start,
  }
  for game.Next.executeState(&amp;game) {}
}
</code></pre>
<p>Bueno, sí, no puede ser más simple. El juego debe comenzar con el método <code>start</code>,
 aunque podría abstraerse más en el exterior en caso de que el juego
necesite más inicialización en el futuro, pero en nuestro caso está
bien. Luego, creamos un contexto donde establecemos el estado <code>Next</code> como un puntero a la variable <code>start</code>. Entonces, el primer estado que se ejecutará en el juego será el estado <code>StartState</code>.</p>
<p>La última línea de la función <code>main</code> tiene muchas cosas
allí. Creamos un bucle, sin ninguna declaración dentro de él. Al igual
que con cualquier bucle, sigue dando vueltas cuando la condición no está
 satisfecha. La condición que estamos usando es el valor devuelto de la
estructura <code>GameStates</code>, <code>true</code> tan pronto como el juego no esté terminado.</p>
<p>Entonces, la idea es simple: ejecutamos el estado en el contexto, pasándole un puntero al contexto. Cada estado regresa <code>true</code> hasta que el juego haya terminado y la estructura <code>FinishState</code> regrese <code>false</code>. Entonces, nuestro bucle for seguirá en bucle, esperando que <code>false</code> la estructura <code>FinishState</code> envíe una condición para finalizar la aplicación.</p>
<p>Juguemos una vez:</p>
<pre class="srci"><code class="sh"><span class="in"><span class="prompt">&gt; </span>go run state.go
</span><span class="out">Introduce a number a number of retries to set the difficulty:
5
Introduce a number between 0 and 10, you have 5 tries left
8
Introduce a number between 0 and 10, you have 4 tries left
2
Introduce a number between 0 and 10, you have 3 tries left
1
Introduce a number between 0 and 10, you have 2 tries left
3
Introduce a number between 0 and 10, you have 1 tries left
4
You lose
</span></code></pre>
<p>¡Perdimos! Establecimos el número de reintentos en 5. Luego seguimos
insertando números, tratando de adivinar el número secreto. Ingresamos
8, 2, 1, 3 y 4, pero no era ninguno de ellos. Ni siquiera sé cuál era el
 número correcto; arreglemos esto!</p>
<p>Vaya a la definición de la estructura <code>FinishState</code> y cambie la línea donde dice <code>You lose</code>, y reemplácela con lo siguiente:</p>
<pre class="code"><code class="go">fmt.Printf("You lose. The correct number was: %d\n", c.SecretNumber)
</code></pre>
<p>Ahora mostrará el número correcto. Juguemos otra vez:</p>
<pre class="srci"><code class="sh"><span class="in"><span class="prompt">&gt; </span>go run state.go
</span><span class="out">Introduce a number a number of retries to set the difficulty:
3
Introduce a number between 0 and 10, you have 3 tries left
6
Introduce a number between 0 and 10, you have 2 tries left
2
Introduce a number between 0 and 10, you have 1 tries left
1
You lose. The correct number was: 9
</span></code></pre>
<p>Esta vez lo hacemos un poco más difícil al establecer solo tres
intentos ... y lo perdimos de nuevo. Ingresé 6, 2 y 1, pero el número
correcto fue 9. Último intento:</p>
<pre class="srci"><code class="sh"><span class="in"><span class="prompt">&gt; </span>go run state.go
</span><span class="out">Introduce a number a number of retries to set the difficulty:
5
Introduce a number between 0 and 10, you have 5 tries left
3
Introduce a number between 0 and 10, you have 4 tries left
4
Introduce a number between 0 and 10, you have 3 tries left
5
Introduce a number between 0 and 10, you have 2 tries left
6
Congrats, you won
</span></code></pre>
<p>¡Estupendo! Esta vez bajamos la dificultad, permitiendo hasta cinco
intentos y ¡ganamos! incluso nos quedaba una oportunidad más, pero
adivinamos el número en el cuarto intento después de ingresar 3, 4, 5.
El número correcto fue 6, que fue mi cuarto intento.</p>
</div>
<h4 id="a-state-to-win-and-a-state-to-lose">Un estado para ganar y un estado para perder</h4>
<div class="hBody-4">
<p>¿Te has dado cuenta de que podríamos tener un estado ganador y
ganador en lugar de imprimir los mensajes directamente en la estructura <code>FinishState</code>?
 De esta forma, podríamos, por ejemplo, verificar algún marcador
hipotético en la sección de ganancias para ver si hemos establecido un
registro. Vamos a refactorizar nuestro juego. Primero necesitamos a <code>WinState</code>y una estructura <code>LoseState</code>:</p>
<pre class="code"><code class="go">type WinState struct{}

func (w *WinState) executeState(c *GameContext) bool {
  println("Congrats, you won")

  return false
}

type LoseState struct{}

func (l *LoseState) executeState(c *GameContext) bool {
  fmt.Printf("You lose. The correct number was: %d\n", c.SecretNumber)
  return false
}
</code></pre>
<p>Estos dos nuevos estados no tienen nada nuevo. Contienen los mismos mensajes que anteriormente estaban en el estado <code>FinishState</code> que, dicho sea de paso, se deben modificar para usar estos nuevos estados:</p>
<pre class="code"><code class="go">func (f *FinishState) executeState(c *GameContext) bool {
  if c.Won {
    c.Next = &amp;WinState{}
  } else {
    c.Next = &amp;LoseState{}
  }
  return true
}
</code></pre>
<p>Ahora, el estado de finalización no imprime nada y, en cambio, delega esto al siguiente estado de la cadena: la estructura <code>WinState</code>, si el usuario ha ganado y la estructura <code>LoseState</code>, si no. Recuerde que el juego no termina <code>FinishState</code> ahora en la estructura, y debemos devolver verdadero en lugar de <code>false</code> notificar al motor que debe seguir ejecutando estados en la cadena.</p>
</div>
<h4 id="the-game-built-using-the-state-pattern">El juego construido usando el patrón state</h4>
<div class="hBody-4">
<p>Debes pensar ahora que puedes extender este juego para siempre con
nuevos estados, y es cierto. El poder del patrón state no es solo la
capacidad de crear un FSM complejo, sino también la flexibilidad de
mejorarlo tanto como se desee agregando nuevos estados y modificando
algunos estados antiguos para que apunten a los nuevos sin afectar el
resto del FSM.</p>
</div>
<h3 id="mediator-design-pattern">Patrón de diseño del mediador</h3>
<div class="hBody-3">
<p>Continuemos con el patrón Mediator. Como su nombre lo indica, es un
patrón que estará entre dos tipos para intercambiar información. Pero,
¿por qué querremos este comportamiento? Veamos esto en detalle.</p>
</div>
<h4 id="description">Descripción</h4>
<div class="hBody-4">
<p>Uno de los objetivos clave de cualquier patrón de diseño es evitar el
 acoplamiento apretado entre los objetos. Esto se puede hacer de muchas
maneras, como ya hemos visto.</p>
<p>Pero un método particularmente efectivo cuando la aplicación crece
mucho es el patrón de Mediator. El patrón de Mediator es el ejemplo
perfecto de un patrón que es comúnmente utilizado por todos los
programadores sin pensar demasiado en ello.</p>
<p>El patrón del mediador actuará como el tipo encargado de intercambiar
 la comunicación entre dos objetos. De esta forma, los objetos que se
comunican no necesitan conocerse entre ellos y pueden cambiar más
libremente. El patrón que mantiene qué objetos dan qué información es el
 Mediador.</p>
</div>
<h4 id="objectives">Objetivos</h4>
<div class="hBody-4">
<p>Como se describió anteriormente, los principales objetivos del patrón
 del Mediador son el acoplamiento y la encapsulación sueltos. Los
objetivos son:</p>
<ul>
<li>
<p>Para proporcionar un acoplamiento flexible entre dos objetos que deben comunicarse entre ellos</p>
</li>
<li>
<p>Para reducir la cantidad de dependencias de un tipo particular al mínimo pasando estas necesidades al patrón de Mediator</p>
</li>
</ul>
</div>
<h4 id="a-calculator">Una calculadora</h4>
<div class="hBody-4">
<p>Para el patrón de Mediator, vamos a desarrollar una calculadora
aritmética extremadamente simple. Probablemente estés pensando que una
calculadora es tan simple que no necesita ningún patrón. Pero veremos
que esto no es exactamente cierto.</p>
<p>Nuestra calculadora solo hará dos operaciones muy simples: suma y resta.</p>
</div>
<h4 id="acceptance-criteria">Criterios de aceptación</h4>
<div class="hBody-4">
<p>Suena bastante divertido hablar sobre los criterios de aceptación para definir una calculadora, pero hagámoslo de todos modos:</p>
<ol class="num">
<li>
<p>Defina una operación llamada <code>Sum</code> que toma un número y lo agrega a otro número.</p>
</li>
<li>
<p>Defina una operación llamada <code>Subtract</code> que toma un número y lo substrae a otro número.</p>
</li>
</ol>
<p>Bueno, no sé ustedes, pero realmente necesito un descanso después de este <i>complejo</i> criterio. Entonces, ¿por qué estamos definiendo esto tanto? Paciencia, tendrás la respuesta pronto.</p>
</div>
<h4 id="implementation">Implementación</h4>
<div class="hBody-4">
<p>Tenemos que ir directamente a la implementación porque no podemos
probar que la suma será correcta (bueno, podemos, pero vamos a probar si
 Go está escrito correctamente). Podríamos probar que aprobamos los
criterios de aceptación, pero es un poco exagerado para nuestro ejemplo.</p>
<p>Empecemos por implementar los tipos necesarios:</p>
<pre class="code"><code class="go">package main

type One struct{}
type Two struct{}
type Three struct{}
type Four struct{}
type Five struct{}
type Six struct{}
type Seven struct{}
type Eight struct{}
type Nine struct{}
type Zero struct{}
</code></pre>
<p>Bueno ... esto se ve bastante incómodo. Ya tenemos tipos numéricos en
 Ir para realizar estas operaciones, ¡no necesitamos un tipo para cada
número!</p>
<p>Pero continuemos por un segundo con este enfoque insano. Implementemos la estructura <code>One</code>:</p>
<pre class="code"><code class="go">type One struct{}

func (o *One) OnePlus(n interface{}) interface{} {
  switch n.(type) {
  case One:
    return &amp;Two{}
  case Two:
    return &amp;Three{}
  case Three:
    return &amp;Four{}
  case Four:
    return &amp;Five{}
  case Five:
    return &amp;Six{}
  case Six:
    return &amp;Seven{}
  case Seven:
    return &amp;Eight{}
  case Eight:
    return &amp;Nine{}
  case Nine:
    return [2]interface{}{&amp;One{}, &amp;Zero{}}
  default:
    return fmt.Errorf("Number not found")
  }
}
</code></pre>
<p>OK, me detendré aquí. ¿Qué pasa con esta implementación? ¡Esto es
completamente loco! ¡Es excesivo hacer todas las operaciones posibles
entre números para hacer sumas! Especialmente cuando tenemos más de un
dígito.</p>
<p>Bueno, créalo o no, así es como hoy en día se diseña una gran
cantidad de software. Una pequeña aplicación donde un objeto usa dos o
tres objetos crece y termina usando docenas de ellos. Se convierte en un
 infierno absoluto simplemente agregar o eliminar un tipo de la
aplicación, ya que está oculto en algunas de estas locuras.</p>
<p>Entonces, ¿qué podemos hacer en esta calculadora? Use un tipo de mediador que libere todos los casos:</p>
<pre class="code"><code class="go">func Sum(a, b interface{}) interface{}{
  switch a := a.(type) {
    case One:
    switch b.(type) {
      case One:
        return &amp;Two{}
      case Two:
        return &amp;Three{}
      default:
        return fmt.Errorf("Number not found")
    }
    case Two:
    switch b.(type) {
      case One:
        return &amp;Three{}
      case Two:
        return &amp;Four{}
      default:
      return fmt.Errorf("Number not found")

    }
    case int:
    switch b := b.(type) {
      case One:
        return &amp;Three{}
      case Two:
        return &amp;Four{}
      case int:
        return a + b
      default:
      return fmt.Errorf("Number not found")

    }
    default:
    return fmt.Errorf("Number not found")
  }
}
</code></pre>
<p>Acabamos de desarrollar un par de números para mantener las cosas cortas. La función <code>Sum</code> actúa como un mediador entre dos números. Primero, verifica el tipo del primer número nombrado <code>a</code>. Luego, para cada tipo del primer número, verifica el tipo del segundo número llamado b y devuelve el tipo resultante.</p>
<p>Si bien la solución todavía se ve muy loca ahora, la única que conoce
 todos los números posibles en la calculadora es la función <code>Sum</code>. Pero eche un vistazo más de cerca y verá que hemos agregado un tipo de caso para el tipo int. Tenemos casos <code>One</code>, <code>Two</code>y <code>int</code>. Dentro del caso <code>int</code>, también tenemos otro caso <code>int</code> para el número b. Qué hacemos aquí? Si ambos tipos son del caso <code>int</code>, podemos devolver la suma de ellos.</p>
<p>¿Crees que esto funcionará? Escribamos una función <code>main</code> simple :</p>
<pre class="code"><code class="go">func main(){
  fmt.Printf("%#v\n", Sum(One{}, Two{}))
  fmt.Printf("%d\n", Sum(1,2))
}
</code></pre>
<p>Imprimimos la suma de tipo <code>One</code>y tipo <code>Two</code>. Al usar el formato <code>"%#v"</code>, solicitamos imprimir información sobre el tipo. La segunda línea de la función usa tipos <code>int</code>, y también imprimimos el resultado. Esto en la consola produce el siguiente resultado:</p>
<pre class="srci"><code class="sh"><span class="in"><span class="prompt">&gt; </span>go run mediator.go
</span><span class="out">&amp;main.Three{}
7
</span></code></pre>
<p>No es muy impresionante, ¿verdad? Pero pensemos por un segundo. Al
utilizar el patrón de Mediator, hemos podido refactorizar la calculadora
 inicial, donde tenemos que definir cada operación en cada tipo en un
patrón de Mediator, la función <code>Sum</code>.</p>
<p>Lo bueno es que, gracias al patrón Mediator, hemos podido comenzar a
usar números enteros como valores para nuestra calculadora. Acabamos de
definir el ejemplo más simple agregando dos enteros, pero podríamos
haber hecho lo mismo con un entero y el <code>type</code>:</p>
<pre class="code"><code class="go">case One:
  switch b := b.(type) {
  case One:
    return &amp;Two{}
  case Two:
    return &amp;Three{}
  case int:
    return b+1
  default:
    return fmt.Errorf("Number not found")
  }
</code></pre>
<p>Con esta pequeña modificación, ahora podemos usar el tipo <code>One</code> con un <code>int</code>número como <code>b</code>.
 Si seguimos trabajando en este patrón de Mediator, podemos lograr mucha
 flexibilidad entre los tipos, sin tener que implementar todas las
operaciones posibles entre ellos, generando un acoplamiento ajustado.</p>
<p>Añadiremos un nuevo método <code>Sum</code> en la función principal para ver esto en acción:</p>
<pre class="code"><code class="go">func main(){
  fmt.Printf("%#v\n", Sum(One{}, Two{}))
  fmt.Printf("%d\n", Sum(1,2))
 fmt.Printf("%d\n", Sum(One{},2))
}
</code></pre>
<pre class="srci"><code class="sh"><span class="in"><span class="prompt">&gt; </span>go run mediator.go
</span><span class="out">&amp;main.Three{}
3
3</span></code></pre>
<p>Bien, el patrón del Mediador es el encargado de conocer la posible
tipos y devuelve el tipo más conveniente para nuestro caso, que es un
número entero. Ahora podríamos seguir desarrollando esta función <code>Sum</code> hasta que nos deshagamos por completo del uso de los tipos numéricos que hemos definido.</p>
</div>
<h4 id="uncoupling-two-types-with-the-mediator">Desacoplando dos tipos con el Mediador</h4>
<div class="hBody-4">
<p>Hemos llevado a cabo un ejemplo disruptivo para tratar de pensar de
manera innovadora y razonar profundamente sobre el patrón del Mediador.
El estrecho acoplamiento entre entidades en una aplicación puede ser
realmente complejo de manejar en el futuro y permitir una
refactorización más difícil si es necesario.</p>
<p>Solo recuerde que el patrón de Mediator está ahí para actuar como un
tipo de gestión entre dos tipos que no se conocen entre sí, de modo que
puede tomar uno de los tipos sin afectar al otro y reemplazar un tipo de
 una manera más fácil y conveniente.</p>
</div>
<h3 id="observer-design-pattern">Patrón de diseño del observador</h3>
<div class="hBody-3">
<p>Terminaremos los patrones de diseño comunes de la <i>Banda de los Cuatro</i>
 con mi patrón favorito: el patrón Observer, también conocido como
publicar / suscribir o publicar / escuchar. Con el patrón state,
definimos nuestra primera arquitectura basada en eventos, pero con el
patrón Observer realmente alcanzaremos un nuevo nivel de abstracción.</p>
</div>
<h4 id="description">Descripción</h4>
<div class="hBody-4">
<p>La idea detrás del patrón Observer es simple: suscribirse a algún
evento que desencadene algún comportamiento en muchos tipos suscritos.
¿Por qué es esto tan interesante? Porque desacoplamos un evento de sus
posibles manejadores.</p>
<p>Por ejemplo, imagine un botón de inicio de sesión. Podríamos
codificar eso cuando el usuario hace clic en el botón, el color del
botón cambia, se ejecuta una acción y se realiza una verificación de
forma en el fondo. Pero con el patrón Observer, el tipo que cambia el
color se suscribirá al evento del clic del botón. El tipo que verifica
el formulario y el tipo que realiza una acción también se suscribirán a
este evento.</p>
</div>
<h4 id="objectives">Objetivos</h4>
<div class="hBody-4">
<p>El patrón Observer es especialmente útil para lograr muchas acciones
que se desencadenan en un evento. También es especialmente útil cuando
no se sabe cuántas acciones se realizan después de un evento por
adelantado o existe la posibilidad de que el número de acciones vaya a
crecer en el futuro cercano. Para reanudar, haga lo siguiente:</p>
<ul>
<li>
<p>Proporcionar una arquitectura impulsada por eventos donde un evento puede desencadenar una o más acciones</p>
</li>
<li>
<p>Desacoplar las acciones que se realizan desde el evento que las desencadena</p>
</li>
<li>
<p>Proporcione más de un evento que desencadene la misma acción</p>
</li>
</ul>
</div>
<h4 id="the-notifier">El notificador</h4>
<div class="hBody-4">
<p>Desarrollaremos la aplicación más simple posible para comprender
completamente las raíces del patrón Observer. Vamos a hacer una
estructura <code>Publisher</code>, que es la que desencadena un evento, por lo que debe aceptar nuevos observadores y eliminarlos si es necesario. Cuando <code>Publisher</code> se activa la estructura, debe notificar a todos sus observadores del nuevo evento con los datos asociados.</p>
</div>
<h4 id="acceptance-criteria">Criterios de aceptación</h4>
<div class="hBody-4">
<p>Los requisitos deben indicarnos que tenemos algún tipo que active algún método en una o más acciones:</p>
<ol class="num">
<li>
<p>Debemos tener un editor con un método <code>NotifyObservers</code> que acepte un mensaje como argumento y active un método <code>Notify</code> en cada observador suscrito.</p>
</li>
<li>
<p>Debemos tener un método para agregar nuevos suscriptores al editor.</p>
</li>
<li>
<p>Debemos tener un método para eliminar nuevos suscriptores del editor.</p>
</li>
</ol>
</div>
<h4 id="unit-tests">Pruebas unitarias</h4>
<div class="hBody-4">
<p>Tal vez se haya dado cuenta de que nuestros requisitos definen casi exclusivamente el tipo <code>Publisher</code>.
 Esto se debe a que la acción realizada por el observador es irrelevante
 para el patrón Observer. Simplemente debe ejecutar una acción, en este
caso el método <code>Notify</code>, que implementará uno o varios tipos. Así que vamos a definir esta única interfaz para este patrón:</p>
<pre class="code"><code class="go">type Observer interface {
  Notify(string)
}
</code></pre>
<p>La interfaz <code>Observer</code> tiene un método <code>Notify</code>
 que acepta un tipo de cadena que contendrá el mensaje para difundir. No
 es necesario devolver nada, pero podríamos devolver un error si
queremos verificar si se ha alcanzado a todos los observadores al llamar
 al método <code>publish</code> delestructura <code>Publisher</code>.</p>
<p>Para probar todos los criterios de aceptación, solo necesitamos una estructura llamada <code>Publisher</code> con tres métodos:</p>
<pre class="code"><code class="go">type Publisher struct {
  ObserversList []Observer
}

func (s *Publisher) AddObserver(o Observer) {}

func (s *Publisher) RemoveObserver(o Observer) {}

func (s *Publisher) NotifyObservers(m string) {}
</code></pre>
<p>La estructura <code>Publisher</code> almacena la lista de observadores suscritos en un campo de sector llamado <code>ObserversList</code>. Luego tiene los tres métodos mencionados en los criterios de aceptación: el método <code>AddObserver</code> para suscribir a un nuevo observador al editor, el método <code>RemoveObserver</code> para anular la suscripción de un observador y el<code>NotifyObservers</code> método con una cadena que actúa como el mensaje que queremos distribuir entre todos los observadores.</p>
<p>Con estos tres métodos, tenemos que configurar una prueba de raíz para configurar el <code>Publisher</code>y
 tres subpruebas para probar cada método. También necesitamos definir
una estructura de tipo de prueba que implemente la interfaz <code>Observer</code>. Esta estructura se llamará <code>TestObserver</code>:</p>
<pre class="code"><code class="go">type TestObserver struct {
  ID      int
  Message string
}
func (p *TestObserver) Notify(m string) {
  fmt.Printf("Observer %d: message '%s' received \n", p.ID, m)
  p.Message = m
}
</code></pre>
<p>La estructura <code>TestObserver</code> implementa el patrón Observer al definir un método <code>Notify(string)</code>
 en su estructura. En este caso, imprime el mensaje recibido junto con
su propia ID de observador. Luego, almacena el mensaje en su campo <code>Message</code>. Esto nos permite verificar más adelante si el contenido del campo <code>Message</code> es el esperado. Recuerde que también se puede hacer pasando el puntero <code>testing.T</code> y el mensaje esperado y comprobando dentro de la estructura <code>TestObserver</code>.</p>
<p>Ahora podemos configurar la estructura <code>Publisher</code> para ejecutar las tres pruebas. Crearemos tres instancias de la estructura <code>TestObserver</code>:</p>
<pre class="code"><code class="go">func TestSubject(t *testing.T) {
  testObserver1 := &amp;TestObserver{1, ""}
  testObserver2 := &amp;TestObserver{2, ""}
  testObserver3 := &amp;TestObserver{3, ""}
  publisher := Publisher{}
</code></pre>
<p>Hemos dado una identificación diferente a cada observador para que
podamos ver más tarde que cada uno de ellos ha impreso el mensaje
esperado. Luego, hemos agregado los observadores llamando al método <code>AddObserver</code> en la estructura <code>Publisher</code>.</p>
<p>Vamos a escribir una prueba <code>AddObserver</code>, debe agregar un nuevo observador al campo <code>ObserversList</code> de la estructura <code>Publisher</code>:</p>
<pre class="code"><code class="go">t.Run("AddObserver", func(t *testing.T) {
  publisher.AddObserver(testObserver1)
  publisher.AddObserver(testObserver2)
  publisher.AddObserver(testObserver3)

  if len(publisher.ObserversList) != 3 {
    t.Fail()
  }
})
</code></pre>
<p>Hemos agregado tres observadores a la estructura <code>Publisher</code>, por lo que la longitud del corte debe ser 3. Si no es 3, la prueba fallará.</p>
<p>La prueba <code>RemoveObserver</code> tomará al observador con ID 2 y lo eliminará de la lista:</p>
<pre class="code"><code class="go">t.Run("RemoveObserver", func(t *testing.T) {
  publisher.RemoveObserver(testObserver2)

  if len(publisher.ObserversList) != 2 {
    t.Errorf("The size of the observer list is not the " +
      "expected. 3 != %d\n", len(publisher.ObserversList))
  }

  for _, observer := range publisher.ObserversList {
    testObserver, ok := observer.(TestObserver)
    if !ok {
      t.Fail()
    }

    if testObserver.ID == 2 {
      t.Fail()
    }
  }
})
</code></pre>
<p>Después de eliminar el segundo observador, la longitud de la estructura <code>Publisher</code> debe ser 2 ahora. También verificamos que ninguno de los observadores que quedan tenga el<code>ID</code> 2 porque debe ser eliminado.</p>
<p>El último método para probar es el método <code>Notify</code>. Cuando se utiliza el método Notify, todas las instancias de estructura <code>TestObserver</code> deben cambiar su campo <code>Message</code> de vacío al mensaje pasado ( <code>Hello World!</code> en este caso). Primero, verificaremos que todos los campos <code>Message</code> estén, de hecho, vacíos antes de llamar a la prueba <code>NotifyObservers</code>:</p>
<pre class="code"><code class="go">t.Run("Notify", func(t *testing.T) {
  for _, observer := range publisher.ObserversList {
    printObserver, ok := observer.(*TestObserver)
    if !ok {
      t.Fail()
      break
    }

    if printObserver.Message != "" {
      t.Errorf("The observer's Message field weren't " +
        " empty: %s\n", printObserver.Message)
    }
  }
</code></pre>
<p>Usando una declaración <code>for</code>, estamos iterando sobre el campo <code>ObserversList</code> para dividir la instancia <code>publisher</code>. Necesitamos hacer una conversión de tipo desde un puntero a un observador, a un puntero a la estructura <code>TestObserver</code>, y verificar que la fundición se haya realizado correctamente. Luego, verificamos que el campo <code>Message</code> esté vacío.</p>
<p>El siguiente paso es crear un mensaje para enviar, en este caso, será <code>"Hello World!"</code>y luego pasar este mensaje al método <code>NotifyObservers</code> para notificar a todos los observadores en la lista (actualmente solo observadores 1 y 3):</p>
<pre class="code"><code class="go">    message := "Hello World!"
    publisher.NotifyObservers(message)

    for _, observer := range publisher.ObserversList {
      printObserver, ok := observer.(*TestObserver)
      if !ok {
        t.Fail()
        break
      }

      if printObserver.Message != message {
        t.Errorf("Expected message on observer %d was " +
          "not expected: '%s' != '%s'\n", printObserver.ID,
          printObserver.Message, message)
      }
    }
  })
}
</code></pre>
<p>Después de llamar al método <code>NotifyObservers</code>, cada prueba <code>TestObserver</code> en el campo <code>ObserversList</code> debe tener el mensaje <code>"Hello World!"</code> almacenado en su campo <code>Message</code>. De nuevo, usamos un bucle <code>for</code> para iterar sobre cada observador del campo <code>ObserversList</code> y en cada uno de ellos hacemos una prueba <code>TestObserver</code> (recuerde que la estructura <code>TestObserver</code> no tiene ningún campo ya que es una interfaz). Podríamos evitar la conversión de tipo al agregar un nuevo método <code>Message()</code> a la instancia <code>Observer</code> e implementarlo en el</p>
<p>estructura <code>TestObserver</code> para devolver el contenido del campo <code>Message</code>. Ambos métodos son igualmente válidos. Una vez que tenemos el tipo de conversión a un método <code>TestObserver</code> llamado variable <code>printObserver</code> como una variable local, verificamos que cada instancia en la estructura <code>ObserversList</code> tenga la cadena <code>"Hello World!"</code> almacenada en su campo <code>Message</code>.</p>
<p>Es hora de ejecutar las pruebas que deben fallar para verificar su efectividad en la implementación posterior:</p>
<pre class="srci"><code class="sh"><span class="in"><span class="prompt">&gt; </span>go test -v
</span><span class="out">=== RUN   TestSubject
=== RUN   TestSubject/AddObserver
=== RUN   TestSubject/RemoveObserver
=== RUN   TestSubject/Notify
--- FAIL: TestSubject (0.00s)
    --- FAIL: TestSubject/AddObserver (0.00s)
    --- FAIL: TestSubject/RemoveObserver (0.00s)
        observer_test.go:40: The size of the observer list is
not the expected. 3 != 0
    --- PASS: TestSubject/Notify (0.00s)
FAIL
exit status 1
FAIL
</span></code></pre>
<p>Algo no funciona como se esperaba ¿Cómo está <code>Notify</code> pasando el método las pruebas si aún no hemos implementado la función? Eche un vistazo a la prueba del método <code>Notify</code> nuevamente. La prueba itera sobre la estructura <code>ObserversList</code> y cada llamada <code>Fail</code> se encuentra dentro de este ciclo for. Si la lista está vacía, no se repetirá, por lo que no ejecutará ninguna llamada <code>Fail</code>.</p>
<p>Arreglemos este problema agregando una pequeña verificación de lista no vacía al comienzo de la prueba <code>Notify</code>:</p>
<pre class="code"><code class="go">  if len(publisher.ObserversList) == 0 {
      t.Errorf("The list is empty. Nothing to test\n")
  }
</code></pre>
<p>Y volveremos a ejecutar las pruebas para ver si el método <code>TestSubject/Notify</code> ya está fallando:</p>
<pre class="srci"><code class="sh"><span class="in"><span class="prompt">&gt; </span>go test -v
</span><span class="out">=== RUN   TestSubject
=== RUN   TestSubject/AddObserver
=== RUN   TestSubject/RemoveObserver
=== RUN   TestSubject/Notify
--- FAIL: TestSubject (0.00s)
    --- FAIL: TestSubject/AddObserver (0.00s)
    --- FAIL: TestSubject/RemoveObserver (0.00s)
        observer_test.go:40: The size of the observer list is
not the expected. 3 != 0
    --- FAIL: TestSubject/Notify (0.00s)
        observer_test.go:58: The list is empty. Nothing to test
FAIL
exit status 1
FAIL
</span></code></pre>
<p>Bien, todos fallan y ahora tenemos algo de garantía en nuestras pruebas. Podemos proceder a la implementación.</p>
</div>
<h3 id="implementation">Implementación</h3>
<div class="hBody-3">
<p>Nuestra implementación es solo para definir el <code>AddObserver</code>, el <code>RemoveObserver</code>y los métodos <code>NotifyObservers</code>:</p>
<pre class="code"><code class="go">func (s *Publisher) AddObserver(o Observer) {
  s.ObserversList = append(s.ObserversList, o)
}
</code></pre>
<p>El método <code>AddObserver</code> agrega la instancia <code>Observer</code> a la estructura <code>ObserversList</code> al agregar el puntero a la lista actual de punteros. Este fue muy fácil. La prueba <code>AddObserver</code> debe estar pasando ahora (pero no el resto o podríamos haber hecho algo mal):</p>
<pre class="srci"><code class="sh"><span class="in"><span class="prompt">&gt; </span>go test -v
</span><span class="out">=== RUN   TestSubject
=== RUN   TestSubject/AddObserver
=== RUN   TestSubject/RemoveObserver
=== RUN   TestSubject/Notify
--- FAIL: TestSubject (0.00s)
    --- PASS: TestSubject/AddObserver (0.00s)
    --- FAIL: TestSubject/RemoveObserver (0.00s)
        observer_test.go:40: The size of the observer list is
not the expected. 3 != 3
    --- FAIL: TestSubject/Notify (0.00s)
        observer_test.go:87: Expected message on observer 1 was
not expected: 'default' != 'Hello World!'
        observer_test.go:87: Expected message on observer 2 was
not expected: 'default' != 'Hello World!'
        observer_test.go:87: Expected message on observer 3 was
not expected: 'default' != 'Hello World!'
FAIL
exit status 1
FAIL
</span></code></pre>
<p>Exelente, solo el método <code>AddObserver</code> ha pasado la prueba, entonces podemos ahora continúa con el método <code>RemoveObserver</code>:</p>
<pre class="code"><code class="go">func (s *Publisher) RemoveObserver(o Observer) {
  var indexToRemove int

  for i, observer := range s.ObserversList {
    if observer == o {
      indexToRemove = i
      break
    }
  }

  s.ObserversList = append(s.ObserversList[:indexToRemove],
    s.ObserversList[indexToRemove+1:]...)
}
</code></pre>
<p>El método <code>RemoveObserver</code> iterará para cada elemento en la estructura <code>ObserversList</code>, comparando la variable <code>Observer</code> o del objeto con los almacenados en la lista. Si encuentra una coincidencia, guarda el índice en la variable local <code>indexToRemove</code>, y detiene la iteración. La forma de eliminar índices en un sector en Go es un poco complicado:</p>
<ol class="num">
<li>
<p>En primer lugar, tenemos que usar la indexación de sectores para
devolver un segmento nuevo que contenga todos los objetos desde el
comienzo del sector hasta el índice que queremos eliminar (no incluido).</p>
</li>
<li>
<p>Luego, obtenemos otra porción del índice que queremos eliminar (no incluido) para el último objeto en la porción</p>
</li>
<li>
<p>Finalmente, unimos las dos nuevas divisiones anteriores en una nueva (la función <code>append</code>)</p>
</li>
</ol>
<p>Por ejemplo, en una lista de 1 a 10 en la que queremos eliminar el
número 5, tenemos que crear un nuevo sector, uniendo un segmento del 1
al 4 y un segmento del 6 al 10.</p>
<p>Esta eliminación de índice se realiza <code>append</code> nuevamente
con la función porque en realidad estamos agregando dos listas juntas.
Solo eche un vistazo más de cerca a los tres puntos al final del segundo
 argumento de la función <code>append</code>. La función <code>append</code>
 agrega un elemento (el segundo argumento) a un sector (el primero),
pero queremos agregar una lista completa. Esto se puede lograr usando
los tres puntos, que se traducen en algo así como <i>seguir agregando elementos hasta que termine la segunda matriz</i>.</p>
<p>Ok, vamos a ejecutar esta prueba ahora:</p>
<pre class="srci"><code class="sh"><span class="in"><span class="prompt">&gt; </span>go test -v
</span><span class="out">=== RUN   TestSubject
=== RUN   TestSubject/AddObserver
=== RUN   TestSubject/RemoveObserver
=== RUN   TestSubject/Notify
--- FAIL: TestSubject (0.00s)
    --- PASS: TestSubject/AddObserver (0.00s)
    --- PASS: TestSubject/RemoveObserver (0.00s)
    --- FAIL: TestSubject/Notify (0.00s)
        observer_test.go:87: Expected message on observer 1 was
not expected: 'default' != 'Hello World!'
        observer_test.go:87: Expected message on observer 3 was
not expected: 'default' != 'Hello World!'
FAIL
exit status 1
FAIL
</span></code></pre>
<p>Continuamos en el buen camino. La prueba <code>RemoveObserver</code> ha sido arreglada sin arreglar nada más. Ahora tenemos que finalizar nuestra implementación definiendo el método <code>NotifyObservers</code>:</p>
<pre class="code"><code class="go">func (s *Publisher) NotifyObservers(m string) {
  fmt.Printf("Publisher received message '%s' to notify observers\n", m)
  for _, observer := range s.ObserversList {
    observer.Notify(m)
  }
}
</code></pre>
<p>El método <code>NotifyObservers</code> es bastante simple porque imprime un mensaje en la consola para anunciar que un mensaje en particular se pasará al <code>Observers</code>. Después de esto, usamos un ciclo for para iterar sobre la estructura <code>ObserversList</code> y ejecutar cada método <code>Notify(string)</code> pasando el argumento <code>m</code>. Después de ejecutar esto, todos los observadores deben tener el mensaje <code>Hello World!</code> almacenado en su campo <code>Message</code>. Veamos si esto es cierto ejecutando las pruebas:</p>
<pre class="srci"><code class="sh"><span class="in"><span class="prompt">&gt; </span>go test -v
</span><span class="out">=== RUN   TestSubject
=== RUN   TestSubject/AddObserver
=== RUN   TestSubject/RemoveObserver
=== RUN   TestSubject/Notify
Publisher received message 'Hello World!' to notify observers
Observer 1: message 'Hello World!' received
Observer 3: message 'Hello World!' received
--- PASS: TestSubject (0.00s)
    --- PASS: TestSubject/AddObserver (0.00s)
    --- PASS: TestSubject/RemoveObserver (0.00s)
    --- PASS: TestSubject/Notify (0.00s)
PASS
ok
</span></code></pre>
<p>¡Excelente! También podemos ver los resultados de los tipos <code>Publisher</code> Observer en la consola. La estructura <code>Publisher</code> imprime el siguiente mensaje:</p>
<pre class="srci"><code class="sh"><span class="out">hey! I have received the message  'Hello World!' and I'm going
to pass the same message to the observers
</span></code></pre>
<p>Después de esto, todos los observadores imprimen sus respectivos mensajes de la siguiente manera:</p>
<pre class="srci"><code class="sh"><span class="out">hey, I'm observer 1 and I have received the message 'Hello
World!'
</span></code></pre>
<p>Y lo mismo para el tercer observador.</p>
</div>
<h4 id="summary">Resumen</h4>
<div class="hBody-4">
<p>Hemos desbloqueado el poder de las arquitecturas impulsadas por
eventos con el patrón state y el patrón Observer. Ahora puede ejecutar
algoritmos asincrónicos y operaciones en su aplicación que responden a
los eventos en su sistema.</p>
<p>El patrón Observer se usa comúnmente en UI's. La programación de
Android está llena de patrones de Observer para que el SDK de Android
pueda delegar las acciones que realizarán los programadores al crear una
 aplicación.</p>
</div>
<h3 id="chapter-8.-introduction-to-gos-concurrency">Capítulo 8. Introducción a la concurrencia de Gos</h3>
<div class="hBody-3">
<p>Acabamos de terminar con los patrones de diseño de la <i>Banda de los Cuatro</i>
 que se usan comúnmente en lenguajes de programación orientados a
objetos. Se han utilizado ampliamente durante las últimas décadas
(incluso antes de que se definieran explícitamente en un libro).</p>
<p>En este capítulo, vamos a ver concurrencia en el lenguaje Go.
Aprenderemos que con múltiples núcleos y procesos múltiples, las
aplicaciones pueden ayudarnos a lograr un mejor rendimiento y
posibilidades infinitas. Veremos cómo usar algunos de los patrones ya
conocidos en formas concurrentemente seguras.</p>
</div>
<h4 id="a-little-bit-of-history-and-theory">Un poco de historia y teoría</h4>
<div class="hBody-4">
<p>Cuando hablamos de la concurrencia de Go, es imposible no hablar de
historia. En las últimas décadas, vimos una mejora en la velocidad de
las CPU hasta que alcanzamos los límites de hardware impuestos por los
materiales de hardware, diseño y arquitecturas actuales. Cuando llegamos
 a este punto, comenzamos a jugar con las primeras computadoras
multinúcleo, las primeras placas base de doble CPU y luego las CPU
individuales con más de un núcleo en su corazón.</p>
<p>Desafortunadamente, los lenguajes que estamos utilizando siguen
siendo los creados cuando teníamos CPU de un solo núcleo, como Java o C
++. Aunque son lenguajes de sistemas fabulosos, carecen de un soporte de
 simultaneidad adecuado por diseño. Puede desarrollar aplicaciones
simultáneas en los dos idiomas utilizados en su proyecto utilizando
herramientas de terceros o desarrollando su propia (tarea no muy fácil).</p>
<p>La concurrencia de Go se diseñó teniendo en cuenta estas
advertencias. Los creadores querían que se recogiera basura y un
lenguaje de procedimientos que sea familiar para los recién llegados,
pero que, al mismo tiempo, se pueda usar para escribir aplicaciones
concurrentes fácilmente y sin afectar el núcleo del lenguaje.</p>
<p>Hemos experimentado esto en los primeros capítulos. Hemos
desarrollado más de 20 patrones de diseño sin una palabra sobre
concurrencia. Esto muestra claramente que las características
concurrentes del lenguaje Go están completamente separadas del lenguaje
central al tiempo que forman parte de él, un ejemplo perfecto de
abstracción y encapsulación.</p>
<p>Existen muchos modelos de simultaneidad en informática, siendo el más famoso el modelo de actor presente en lenguajes como <b>Erlang</b> o <b>Scala</b>. Ir, en el otro lado, usa la <b>comunicación de procesos secuenciales</b> ( <span class="acronym">CSP</span> ), que tiene un enfoque diferente a la concurrencia.</p>
</div>
<h4 id="concurrency-versus-parallelism">Concurrencia versus paralelismo</h4>
<div class="hBody-4">
<p>Muchas personas han malentendido las diferencias entre ambos, incluso
 pensando que son lo mismo. Hay un discurso popular de Rob Pike, uno de
los creadores de Go, la <i>concurrencia no es paralelismo</i>, con lo que realmente estoy de acuerdo. Como un resumen rápido de la charla, podemos extraer lo siguiente:</p>
<ul>
<li>
<p>La concurrencia se trata de lidiar con muchas cosas a la vez</p>
</li>
<li>
<p>El paralelismo se trata de hacer muchas cosas al mismo tiempo</p>
</li>
</ul>
<p>La concurrencia permite el paralelismo mediante el diseño de una estructura correcta de trabajo de concurrencia.</p>
<p>Por ejemplo, podemos pensar en el mecanismo de una bicicleta. Cuando
pedaleemos, generalmente presionamos el pedal para producir fuerza (y
este empuje, levanta la pierna opuesta en el pedal opuesto). No podemos
empujar con ambas piernas al mismo tiempo porque las bielas no nos
permiten hacerlo. Pero este diseño permite la construcción de una
bicicleta paralela, comúnmente llamada <b>bicicleta tándem</b>. Una
bicicleta tándem es una bicicleta que dos personas pueden conducir al
mismo tiempo; ambos pedalean y aplican fuerza a la bicicleta.</p>
<p>En el ejemplo de la bicicleta, la concurrencia es el diseño de una
bicicleta que, con dos patas (Goroutines), puede producir energía para
mover la bicicleta usted mismo.</p>
<p>El diseño es concurrente y correcto. Si utilizamos una bicicleta
tándem y dos personas (dos núcleos), la solución es concurrente,
correcta y paralela. Pero la clave es que con un diseño concurrente, no
tenemos que preocuparnos por el paralelismo; podemos considerarlo como
una característica adicional si nuestro diseño simultáneo es correcto.
De hecho, podemos usar la bicicleta tándem con una sola persona, pero el
 diseño simultáneo de las piernas, los pedales, la cadena y las ruedas
de una bicicleta sigue siendo correcto.</p>
<figure>
<img src="Ir%20a%20patrones%20de%20dise%C3%B1o_files/356_1.jpg">
</figure>
<p>Con concurrencia, en el lado izquierdo, tenemos un diseño y una
estructura que se ejecuta secuencialmente por el mismo núcleo de la CPU.
 Una vez que tenemos este diseño y estructura, se puede lograr el
paralelismo simplemente repitiendo esta estructura en un hilo diferente.</p>
<p>Así es como Go alivia el razonamiento sobre los programas
concurrentes y paralelos simplemente al no preocuparse demasiado por la
ejecución paralela y concentrarse mucho más en el diseño y la estructura
 concurrentes. Al dividir una gran tarea en tareas más pequeñas que se
pueden ejecutar simultáneamente, se obtiene un rendimiento mucho mejor
en una computadora de un solo núcleo, pero si este diseño también se
puede ejecutar en paralelo, podríamos lograr un rendimiento aún mayor (o
 no, dependiendo del diseño).</p>
<p>De hecho, podemos establecer el número de núcleos en uso en una aplicación Go estableciendo la variable de entorno <code>GOMAXPROCS</code> en la cantidad de núcleos que queremos. Esto no solo es útil cuando se utilizan programadores, como <b>Apache Mesos</b>, sino que nos da más control sobre cómo funciona y funciona una aplicación Go.</p>
<p>Entonces, para recapitular, es muy importante tener en cuenta que la
concurrencia es acerca de la estructura y el paralelismo es sobre la
ejecución. Debemos pensar en hacer nuestros programas concurrentes de
una mejor manera, dividiéndolos en pequeños trabajos, y el planificador
de Go intentará hacerlos paralelos si es posible y permitido.</p>
</div>
<h4 id="csp-versus-actor-based-concurrency">CSP versus concurrencia basada en actores</h4>
<div class="hBody-4">
<p>La forma más común y quizás más intuitiva de pensar sobre la
concurrencia es similar a la forma en que funciona el modelo de actor.</p>
<figure>
<img src="Ir%20a%20patrones%20de%20dise%C3%B1o_files/357_1.jpg">
</figure>
<p>En el modelo de actor, si el <b>Actor 1</b> quiere comunicarse con el <b>Actor 2</b>, entonces el <b>Actor 1</b> debe conocer al <b>Actor 2</b>
 primero; por ejemplo, debe tener su ID de proceso, tal vez desde el
paso de creación, y poner un mensaje en su cola de la bandeja de
entrada. Después de colocar el mensaje, el <b>Actor 1</b> puede continuar sus tareas sin ser bloqueado si el <b>Actor 2</b> no puede procesar el mensaje inmediatamente.</p>
<p>CSP, por otro lado, introduce una nueva entidad en los canales de
ecuaciones. Los canales son la forma de comunicarse entre procesos
porque son completamente anónimos (a diferencia de los actores, donde
necesitamos conocer sus identificaciones de proceso). En el caso de CSP,
 no tenemos una ID de proceso para usar para comunicarnos. En cambio,
tenemos que crear un canal para los procesos que permita la comunicación
 entrante y saliente. En este caso, lo que sabemos que el receptor es el
 canal que utiliza para recibir datos:</p>
<figure>
<img src="Ir%20a%20patrones%20de%20dise%C3%B1o_files/358_1.jpg">
</figure>
<p>En este diagrama, podemos ver que los procesos son anónimos, pero tenemos un canal con ID 1, es decir, <b>Canal 1</b>,
 que los conecta entre sí. Esta abstracción no nos dice cuántos procesos
 hay en cada lado del canal; simplemente los conecta y permite la
comunicación entre procesos mediante el uso del canal.</p>
<p>La clave aquí es que los canales aíslan ambos extremos para que el
proceso A pueda enviar datos a través de un canal que será manejado por
uno o más procesos que son transparentes para A. También funciona igual
en sentido inverso; el proceso B puede recibir datos de muchos canales,
uno a la vez.</p>
</div>
<h3 id="goroutines">Goroutines</h3>
<div class="hBody-3">
<p>En Go, logramos concurrencia al trabajar con Goroutines. Son como
procesos que ejecutan aplicaciones en una computadora al mismo tiempo;
de hecho, el ciclo principal de Go podría considerarse también un
Goroutine. Los goroutines se usan en lugares donde usaríamos actores.
Ejecutan un poco de lógica y mueren (o mantienen el bucle si es
necesario).</p>
<p>Pero los Goroutines no son hilos. Podemos lanzar miles de Goroutines
concurrentes, incluso millones. Son increíblemente baratos, con una
pequeña pila de crecimiento. Usaremos Goroutines para ejecutar el código
 que queremos que funcione al mismo tiempo. Por ejemplo, tres llamadas a
 tres servicios para componer una respuesta se pueden diseñar al mismo
tiempo con tres Goroutines para hacer las llamadas de servicio
potencialmente en paralelo y un cuarto Goroutine para recibirlas y
componer la respuesta. ¿Cuál es el punto aquí? Que si tenemos una
computadora con cuatro núcleos, podríamos ejecutar esta llamada de
servicio en paralelo, pero si usamos una computadora de un solo núcleo,
el diseño seguirá siendo correcto y las llamadas se ejecutarán
simultáneamente en un solo núcleo. Al diseñar aplicaciones concurrentes,
 no necesitamos preocuparnos por la ejecución paralela.</p>
<p>Volviendo a la analogía de la bicicleta, estábamos empujando los
pedales de la bicicleta con nuestras dos piernas. Son dos Goroutines
empujando simultáneamente los pedales. Cuando usamos el tándem, tuvimos
un total de cuatro Goroutines, posiblemente trabajando en paralelo. Pero
 también tenemos dos manos para manejar los frenos delanteros y
traseros. Eso es un total de ocho Goroutines para nuestra bicicleta de
dos hilos. En realidad, no pedaleamos cuando frenamos y no frenamos
cuando pedaleemos; ese es un diseño concurrente correcto. Nuestro
sistema nervioso transporta la información sobre cuándo dejar de
pedalear y cuándo comenzar a frenar. En Go, nuestro sistema nervioso
está compuesto de canales; los veremos después de jugar un poco con
Goroutines primero.</p>
</div>
<h4 id="our-first-goroutine">Nuestro primer Goroutine</h4>
<div class="hBody-4">
<p>Ya basta de explicaciones. Vamos a ensuciarnos las manos. Para nuestro primer Goroutine, imprimiremos el mensaje <code>Hello World!</code> en un Goroutine. Comencemos con lo que hemos estado haciendo hasta ahora:</p>
<pre class="code"><code class="go">package main

func main() {
  helloWorld()
}

func helloWorld(){
  println("Hello World!")
}
</code></pre>
<p>La ejecución de este pequeño fragmento de código simplemente saldrá <code>Hello World!</code> en la consola:</p>
<pre class="srci"><code class="sh"><span class="in"><span class="prompt">&gt; </span>go run main.go
</span><span class="out">Hello World!
</span></code></pre>
<p>No es nada impresionante. Para ejecutarlo en un nuevo Goroutine, solo necesitamos agregar la palabra clave <code>go</code> al comienzo de la llamada a la función:</p>
<pre class="code"><code class="go">package main

func main() {
  go helloWorld()
}

func helloWorld(){
  println("Hello World!")
}
</code></pre>
<p>Con esta simple palabra, le estamos diciendo a Go que comience un nuevo Goroutine ejecutando el contenido de la función <code>helloWorld</code>.</p>
<p>Entonces, vamos a ejecutarlo</p>
<pre class="srci"><code class="sh"><span class="in"><span class="prompt">&gt; </span>go run main.go
</span><span class="out">&gt;
</span></code></pre>
<p>¿Qué? ¡No imprimió nada! ¿Porqué es eso? Las cosas se complican
cuando empiezas a lidiar con aplicaciones concurrentes. El problema es
que la función <code>main</code> termina antes de <code>helloWorld</code> que se ejecute la función. Analicémoslo paso a paso. la función <code>main</code> se inicia y programa un nuevo Goroutine que ejecutará la función <code>helloWorld</code>, pero la función no se ejecuta cuando la función finaliza; todavía está en el proceso de programación.</p>
<p>Entonces, nuestro <code>main</code> problema es que la función <code>main</code>
 tiene que esperar a que se ejecute el Goroutine antes de finalizar. Así
 que hagamos una pausa por un segundo para darle un poco de espacio al
Goroutine:</p>
<pre class="code"><code class="go">package main
import "time"

func main() {
  go helloWorld()

  time.Sleep(time.Second)
}

func helloWorld(){
  println("Hello World!")
}
</code></pre>
<p>La función <code>time.Sleep</code> efectivamente duerme el Goroutine
principal durante un segundo antes de continuar (y salir). Si ejecutamos
 esto ahora, debemos recibir el mensaje:</p>
<pre class="srci"><code class="sh"><span class="in"><span class="prompt">&gt; </span>go run main.go
</span><span class="out">Hello World!
</span></code></pre>
<p>Supongo que debe haberse dado cuenta ahora del pequeño espacio de
tiempo en que el programa se congela antes de terminar. Esta es la
función para dormir. Si está haciendo muchas tareas, puede elevar el
tiempo de espera a lo que desee. Solo recuerda que en cualquier
aplicación la función <code>main</code> no puede terminar antes que el resto de los Goroutines.</p>
</div>
<h4 id="anonymous-functions-launched-as-new-goroutines">Funciones anónimas lanzadas como nuevas Goroutinas</h4>
<div class="hBody-4">
<p>Hemos definido la función <code>helloWorld</code> para que pueda ser
lanzada con un Goroutine diferente. Esto no es estrictamente necesario
porque puede lanzar fragmentos de código directamente en el alcance de
la función:</p>
<pre class="code"><code class="go">package main
import "time"

func main() {
  go func() {
    println("Hello World")
  }()
  time.Sleep(time.Second)
}
</code></pre>
<p>Esto también es válido Hemos utilizado una función anónima y la hemos lanzado en un nuevo Goroutine utilizando la palabra clave <code>go</code>.
 Eche un vistazo más de cerca a las llaves de cierre de la función; a
continuación, se abren y cierran los paréntesis, lo que indica la
ejecución de la función.</p>
<p>También podemos pasar datos a funciones anónimas:</p>
<pre class="code"><code class="go">package main
import "time"

func main() {
  go func(msg string) {
    println(msg)
  }("Hello World")
  time.Sleep(time.Second)
}
</code></pre>
<p>Esto también es válido Habíamos definido una función anónima que
recibió una cadena, que luego imprimió la cadena recibida. Cuando
llamamos a la función en un Goroutine diferente, pasamos el mensaje que
queríamos imprimir. En este sentido, el siguiente ejemplo también sería
válido:</p>
<pre class="code"><code class="go">package main
import "time"

func main() {
  messagePrinter := func(msg string) {
    println(msg)
  }

  go messagePrinter("Hello World")
  go messagePrinter("Hello goroutine")
  time.Sleep(time.Second)
}
</code></pre>
<p>En este caso, hemos definido una función dentro del alcance de nuestra función <code>main</code> y la hemos almacenado en una variable llamada <code>messagePrinter</code>. Ahora podemos imprimir al mismo tiempo tantos mensajes como queramos usando la firma <code>messagePrinter(string)</code>:</p>
<pre class="srci"><code class="sh"><span class="in"><span class="prompt">&gt; </span>go run main.go
</span><span class="out">Hello World
Hello goroutine
</span></code></pre>
<p>Recién hemos arañado la superficie de la programación concurrente en
Go, pero ya podemos ver que puede ser bastante poderosa. Pero
definitivamente tenemos que hacer algo con ese período de sueño.
WaitGroups puede ayudarnos con este problema.</p>
</div>
<h4 id="waitgroups">WaitGroups</h4>
<div class="hBody-4">
<p>WaitGroup viene en el paquete de sincronización (el paquete <code>sync</code>)
 para ayudarnos a sincronizar muchos Goroutines concurrentes. Funciona
muy fácilmente: cada vez que tenemos que esperar que un Goroutine
termine, agregamos 1 al grupo, y una vez que se agregan todos, le
pedimos al grupo que espere. Cuando el Goroutine termina, dice <code>Done</code>y el WaitGroup tomará uno del grupo:</p>
<pre class="code"><code class="go">package main

import (
  "sync"
  "fmt"
)

func main() {
  var wait sync.WaitGroup
  wait.Add(1)

  go func(){
    fmt.Println("Hello World!")
    wait.Done()
  }()
  wait.Wait()
}
</code></pre>
<p>Este es el ejemplo más simple posible de a <code>WaitGroup</code>. Primero, creamos una variable para mantenerla llamada la variable <code>wait</code>. Luego, antes de lanzar el nuevo Goroutine, le decimos al WaitGroup <code>hey, you'll have to wait for one thing to finish</code> usando el método <code>wait.Add(1)</code>.
 Ahora podemos lanzar el 1 que espera el WaitGroup, que en este caso es
el anterior Goroutine que imprime Hello World y dice Done (usando el
método <code>wait.Done()</code>) al final de Goroutine. Finalmente, indicamos al WaitGroup que espere. Debemos recordar que la función <code>wait.Wait()</code> probablemente fue ejecutada antes de Goroutine.</p>
<p>Vamos a ejecutar el código de nuevo:</p>
<pre class="srci"><code class="sh"><span class="in"><span class="prompt">&gt; </span>go run main.go
</span><span class="out">Hello World!
</span></code></pre>
<p>Ahora solo espera el tiempo necesario y no un milisegundo más antes
de salir de la aplicación. Recuerde que cuando usamos el método <code>Add(value)</code>, agregamos entidades al <code>WaitGroup</code>, y cuando usamos el método <code>Done()</code>, restamos uno.</p>
<p>En realidad, la función <code>Add</code> toma un valor delta, por lo que el siguiente código es equivalente al anterior:</p>
<pre class="code"><code class="go">package main

import (
  "sync"
  "fmt"
)

func main() {
  var wait sync.WaitGroup
  wait.Add(1)

  go func(){
    fmt.Println("Hello World!")
    wait.Add(-1)
  }()
  wait.Wait()
}
</code></pre>
<p>En este caso, agregamos 1 antes de lanzar el Goroutine y agregamos <code>-1</code>(restamos 1) al final del mismo. Si sabemos de antemano cuántos Goroutines vamos a lanzar, también podemos llamar al método <code>Add</code> solo una vez:</p>
<pre class="code"><code class="go">package main
import (
  "fmt"
  "sync"
)

func main() {
  var wait sync.WaitGroup

  goRoutines := 5
  wait.Add(goRoutines)

  for i := 0; i &lt; goRoutines; i++ {
    go func(goRoutineID int) {
      fmt.Printf("ID:%d: Hello goroutines!\n", goRoutineID)
      wait.Done()
    }(i)
  }
  wait.Wait()
}
</code></pre>
<p>En este ejemplo, vamos a crear cinco Goroutines (como se indica en la variable <code>goroutines</code>).
 Lo sabemos de antemano, así que simplemente los agregamos todos al
WaitGroup. Entonces vamos a lanzar la misma cantidad de variables <code>goroutine</code> mediante el uso de un bucle <code>for</code>. Cada vez que termina un Goroutine, llama al método <code>Done()</code> del WaitGroup que efectivamente está esperando al final del ciclo principal.</p>
<p>De nuevo, en este caso, el código llega al final de la función <code>main</code> antes de que se inicien todos los Goroutines (si corresponde), y el WaitGroup espera a que se ejecute el flujo principal hasta <code>Done</code> que se llamen todos los mensajes. Vamos a ejecutar este pequeño programa:</p>
<pre class="srci"><code class="sh"><span class="in"><span class="prompt">&gt; </span>go run main.go
</span><span class="out">ID:4: Hello goroutines!
ID:0: Hello goroutines!
ID:1: Hello goroutines!
ID:2: Hello goroutines!
ID:3: Hello goroutines!
</span></code></pre>
<p>No lo hemos mencionado antes, pero hemos pasado el índice de iteración a cada Goroutine como el parámetro <code>GoroutineID</code> para imprimirlo con el mensaje. <code>Hello goroutines!</code>
 También podría haber notado que los Goroutines no se ejecutan en orden.
 ¡Por supuesto! Estamos tratando con un planificador que no garantiza el
 orden de ejecución de los Goroutines. Esto es algo a tener en cuenta al
 programar aplicaciones simultáneas. De hecho, si lo ejecutamos de
nuevo, no obtendremos necesariamente el mismo orden de salida:</p>
<pre class="srci"><code class="sh"><span class="in"><span class="prompt">&gt; </span>go run main.go
</span><span class="out">ID:4: Hello goroutines!
ID:2: Hello goroutines!
ID:1: Hello goroutines!
ID:3: Hello goroutines!
ID:0: Hello goroutines!
</span></code></pre>
</div>
<h3 id="callbacks">Devolución de llamada</h3>
<div class="hBody-3">
<p>Ahora que sabemos cómo usar WaitGroups, también podemos presentar el
concepto de devolución de llamada. Si alguna vez ha trabajado con
lenguajes como JavaScript que los usan extensamente, esta sección le
resultará familiar. Una devolución de llamada es una función anónima que
 se ejecutará dentro del contexto de una función diferente.</p>
<p>Por ejemplo, queremos escribir una función para convertir una cadena
en mayúscula, así como para hacerla asíncrona. ¿Cómo escribimos esta
función para que podamos trabajar con devoluciones de llamada? Hay un
pequeño truco: podemos tener una función que toma una cadena y devuelve
una cadena:</p>
<pre class="code"><code class="go">func toUpperSync(word string) string {
  // Code will go here
}
</code></pre>
<p>Así que tome el tipo de retorno de esta función (una cadena) y
póngalo como el segundo parámetro en una función anónima, como se
muestra aquí:</p>
<pre class="code"><code class="go">func toUpperSync(word string, f func(string)) {
  // Code will go here
}
</code></pre>
<p>Ahora, la función <code>toUpperSync</code> no devuelve nada, pero
también toma una función que, por coincidencia, también toma una cadena.
 Podemos ejecutar esta función con el resultado que normalmente
devolveremos.</p>
<pre class="code"><code class="go">func toUpperSync(word string, f func(string)) {
  f(strings.ToUpper(word))
}
</code></pre>
<p>Ejecutamos la función f con el resultado de llamar al método <code>strings.ToUpper</code> con la palabra proporcionada (que devuelve la palabra <code>parameter</code> en mayúscula). Vamos a escribir la función <code>main</code> también:</p>
<pre class="code"><code class="go">package main

import (
  "fmt"
  "strings"
)

func main() {
  toUpperSync("Hello Callbacks!", func(v string) {
    fmt.Printf("Callback: %s\n", v) })
}

func toUpperSync(word string, f func(string)) {
  f(strings.ToUpper(word))
}
</code></pre>
<p>En nuestro código principal, hemos definido nuestra devolución de llamada. Como puede ver, aprobamos la prueba <code>Hello Callbacks!</code>
 para convertirla a mayúsculas. A continuación, pasamos la devolución de
 llamada para que se ejecute con el resultado de pasar nuestra cadena a
mayúsculas. En este caso, simplemente imprimimos el texto en la consola
con el texto <code>Callback</code> al frente. Cuando ejecutamos este código, obtenemos el siguiente resultado:</p>
<pre class="srci"><code class="sh"><span class="in"><span class="prompt">&gt; </span>go run main.go
</span><span class="out">Callback: HELLO CALLBACKS!
</span></code></pre>
<p>Estrictamente hablando, esta es una devolución de llamada sincrónica.
 Para que sea asíncrono tenemos que introducir un manejo simultáneo:</p>
<pre class="code"><code class="go">package main
import (
  "fmt"
  "strings"
  "sync"
)

var wait sync.WaitGroup

func main() {
  wait.Add(1)

  toUpperAsync("Hello Callbacks!", func(v string) {
    fmt.Printf("Callback: %s\n", v)
    wait.Done()
  })

  println("Waiting async response...")
  wait.Wait()
}

func toUpperAsync(word string, f func(string)) {
  go func(){
    f(strings.ToUpper(word))
  }()
}
</code></pre>
<p>Este es el mismo código ejecutado de forma asincrónica. Usamos
WaitGroups para gestionar la simultaneidad (veremos más adelante que los
 canales también se pueden usar para esto). Ahora, nuestra función <code>toUpperAsync</code> es, como su nombre lo indica, asíncrona. Lanzamos la devolución de llamada en un Goroutine diferente al usar la palabra clave <code>go</code>
 cuando llamamos a la devolución de llamada. Escribimos un pequeño
mensaje para mostrar la naturaleza de ordenamiento de la ejecución
simultánea de manera más precisa. Esperamos hasta que la devolución de
llamada indique que ha terminado y podemos salir del programa de forma
segura. Cuando ejecutamos esto, obtenemos el siguiente resultado:</p>
<pre class="srci"><code class="sh"><span class="in"><span class="prompt">&gt; </span>go run main.go
</span><span class="out">
Waiting async response...
Callback: HELLO CALLBACKS!
</span></code></pre>
<p>Como puede ver, el programa llega al final de la función <code>main</code> antes de ejecutar la devolución de llamada en la función <code>toUpperAsync</code>.
 Este patrón ofrece muchas posibilidades, pero nos deja abiertos a un
gran problema llamado "infierno de devolución de llamada".</p>
</div>
<h4 id="callback-hell">Infierno de devolución de llamada</h4>
<div class="hBody-4">
<p>El término <b>infierno de devolución de llamada</b> se usa comúnmente
 para referirse a cuando muchas devoluciones de llamada se han apilado
una dentro de la otra. Esto los hace difíciles de razonar y manejar
cuando crecen demasiado. Por ejemplo, usando el mismo código que antes,
podríamos apilar otra llamada asincrónica con los contenidos que
imprimimos previamente a la consola:</p>
<pre class="code"><code class="go">func main() {
  wait.Add(1)

  toUpperAsync("Hello Callbacks!", func(v string) {
    toUpperAsync(fmt.Sprintf("Callback: %s\n", v), func(v string) {
      fmt.Printf("Callback within %s", v)
      wait.Done()
    })
  })
  println("Waiting async response...")
  wait.Wait()
}
</code></pre>
<p>(Hemos omitido las importaciones, el nombre del paquete y la función <code>toUpperAsync</code>, ya que no han cambiado). Ahora tenemos la función <code>toUpperAsync</code> dentro de una función <code>toUpperAsync</code>,
 y podríamos insertar muchas más si queremos. En este caso, volvemos a
pasar el texto que imprimimos previamente en la consola para usarlo en
la siguiente devolución de llamada. La devolución de llamada interna
finalmente lo imprime en la consola, dando el siguiente resultado:</p>
<pre class="srci"><code class="sh"><span class="in"><span class="prompt">&gt; </span>go run main.go
</span><span class="out">Waiting async response...
Callback within CALLBACK: HELLO CALLBACKS!
</span></code></pre>
<p>En este caso, podemos suponer que la devolución de llamada externa se
 ejecutará antes que la interna. Es por eso que no necesitamos agregar
uno más al WaitGroup.</p>
<p>El punto aquí es que debemos tener cuidado al usar devoluciones de
llamada. En sistemas muy complejos, demasiadas devoluciones de llamadas
son difíciles de razonar y difíciles de manejar. Pero con cuidado y
racionalidad, son herramientas poderosas.</p>
</div>
<h3 id="mutexes">Mutexes</h3>
<div class="hBody-3">
<p>Si está trabajando con aplicaciones concurrentes, tiene que tratar
con más de un recurso que potencialmente acceda a alguna ubicación de
memoria. Esto generalmente se llama <b>condición de raza</b>.</p>
<p>En términos más simples, una condición de carrera es similar a ese
momento en el que dos personas intentan obtener el último trozo de pizza
 exactamente al mismo tiempo: sus manos chocan. Reemplace la pizza con
una variable y sus manos con Goroutines y tendremos una analogía
perfecta.</p>
<p>Hay un personaje en la mesa para resolver este problema: un padre o
una madre. Han mantenido la pizza en una mesa diferente y tenemos que
pedir permiso para ponerse de pie antes de tomar nuestra porción de
pizza. No importa si todos los niños preguntan al mismo tiempo, solo
permitirán que un niño se pare.</p>
<p>Bueno, un mutex es como nuestros padres. Controlarán quién puede
acceder a la pizza, es decir, una variable, y no permitirán que nadie
más acceda a ella.</p>
<p>Para usar un mutex, tenemos que bloquearlo activamente; si ya está
bloqueado (otro Goroutine lo está usando), tendremos que esperar hasta
que se desbloquee de nuevo. Una vez que tenemos acceso al mutex, podemos
 volver a bloquearlo, hacer las modificaciones que sean necesarias y
desbloquearlo nuevamente. Veremos esto usando un ejemplo.</p>
</div>
<h4 id="an-example-with-mutexes---concurrent-counter">Un ejemplo con mutexes - contador concurrente</h4>
<div class="hBody-4">
<p>Los mutexes son ampliamente utilizados en la programación
concurrente. Tal vez no tanto en Go porque tiene una forma más
idiomática de programación concurrente en el uso de canales, pero vale
la pena ver cómo funcionan para las situaciones donde los canales
simplemente no encajan tan bien.</p>
<p>Para nuestro ejemplo, vamos a desarrollar un pequeño contador
simultáneo. Este contador agregará uno a un campo entero en un tipo <code>Counter</code>. Esto se debe hacer de forma simultánea y segura.</p>
<p>Nuestra estructura <code>Counter</code> se define así:</p>
<pre class="code"><code class="go">type Counter struct {
  sync.Mutex
  value int
}
</code></pre>
<p>La estructura <code>Counter</code> tiene un campo de tipo <code>int</code> que almacena el valor actual del recuento. También incrusta el tipo <code>Mutex</code> del paquete <code>sync</code>. Incrustar este campo nos permitirá bloquear y desbloquear toda la estructura sin llamar activamente a un campo específico.</p>
<p>Nuestra función <code>main</code> lanza 10 Goroutines que intentan agregar uno al valor de campo de la estructura <code>Counter</code>. Todo esto se hace al mismo tiempo:</p>
<pre class="code"><code class="go">package main

import (
  "sync"
  "time"
)

func main() {
  counter := Counter{}

  for i := 0; i &lt; 10; i++ {
    go func(i int) {
      counter.Lock()
      counter.value++
      defer counter.Unlock()
    }(i)
  }
  time.Sleep(time.Second)

  counter.Lock()
  defer counter.Unlock()

  println(counter.value)
}
</code></pre>
<p>Hemos creado un tipo llamado Counter. Usando un bucle for, hemos lanzado un total de 10 Goroutines, como vimos en las <i>funciones Anónimas lanzadas como la nueva</i> sección de <i>Goroutines</i>.
 Pero dentro de cada Goroutine, estamos bloqueando el mostrador para que
 no más Goroutines pueda acceder, agregar uno al valor del campo y
desbloquearlo de nuevo para que otros puedan acceder a él.</p>
<p>Finalmente, imprimiremos el valor mantenido por el contador. Debe ser
 10 porque hemos lanzado 10 Goroutines. Pero, ¿cómo podemos saber que
este programa es seguro para subprocesos? Bueno, Go viene con una
característica muy útil incorporada llamada "detector de raza".</p>
</div>
<h4 id="presenting-the-race-detector">Presentando el detector de raza</h4>
<div class="hBody-4">
<p>Ya sabemos lo que es una condición de carrera. Para recapitular, se
usa cuando dos procesos intentan acceder al mismo recurso al mismo
tiempo con una o más operaciones de escritura (tanto escritura de
procesos como una escritura de proceso mientras que la otra lee)
involucradas en ese momento preciso.</p>
<p>Go tiene una herramienta muy útil para ayudar a diagnosticar las
condiciones de carrera, que puede ejecutar en sus pruebas o en su
aplicación principal directamente. Así que reutilicemos el ejemplo que
acabamos de escribir para la sección de <i>exclusión mutua</i> y
ejecútelo con el detector de raza. Esto es tan simple como agregar el
indicador de la línea de comandos -race a la ejecución del comando de
nuestro programa:</p>
<pre class="srci"><code class="sh"><span class="in"><span class="prompt">&gt; </span>go run -race main.go
</span><span class="out">10
</span></code></pre>
<p>Bueno, no es muy impresionante ¿verdad? Pero, de hecho, nos dice que
no ha detectado una posible condición de carrera en el código de este
programa. Hagamos que el detector de bandera <code>-race</code> nos advierta de una posible condición de carrera al no bloquear<code>counter</code> antes de modificarlo:</p>
<pre class="code"><code class="go">for i := 0; i &lt; 10; i++ {
  go func(i int) {
    // counter.Lock()
    counter.value++
    // counter.Unlock()
  }(i)
}
</code></pre>
<p>Dentro del bucle <code>for</code>, el comentar <code>Lock</code>y llamadas <code>Unlock</code> antes y después de añadir <code>1</code>
 al valor del campo. Esto introducirá una condición de carrera. Vamos a
ejecutar el mismo programa nuevamente con la bandera de carrera
activada:</p>
<pre class="srci"><code class="sh"><span class="in"><span class="prompt">&gt; </span>go run -race main.go
</span><span class="out">==================
WARNING: DATA RACE
Read at 0x00c42007a068 by goroutine 6:
  main.main.func1()
      [some_path]/concurrency/locks/main.go:19 +0x44
Previous write at 0x00c42007a068 by goroutine 5:
  main.main.func1()
      [some_path]/concurrency/locks/main.go:19 +0x60
Goroutine 6 (running) created at:
  main.main()
      [some_path]/concurrency/locks/main.go:21 +0xb6
Goroutine 5 (finished) created at:
  main.main()
      [some_path]/concurrency/locks/main.go:21 +0xb6
==================
10
Found 1 data race(s)
exit status 66
</span></code></pre>
<p>Reduje un poco la salida para ver las cosas más claramente. Podemos ver una gran lectura de mensaje en mayúsculas <code>WARNING: DATA RACE</code>. Pero esta salida es muy fácil de razonar. Primero, nos está diciendo que alguna posición de memoria representada por la <i>línea 19</i> en nuestro archivo <span class="file">main.go</span> está leyendo alguna variable. ¡Pero también hay una operación de escritura en la <i>línea 19</i> del mismo archivo!</p>
<p>Esto se debe a que una <q><code>++</code></q>operación requiere una
lectura del valor actual y una escritura para agregarle uno. Es por eso
que la condición de carrera está en la misma línea, porque cada vez que
se ejecuta, lee y escribe el campo en la estructura <code>Counter</code>.</p>
<p>Pero tengamos en cuenta que el detector de raza funciona en tiempo de
 ejecución. ¡No analiza nuestro código estáticamente! Qué significa eso?
 Significa que podemos tener una condición de carrera potencial en
nuestro diseño que el detector de raza no detectará. Por ejemplo:</p>
<pre class="code"><code class="go">package main

import "sync"

type Counter struct {
  sync.Mutex
  value int
}

func main() {
  counter := Counter{}

  for i := 0; i &lt; 1; i++ {
    go func(i int) {
      counter.value++
    }(i)
  }
}
</code></pre>
<p>Dejaremos el código como se muestra en el ejemplo anterior. Tomaremos
 todos los bloqueos y desbloqueos del código y lanzaremos un solo
Goroutine para actualizar el campo <code>value</code>:</p>
<pre class="srci"><code class="sh"><span class="in"><span class="prompt">&gt; </span>go run -race main.go
</span></code></pre>
<p>No hay advertencias, por lo que el código es correcto. Bueno, sabemos
 que, por diseño, no lo es. Podemos aumentar el número de Goroutines
ejecutados a dos y ver qué sucede:</p>
<pre class="code"><code class="go">for i := 0; i &lt; 2; i++ {
  go func(i int) {
    counter.value++
  }(i)
}
</code></pre>
<p>Ejecutamos el programa nuevamente:</p>
<pre class="srci"><code class="sh"><span class="in"><span class="prompt">&gt; </span>go run -race main.go
</span><span class="out">WARNING: DATA RACE
Read at 0x00c42007a008 by goroutine 6:
  main.main.func1()
    [some_path]concurrency/race_detector/main.go:15 +0x44
Previous write at 0x00c42007a008 by goroutine 5:
  main.main.func1()
    [some_path]/concurrency/race_detector/main.go:15 +0x60
Goroutine 6 (running) created at:
  main.main()
    [some_path]/concurrency/race_detector/main.go:16 +0xad
Goroutine 5 (finished) created at:
  main.main()
    [some_path]/concurrency/race_detector/main.go:16 +0xad
==================
Found 1 data race(s)
exit status 66
</span></code></pre>
<p>Ahora sí, se detecta la condición de carrera. Pero, ¿qué pasa si
reducimos la cantidad de procesadores en uso a solo uno? ¿Tendremos una
condición de carrera también?</p>
<pre class="srci"><code class="sh"><span class="in"><span class="prompt">&gt; </span>GOMAXPROCS=1 go run -race main.go
</span></code></pre>
<p>Parece que no se ha detectado ninguna condición de carrera. Esto se
debe a que el programador ejecutó primero un Goroutine y luego el otro,
por lo que, finalmente, no se produjo la condición de carrera. Pero con
un mayor número de Goroutines, también nos avisará sobre una condición
de carrera, incluso si se usa solo un núcleo.</p>
<p>Entonces, el detector de raza puede ayudarnos a detectar las
condiciones de carrera que están ocurriendo en nuestro código, pero no
nos protegerá de un mal diseño que no está ejecutando las condiciones de
 carrera de forma inmediata. Una característica muy útil que puede
salvarnos de muchos dolores de cabeza.</p>
</div>
<h3 id="channels">Canales</h3>
<div class="hBody-3">
<p>Los canales son la segunda primitiva en el lenguaje que nos permite
escribir aplicaciones simultáneas. Hemos hablado un poco acerca de los
canales en la sección de <i>Procesos secuenciales de comunicación</i>.</p>
<p>Los canales son la forma en que nos comunicamos entre los procesos.
Podríamos compartir una ubicación de memoria y usar mutexes para
controlar el acceso de los procesos. Pero los canales nos proporcionan
una forma más natural de manejar aplicaciones simultáneas que también
producen mejores diseños concurrentes en nuestros programas.</p>
</div>
<h4 id="our-first-channel">Nuestro primer canal</h4>
<div class="hBody-4">
<p>Trabajar con muchos Goroutines parece bastante difícil si no podemos
crear una sincronización entre ellos. El orden de ejecución podría ser
irrelevante tan pronto como se sincronicen. Los canales son la segunda
característica clave para escribir aplicaciones simultáneas en Go.</p>
<p>Un canal de televisión en la vida real es algo que conecta una
emisión (desde un estudio) a millones de televisores (los receptores).
Los canales en Go funcionan de manera similar. Uno o más Goroutines
pueden funcionar como emisores, y uno o más Goroutine pueden actuar como
 receptores.</p>
<p>Una cosa más canales, por defecto, bloquea la ejecución de Goroutines
 hasta que se recibe algo. Es como si nuestro programa de televisión
favorito retrasara la emisión hasta que enciendamos el televisor para no
 perdernos nada.</p>
<p>¿Cómo se hace esto en Go?</p>
<pre class="code"><code class="go">package main

import "fmt"

func main() {
  channel := make(chan string)
  go func() {
    channel &lt;- "Hello World!"
  }()

  message := &lt;-channel
  fmt.Println(message)
}
</code></pre>
<p>Para crear canales en Go, usamos la misma sintaxis que usamos para crear sectores. La palabra clave <code>make</code> se usa para crear un canal, y tenemos que pasar la palabra clave <code>chan</code>y el tipo que transportará el canal, en este caso, cadenas. Con esto, tenemos un canal de bloqueo con el nombre <code>channel</code>. A continuación, lanzamos un Goroutines que envía el mensaje <code>Hello</code> <code>World!</code> al canal. Esto se indica mediante la flecha intuitiva que muestra el flujo: el <code>Hello World!</code> texto que va a ( <code>&lt;-</code>)
 un canal. Esto funciona como una asignación en una variable, por lo que
 solo podemos pasar algo a un canal escribiendo primero el canal, luego
la flecha y finalmente el valor para pasar. No podemos escribir <code>"Hello World!" -&gt; channel</code>.</p>
<p>Como mencionamos anteriormente, este canal bloquea la ejecución de
Gorountines hasta que se recibe un mensaje. En este caso, la ejecución
de la función <code>main</code> se detiene hasta que el mensaje de los Goroutines iniciados llegue al otro extremo del canal en la línea <code>message := &lt;-channel</code>.
 En este caso, la flecha apunta en la misma dirección, pero se coloca
antes del canal, lo que indica que los datos se extraen del canal y se
asignan a una nueva variable llamada mensaje (utilizando el nuevo <q><code>:=</code></q>operador de asignación ).</p>
<p>En este caso, no es necesario usar un WaitGroup para sincronizar la función <code>main</code>
 con los Goroutines creados, ya que la naturaleza predeterminada de los
canales es bloquear hasta que se reciban los datos. Pero, ¿funciona al
revés? Si no hay un receptor cuando Goroutine envía el mensaje,
¿continúa? Editemos este ejemplo para ver esto:</p>
<pre class="code"><code class="go">package main

import (
  "fmt"
  "time"
)

func main() {
  channel := make(chan string)

  var waitGroup sync.WaitGroup

  waitGroup.Add(1)
  go func() {
    channel &lt;- "Hello World!"
    println("Finishing goroutine")
    waitGroup.Done()
  }()

  time.Sleep(time.Second)
  message := &lt;-channel
  fmt.Println(message)
  waitGroup.Wait()
}
</code></pre>
<p>Vamos a usar la función <code>Sleep</code> nuevamente. En este caso, imprimimos un mensaje cuando el Goroutine finaliza. La gran diferencia está en la función <code>main</code>. Ahora esperamos un segundo antes de escuchar el canal de datos:</p>
<pre class="srci"><code class="sh"><span class="in"><span class="prompt">&gt; </span>go run main.go
</span><span class="out">Finishing goroutine
Hello World!
</span></code></pre>
<p>La salida puede diferir porque, una vez más, no hay garantías en el
orden de ejecución, pero ahora podemos ver que no se imprime ningún
mensaje hasta que ha transcurrido un segundo. Después del retraso
inicial, comenzamos a escuchar el canal, tomar los datos e imprimirlo.
Entonces, el emisor también debe esperar una señal del otro lado del
canal para continuar su ejecución.</p>
<p>Para recapitular, los canales son formas de comunicarse entre
Goroutines enviando datos a través de un extremo y recibiéndolos en el
otro (como una tubería). En su estado predeterminado, un emisor
Goroutine bloqueará su ejecución hasta que un receptor Goroutine tome
los datos. Lo mismo aplica para un receptor Goroutine, que bloqueará
hasta que algún emisor envíe datos a través del canal. Entonces puede
tener oyentes pasivos (esperando datos) o emisores pasivos (esperando a
los oyentes).</p>
</div>
<h3 id="buffered-channels">Canales almacenados</h3>
<div class="hBody-3">
<p>Un canal en búfer funciona de manera similar a los canales sin búfer
predeterminados. También puedes pasar y tomar valores de ellos usando
las flechas, pero, a diferencia de los canales sin búfer, los remitentes
 no necesitan esperar hasta que algún Goroutine elija los datos que
están enviando:</p>
<pre class="code"><code class="go">package main

import (
  "fmt"
  "time"
)

func main() {
  channel := make(chan string, 1)

  go func() {
    channel &lt;- "Hello World!"
    println("Finishing goroutine")
  }()

  time.Sleep(time.Second)

  message := &lt;-channel
  fmt.Println(message)
}
</code></pre>
<p>Este ejemplo es como el primer ejemplo que usamos para los canales,
pero ahora hemos establecido la capacidad del canal a uno en la
declaración <code>make</code>. Con esto, le decimos al compilador que
este canal tiene una capacidad de una cadena antes de ser bloqueado.
Entonces la primera cuerda no bloquea el emisor, pero la segunda sí.
Vamos a ejecutar este ejemplo:</p>
<pre class="srci"><code class="sh"><span class="in"><span class="prompt">&gt; </span>go run main.go
</span><span class="out">
Finishing goroutine
Hello World!
</span></code></pre>
<p>Ahora podemos ejecutar este pequeño programa tantas veces como
queramos; la salida siempre estará en el mismo orden. Esta vez, hemos
lanzado la función concurrente y esperamos un segundo. Anteriormente, la
 función anónima no continuaría hasta que haya pasado el segundo y
alguien pueda elegir los datos enviados. En este caso, con un canal
almacenado, los datos se mantienen en el canal y liberan a Goroutine
para continuar su ejecución. En este caso, el Goroutine siempre termina
antes de que pase el tiempo de espera.</p>
<p>Este nuevo canal tiene un tamaño de uno, por lo que un segundo mensaje bloquearía la ejecución de Goroutine:</p>
<pre class="code"><code class="go">package main

import (
  "fmt"
  "time"
)

func main() {
  channel := make(chan string, 1)

  go func() {
    channel &lt;- "Hello World! 1"
    channel &lt;- "Hello World! 2"
    println("Finishing goroutine")
  }()

  time.Sleep(time.Second)

  message := &lt;-channel
  fmt.Println(message)
}
</code></pre>
<p>Aquí, agregamos un segundo mensaje <code>Hello world! 2</code>, y le proporcionamos un índice. En este caso, el resultado de este programa podría ser similar al siguiente:</p>
<pre class="srci"><code class="sh"><span class="in"><span class="prompt">&gt; </span>go run main.go
</span><span class="out">Hello World! 1
</span></code></pre>
<p>Indicando que acabamos de tomar un mensaje del buffer de canal, lo hemos impreso y la función <code>main</code>
 finalizó antes de que el Goroutine lanzado pudiera finalizar. El
Goroutine se bloqueó al enviar el segundo mensaje y no pudo continuar
hasta que el otro extremo recibió el primer mensaje. Luego lo imprime
tan rápido que no tiene tiempo de imprimir el mensaje para mostrar la
finalización de Goroutine. Si continúa ejecutando el programa en la
consola, tarde o temprano el planificador finalizará la ejecución de
Goroutine antes del hilo principal.</p>
</div>
<h4 id="directional-channels">Canales direccionales</h4>
<div class="hBody-4">
<p>Una buena característica de los canales Go es que, cuando los
utilizamos como parámetros, podemos restringir su direccionalidad para
que solo se puedan usar para enviar o recibir. El compilador se quejará
si se usa un canal en la dirección restringida. Esta función aplica un
nuevo nivel de tipado estático a las aplicaciones Go y hace que el
código sea más comprensible y legible.</p>
<p>Tomaremos un ejemplo simple con canales:</p>
<pre class="code"><code class="go">package main

import (
  "fmt"
  "time"
)

func main() {
  channel := make(chan string, 1)

  go func(ch chan&lt;- string) {
    ch &lt;- "Hello World!"
    println("Finishing goroutine")
  }(channel)

  time.Sleep(time.Second)

  message := &lt;-channel
  fmt.Println(message)
}
</code></pre>
<p>La línea donde lanzamos el nuevo Goroutine <code>go func(ch chan&lt;- string)</code> establece que el canal pasado a esta función solo puede usarse como un canal de entrada y no puede escucharlo.</p>
<p>También podemos pasar un canal que se utilizará solo como canal receptor:</p>
<pre class="code"><code class="go">func receivingCh(ch &lt;-chan string) {
  msg := &lt;-ch
  println(msg)
}
</code></pre>
<p>Como puede ver, la flecha está en el lado opuesto de la palabra clave <code>chan</code>,
 lo que indica una operación de extracción del canal. Tenga en cuenta
que la flecha del canal siempre apunta a la izquierda, para indicar un
canal de recepción, debe ir a la izquierda, y para indicar un canal de
inserción, debe ir a la derecha.</p>
<p>Si intentamos enviar un valor a través de este canal de <i>solo recepción</i>, el compilador se quejará al respecto:</p>
<pre class="code"><code class="go">func receivingCh(ch &lt;-chan string) {
  msg := &lt;-ch
  println(msg)
  ch &lt;- "hello"
}
</code></pre>
<p>Esta función tiene un canal de solo recepción que trataremos de usar para enviar el mensaje <code>hello</code>. Veamos lo que dice el compilador:</p>
<pre class="srci"><code class="sh"><span class="in"><span class="prompt">&gt; </span>go run main.go
</span><span class="out">./main.go:20: invalid operation: ch &lt;- "hello2" (send to
receive-only type &lt;-chan string)
</span></code></pre>
<p>No le gusta y nos pide que lo corrijamos. Ahora el código es aún más
legible y seguro, y acabamos de colocar una flecha delante o detrás del
argumento <code>chan</code>.</p>
</div>
<h4 id="the-select-statement">La declaración seleccionada</h4>
<div class="hBody-4">
<p>La instrucción select también es una característica clave en Go. Se
usa para manejar más de una entrada de canal dentro de un Goroutine. De
hecho, abre muchas posibilidades, y lo usaremos ampliamente en los
siguientes capítulos.</p>
<figure>
<img src="Ir%20a%20patrones%20de%20dise%C3%B1o_files/384_1.jpg">
</figure>
<p>En la estructura <code>select</code>, solicitamos al programa que
elija entre uno o más canales para recibir sus datos. Podemos guardar
esta información en una variable y hacer algo con ella antes de
finalizar la selección. La estructura <code>select</code> se acaba de
ejecutar una vez; no importa si está escuchando más canales, se
ejecutará solo una vez y el código continuará ejecutándose. Si queremos
que maneje los mismos canales más de una vez, tenemos que ponerlo en un
bucle <code>for</code>.</p>
<p>Crearemos una pequeña aplicación que enviará el mensaje <code>hello</code>y el mensaje <code>goodbye</code> al mismo Goroutine, que los imprimirá y saldrá si no recibe nada más en cinco segundos.</p>
<p>Primero, haremos una función genérica que envía una cadena sobre un canal:</p>
<pre class="code"><code class="go">func sendString(ch chan&lt;- string, s string) {
  ch &lt;- s
}
</code></pre>
<p>Ahora podemos enviar una cadena sobre un canal simplemente llamando al método <code>sendString</code>. Es hora de que el receptor. El receptor tomará mensajes de ambos canales, el que envía mensajes <code>hello</code> y el que envía mensajes <code>goodbye</code>. También puedes ver esto en el diagrama anterior:</p>
<pre class="code"><code class="go">func receiver(helloCh, goodbyeCh &lt;-chan string, quitCh chan&lt;-
bool) {
  for {
    select {
    case msg := &lt;-helloCh:
      println(msg)
    case msg := &lt;-goodbyeCh:
      println(msg)
    case &lt;-time.After(time.Second * 2):
      println("Nothing received in 2 seconds. Exiting")
      quitCh &lt;- true
      break
    }
  }
}
</code></pre>
<p>Comencemos con los argumentos. Esta función toma tres canales: dos
receptores y uno para enviar algo a través de él. Luego, comienza un
ciclo infinito con la palabra clave <code>for</code>. De esta manera, podemos seguir escuchando los dos canales para siempre.</p>
<p>Dentro del alcance del <code>select</code> bloque, tenemos que usar un caso para cada canal que queremos manejar (¿se ha dado cuenta de lo similar que es la declaración <code>switch</code>?). Veamos los tres casos paso a paso:</p>
<ul>
<li>
<p>El primer caso toma los datos entrantes del argumento <code>helloCh</code> y los guarda en una variable llamada <code>msg</code>. Luego imprime el contenido de esta variable.</p>
</li>
<li>
<p>El segundo caso toma los datos entrantes del argumento <code>goodbyeCh</code> y los guarda en una variable llamada <code>msg</code> también. Luego, también imprime el contenido de esta variable.</p>
</li>
<li>
<p>El tercer caso es bastante interesante. Llama a la función <code>time</code>.
 Después de eso, si comprobamos su firma, acepta un valor de tiempo y
duración y devuelve un canal de recepción. Este canal receptor recibirá
un tiempo, el valor de <code>time</code> después de que haya pasado la
duración especificada. En nuestro ejemplo, usamos el canal que devuelve
como un tiempo de espera. Como la selección se reinicia después de cada
identificador, el temporizador también se reinicia. Esta es una manera
muy simple de configurar un temporizador para un Goroutine esperando la
respuesta de uno o más canales.</p>
</li>
</ul>
<p>Todo está listo para la función <code>main</code>:</p>
<pre class="code"><code class="go">package main
import "time"

func main() {
  helloCh := make(chan string, 1)
  goodbyeCh := make(chan string, 1)
  quitCh := make(chan bool)
  go receiver(helloCh, goodbyeCh, quitCh)

  go sendString(helloCh, "hello!")

  time.Sleep(time.Second)

  go sendString(goodbyeCh, "goodbye!")
  &lt;-quitCh
}
</code></pre>
<p>De nuevo, paso a paso, creamos los tres canales que necesitaremos en este ejercicio. Entonces, lanzamos nuestra función <code>receiver</code>
 en un Goroutine diferente. Este Goroutine es manejado por el
programador de Go y nuestro programa continúa. Lanzamos un nuevo
Goroutine para enviar el mensaje <code>hello</code>a los argumentos <code>helloCh</code>. Nuevamente, esto va a ocurrir eventualmente cuando el programador de Go lo decida.</p>
<p>Nuestro programa continúa de nuevo y espera por un segundo. En este
receso, el programador de Go tendrá tiempo para ejecutar el receptor y
el primer mensaje (si aún no lo ha hecho), de modo que el mensaje <code>hello!</code> aparecerá en la consola durante el receso.</p>
<p>¡Se envía un nuevo mensaje por el canal <code>goodbye</code> con la
despedida! texto en un nuevo Goroutine, y nuestro programa continúa de
nuevo a una línea donde esperamos un mensaje entrante en el argumento <code>quitCh</code>.</p>
<p>Ya hemos lanzado tres Goroutines, el receptor que todavía está
funcionando, el primer mensaje que había terminado cuando el mensaje fue
 manejado por la declaración <code>select</code>, y el segundo mensaje
se imprimió casi de inmediato y también terminó. Entonces, solo el
receptor se está ejecutando en este momento, y si no recibe ningún otro
mensaje en los siguientes dos segundos, manejará el mensaje entrante de
la estructura <code>time</code>. Después del tipo <code>channel</code>, imprima un mensaje para decir que está saliendo, envíe un <code>true</code>a <code>quitCh</code>, y rompa el bucle infinito donde estaba en bucle.</p>
<p>Vamos a ejecutar esta pequeña aplicación:</p>
<pre class="srci"><code class="sh"><span class="in"><span class="prompt">&gt; </span>go run main.go
</span><span class="out">
hello!
goodbye!
Nothing received in 2 seconds. Exiting
</span></code></pre>
<p>El resultado puede no ser muy impresionante, pero el concepto es
claro. Podemos manejar muchos canales entrantes en el mismo Goroutine
usando la instrucción select.</p>
</div>
<h4 id="ranging-over-channels-too!">¡También abarca canales!</h4>
<div class="hBody-4">
<p>La última característica de los canales que veremos es la de los
canales. Estamos hablando de la palabra clave range. Lo hemos usado
extensamente para extender el rango sobre las listas, y también podemos
usarlo para abarcar un canal:</p>
<pre class="code"><code class="go">package main

import "time"

func main() {
  ch := make(chan int)

  go func() {
    ch &lt;- 1
    time.Sleep(time.Second)

    ch &lt;- 2

    close(ch)
  }()
  for v := range ch {
    println(v)
  }
}
</code></pre>
<p>En este caso, hemos creado un canal sin búfer, pero también
funcionaría con un búfer. Lanzamos una función en un nuevo Goroutine que
 envía el número "1" sobre un canal, espera un segundo, envía el número
"2" y cierra el canal.</p>
<p>El último paso es recorrer el canal. La sintaxis es bastante similar a
 un rango de lista. Almacenamos los datos entrantes del canal en la
variable v e imprimimos esta variable en la consola. El rango sigue
iterando hasta que se cierra el canal, tomando datos del canal.</p>
<p>¿Puedes adivinar el resultado de este pequeño programa?</p>
<pre class="srci"><code class="sh"><span class="in"><span class="prompt">&gt; </span>go run main.go
</span><span class="out">1
2
</span></code></pre>
<p>De nuevo, no muy impresionante. Imprime el número "1", luego espera un segundo, imprime el número "2" y sale de la aplicación.</p>
<p>De acuerdo con el diseño de esta aplicación simultánea, el rango fue
iterado sobre posibles datos entrantes del canal hasta que el Goroutine
concurrente cierre este canal. En ese momento, el rango finaliza y la
aplicación puede salir.</p>
<p>El rango es muy útil para tomar datos de un canal, y se usa
comúnmente en patrones de abanico donde muchos Goroutines diferentes
envían datos al mismo canal.</p>
</div>
<h3 id="using-it-all---concurrent-singleton">Utilizándolo todo: singleton concurrente</h3>
<div class="hBody-3">
<p>Ahora que sabemos cómo crear Goroutines y canales, pondremos todo
nuestro conocimiento en un solo paquete. Recordamos los primeros
capítulos, cuando explicamos el patrón de singleton: era una estructura o
 variable que solo podía existir una vez en nuestro código. Todo el
acceso a esta estructura debe hacerse utilizando el patrón descrito,
pero, de hecho, no fue concurrente seguro.</p>
<p>Ahora escribiremos teniendo en cuenta la simultaneidad. Escribiremos
un contador simultáneo, como el que escribimos en la sección de <i>exclusión mutua</i>, pero esta vez lo resolveremos con canales.</p>
</div>
<h4 id="unit-test">Prueba de unidad</h4>
<div class="hBody-4">
<p>Para restringir el acceso simultáneo a la instancia <code>singleton</code>,
 solo un Goroutine podrá acceder a él. Lo accederemos por canales: el
primero en agregar uno, el segundo para obtener el conteo actual y el
tercero para detener el Goroutine.</p>
<p>Añadiremos uno 10,000 veces usando 10,000 Goroutines diferentes lanzados desde dos instancias <code>singleton</code> diferentes . Luego, presentaremos un bucle para verificar el conteo de <code>singleton</code> hasta que sea 5,000, pero escribiremos cuánto es el conteo antes de comenzar el ciclo.</p>
<p>Una vez que el recuento ha llegado a 5,000, el ciclo saldrá y saldrá
de la ejecución de Goroutine; el código de prueba se ve así:</p>
<pre class="code"><code class="go">package channel_singleton
import (
  "testing"
  "time"
  "fmt"
)

func TestStartInstance(t *testing.T) {
  singleton := GetInstance()
  singleton2 := GetInstance()

  n := 5000

  for i := 0; i &lt; n; i++ {
    go singleton.AddOne()
    go singleton2.AddOne()
  }

  fmt.Printf("Before loop, current count is %d\n", singleton.GetCount())

  var val int
  for val != n*2 {
    val = singleton.GetCount()
    time.Sleep(10 * time.Millisecond)
  }
  singleton.Stop()
}
</code></pre>
<p>Aquí, podemos ver la prueba completa que usaremos. Después de crear dos instancias de <code>singleton</code>, hemos creado un <code>for</code> ciclo que inicia el método <code>AddOne</code>
 5,000 veces desde cada instancia. Esto no está sucediendo todavía; se
están programando y se ejecutarán eventualmente. Estamos imprimiendo el
conteo de la instancia <code>singleton</code> para ver claramente esta eventualidad; dependiendo de la computadora, imprimirá un número mayor que 0 y menor a 10,000.</p>
<p>El último paso antes de detener el Goroutine que contiene el conteo
es ingresar un ciclo que verifique el valor del conteo y espere 10
milisegundos si el valor no es el valor esperado (10,000). Una vez que
alcanza este valor, el ciclo se cerrará y podremos detener la instancia <code>singleton</code>.</p>
<p>Pasaremos directamente a la implementación ya que el requisito es bastante simple.</p>
</div>
<h4 id="implementation">Implementación</h4>
<div class="hBody-4">
<p>Antes que nada, crearemos el Goroutine que contendrá el conteo:</p>
<pre class="code"><code class="go">var addCh chan bool = make(chan bool)
var getCountCh chan chan int = make(chan chan int)
var quitCh chan bool = make(chan bool)

func init() {
  var count int

  go func(addCh &lt;-chan bool, getCountCh &lt;-chan chan int, quitCh &lt;-chan bool) {
    for {
      select {
      case &lt;-addCh:
        count++
      case ch := &lt;-getCountCh:
        ch &lt;- count
      case &lt;-quitCh:
        return
      }
    }
  }(addCh, getCountCh, quitCh)
}
</code></pre>
<p>Creamos tres canales, como mencionamos anteriormente:</p>
<ul>
<li>
<p>El canal <code>addCh</code> se utiliza para comunicarse con la acción de agregar uno al conteo, y recibe un tipo <code>bool</code> solo para indicar "agregar uno" (no es necesario que enviemos el número, aunque podríamos).</p>
</li>
<li>
<p>El canal <code>getCountCh</code> devolverá un canal que recibirá el valor actual del conteo. Tómese un momento para razonar sobre el canal <code>getCountCh</code>:
 es un canal que recibe un canal que recibe tipos enteros. Suena un poco
 complicado, pero tendrá más sentido cuando terminemos el ejemplo, no te
 preocupes.</p>
</li>
<li>
<p>El canal <code>quitCh</code> le comunicará al Goroutine que debe finalizar su ciclo infinito y terminar también.</p>
</li>
</ul>
<p>Ahora tenemos los canales que necesitamos para realizar las acciones
que queremos. A continuación, lanzamos el Goroutine pasando los canales
como argumentos. Como puede ver, estamos restringiendo la dirección de
los canales para proporcionar más seguridad de tipo. Dentro de este
Goroutine, creamos un bucle <code>for</code> infinito . Este ciclo no se detendrá hasta que se ejecute un corte dentro de él.</p>
<p>Finalmente, la declaración <code>select</code>, si lo recuerda, fue
una forma de recibir datos de diferentes canales al mismo tiempo.
Tenemos tres casos, por lo que escuchamos los tres canales entrantes que
 ingresaron como argumentos:</p>
<ul>
<li>
<p>El caso <code>addCh</code> agregará uno al recuento. Recuerde que
solo se puede ejecutar un caso en cada iteración para que ningún
Goroutine pueda acceder al recuento actual hasta que hayamos terminado
de agregar uno.</p>
</li>
<li>
<p>El canal <code>getCountCh</code> recibe un canal que recibe un número
 entero, por lo que capturamos este nuevo canal y enviamos el valor
actual a través del mismo al otro extremo.</p>
</li>
<li>
<p>El canal <code>quitCh</code> rompe el <code>for</code> ciclo, por lo que el Goroutine termina.</p>
</li>
</ul>
<p>Una última cosa. La función <code>init()</code> en cualquier paquete
se ejecutará en la ejecución del programa, por lo que no debe
preocuparse de ejecutar esta función específicamente desde nuestro
código.</p>
<p>Ahora, crearemos el tipo que esperan las pruebas. Veremos que toda la
 magia y la lógica están ocultas para el usuario final en este tipo
(como hemos visto en el código de la prueba):</p>
<pre class="code"><code class="go">type singleton struct {}

var instance singleton
func GetInstance() *singleton {
  return &amp;instance
}
</code></pre>
<p>El tipo <code>singleton</code> funciona de forma similar a como funcionaba en el <a href="https://nasciiboy.github.io/book4all/Go%20Design%20Patterns.html#chapter-2">Capítulo 2</a>, <i>Patrones de creación: Singleton, Builder, Factory, Prototype y Abstract Factory</i>, pero esta vez no contendrá el valor de recuento. Creamos un valor local para el llamado <code>instance</code>, y devolvemos el puntero a esta instancia cuando llamamos al método <code>GetInstance</code> (). No es estrictamente necesario hacerlo de esta manera, pero no necesitamos asignar una nueva instancia del tipo <code>singleton</code> cada vez que queremos acceder a la variable de conteo.</p>
<p>Primero, el método <code>AddOne()</code> tendrá que agregar uno al recuento actual. ¿Cómo? Al enviar <code>true</code> al canal <code>addCh</code>. Así de simple:</p>
<pre class="code"><code class="go">func (s *singleton) AddOne() {
  addCh &lt;- true
}
</code></pre>
<p>Este pequeño fragmento desencadenará el caso <code>addCh</code> en nuestro Goroutine a su vez. El caso <code>addCh</code> simplemente se ejecuta <code>count++</code>y finaliza, permitiendo <code>select</code> que el flujo de control de canal que se ejecuta en la función <code>init</code> anterior ejecute la siguiente instrucción:</p>
<pre class="code"><code class="go">func (s *singleton) GetCount() int {
  resCh := make(chan int)
  defer close(resCh)
  getCountCh &lt;- resCh
  return &lt;-resCh
}
</code></pre>
<p>El método <code>GetCount</code> crea un canal cada vez que se invoca y
 difiere la acción de cerrarlo al final de la función. Este canal no
está búfer, como hemos visto anteriormente en este capítulo. Un canal
sin búfer bloquea la ejecución hasta que recibe algunos datos. Por lo
tanto, enviamos este canal al <code>getCountCh</code> que también pertenece un canal y, efectivamente, esperamos que un tipo <code>chan int</code> envíe el valor de conteo actual nuevamente a través de él. El método <code>GetCount()</code> no volverá hasta que el valor de la variable <code>count</code> llegue al canal <code>resCh</code>.</p>
<p>Usted podría estar pensando, ¿por qué no estamos usando el mismo
canal en ambas direcciones para recibir el valor del conteo? De esta
manera evitaremos una asignación. Bueno, si utilizamos el mismo canal
dentro del método <code>GetCount()</code>, tendremos dos oyentes en este canal: uno en el <code>select</code>
 enunciado, al comienzo del archivo en la función de inicio, y el otro
allí, para que pueda resolverse en cualquiera de ellos cuando
devolviendo el valor:</p>
<pre class="code"><code class="go">func (s *singleton) Stop() {
  quitCh &lt;- true
  close(addCh)
  close(getCountCh)
  close(quitCh)
}
</code></pre>
<p>Finalmente, debemos detener al Goroutine en algún momento. El método <code>Stop</code> envía el valor al tipo <code>singleton</code> Goroutine para que la <code>quitCh</code> caja se active y el bucle <code>for</code>
 se rompa. El siguiente paso es cerrar todos los canales para que no se
puedan enviar más datos a través de ellos. Esto es muy conveniente
cuando sabe que ya no usará algunos de sus canales.</p>
<p>Es hora de ejecutar las pruebas y echar un vistazo:</p>
<pre class="srci"><code class="sh"><span class="in"><span class="prompt">&gt; </span>go test -v .
</span><span class="out">=== RUN   TestStartInstance
Before loop, current count is 4911
--- PASS: TestStartInstance (0.03s)
PASS
ok
</span></code></pre>
<p>Muy poca salida de código, pero todo ha funcionado como se esperaba.
En la prueba, imprimimos el valor del conteo antes de ingresar al ciclo
que itera hasta que alcanza el valor 10,000. Como vimos anteriormente,
el programador Go intentará ejecutar el contenido de los Goroutines
usando tantos hilos del sistema operativo como configuró utilizando la <code>GOMAXPROCS</code>
 configuración. En mi computadora, está configurado en 4 porque mi
computadora tiene cuatro núcleos. Pero el punto es que podemos ver que
muchas cosas pueden suceder después de lanzar un Goroutine (o 10,000) y
la siguiente línea de ejecución.</p>
<p>Pero, ¿qué pasa con el uso de mutexes?</p>
<pre class="code"><code class="go">type singleton struct {
  count int
  sync.RWMutex
}

var instance singleton

func GetInstance() *singleton {
  return &amp;instance
}

func (s *singleton) AddOne() {
  s.Lock()
  defer s.Unlock()
  s.count++
}

func (s *singleton) GetCount()int {
  s.RLock()
  defer s.RUnlock()
  return s.count
}
</code></pre>
<p>En este caso, el código es mucho más ágil. Como vimos anteriormente, podemos insertar el mutex dentro de la estructura <code>singleton</code>. El recuento también se lleva a cabo en el campo <code>count</code> y el <code>AddOne()</code>y <code>GetCount()</code> los métodos de bloquear y desbloquear el valor de ser al mismo tiempo seguro.</p>
<p>Una cosa más. En este caso <code>singleton</code>, estamos usando el tipo <code>RWMutex</code> en lugar del tipo <code>sync.Mutex</code> ya conocido . La principal diferencia aquí es que el tipo <code>RWMutex</code>
 tiene dos tipos de bloqueos: un bloqueo de lectura y un bloqueo de
escritura. El bloqueo de lectura, ejecutado llamando al método <code>RLock</code>,
 solo espera si un bloqueo de escritura está activo actualmente. Al
mismo tiempo, solo bloquea un bloqueo de escritura, por lo que muchas
acciones de lectura se pueden realizar en paralelo. Tiene mucho sentido;
 no queremos bloquear un Goroutine que quiera leer un valor simplemente
porque otro Goroutine también está leyendo el valor, no cambiará. El
tipo <code>sync.RWMutex</code> nos ayuda a lograr esta lógica en nuestro código.</p>
</div>
<h3 id="summary">Resumen</h3>
<div class="hBody-3">
<p>Hemos visto cómo escribir un Singleton concurrente usando mutexes y
canales. Si bien el ejemplo de canales fue más complejo, también muestra
 el poder central de la concurrencia de Go, ya que puede lograr niveles
complejos de arquitecturas basadas en eventos simplemente usando
canales.</p>
<p>Solo tenga en cuenta que, si no ha escrito un código concurrente en
el pasado, puede tomar algún tiempo comenzar a pensar al mismo tiempo de
 una manera cómoda. Pero no es nada que la práctica no pueda resolver.</p>
<p>Hemos visto la importancia de diseñar aplicaciones concurrentes para
lograr el paralelismo en nuestros programas. Hemos tratado la mayoría de
 las primitivas de Go para escribir aplicaciones concurrentes, y ahora
podemos escribir patrones de diseño simultáneos comunes.</p>
</div>
<h3 id="chapter-9.-concurrency-patterns---barrier,-future,-and-pipeline-design-patterns">Capítulo 9. Patrones de concurrencia: patrones de diseño de barrera, futuro y tubería</h3>
<div class="hBody-3">
<p>Ahora que estamos familiarizados con los conceptos de concurrencia y
paralelismo, y que hemos entendido cómo lograrlos mediante el uso de
primitivas de concurrencia de Go, podemos ver algunos patrones con
respecto al trabajo simultáneo y la ejecución paralela. En este capítulo
 veremos los siguientes patrones:</p>
<ul>
<li>
<p>La barrera es un patrón muy común, especialmente cuando tenemos que
esperar más de una respuesta de diferentes Goroutines antes de permitir
que el programa continúe</p>
</li>
<li>
<p>El patrón futuro nos permite escribir un algoritmo que se ejecutará
eventualmente en el tiempo (o no) por el mismo Goroutine o uno diferente</p>
</li>
<li>
<p>Pipeline es un poderoso patrón para crear flujos síncronos complejos
de Goroutines que están conectados entre sí de acuerdo con alguna lógica</p>
</li>
</ul>
<p>Eche un vistazo rápido a la descripción de los tres patrones. Todos
describen algún tipo de lógica para sincronizar la ejecución en el
tiempo. Es muy importante tener en cuenta que ahora estamos
desarrollando estructuras concurrentes con todas las herramientas y
patrones que hemos visto en los capítulos anteriores. Con los patrones
de Creación, nos ocupamos de crear objetos. Con los patrones
estructurales estábamos aprendiendo cómo construir estructuras
idiomáticas y en los patrones de comportamiento que manejamos
principalmente con algoritmos. Ahora, con los patrones de Simultaneidad,
 administraremos principalmente la ejecución de tiempos y la ejecución
de pedidos de las aplicaciones que tienen más de un <i>flujo</i>.</p>
</div>
<h4 id="barrier-concurrency-pattern">Patrón de simultaneidad de barrera</h4>
<div class="hBody-4">
<p>Vamos a comenzar con el patrón de Barrera. Su propósito es simple:
poner una barrera para que nadie pase hasta que tengamos todos los
resultados que necesitamos, algo bastante común en las aplicaciones
concurrentes.</p>
</div>
<h4 id="description">Descripción</h4>
<div class="hBody-4">
<p>Imagine la situación en la que tenemos una aplicación de
microservicios donde un servicio necesita componer su respuesta
fusionando las respuestas de otros tres microservicios. Aquí es donde el
 patrón de barrera puede ayudarnos.</p>
<p>Nuestro patrón de barrera podría ser un servicio que bloqueará su
respuesta hasta que se haya compuesto con los resultados devueltos por
uno o más Goroutines (o servicios) diferentes. ¿Y qué tipo de primitivo
tenemos que tiene una naturaleza de bloqueo? Bueno, podemos usar un
candado, pero es más idiomático en Ir para usar un canal sin búfer.</p>
</div>
<h4 id="objectives">Objetivos</h4>
<div class="hBody-4">
<p>Como su nombre lo indica, el patrón de barrera intenta detener una
ejecución por lo que no termina antes de que esté listo para finalizar.
Los objetivos del patrón de barrera son los siguientes:</p>
<ul>
<li>
<p>Componga el valor de un tipo con los datos que provienen de uno o más Goroutines.</p>
</li>
<li>
<p>Controle la corrección de cualquiera de esos conductos de datos
entrantes para que no se devuelvan datos incoherentes. No queremos un
resultado parcialmente llenado porque una de las tuberías ha devuelto un
 error.</p>
</li>
</ul>
</div>
<h4 id="an-http-get-aggregator">Un agregador HTTP GET</h4>
<div class="hBody-4">
<p>Para nuestro ejemplo, vamos a escribir una situación muy típica en
una aplicación de microservicios, una aplicación que realiza dos
llamadas <code>GET</code> HTTP y las une en una única respuesta que se imprimirá en la consola.</p>
<p>Nuestra pequeña aplicación debe realizar cada solicitud en un
Goroutine diferente e imprimir el resultado en la consola si ambas
respuestas son correctas. Si alguno de ellos devuelve un error,
imprimimos el error.</p>
<p>El diseño debe ser simultáneo, lo que nos permite aprovechar nuestras CPU multinúcleo para hacer las llamadas en paralelo:</p>
<figure>
<img src="Ir%20a%20patrones%20de%20dise%C3%B1o_files/399_1.jpg">
</figure>
<p>En el diagrama anterior, las líneas continuas representan llamadas y
las líneas discontinuas representan canales. Los globos son Goroutines,
por lo que tenemos dos Goroutines lanzados por la función <code>main</code> (que también podría considerarse un Goroutine). Estas dos funciones se comunicarán a la función <code>main</code> utilizando un <b>canal común</b> que recibieron cuando se crearon en las llamadas <code>makeRequest</code>.</p>
</div>
<h4 id="acceptance-criteria">Criterios de aceptación</h4>
<div class="hBody-4">
<p>Nuestro principal objetivo en esta aplicación es obtener una
respuesta combinada de dos llamadas diferentes, para que podamos
describir nuestros criterios de aceptación de esta manera:</p>
<ul>
<li>
<p>Imprima en la consola el resultado fusionado de las dos llamadas a <a href="http://httpbin.org/headers">http://httpbin.org/headers</a> y <a href="http://httpbin.org/user-agent">http://httpbin.org/user-agent</a>
 URLs. Estos son un par de puntos finales públicos que responden con
datos de las conexiones entrantes. Son muy populares para fines de
prueba. Necesitará una conexión a Internet para hacer este ejercicio.</p>
</li>
<li>
<p>Si alguna de las llamadas falla, no debe imprimir ningún resultado,
solo el mensaje de error (o mensajes de error si ambas llamadas
fallaron).</p>
</li>
<li>
<p>La salida debe imprimirse como un resultado compuesto cuando ambas
llamadas hayan finalizado. Significa que no podemos imprimir el
resultado de una llamada y luego la otra.</p>
</li>
</ul>
</div>
<h4 id="unit-test---integration">Prueba unitaria: integración</h4>
<div class="hBody-4">
<p>Escribir pruebas unitarias o de integración para diseños concurrentes
 a veces puede ser complicado, pero esto no nos impedirá escribir
nuestras increíbles pruebas unitarias. Tendremos un único método <code>barrier</code> que acepta un conjunto de puntos finales definidos como un tipo <code>string</code>. La barrera hará una solicitud <code>GET</code>
 a cada punto final y redactará el resultado antes de imprimirlo. En
este caso, escribiremos tres pruebas de integración para simplificar
nuestro código, de modo que no necesitemos generar respuestas falsas:</p>
<pre class="code"><code class="go">package barrier

import (
  "bytes"
  "io"
  "os"
  "strings"
  "testing"
)

func TestBarrier(t *testing.T) {
  t.Run("Correct endpoints", func(t *testing.T) {
    endpoints := []string{"http://httpbin.org/headers",
      "http://httpbin.org/User-Agent"
    }
  })

  t.Run("One endpoint incorrect", func(t *testing.T) {
    endpoints := []string{"http://malformed-url",
      "http://httpbin.org/User-Agent"}
  })

  t.Run("Very short timeout", func(t *testing.T) {
    endpoints := []string{"http://httpbin.org/headers",
      "http://httpbin.org/User-Agent"}
  })
}
</code></pre>
<p>Tenemos una prueba única que ejecutará tres subpruebas:</p>
<ul>
<li>
<p>La primera prueba realiza dos llamadas a los puntos finales correctos</p>
</li>
<li>
<p>La segunda prueba tendrá un punto final incorrecto, por lo que debe devolver un error</p>
</li>
<li>
<p>La última prueba devolverá el tiempo máximo de tiempo de espera para que podamos forzar un error de tiempo de espera</p>
</li>
</ul>
<p>Tendremos una función llamada <code>barrier</code> que aceptará un número indeterminado de puntos finales en forma de cadenas. Su firma podría ser así:</p>
<pre class="code"><code class="go">func barrier(endpoints ...string) {}
</code></pre>
<p>Como puede ver, la función <code>barrier</code> no devuelve ningún
valor porque su resultado se imprimirá en la consola. Previamente, hemos
 escrito una implementación de una interfaz <code>io.Writer</code> para emular la escritura en la biblioteca <code>stdout</code> del sistema operativo . Solo para cambiar un poco las cosas, capturaremos la biblioteca <code>stdout</code> en lugar de emular una. El proceso para capturar la biblioteca <code>stdout</code> no es difícil una vez que comprenda las primitivas de concurrencia en Go:</p>
<pre class="code"><code class="go">func captureBarrierOutput(endpoints ...string) string {
    reader, writer, _ := os.Pipe()

    os.Stdout = writer
    out := make(chan string)

    go func() {
      var buf bytes.Buffer
      io.Copy(&amp;buf, reader)
      out &lt;- buf.String()
    }()

    barrier(endpoints...)

    writer.Close()
    temp := &lt;-out

    return temp
}
</code></pre>
<p>No te sientas intimidado por este código; es realmente simple. Primero creamos una tubería; ya lo hemos hecho antes en el <a href="https://nasciiboy.github.io/book4all/Go%20Design%20Patterns.html#chapter-3">Capítulo 3</a>, <i>Patrones estructurales - Adaptador, puente y patrones de diseño compuesto</i>, cuando hablamos sobre el patrón de diseño del adaptador. Para recordar, un tubo nos permite conectar una interfaz <code>io.Writer</code> a una interfaz <code>io.Reader</code> para que la entrada del lector sea la <code>Writer</code> salida. Nosotros definimos el<code>os.Stdout</code>
 como el escritor. Entonces, para capturar la salida de stdout,
necesitaremos un Goroutine diferente que escuche mientras escribimos a
la consola Como saben, si escribimos, no capturamos, y si capturamos, no
 estamos escribiendo. La palabra clave aquí es while; es una buena regla
 general que si encuentra esta palabra en alguna definición,
probablemente necesite una estructura concurrente. Entonces usamos la
palabra clave go para lanzar un Goroutine diferente que copia la entrada
 del lector a un buffer de bytes antes de enviar el contenido del buffer
 a través de un canal (que deberíamos haber creado previamente).</p>
<p>En este punto, tenemos una escucha de Goroutine, pero aún no hemos
impreso nada, por lo que llamamos a nuestra función (aún no escrita) <code>barrier</code>
 con los puntos finales proporcionados. Luego, tenemos que cerrar al
escritor para indicarle a Goroutine que no se le dará más información.
Nuestro canal llamó a la ejecución de bloques hasta que se reciba algún
valor (el enviado por nuestro Goroutine lanzado). El último paso es
devolver los contenidos capturados desde la consola.</p>
<p>OK, entonces tenemos una función llamada <code>captureBarrierOutput</code> que capturará las salidas <code>stdout</code>y las devolverá como una cadena. Podemos escribir nuestras pruebas ahora:</p>
<pre class="code"><code class="go">t.Run("Correct endpoints", func(t *testing.T) {
  endpoints := []string{"http://httpbin.org/headers", "http://httpbin.org/User-Agent"}

  result := captureBarrierOutput(endpoints...)

  if !strings.Contains(result, "Accept-Encoding") ||
    strings.Contains (result, "User-Agent") {
    t.Fail()
  }

  t.Log(result)
})
</code></pre>
<p>Todas las pruebas son muy fáciles de implementar. En general, es la función <code>captureBarrierOutput</code> que llama a la función <code>barrier</code>. Así que pasamos los puntos finales y verificamos el resultado devuelto. Nuestra respuesta compuesta dirigida a <a href="http://httpbin.org/">http://httpbin.org</a> debe contener el texto <i>Accept-Encoding</i> y <i>User-Agent</i>
 en las respuestas de cada punto final. Si no encontramos esos textos,
la prueba fallará. Para fines de depuración, registramos la respuesta en
 caso de que deseemos verificarla con la prueba <code>-v</code> de bandera en el camino:</p>
<pre class="code"><code class="go">t.Run("One endpoint incorrect", func(t *testing.T) {
  endpoints := []string
  {"http://malformed-url", "http://httpbin.org/User-Agent"}

  result := captureBarrierOutput(endpoints...)

  if !strings.Contains(result, "ERROR") {

    t.Fail()

  }

  t.Log(result)
})
</code></pre>
<p>Esta vez usamos una URL de punto final incorrecta, por lo que la respuesta debe devolver el error con la palabra <i>ERROR</i> que escribiremos en la función <code>barrier</code>.</p>
<p>La última función reducirá el tiempo de espera del <code>GET</code> cliente HTTP a un mínimo de 1 ms, por lo que forzamos un tiempo de espera:</p>
<pre class="code"><code class="go">t.Run("Very short timeout", func(t *testing.T) {
  endpoints := []string
  {"http://httpbin.org/headers", "http://httpbin.org/User-Agent"}
  timeoutMilliseconds = 1

  result := captureBarrierOutput(endpoints...)

  if !strings.Contains(result, "Timeout") {

    t.Fail()

  }

  t.Log(result)
})
</code></pre>
<p>La variable <code>timeoutMilliseconds</code> será una variable de paquete que tendremos que definir más adelante durante la implementación.</p>
</div>
<h4 id="implementation">Implementación</h4>
<div class="hBody-4">
<p>Necesitábamos definir una variable de paquete llamada timeoutMilliseconds. Comencemos desde allí:</p>
<pre class="code"><code class="go">package barrier

import (
    "fmt"
    "io/ioutil"
    "net/http"
    "time"
)

var timeoutMilliseconds int = 5000
</code></pre>
<p>El tiempo de espera inicial es de 5 segundos (5,000 milisegundos) y necesitaremos esos paquetes en nuestro código.</p>
<p>De acuerdo, entonces necesitamos una función que ejecute un Goroutine
 para cada URL de punto final. ¿Recuerdas cómo alcanzamos la
comunicación entre Goroutines? Exactamente - canales! Por lo tanto,
necesitaremos un canal para manejar las respuestas y un canal para
manejar los errores.</p>
<p>Pero podemos simplificarlo un poco más. Recibiremos dos respuestas
correctas, dos errores o una respuesta y un error; en cualquier caso,
siempre hay dos respuestas, por lo que podemos unir los errores y las
respuestas en un tipo fusionado:</p>
<pre class="code"><code class="go">type barrierResp struct {
    Err  error
    Resp string
}
</code></pre>
<p>Entonces, cada Goroutine devolverá un valor del tipo <code>barrierResp</code>. Este valor tendrá un valor <code>Err</code>o un valor para el campo <code>Resp</code>.</p>
<p>El procedimiento es simple: creamos un canal de tamaño 2, el que recibirá respuestas del tipo <code>barrierResp</code>, lanzamos ambas solicitudes y esperamos dos respuestas, y luego verificamos si hay algún error:</p>
<pre class="code"><code class="go">func barrier(endpoints ...string) {
  requestNumber := len(endpoints)

  in := make(chan barrierResp, requestNumber)
  defer close(in)

  responses := make([]barrierResp, requestNumber)

  for _, endpoint := range endpoints {
    go makeRequest(in, endpoint)
  }

  var hasError bool
  for i := 0; i &lt; requestNumber; i++ {
    resp := &lt;-in
    if resp.Err != nil {
      fmt.Println("ERROR: ", resp.Err)
      hasError = true
    }
    responses[i] = resp
  }

  if !hasError {
    for _, resp := range responses {
      fmt.Println(resp.Resp)
    }
  }
}
</code></pre>
<p>Siguiendo la descripción anterior, creamos un canal en búfer llamado <code>in</code>, que es el tamaño de los puntos finales entrantes, y diferimos el cierre del canal. Luego, lanzamos una función llamada <code>makeRequest</code> con cada punto final y el canal de respuesta.</p>
<p>Ahora haremos un bucle dos veces, una para cada punto final. En el ciclo, bloqueamos la ejecución esperando datos del canal <code>in</code>. Si encontramos un error, lo imprimimos con el prefijo <i>ERROR</i> como esperamos en nuestras pruebas, y lo configuramos <code>hasErrorvar</code> como verdadero. Después de dos respuestas, si no encontramos ningún error ( <code>hasError== false</code>) imprimimos cada respuesta y el canal se cerrará.</p>
<p>Todavía nos falta la función <code>makeRequest</code>:</p>
<pre class="code"><code class="go">func makeRequest(out chan&lt;- barrierResp, url string) {
  res := barrierResp{}
  client := http.Client{
    Timeout: time.Duration(time.Duration(timeoutMilliseconds) * time.Millisecond),
  }

  resp, err := client.Get(url)
  if err != nil {
    res.Err = err
    out &lt;- res
    return
  }

  byt, err := ioutil.ReadAll(resp.Body)
  if err != nil {
    res.Err = err
    out &lt;- res
    return
  }

  res.Resp = string(byt)
  out &lt;- res
}
</code></pre>
<p>La función <code>makeRequest</code> es una función muy simple que acepta un canal para generar valores <code>barrierResp</code> y una URL para solicitar. Creamos un <code>http.Client</code>y establecemos su campo de tiempo de espera para el valor de la variable <code>timeoutMilliseconds</code> del paquete. Así es como podemos cambiar el tiempo de espera antes de que la función <code>in</code> pruebe. Luego, simplemente hacemos la llamada <code>GET</code>, tomamos la respuesta, la analizamos en un segmento de bytes y la enviamos a través del canal <code>out</code>.</p>
<p>Hacemos todo esto rellenando una variable llamada <code>res</code> del tipo <code>barrierResp</code>. Si encontramos un error al realizar una solicitud <code>GET</code> o analizar el cuerpo del resultado, llenamos el campo <code>res.Err</code>, lo enviamos al canal <code>out</code>
 (que tiene el lado opuesto conectado al Goroutine original) y salimos
de la función (para que no lo hagamos) enviar dos valores a través del
canal <code>out</code> por error).</p>
<p>Hora de ejecutar las pruebas. Recuerde que necesita una conexión a
Internet, o las dos primeras pruebas fallarán. Primero intentaremos la
prueba que tiene dos puntos finales correctos:</p>
<pre class="srci"><code class="sh"><span class="in"><span class="prompt">&gt; </span>go test -run=TestBarrier/Correct_endpoints -v .
</span><span class="out">=== RUN   TestBarrier
=== RUN   TestBarrier/Correct_endpoints
--- PASS: TestBarrier (0.54s)
    --- PASS: TestBarrier/Correct_endpoints (0.54s)
        barrier_test.go:20: {
          "headers": {
            "Accept-Encoding": "gzip",
"Host": "httpbin.org",
"User-Agent": "Go-http-client/1.1"
             }
         }
         {
              "User-Agent": "Go-http-client/1.1"
          }
    ok
</span></code></pre>
<p>Perfecto, tenemos una respuesta JSON con una clave <code>headers</code>, y otra</p>
<p>Respuesta JSON con una clave <code>User-Agent</code>. En nuestras pruebas de integración, estábamos buscando las cadenas, <code>User-Agent</code>y <code>Accept-Encoding</code>, que están presentes, por lo que la prueba ha pasado con éxito.</p>
<p>Ahora ejecutaremos la prueba que tiene un punto final incorrecto:</p>
<pre class="srci"><code class="sh"><span class="in"><span class="prompt">&gt; </span>go test -run=TestBarrier/One_endpoint_incorrect -v .
</span><span class="out">=== RUN   TestBarrier
=== RUN   TestBarrier/One_endpoint_incorrect
--- PASS: TestBarrier (0.27s)
    --- PASS: TestBarrier/One_endpoint_incorrect (0.27s)
        barrier_test.go:31: ERROR:  Get http://malformed-url:
dial tcp: lookup malformed-url: no such host
ok
</span></code></pre>
<p>Podemos ver que hemos tenido un error en el que <code>http://malformed-url</code> se devuelve un error de <i>host no</i>. Una solicitud a esta URL debe devolver un texto con la palabra <code>ERROR</code>:
 prefijado, tal como lo indicamos durante los criterios de aceptación,
por eso esta prueba es correcta (no tenemos un falso positivo).</p>
<div class="about">
<div class="about-dt">Nota</div>
<div class="about-dd">
<p>En las pruebas, es muy importante comprender los conceptos de las
pruebas de "falso positivo" y "falso negativo". Una prueba de falso
positivo se describe aproximadamente como una prueba que pasa una
condición cuando no debería (resultado: todas pasaron) mientras que el
falso negativo es solo el inverso (resultado: la prueba falló). Por
ejemplo, podríamos estar probando que se devuelve una cadena al hacer
las solicitudes pero, ¡la cadena devuelta podría estar completamente
vacía! Esto dará lugar a un falso negativo, una prueba que no falla
incluso cuando estamos verificando un comportamiento que es incorrecto a
 propósito (una solicitud <code>http://malformed-url</code>).</p>
</div>
</div>
<p>La última prueba redujo el tiempo de espera a 1 ms:</p>
<pre class="srci"><code class="sh"><span class="in"><span class="prompt">&gt; </span>go test -run=TestBarrier/Very_short_timeout -v .
</span><span class="out">=== RUN   TestBarrier
=== RUN   TestBarrier/Very_short_timeout
--- PASS: TestBarrier (0.00s)
    --- PASS: TestBarrier/Very_short_timeout (0.00s)
        barrier_test.go:43: ERROR:  Get
http://httpbin.org/User-Agent: net/http: request canceled while
waiting for connection (Client.Timeout exceeded while awaiting
headers)
        ERROR:  Get http://httpbin.org/headers: net/http:
request canceled while waiting for connection (Client.Timeout
exceeded while awaiting headers)

ok
</span></code></pre>
<p>De nuevo, la prueba pasó con éxito y obtuvimos dos errores de tiempo
de espera. Las URL fueron correctas, pero no tuvimos una respuesta en
menos de un milisegundo, por lo que el cliente ha devuelto un error de
tiempo de espera.</p>
</div>
<h4 id="waiting-for-responses-with-the-barrier-design-pattern">Esperando respuestas con el patrón de diseño de barrera</h4>
<div class="hBody-4">
<p>El patrón de barrera abre la puerta de la programación de
microservicios con su naturaleza composable. Podría considerarse un
patrón estructural, como se puede imaginar.</p>
<p>El patrón de barrera no solo es útil para realizar solicitudes de
red; también podríamos usarlo para dividir algunas tareas en múltiples
Goroutines. Por ejemplo, una operación costosa podría dividirse en
algunas operaciones más pequeñas distribuidas en diferentes Goroutines
para maximizar el paralelismo y lograr un mejor rendimiento.</p>
</div>
<h4 id="future-design-pattern">Patrón de diseño futuro</h4>
<div class="hBody-4">
<p>El patrón de diseño Future (también llamado <b>Promise</b> ) es una
manera rápida y fácil de lograr estructuras concurrentes para la
programación asincrónica. Aprovecharemos las funciones de primera clase
en Ir a desarrollar <i>futuros</i>.</p>
</div>
<h4 id="description">Descripción</h4>
<div class="hBody-4">
<p>En resumen, definiremos cada comportamiento posible de una acción
antes de ejecutarlos en diferentes Goroutines. Node.js utiliza este
enfoque, que proporciona programación controlada por eventos por
defecto. La idea aquí es lograr un <i>fuego y olvidar</i> que maneja todos los resultados posibles en una acción.</p>
<p>Para entenderlo mejor, podemos hablar sobre un tipo que ha
incorporado el comportamiento en caso de que una ejecución sea
satisfactoria o en caso de que falle.</p>
<figure>
<img src="Ir%20a%20patrones%20de%20dise%C3%B1o_files/410_1.jpg">
</figure>
<p>En el diagrama anterior, la función <code>main</code> lanza un <b>futuro</b> dentro de un nuevo Goroutine. No esperará nada, ni recibirá ningún progreso del futuro. Realmente dispara y lo olvida.</p>
<p>Lo interesante aquí es que podemos lanzar un nuevo futuro dentro de
un futuro e incorporar tantos futuros como queramos en el mismo
Goroutine (o nuevos). La idea es aprovechar el resultado de un futuro
para lanzar el siguiente. Por ejemplo:</p>
<figure>
<img src="Ir%20a%20patrones%20de%20dise%C3%B1o_files/412_1.jpg">
</figure>
<p>Aquí, tenemos el mismo Futuro. En este caso, si la función <code>Execute</code> arrojó un resultado correcto, la función <code>Success</code> se ejecuta, y solo en este caso ejecutamos un nuevo Goroutine con otro <code>Future</code> dentro (o incluso sin un Goroutine).</p>
<p>Este es un tipo de programación perezosa, donde <code>Future</code>
podría llamarse a sí mismo indefinidamente o solo hasta que se cumpla
alguna regla. La idea es definir el comportamiento de antemano y dejar
que el futuro resuelva las posibles soluciones.</p>
</div>
<h4 id="objectives">Objetivos</h4>
<div class="hBody-4">
<p>Con el patrón Futuro, podemos lanzar muchos nuevos Goroutines, cada
uno con una acción y sus propios manejadores. Esto nos permite hacer lo
siguiente:</p>
<ul>
<li>
<p>Delegue el manejador de acciones en un Goroutine diferente</p>
</li>
<li>
<p>Apila muchas llamadas asincrónicas entre ellas (una llamada asincrónica que llama a otra llamada asincrónica en sus resultados)</p>
</li>
</ul>
</div>
<h4 id="a-simple-asynchronous-requester">Un simple solicitante asincrónico</h4>
<div class="hBody-4">
<p>Vamos a desarrollar un ejemplo muy simple para tratar de entender
cómo funciona un Futuro. En este ejemplo, tendremos un método que
devuelve una cadena o un error, pero queremos ejecutarlo al mismo
tiempo. Hemos aprendido maneras de hacer esto ya. Usando un canal,
podemos lanzar un nuevo Goroutine y manejar el resultado entrante del
canal.</p>
<p>Pero en este caso, tendremos que manejar el resultado (cadena o
error) y no queremos esto. En su lugar, definiremos qué hacer en caso de
 éxito y qué hacer en caso de error e ignoráramos el Goroutine.</p>
</div>
<h4 id="acceptance-criteria">Criterios de aceptación</h4>
<div class="hBody-4">
<p>No tenemos requisitos funcionales para esta tarea. En cambio, tendremos requisitos técnicos para ello:</p>
<ul>
<li>
<p>Delegue la ejecución de la función a un Goroutine diferente</p>
</li>
<li>
<p>La función devolverá una cadena (quizás) o un error</p>
</li>
<li>
<p>Los controladores deben estar ya definidos antes de ejecutar la función</p>
</li>
<li>
<p>El diseño debe ser reutilizable</p>
</li>
</ul>
</div>
<h3 id="unit-tests">Pruebas unitarias</h3>
<div class="hBody-3">
<p>Entonces, como mencionamos, usaremos funciones de primera clase para
lograr este comportamiento, y necesitaremos tres tipos específicos de
funciones:</p>
<ul>
<li>
<p><code>type SuccessFunc func(string)</code>: La función <code>SuccessFunc</code>
 se ejecutará si todo salió bien. Su argumento de cadena será el
resultado de la operación, por lo que nuestra función será llamada por
nuestro Goroutine.</p>
</li>
<li>
<p><code>type FailFunc func(error)</code>: La función <code>FailFunc</code> maneja el resultado opuesto, es decir, cuando algo sale mal y, como puede ver, devolverá un error.</p>
</li>
<li>
<p><code>type ExecuteStringFunc func() (string, error)</code>: Finalmente, la función <code>ExecuteStringFunc</code>
 es un tipo que define la operación que queremos realizar. Tal vez
devolverá una cadena o un error. No te preocupes si todo esto parece
confuso; será más claro más tarde.</p>
</li>
</ul>
<p>Entonces, creamos el objeto <code>future</code>, definimos un comportamiento de éxito, definimos un comportamiento de falla y pasamos un tipo <code>ExecuteStringFunc</code> para ser ejecutado. En el archivo de implementación, necesitaremos un nuevo tipo:</p>
<pre class="code"><code class="go">type MaybeString struct {}
</code></pre>
<p>También crearemos dos pruebas en el archivo <span class="file">_test.go</span> :</p>
<pre class="code"><code class="go">package future

import (
  "errors"
  "testing"
  "sync"
)

func TestStringOrError_Execute(t *testing.T) {
  future := &amp;MaybeString{}
  t.Run("Success result", func(t *testing.T) {
    ...
  })
  t.Run("Error result", func(t *testing.T) {
  ...
  })
}
</code></pre>
<p>Definiremos funciones encadenándolas, como normalmente verías en
Node.js. Un código como este es compacto y no particularmente difícil de
 seguir:</p>
<pre class="code"><code class="go">t.Run("Success result", func(t *testing.T) {
  future.Success(func(s string) {

    t.Log(s)

  }).Fail(func(e error) {

    t.Fail()

  })

  future.Execute(func() (string, error) {

    return "Hello World!", nil

  })
})
</code></pre>
<p>La función <code>future.Success</code> debe definirse en la estructura <code>MaybeString</code> para aceptar una función <code>SuccessFunc</code> que se ejecutará si todo va bien y devolver el mismo puntero al objeto <code>future</code> (para que podamos seguir encadenando). La función <code>Fail</code> también se debe definir en la estructura <code>MaybeString</code> y debe aceptar una función <code>FailFunc</code> para devolver posteriormente el puntero. Devolvemos el puntero en ambos casos para que podamos definir the <code>Fail</code>y the <code>Success</code>o viceversa.</p>
<p>Finalmente, usamos el método <code>Execute</code> para pasar un tipo <code>ExecuteStringFunc</code>
 (una función que no acepta nada y devuelve una cadena o un error). En
este caso, devolvemos una cadena y nada, por lo que esperamos que la
función <code>SuccessFunc</code> se ejecute y registramos el resultado
en la consola. En caso de que se ejecute la función de falla, la prueba
ha fallado porque la función <code>FailFunc</code> no debe ejecutarse por un error nulo devuelto.</p>
<p>Pero todavía nos falta algo aquí. Dijimos que la función debe
ejecutarse de forma asíncrona en un Goroutine diferente, por lo que
tenemos que sincronizar esta prueba de alguna manera para que no termine
 demasiado pronto. Nuevamente, podemos usar un canal o un <code>sync.WaitGroup</code>:</p>
<pre class="code"><code class="go">t.Run("Success result", func(t *testing.T) {
  var wg sync.WaitGroup
  wg.Add(1)
  future.Success(func(s string) {
    t.Log(s)

    wg.Done()
  }).Fail(func(e error) {
    t.Fail()

    wg.Done()
  })

  future.Execute(func() (string, error) {
    return "Hello World!", nil
  })
  wg.Wait()
})
</code></pre>
<p>Hemos visto WaitGroups antes en el canal anterior. Este WaitGroup está configurado para esperar una señal ( <code>wg.Add(1</code>)). El <code>Success</code>y métodos <code>Fail</code> disparará el método <code>Done()</code> de la <code>WaitGroup</code> de permitir la ejecución de continuar y terminar la prueba (por eso el método <code>Wait()</code> es al final). Recuerde que cada método <code>Done()</code> restará uno del WaitGroup, y solo hemos agregado uno, por lo que nuestro método Wait () solo se bloqueará hasta que <code>Done()</code> se ejecute un método.</p>
<p>Utilizando lo que sabemos sobre la realización de una prueba <code>Success</code> unitaria de resultados, es fácil realizar una prueba <code>Failed</code> unitaria de resultados intercambiando la llamada <code>t.Fail()</code> al método del error al éxito para que la prueba falle si se realiza una llamada al éxito:</p>
<pre class="code"><code class="go">t.Run("Failed result", func(t *testing.T) {
  var wg sync.WaitGroup

  wg.Add(1)

  future.Success(func(s string) {
    t.Fail()
    wg.Done()
  }).Fail(func(e error) {
    t.Log(e.Error())
    wg.Done()
  })

  future.Execute(func() (string, error) {
    return "", errors.New("Error ocurred")
  })

  wg.Wait()
})
</code></pre>
<p>Si usa un IDE como yo, sus llamadas de método Success, Fail y Execute
 deben estar en rojo. Esto se debe a que carecemos de la declaración de
nuestro método en el archivo de implementación:</p>
<pre class="code"><code class="go">package future

type SuccessFunc func(string)
type FailFunc func(error)
type ExecuteStringFunc func() (string, error)

type MaybeString struct {
  ...
}

func (s *MaybeString) Success(f SuccessFunc) *MaybeString {
  return nil
}

func (s *MaybeString) Fail(f FailFunc) *MaybeString {
  return nil
}

func (s *MaybeString) Execute(f ExecuteStringFunc) {
  ...
}
</code></pre>
<p>Nuestra prueba parece lista para ejecutarse. Probémoslo:</p>
<pre class="srci"><code class="sh"><span class="in"><span class="prompt">&gt; </span>go test -v .
</span><span class="out">=== RUN   TestStringOrError_Execute
=== RUN   TestStringOrError_Execute/Success_result
fatal error: all goroutines are asleep - deadlock!
goroutine 1 [chan receive]:
testing.(*T).Run(0xc4200780c0, 0x5122e9, 0x19, 0x51d750,
0xc420041d30)
        /usr/lib/go/src/testing/testing.go:647 +0x316
testing.RunTests.func1(0xc4200780c0)
        /usr/lib/go/src/testing/testing.go:793 +0x6d
testing.tRunner(0xc4200780c0, 0xc420041e20)
        /usr/lib/go/src/testing/testing.go:610 +0x81
testing.RunTests(0x51d758, 0x5931e0, 0x1, 0x1, 0x50feb4)
        /usr/lib/go/src/testing/testing.go:799 +0x2f5
testing.(*M).Run(0xc420041ee8, 0xc420014550)
        /usr/lib/go/src/testing/testing.go:743 +0x85
main.main()
        go-design-patterns/future/_test/_testmain.go:54 +0xc6
...continue
</span></code></pre>
<p>Bueno ... las pruebas han fallado, sí ... pero no de manera
controlable. ¿Por qué es esto? No tenemos ninguna aplicación, sin
embargo, por lo que no <code>Success</code>o funciones <code>Fail</code> se ejecutan bien. Nuestro WaitGroup está esperando por siempre una llamada al método <code>Done()</code> que nunca llegará, por lo que no puede continuar y finalizar la prueba. Ese es el significado de <i>Todos los Goroutines están dormidos: ¡punto muerto! </i>. En nuestro ejemplo específico, significaría que <i>Nadie va a llamar <code>Done()</code>, ¡así que estamos muertos! </i>.</p>
<div class="about">
<div class="about-dt">Nota</div>
<div class="about-dd">
<p>Gracias al compilador Go y al ejecutor en tiempo de ejecución,
podemos detectar interbloqueos fácilmente. Imagínese si el tiempo de
ejecución de Go no pudiera detectar interbloqueos: estaríamos
efectivamente atrapados en una pantalla en blanco sin saber qué estaba
mal.</p>
<p>Entonces, ¿cómo podemos resolver esto? Bueno, una manera fácil sería con un tiempo de espera que llama al método <code>Done()</code>
 después de esperar un tiempo hasta su finalización. Para este código,
es seguro esperar 1 segundo porque no está haciendo operaciones de larga
 duración.</p>
</div>
</div>
<p>Declararemos una función <code>timeout</code> dentro de nuestro archivo <code>test</code>
 que espera por un segundo, luego imprimimos un mensaje, establecemos
que la prueba falló y dejamos que WaitGroup continúe llamando a su
método <code>Done()</code>:</p>
<pre class="code"><code class="go">func timeout(t *testing.T, wg *sync.WaitGroup) {
  time.Sleep(time.Second)
  t.Log("Timeout!")

  t.Fail()
  wg.Done()
}
</code></pre>
<p>El aspecto final de cada subprueba es similar a nuestro ejemplo anterior de <code>"Success result"</code>:</p>
<pre class="code"><code class="go">t.Run("Success result", func(t *testing.T) {
  var wg sync.WaitGroup
  wg.Add(1)

  // Timeout!
  go timeout(t, wg)
  // ...
})
</code></pre>
<p>Veamos qué pasa cuando ejecutamos nuestras pruebas nuevamente:</p>
<pre class="srci"><code class="sh"><span class="in"><span class="prompt">&gt; </span>go test -v .
</span><span class="out">=== RUN   TestStringOrError_Execute
=== RUN   TestStringOrError_Execute/Success_result
=== RUN   TestStringOrError_Execute/Failed_result
--- FAIL: TestStringOrError_Execute (2.00s)
    --- FAIL: TestStringOrError_Execute/Success_result (1.00s)
        future_test.go:64: Timeout!
    --- FAIL: TestStringOrError_Execute/Failed_result (1.00s)
        future_test.go:64: Timeout!
FAIL
exit status 1
FAIL
</span></code></pre>
<p>Nuestras pruebas fallaron, pero de forma controlada. Mire el final de las líneas <code>FAIL</code>:
 observe cómo el tiempo transcurrido es de 1 segundo porque se ha
desencadenado por el tiempo de espera, como podemos ver en los mensajes
de registro.</p>
<p>Es hora de pasar a la implementación.</p>
</div>
<h4 id="implementation">Implementación</h4>
<div class="hBody-4">
<p>De acuerdo con nuestras pruebas, la implementación debe tomar una <code>SuccessFunc</code>, una <code>FailFunc</code>y una función <code>ExecuteStringFunc</code> de forma encadenada dentro del tipo <code>MaybeString</code> y ejecuta la función <code>ExecuteStringFunc</code> de manera asíncrona para llamar <code>SuccessFunc</code>o funciones <code>FailFunc</code> de acuerdo con el resultado devuelto de la función <code>ExecuteStringFunc</code>.</p>
<p>La cadena se implementa almacenando las funciones dentro del tipo y
devolviendo el puntero al tipo. Estamos hablando de nuestros métodos de
tipo previamente declarados, por supuesto:</p>
<pre class="code"><code class="go">type MaybeString struct {
  successFunc SuccessFunc
  failFunc    FailFunc
}

func (s *MaybeString) Success(f SuccessFunc) *MaybeString {
  s.successFunc = f
  return s
}

func (s *MaybeString) Fail(f FailFunc) *MaybeString {
  s.failFunc = f
  return s
}
</code></pre>
<p>Necesitábamos dos campos para almacenar el <code>SuccessFunc</code>y las funciones <code>FailFunc</code>, que reciben el nombre de <code>successFunc</code>y campos <code>failFunc</code> respectivamente. De esta forma, las llamadas a los métodos <code>Success</code>y <code>Fail</code>
 simplemente almacenan sus funciones entrantes a nuestros nuevos campos.
 Simplemente son setters que también devuelven el puntero al valor <code>MaybeString</code> específico . Estos métodos tipo toman un puntero a la estructura <code>MaybeString</code>, así que no olvides poner "*" <code>MaybeString</code> después de la declaración <code>func</code>.</p>
<p>Execute toma el método <code>ExecuteStringFunc</code> y lo ejecuta de forma asíncrona. Esto parece bastante simple con un Goroutine, ¿verdad?</p>
<pre class="code"><code class="go">func (s *MaybeString) Execute(f ExecuteStringFunc) {
  go func(s *MaybeString) {
    str, err := f()
    if err != nil {
      s.failFunc(err)
    } else {
      s.successFunc(str)
    }
  }(s)
}
</code></pre>
<p>¡Parece bastante simple porque es simple! Lanzamos el Goroutine que ejecuta el método <code>f</code> (an <code>ExecuteStringFunc</code>) y toma su resultado, tal vez una cadena y tal vez un error. Si hay un error, llamamos al campo <code>failFunc</code> en nuestra estructura <code>MaybeString</code>. Si no hay error, llamamos al campo <code>successFunc</code>.
 Usamos un Goroutine para delegar la ejecución de una función y el
manejo de errores para que nuestro Goroutine no tenga que hacerlo.</p>
<p>Ejecutamos pruebas unitarias ahora:</p>
<pre class="srci"><code class="sh"><span class="in"><span class="prompt">&gt; </span>go test -v .
</span><span class="out">=== RUN   TestStringOrError_Execute
=== RUN   TestStringOrError_Execute/Success_result
=== RUN   TestStringOrError_Execute/Failed_result
--- PASS: TestStringOrError_Execute (0.00s)
    --- PASS: TestStringOrError_Execute/Success_result (0.00s)
        future_test.go:21: Hello World!
    --- PASS: TestStringOrError_Execute/Failed_result (0.00s)
        future_test.go:49: Error ocurred
PASS
ok
</span></code></pre>
<p>¡Estupendo! Mira cómo el tiempo de ejecución ahora es casi cero, por
lo que nuestros tiempos de espera no se han ejecutado (en realidad, se
ejecutaron, pero las pruebas ya se terminaron y su resultado ya se
indicó).</p>
<p>Además, ahora podemos usar nuestro tipo <code>MaybeString</code> para
 ejecutar asincrónicamente cualquier tipo de función que no acepte nada y
 devuelva una cadena o un error. Una función que no acepta nada parece
un poco inútil, ¿no? Pero podemos usar cierres para introducir un
contexto en este tipo de función.</p>
<p>Vamos a escribir una función <code>setContext</code> que toma una cadena como argumento y devuelve un método <code>ExecuteStringFunc</code> que devuelve el argumento anterior con el sufijo <code>Closure!</code>:</p>
<pre class="code"><code class="go">func setContext(msg string) ExecuteStringFunc {
  msg = fmt.Sprintf("%d Closure!\n", msg)

  return func() (string, error){
    return msg, nil
  }
}
</code></pre>
<p>Entonces, podemos escribir una prueba nueva que use este cierre:</p>
<pre class="code"><code class="go">t.Run("Closure Success result", func(t *testing.T) {
  var wg sync.WaitGroup
  wg.Add(1)
  // Timeout!
  go timeout(t, &amp;wg)

  future.Success(func(s string) {
    t.Log(s)
    wg.Done()
  }).Fail(func(e error) {
    t.Fail()
    wg.Done()
  })
  future.Execute(setContext("Hello"))
  wg.Wait()
})
</code></pre>
<p>La función <code>setContext</code> devuelve un método <code>ExecuteStringFunc</code> que puede pasar directamente a la función <code>Execute</code>. Llamamos a la función <code>setContext</code> con un texto arbitrario que sabemos que será devuelto.</p>
<p>Ejecutamos nuestras pruebas nuevamente. ¡Ahora todo tiene que ir bien!</p>
<pre class="srci"><code class="sh"><span class="in"><span class="prompt">&gt; </span>go test -v .
</span><span class="out">=== RUN   TestStringOrError_Execute
=== RUN   TestStringOrError_Execute/Success_result
=== RUN   TestStringOrError_Execute/Failed_result
=== RUN   TestStringOrError_Execute/Closure_Success_result
--- PASS: TestStringOrError_Execute (0.00s)
    --- PASS: TestStringOrError_Execute/Success_result (0.00s)
        future_test.go:21: Hello World!
    --- PASS: TestStringOrError_Execute/Failed_result (0.00s)
        future_test.go:49: Error ocurred
    --- PASS: TestStringOrError_Execute/Closure_Success_result (0.00s)
        future_test.go:69: Hello Closure!
PASS
ok
</span></code></pre>
<p>Nos dio un OK también. La prueba de cierre muestra el comportamiento que explicamos anteriormente. Al tomar un mensaje <code>"Hello"</code>y anexarlo con algo más ( <code>"Closure!"</code>), podemos cambiar el contexto del texto que queremos devolver. Ahora escale esto a una llamada <code>GET</code>
 HTTP , una llamada a una base de datos, o cualquier cosa que pueda
imaginar. Simplemente deberá finalizar devolviendo una cadena o un
error. Recuerde, sin embargo, que todo dentro de la función <code>setContext</code>
 pero fuera de la función anónima que estamos devolviendo no es
concurrente, y se ejecutará de forma asincrónica antes de ejecutar
ejecutar, por lo que debemos tratar de poner tanta lógica como sea
posible dentro de la función anónima.</p>
</div>
<h4 id="putting-the-future-together">Uniendo el futuro</h4>
<div class="hBody-4">
<p>Hemos visto una buena manera de lograr una programación asincrónica
mediante el uso de un sistema de tipo de función. Sin embargo, podríamos
 haber hecho sin funciones mediante el establecimiento de una interfaz
con <code>Success</code>, <code>Fail</code>y <code>Execute</code> los
métodos y los tipos que las satisfacen, y utilizando el patrón de
plantilla para ejecutarlos de forma asincrónica, como hemos visto
anteriormente en este capítulo. ¡Es tu decision!</p>
</div>
<h3 id="pipeline-design-pattern">Patrón de diseño de tubería</h3>
<div class="hBody-3">
<p>El tercer y último patrón que veremos en este capítulo es el patrón
Pipeline. Usará este patrón en gran medida en sus estructuras
concurrentes, y podemos considerarlo uno de los más útiles también.</p>
</div>
<h4 id="description">Descripción</h4>
<div class="hBody-4">
<p>Ya sabemos lo que es una tubería. Cada vez que escribimos cualquier
función que realiza alguna lógica, estamos escribiendo una tubería: Si <i>esto</i> entonces <i>que</i>, o bien <i>alguna otra cosa</i>.
 El patrón de tuberías se puede hacer más complejo al usar algunas
funciones que se llaman entre sí. Incluso pueden engancharse en su
ejecución.</p>
<p>El patrón Pipeline en Go funciona de manera similar, pero cada paso
en la tubería estará en una comunicación y otro de Goroutine diferentes,
 y la sincronización se realizará mediante canales.</p>
</div>
<h4 id="objectives">Objetivos</h4>
<div class="hBody-4">
<p>Al crear un Pipeline, buscamos principalmente los siguientes beneficios:</p>
<ul>
<li>
<p>Podemos crear una estructura concurrente de un algoritmo de varios pasos</p>
</li>
<li>
<p>Podemos explotar el paralelismo de máquinas multinúcleo descomponiendo un algoritmo en diferentes Goroutines</p>
</li>
</ul>
<p>Sin embargo, solo porque descompongamos un algoritmo en diferentes
Goroutines no necesariamente significa que se ejecutará más rápido.
Estamos hablando constantemente de CPU, por lo que, idealmente, el
algoritmo debe ser intensivo en CPU para aprovechar una estructura
simultánea. La sobrecarga de crear Goroutines y canales podría hacer un
algoritmo más pequeño.</p>
</div>
<h4 id="a-concurrent-multi-operation">Una operación múltiple concurrente</h4>
<div class="hBody-4">
<p>Vamos a hacer algunas matemáticas para nuestro ejemplo. Vamos a
generar una lista de números comenzando con 1 y terminando con un número
 arbitrario N. A continuación, tomaremos cada número, lo potenciaremos a
 2 y sumaremos los números resultantes a un resultado único. Entonces,
si <span class="math">N = 3</span>, nuestra lista será [1,2,3]. Después
de impulsarlos a 2, nuestra lista se convierte en [1,4,9]. Si sumamos la
 lista resultante, el valor resultante es 14.</p>
</div>
<h4 id="acceptance-criteria">Criterios de aceptación</h4>
<div class="hBody-4">
<p>Funcionalmente hablando, nuestro patrón Pipeline necesita elevar a la
 potencia de 2 cada número y luego sumarlos todos. Se dividirá en un
generador de números y dos operaciones, por lo que:</p>
<ol class="num">
<li>
<p>Genere una lista de 1 a N donde N puede ser cualquier número entero.</p>
</li>
<li>
<p>Tome cada número de esta lista generada y levántelo a la potencia de 2.</p>
</li>
<li>
<p>Sume cada número resultante en un resultado final y devuélvalo.</p>
</li>
</ol>
</div>
<h4 id="beginning-with-tests">Comenzando con las pruebas</h4>
<div class="hBody-4">
<p>Crearemos solo una función que administrará todo. Llamaremos a esta función <code>LaunchPipeline</code>
 para simplificar las cosas. Tomará un número entero como argumento, que
 será nuestro N número, el número de elementos en nuestra lista. La
declaración en el archivo de implementación se ve así:</p>
<pre class="code"><code class="go">package pipelines

func LaunchPipeline(amount int) int {
  return 0
}
</code></pre>
<p>En nuestro archivo de prueba, crearemos una tabla de pruebas utilizando una porción de sectores:</p>
<pre class="code"><code class="go">package pipelines

import "testing"

func TestLaunchPipeline(t *testing.T) {
  tableTest := [][]int{
    {3, 14},
    {5, 55},
  }
  // ...
}
</code></pre>
<p>Nuestra tabla es una slice de sectores de tipos enteros. En cada
sector, el primer entero representa el tamaño de la lista y la segunda
posición representa el elemento dentro de la lista. Es, efectivamente,
una matriz. Cuando pasa 3, debe devolver 14. Al pasar 5, debe devolver
55. Luego, tenemos que iterar sobre la tabla y pasar el primer índice de
 cada matriz a la función <code>LaunchPipeline</code>:</p>
<pre class="code"><code class="go">  // ...

  var res int
  for _, test := range tableTest {
    res = LaunchPipeline(test[0])
    if res != test[1] {
      t.Fatal()
    }

    t.Logf("%d == %d\n", res, test[1])
  }
}
</code></pre>
<p>Usando <code>range</code>, obtenemos cada fila en la matriz. Cada fila está contenida en una variable temporal llamada <code>test</code>. <code>test[0]</code> representa <span class="math">N</span> y <code>test[1]</code> el resultado esperado. Comparamos el resultado esperado con el valor de retorno de la función <code>LaunchPipeline</code>. Si no son lo mismo, la prueba falla:</p>
<pre class="srci"><code class="sh"><span class="in"><span class="prompt">&gt; </span>go test -v .
</span><span class="out">=== RUN   TestLaunchPipeline
--- FAIL: TestLaunchPipeline (0.00s)
        pipeline_test.go:15:
FAIL
exit status 1
FAIL
</span></code></pre>
</div>
<h4 id="implementation">Implementación</h4>
<div class="hBody-4">
<p>La clave para nuestra implementación es separar cada operación en un
Goroutine diferente y conectarlas con los canales. La función <code>LaunchPipeline</code> es la que los orquesta a todos, como se muestra en el siguiente diagrama:</p>
<figure>
<img src="Ir%20a%20patrones%20de%20dise%C3%B1o_files/428_1.jpg">
</figure>
<figure>
<img src="Ir%20a%20patrones%20de%20dise%C3%B1o_files/429_1.jpg">
</figure>
<p>La operación consta de tres pasos: generar una lista de números,
aumentarlos a la potencia de 2 y agregar los números resultantes.</p>
<p>Cada paso de este patrón Pipeline tendrá la siguiente estructura:</p>
<pre class="code"><code class="go">func functionName(in &lt;-chan int) (&lt;-chan int){
  out := make(chan bool, 100)

  go func(){
    for v := range in {
      // Do something with v and send it to channel out
}

close(out)
   }()

  return out
}
</code></pre>
<p>Esta función representa un paso común. Analicémoslo en el mismo orden
 que el programador Go probablemente tomará para ejecutarlo:</p>
<ol class="num">
<li>
<p>La función <code>functionName</code> comúnmente recibirá un canal para tomar valores de ( <code>in &lt;-chan int</code>). Lo llamamos la función <code>in</code>,
 como en la palabra entrante. No podemos enviar valores a través de él
dentro del alcance de esta función; es por eso que los puntos <code>out</code> de flecha de la palabra clave <code>chan</code>.</p>
</li>
<li>
<p>La función <code>functionName</code> devuelve un canal ( <code>&lt;-chan in</code>) del que solo se le permitirá tomar valores al llamador de la función (de nuevo, representado por la flecha que apunta <code>out</code>a la palabra clave <code>chan</code>). Esto también significa que cualquier valor que pase por ese canal debe generarse dentro del alcance de la función.</p>
</li>
<li>
<p>En la primera línea de la función, creamos un canal llamado que será el retorno de la función ( <i>punto 2</i> en esta lista).</p>
</li>
<li>
<p>Entonces, lanzaremos un nuevo Goroutine. Su alcance entrará en juego después de devolver esta función, así que continuemos.</p>
</li>
<li>
<p>Devolvemos el canal <code>out</code> creado previamente .</p>
</li>
<li>
<p>Eventualmente, después de terminar la ejecución de la función y devolver el canal <code>out</code>, se ejecuta el Goroutine. Tomará valores del canal <code>in</code>
 hasta que se cierre. Entonces, el que llama de esta función es
responsable de cerrar este canal, de lo contrario, el Goroutine nunca
terminará.</p>
</li>
<li>
<p>Cuando el canal <code>in</code> está cerrado, el bucle for finaliza y cerramos el canal <code>out</code>. Cualquier Goroutine que haga uso de este canal no recibirá ningún valor nuevo desde el último que se envió.</p>
</li>
</ol>
<p>El único paso que no se ajusta por completo a este enfoque es el
primer paso que recibe un número, que representa el umbral superior en
la lista en lugar de un canal de valores entrantes. Por lo tanto, si
codificamos esta operación para cada paso en nuestra cartera, el
diagrama final se parece más a esto:</p>
<figure>
<img src="Ir%20a%20patrones%20de%20dise%C3%B1o_files/431_1.jpg">
</figure>
<p>Aunque la idea es exactamente la misma, ahora podemos ver que es la función <code>LaunchPipeline</code>
 la que va a recibir los canales y los envía de vuelta al siguiente paso
 en Pipeline. Usando este diagrama, podemos ver claramente el flujo de
la creación de la tubería siguiendo los números de las flechas. Una
flecha sólida representa una llamada de función y una flecha de línea un
 canal.</p>
<p>Miremos un poco más de cerca el código.</p>
</div>
<h4 id="the-list-generator">El generador de lista</h4>
<div class="hBody-4">
<p>El primer paso en la operación es generación de lista. La lista
comienza en 1 y recibiremos un número entero que representa el umbral
más alto. Tenemos que pasar cada número de la lista al siguiente paso:</p>
<pre class="code"><code class="go">func generator(max int) &lt;-chan int {
  outChInt := make(chan int, 100)

  go func() {
    for i := 1; i &lt;= max; i++ {
      outChInt &lt;- i
    }

    close(outChInt)
  }()
  return outChInt
}
</code></pre>
<p>Como mencionamos anteriormente, este es el patrón que seguiremos en
cada paso: crear un canal, iniciar el Goroutine que enviará los datos a
través del canal e inmediatamente devolver el canal. Este Goroutine
repetirá de 1 al argumento máximo, que es el umbral más alto para
nuestra lista, y enviará cada número a través del canal. Después de
enviar cada número, el canal se cierra para que no se puedan enviar más
datos a través de él, pero los datos ya almacenados se pueden recuperar.</p>
</div>
<h4 id="raising-numbers-to-the-power-of-2">Aumentando los números a la potencia de 2</h4>
<div class="hBody-4">
<p>El segundo paso tomará cada número entrante del canal del primer paso
 (que se toma de los argumentos) y lo elevará a la potencia de 2. Cada
resultado se debe enviar al tercer paso utilizando un nuevo canal:</p>
<pre class="code"><code class="go">func power(in &lt;-chan int) &lt;-chan int {
  out := make(chan int, 100)

  go func() {
    for v := range in {
      out &lt;- v * v
    }
    close(out)
  }()
  return out
}
</code></pre>
<p>Usamos el mismo patrón de nuevo: crea un canal y ejecuta el Goroutine mientras devolvemos el canal creado.</p>
<div class="about">
<div class="about-dt">Nota</div>
<div class="about-dd">
<p>El bucle for-range sigue tomando valores de un canal indefinidamente hasta que se cierra el canal.</p>
</div>
</div>
</div>
<h4 id="final-reduce-operation">Operación de reducción final</h4>
<div class="hBody-4">
<p>El tercer y último paso recibe cada número del segundo paso y los
agrega a un valor local hasta que se cierra el canal de conexión:</p>
<pre class="code"><code class="go">func sum(in &lt;-chan int) &lt;-chan int {
  out := make(chan int, 100)
  go func() {
    var sum int

    for v := range in {
      sum += v
    }

    out &lt;- sum
    close(out)
  }()

  return out
}
</code></pre>
<p>La función suma también toma un canal como argumento (el que regresó del <i>paso 2</i>
 ). También sigue el mismo patrón de creación de un canal, el
lanzamiento de Goroutine y la devolución de un canal. Goroutine sigue
agregando valores a una variable llamada <code>sum</code> hasta <code>in</code> que se cierre el canal. Cuando el canal <code>in</code> está cerrado, el valor de la suma se envía al canal <code>out</code> y se cierra inmediatamente.</p>
</div>
<h4 id="launching-the-pipeline-pattern">Lanzamiento del patrón Pipeline</h4>
<div class="hBody-4">
<p>Finalmente, podemos implementar la función <code>LaunchPipeline</code>:</p>
<pre class="code"><code class="go">func LaunchPipeline(amount int) int {
  firstCh := generator(amount)
  secondCh := power(firstCh)
  thirdCh := sum(secondCh)

  result := &lt;-thirdCh

  return result
}
</code></pre>
<p>La función <code>generator</code> primero devuelve el canal que se pasa a la función de potencia. La función <code>power</code> devuelve el segundo canal que se pasa a la función <code>sum</code>. La función <code>sum</code> finalmente devuelve el primer canal que recibirá un valor único, el resultado. Tratemos de probar esto ahora:</p>
<pre class="srci"><code class="sh"><span class="in"><span class="prompt">&gt; </span>go test -v .
</span><span class="out">=== RUN   TestLaunchPipeline
--- PASS: TestLaunchPipeline (0.00s)
        pipeline_test.go:18: 14 == 14
        pipeline_test.go:18: 55 == 55
PASS
ok
</span></code></pre>
<p>¡Increíble! Vale la pena mencionar que la función <code>LaunchPipeline</code> no necesita asignar todos los canales, y puede reescribirse de esta manera:</p>
<pre class="code"><code class="go">func LaunchPipeline(amount int) int {
  return &lt;-sum(power(generator(amount)))
}
</code></pre>
<p>El resultado de la función del generador se pasa directamente a la función de potencia y el resultado de <code>power</code>a las funciones <code>sum</code>.</p>
</div>
<h4 id="final-words-on-the-pipeline-pattern">Palabras finales en el patrón Pipeline</h4>
<div class="hBody-4">
<p>Con el patrón Pipeline, podemos crear flujos de trabajo concurrentes
muy complejos de una manera muy fácil. En nuestro caso, creamos un flujo
 de trabajo lineal, pero también podría tener condicionales, pools y
comportamiento de fan-in y fan-out. Veremos algunos de estos en el
siguiente capítulo.</p>
</div>
<h3 id="summary">Resumen</h3>
<div class="hBody-3">
<p>Los patrones de diseño de concurrencia son un paso adelante en la
dificultad, y toman un tiempo para comprender. Nuestro mayor error como
programadores concurrentes es pensar en términos de paralelismo (¿cómo
puedo hacer esto paralelo? O ¿cómo puedo ejecutar esto en un nuevo
hilo?) En lugar de en términos de estructuras concurrentes.</p>
<p>Las funciones puras (funciones que siempre producirán la misma salida
 (con la misma entrada) sin afectar nada fuera de su alcance) ayudan en
este diseño.</p>
<p>La programación concurrente requiere práctica y más práctica. Ir lo
hace fácil una vez que entiendes las primitivas básicas. Los diagramas
pueden ayudarlo a comprender el posible flujo de datos, pero la mejor
manera de entenderlo es simplemente practicar.</p>
<p>En el siguiente capítulo, veremos cómo usar un grupo de trabajadores
de tuberías para hacer algo de trabajo en lugar de tener una cartera
única. Además, aprenderemos cómo crear el patrón de publicación /
suscriptor en una estructura concurrente y veremos qué diferente puede
ser el mismo patrón cuando creamos usando concurrencia.</p>
</div>
<h3 id="chapter-10.-concurrency-patterns---workers-pool-and-publish/subscriber-design-patterns">Capítulo 10. Patrones de concurrencia: Patrones de agrupación de trabajadores y patrones de diseño de publicación / suscriptor</h3>
<div class="hBody-3">
<p>Hemos llegado al último capítulo del libro, donde discutiremos un par
 de patrones con estructuras concurrentes. Explicaremos cada paso en
detalle para que pueda seguir los ejemplos cuidadosamente.</p>
<p>La idea es aprender sobre patrones para diseñar aplicaciones
simultáneas en Go idiomático. Estamos utilizando canales y Goroutines en
 gran medida, en lugar de bloquear o compartir variables.</p>
<ul>
<li>
<p>Veremos una forma de desarrollar un grupo de trabajadores. Esto es útil para controlar el número de Goroutines en una ejecución.</p>
</li>
<li>
<p>El segundo ejemplo es una reescritura del patrón Observer, que vimos en el <a href="https://nasciiboy.github.io/book4all/Go%20Design%20Patterns.html#chapter-7">Capítulo 7</a>, <i>Patrones de comportamiento:</i> patrón de <i>visitante, estado, mediador y diseño de observador</i>,
 escrito con una estructura concurrente. Con este ejemplo
profundizaremos un poco más en las estructuras concurrentes y veremos
cómo pueden diferir de un enfoque común.</p>
</li>
</ul>
</div>
<h4 id="workers-pool">Grupo de trabajadores</h4>
<div class="hBody-4">
<p>Un problema que podemos enfrentar con algunos de los enfoques previos
 a la concurrencia es su contexto ilimitado. No podemos permitir que una
 aplicación cree una cantidad ilimitada de Goroutines. Los goroutines
son livianos, pero el trabajo que realizan puede ser muy pesado. Un
grupo de trabajadores nos ayuda a resolver este problema.</p>
</div>
<h4 id="description">Descripción</h4>
<div class="hBody-4">
<p>Con un grupo de trabajadores, queremos vincular la cantidad de
Goroutines disponible para que tengamos un control más profundo del
conjunto de recursos. Esto es fácil de lograr creando un canal para cada
 trabajador y teniendo trabajadores con un estado inactivo o ocupado. La
 tarea puede parecer desalentadora, pero no es para nada.</p>
</div>
<h4 id="objectives">Objetivos</h4>
<div class="hBody-4">
<p>La creación de un <code>Worker</code> grupo tiene que ver con el
control de recursos: CPU, RAM, tiempo, conexiones, etc. El patrón de
diseño del grupo de trabajadores nos ayuda a hacer lo siguiente:</p>
<ul>
<li>
<p>Controlar el acceso a recursos compartidos utilizando cuotas</p>
</li>
<li>
<p>Crea una cantidad limitada de Goroutines por aplicación</p>
</li>
<li>
<p>Proporcione más capacidades de paralelismo a otras estructuras concurrentes</p>
</li>
</ul>
</div>
<h4 id="a-pool-of-pipelines">Un grupo de tuberías</h4>
<div class="hBody-4">
<p>En el capítulo anterior, vimos cómo trabajar con una tubería. Ahora
lanzaremos un número limitado de ellos para que el planificador Go pueda
 procesar solicitudes en paralelo. La idea aquí es controlar el número
de Goroutines, detenerlos con gracia cuando la aplicación haya terminado
 y maximizar el paralelismo utilizando una estructura concurrente sin
condiciones de carrera.</p>
<p>La tubería que utilizaremos es similar a la que usamos en el capítulo
 anterior, donde generamos números, los elevamos a la potencia de 2 y
sumamos los resultados finales. En este caso, vamos a pasar cadenas a
las que agregaremos y agregaremos datos.</p>
</div>
<h4 id="acceptance-criteria">Criterios de aceptación</h4>
<div class="hBody-4">
<p>En términos comerciales, queremos algo que nos diga que el trabajador
 ha procesado una solicitud, un final predefinido y datos entrantes
analizados en mayúsculas:</p>
<ol class="num">
<li>
<p>Al realizar una solicitud con un valor de cadena (cualquiera), debe estar en mayúscula.</p>
</li>
<li>
<p>Una vez que la cadena está en mayúscula, se debe anexar un texto predefinido. Este texto no debe estar en mayúscula.</p>
</li>
<li>
<p>Con el resultado anterior, la ID del trabajador debe estar prefijada a la cadena final.</p>
</li>
<li>
<p>La cadena resultante se debe pasar a un controlador predefinido. No
hemos hablado sobre cómo hacerlo técnicamente, solo lo que quiere el
negocio. Con toda la descripción, al menos tendremos trabajadores,
solicitudes y manipuladores.</p>
</li>
</ol>
</div>
<h4 id="implementation">Implementación</h4>
<div class="hBody-4">
<p>El comienzo es un tipo de solicitud. De acuerdo con la descripción,
debe contener la cadena que ingresará a la tubería, así como la función
del manejador:</p>
<pre class="code"><code class="go"> // workers_pipeline.go file
  type Request struct {
        Data    interface{}
        Handler RequestHandler
  }
</code></pre>
<p>Donde esta el <code>string</code>? Tenemos un campo <code>Data</code> de tipo <code>interface{}</code> para que podamos usarlo para pasar una cadena. Al usar una interfaz, podemos reutilizar este tipo para a <code>string</code>, an <code>int</code>o un tipo <code>struct</code> de datos. El receptor es quien debe saber cómo lidiar con la interfaz entrante.</p>
<p>El campo <code>Handler</code> tiene el <code>Request</code> controlador de tipo , que aún no hemos definido:</p>
<pre class="code"><code class="go">type RequestHandler func(interface{})
</code></pre>
<p>Un controlador de solicitudes es cualquier función que acepta una
interfaz como primer argumento y no devuelve nada. De nuevo, vemos el <code>interface{}</code>,
 donde normalmente veríamos una cuerda. Este es uno de los receptores
que mencionamos anteriormente, y tendremos que emitir el resultado.</p>
<p>Entonces, al enviar una solicitud, debemos llenarla con algún valor en el campo <code>Data</code> e implementar un controlador; por ejemplo:</p>
<pre class="code"><code class="go">func NewStringRequest(s string, id int, wg *sync.WaitGroup)
Request {
  myRequest := Request{
    Data: "Hello", Handler: func(i interface{})
    {
      defer wg.Done()
      s, ok := i.(string)
      if !ok{
        log.Fatal("Invalid casting to string")
      }
      fmt.Println(s)
    }
  }
}
</code></pre>
<p>El controlador se define mediante el uso de un cierre. Comprobamos
nuevamente el tipo si la interfaz (y diferimos la llamada al método <code>Done()</code>
 al final). En el caso de una interfaz incorrecta, simplemente
imprimimos su contenido y lo devolvemos. Si el moldeado está bien,
también lo imprimimos, pero aquí es donde normalmente haremos algo con
el resultado de la operación; tenemos que usar el tipo de conversión
para recuperar el contenido de <code>interface{}</code>(que es una cadena). Esto debe hacerse en cada paso de la tubería, aunque introducirá un poco de sobrecarga.</p>
<p>Ahora necesitamos un tipo que pueda manejar tipos <code>Request</code>. Las posibles implementaciones son virtualmente infinitas, por lo que es mejor definir primero una interfaz:</p>
<pre class="code"><code class="go"> // worker.go file
  type WorkerLauncher interface {
      LaunchWorker(in chan Request)
  }
</code></pre>
<p>La interfaz <code>WorkerLauncher</code> debe implementar solo el método <code>LaunchWorker(chan Request)</code>. Cualquier tipo que implemente esta interfaz tendrá que recibir un canal de tipo <code>Request</code> para satisfacerlo. Este canal del tipo <code>Request</code> es el único punto de entrada a la tubería.</p>
</div>
<h4 id="the-dispatcher">El despachador</h4>
<div class="hBody-4">
<p>Ahora, para lanzar los trabajadores en paralelo y manejar todos los
canales entrantes posibles, necesitaremos algo así como un despachador:</p>
<pre class="code"><code class="go">// dispatcher.go file
 type Dispatcher interface {
     LaunchWorker(w WorkerLauncher)
     MakeRequest(Request)
     Stop()
 }
</code></pre>
<p>Una interfaz <code>Dispatcher</code> puede lanzar un tipo <code>WorkerLaunchers</code> inyectado en su propio método <code>LaunchWorker</code>. La interfaz <code>Dispatcher</code> debe usar el método <code>LaunchWorker</code> de cualquiera de los tipos <code>WorkerLauncher</code> para inicializar una tubería. De esta forma podemos reutilizar la interfaz <code>Dispatcher</code> para lanzar muchos tipos de <code>WorkerLaunchers</code>.</p>
<p>Al usar <code>MakeRequest(Request)</code>, la interfaz <code>Dispatcher</code> expone un buen método para inyectar una nueva <code>Request</code> en el grupo de trabajadores.</p>
<p>Finalmente, el usuario debe llamar a detener cuando todo <code>Goroutines</code>
 debe estar terminado. Debemos manejar el cierre elegante en nuestras
aplicaciones, y queremos evitar las filtraciones de Goroutine.</p>
<p>Tenemos suficientes interfaces, así que comencemos con el despachador que es un poco menos complicado:</p>
<pre class="code"><code class="go">type dispatcher struct {
    inCh chan Request
}
</code></pre>
<p>Nuestra estructura <code>dispatcher</code> almacena un canal de tipo <code>Request</code>
 en uno de sus campos. Este será el único punto de entrada para
solicitudes en cualquier canalización. Dijimos que debe implementar tres
 métodos, de la siguiente manera:</p>
<pre class="code"><code class="go">func (d *dispatcher) LaunchWorker(id int, w WorkerLauncher) {
  w.LaunchWorker(d.inCh)
}

func (d *dispatcher) Stop(){
  close(d.inCh)
}

func (d *dispatcher) MakeRequest(r Request) {
  d.inCh &lt;- r
}
</code></pre>
<p>En este ejemplo, la interfaz <code>Dispatcher</code> no necesita hacer nada especial antes de iniciar un trabajador, por lo que el método <code>LaunchWorker</code> <code>Dispatcher</code> simplemente ejecuta el método <code>LaunchWorker</code> de la entrada <code>WorkerLauncher</code>, que también tiene un método <code>LaunchWorker</code> para iniciarse. Hemos definido previamente que un tipo <code>WorkerLauncher</code> necesita al menos una ID y un canal para las solicitudes entrantes, de modo que eso es por lo que estamos pasando.</p>
<p>Puede parecer innecesario implementar el método <code>LaunchWorker</code> en la interfaz <code>Dispatcher</code>.
 En diferentes escenarios, podría ser interesante guardar los ID de los
trabajadores en ejecución en el despachador para controlar cuáles están
activos o inactivos; la idea es ocultar los detalles de implementación
de lanzamiento. En este caso, la interfaz <code>Dispatcher</code> simplemente actúa como un <code>Facade</code> patrón de diseño que oculta algunos detalles de implementación del usuario.</p>
<p>El segundo método es <code>Stop</code>. Cierra el canal de
solicitudes entrantes, lo que provoca una reacción en cadena. Vimos en
el ejemplo de la tubería que, al cerrar el canal entrante, cada bucle
for-range dentro de Goroutines se rompe y el Goroutine también está
terminado. En este caso, al cerrar un canal compartido, provocará la
misma reacción, pero en cada escucha de Goroutine, todas las tuberías se
 detendrán. Genial, ¿eh?</p>
<p>La implementación de solicitudes es muy simple; simplemente pasamos
la solicitud en el argumento al canal de solicitudes entrantes. El
Goroutine se bloqueará allí para siempre hasta que el extremo opuesto
del canal recupere la solicitud. ¿Siempre? Eso parece mucho si algo
sucede. Podemos introducir un tiempo de espera, de la siguiente manera:</p>
<pre class="code"><code class="go">func (d *dispatcher) MakeRequest(r Request) {
  select {
  case d.inCh &lt;- r:
  case &lt;-time.After(time.Second * 5):
    return
  }
}
</code></pre>
<p>Si recuerda en capítulos anteriores, podemos usar seleccionar para
controlar qué operación se realiza a través de un canal. Como en un caso
 <code>switch</code>, solo se puede ejecutar una operación. En este caso, tenemos dos operaciones diferentes: enviar y recibir.</p>
<p>El primer caso es una operación de envío: intente enviar esto y se
bloqueará allí hasta que alguien tome el valor en el lado opuesto del
canal. No es una gran mejora, entonces. El segundo caso es una operación
 de recepción; se activará después de 5 segundos si la solicitud
superior no se puede enviar con éxito, y la función volverá. Sería muy
conveniente devolver un error aquí, pero para simplificar las cosas, lo
dejaremos vacío</p>
<p>Finalmente, en el despachador, para mayor comodidad, definiremos un <code>Dispatcher</code> creador:</p>
<pre class="code"><code class="go">func NewDispatcher(b int) Dispatcher {
  return &amp;dispatcher{
    inCh:make(chan Request, b),
  }
}
</code></pre>
<p>Al usar esta función en lugar de crear el despachador manualmente,
podemos evitar pequeños errores, como olvidar inicializar el campo del
canal. Como puede ver, el argumento b se refiere al tamaño del búfer en
el canal.</p>
</div>
<h4 id="the-pipeline">La tubería</h4>
<div class="hBody-4">
<p>Entonces, nuestro despachador está listo y tenemos que desarrollar la
 tubería descrita en los criterios de aceptación. Primero, necesitamos
un tipo para implementar el tipo <code>WorkerLauncher</code>:</p>
<pre class="code"><code class="go">// worker.go file
type PreffixSuffixWorker struct {
  id int
  prefixS string
  suffixS string
}

func (w *PreffixSuffixWorker) LaunchWorker(i int, in chan Request) {}
</code></pre>
<p>La variable <code>PreffixSuffixWorker</code> almacena una ID, una cadena para el prefijo y otra cadena para agregar un sufijo a los datos entrantes del tipo <code>Request</code>. Entonces, los valores para prefijar y anexar serán estáticos en estos campos, y los tomaremos desde allí.</p>
<p>Implementaremos el método <code>LaunchWorker</code> más tarde y comenzaremos con cada paso en la tubería. De acuerdo con los <i>primeros criterios de aceptación</i>, la cadena entrante debe estar en mayúscula. Entonces, el método en mayúsculas será el primer paso en nuestro pipeline:</p>
<pre class="code"><code class="go">func (w *PreffixSuffixWorker) uppercase(in &lt;-chan Request) &lt;-chan Request {
  out := make(chan Request)

  go func() {
    for msg := range in {
      s, ok := msg.Data.(string)

      if !ok {
        msg.handler(nil)
        continue
      }

      msg.Data = strings.ToUpper(s)

      out &lt;- msg
    }

    close(out)
  }()

  return out
}
</code></pre>
<p>Bien, como en el capítulo anterior, un paso en la tubería acepta una
canal de datos entrantes y devuelve un canal del mismo tipo. Tiene un
enfoque muy similar a los ejemplos que desarrollamos en el capítulo
anterior. Esta vez, sin embargo, no estamos utilizando funciones de
paquete, y mayúsculas es parte del tipo <code>PreffixSuffixWorker</code> y los datos entrantes son un en <code>struct</code> lugar de un <code>int</code>.</p>
<p>La variable <code>msg</code> es un tipo <code>Request</code> y tendrá una función de controlador y datos en forma de una interfaz. El campo <code>Data</code>
 debe ser una cadena, por lo que escribimos lanzarlo antes de usarlo. Al
 escribir un valor, recibiremos el mismo valor con el tipo solicitado y
una bandera <code>true</code>o <code>false</code>(representada por la
variable ok). Si la variable ok es falsa, no se pudo hacer el reparto y
no arrojaremos el valor por la tubería. Paramos esto <code>Request</code> aquí enviando un <code>nil</code> al manejador (que también provocará un error de tipografía).</p>
<p>Una vez que tenemos una buena cadena en la variable <code>s</code>, podemos mayúsculas y almacenarla nuevamente en el campo <code>Data</code>
 para enviar la tubería al siguiente paso. Tenga en cuenta que el valor
se enviará nuevamente como una interfaz, por lo que el próximo paso
deberá volver a emitirse. Esta es la desventaja de usar este enfoque.</p>
<p>Con el primer paso hecho, continuemos con el segundo. De acuerdo con el <i>segundo criterio de aceptación</i> ahora, debe anexarse ​​un texto predefinido. Este texto es el almacenado en el campo <code>suffixS</code>:</p>
<pre class="code"><code class="go">func (w *PreffixSuffixWorker) append(in &lt;-chan Request) &lt;-chan Request {
  out := make(chan Request)
  go func() {
    for msg := range in {
      uppercaseString, ok := msg.Data.(string)

      if !ok {
        msg.handler(nil)
        continue
      }
      msg.Data = fmt.Sprintf("%s%s", uppercaseString, w.suffixS)
      out &lt;- msg
    }
    close(out)
  }()
  return out
}
</code></pre>
<p>La función <code>append</code> tiene la misma estructura que la función <code>uppercase</code>.
 Recibe y devuelve un canal de solicitudes entrantes, y lanza un nuevo
Goroutine que itera sobre el canal entrante hasta que se cierra.
Necesitamos escribir el valor entrante, como se mencionó anteriormente.</p>
<p>En este paso en la tubería, la cadena entrante está en mayúscula
(después de hacer una aserción de tipo). Para agregarle texto, solo
necesitamos usar la función <code>fmt.Sprintf()</code>, como lo hemos
hecho muchas veces anteriormente, que formatea una nueva cadena con los
datos proporcionados. En este caso, pasamos el valor del campo <code>suffixS</code> como el segundo valor, para agregarlo al final de la cadena.</p>
<p>Solo falta el último paso en la tubería, la operación de prefijo:</p>
<pre class="code"><code class="go">func (w *PreffixSuffixWorker) prefix(in &lt;-chan Request) {
  go func() {
    for msg := range in {
      uppercasedStringWithSuffix, ok := msg.Data.(string)

      if !ok {
        msg.handler(nil)
        continue
      }

      msg.handler(fmt.Sprintf("%s%s", w.prefixS, uppercasedStringWithSuffix))
    }
  }()
}
</code></pre>
<p>¿Qué te llama la atención en esta función? Sí, no devuelve ningún
canal ahora. Podríamos haber hecho todo este proceso de dos maneras.
Supongo que se habrá dado cuenta de que hemos usado una función <code>Future</code>
 de controlador para ejecutar con el resultado final en la tubería. Un
segundo enfoque sería pasar un canal para devolver los datos a su
origen. En algunos casos, a <code>Future</code> sería suficiente,
mientras que en otros podría ser más conveniente pasar un canal para que
 pueda conectarse a una tubería diferente (por ejemplo).</p>
<p>En cualquier caso, la estructura de un paso en una tubería ya debe
serle familiar. Emitimos el valor, verificamos el resultado de la
conversión y enviamos nil al manejador si algo salió mal. Pero, en caso
de que todo estuviera bien, lo último que hay que hacer es formatear el
texto nuevamente para colocar el campo <code>prefixS</code> al comienzo del texto, para enviar la cadena resultante al origen llamando al controlador de la solicitud.</p>
<p>Ahora, con nuestro trabajador casi terminado, podemos implementar el método <code>LaunchWorker</code>:</p>
<pre class="code"><code class="go">func (w *PreffixSuffixWorker) LaunchWorker(in chan Request) {
  w.prefix(w.append(w.uppercase(in)))
}
</code></pre>
<p>¡Eso es todo por los trabajadores! Simplemente pasamos los canales
que regresan a los próximos pasos en el Pipeline, como lo hicimos en el
capítulo anterior. Recuerde que la tubería se ejecuta desde adentro
hacia afuera de las llamadas. Entonces, ¿cuál es el orden de ejecución
de cualquier información entrante a la tubería?</p>
<ol class="num">
<li>
<p>Los datos entran en la tubería a través del Goroutine lanzado en el método de mayúsculas.</p>
</li>
<li>
<p>Luego, va al Goroutine lanzado en append.</p>
</li>
<li>
<p>Finalmente, entra en el Goroutine lanzado en el método de prefijo,
que no devuelve nada pero ejecuta el controlador después de prefijar la
cadena entrante con más datos.</p>
</li>
</ol>
<p>Ahora tenemos una canalización completa y un despachador de tuberías.
 El despachador lanzará tantas instancias de las tuberías como deseemos
para enrutar las solicitudes entrantes a cualquier trabajador
disponible.</p>
<p>Si ninguno de los trabajadores recibe la solicitud dentro de 5 segundos, la solicitud se pierde.</p>
<p>Usemos esta biblioteca en una aplicación pequeña.</p>
</div>
<h4 id="an-app-using-the-workers-pool">Una aplicación que usa el grupo de trabajadores</h4>
<div class="hBody-4">
<p>Lanzaremos tres trabajadores de nuestra cartera definida. Usamos la función <code>NewDispatcher</code>
 para crear el despachador y el canal que recibirá todas las
solicitudes. Este canal tiene un búfer fijo, que podrá almacenar hasta
100 mensajes entrantes antes de bloquear:</p>
<pre class="code"><code class="go">// workers_pipeline.go
func main() {
  bufferSize := 100
  var dispatcher Dispatcher = NewDispatcher(bufferSize)
</code></pre>
<p>Luego, lanzaremos los trabajadores llamando al método <code>LaunchWorker</code> en la interfaz <code>Dispatcher</code> tres veces con un tipo <code>WorkerLauncher</code> ya lleno :</p>
<pre class="code"><code class="go">workers := 3
for i := 0; i &lt; workers; i++ {
  var w WorkerLauncher = &amp;PreffixSuffixWorker{
    prefixS: fmt.Sprintf("WorkerID: %d -&gt; ", i),
    suffixS: " World",
    id:i,
  }
  dispatcher.LaunchWorker(w)
}
</code></pre>
<p>Cada tipo <code>WorkerLauncher</code> es una instancia de <code>PreffixSuffixWorker</code>. El prefijo será un pequeño texto que muestra la ID del trabajador y el texto del sufijo <code>world</code>.</p>
<p>En este punto, tenemos tres trabajadores con tres Goroutines, cada
uno corriendo concurrentemente y esperando que lleguen los mensajes:</p>
<pre class="code"><code class="go">requests := 10

var wg sync.WaitGroup
wg.Add(requests)
</code></pre>
<p>Haremos 10 solicitudes. También necesitamos un WaitGroup para
sincronizar correctamente la aplicación para que no se cierre demasiado
pronto. Puede encontrarse usando WaitGroups bastante cuando se trata de
aplicaciones concurrentes. Para 10 solicitudes, tendremos que esperar 10
 llamadas al método <code>Done()</code>, por lo que llamamos al método <code>Add()</code> con un <i>delta</i>
 de 10. Se llama delta porque también puede pasar un -5 más tarde para
dejarlo en cinco solicitudes. En algunas situaciones, puede ser útil:</p>
<pre class="code"><code class="go">    for i := 0; i &lt; requests; i++ {
        req := NewStringRequest("(Msg_id: %d) -&gt; Hello", i, &amp;wg)
        dispatcher.MakeRequest(req)
    }

    dispatcher.Stop()

    wg.Wait()
}
</code></pre>
<p>Para realizar solicitudes, iteraremos un bucle <code>for</code>. Primero, creamos una Solicitud usando la función <code>NewStringRequest</code> que escribimos al principio de la sección Implementación. En este valor, el campo <code>Data</code>
 será el texto que pasaremos por la tubería, y será el texto que está
"en el medio" de la operación de agregar y sufijar. En este caso, le
enviaremos el número de mensaje y la palabra <code>hello</code>.</p>
<p>Una vez que tenemos una solicitud, llamamos al método <code>MakeRequest</code>
 con ella. Después de que se hayan realizado todas las solicitudes,
detenemos al despachador que, como se explicó anteriormente, provocará
una reacción en cadena que detendrá a todos los Goroutines en la
tubería.</p>
<p>Finalmente, esperamos que el grupo <code>Done()</code> reciba todas las llamadas al método, lo que indica que todas las operaciones han finalizado. Es hora de probarlo:</p>
<pre class="srci"><code class="sh"><span class="in"><span class="prompt">&gt; </span>go run *
</span><span class="out">WorkerID: 1 -&gt; (MSG_ID: 0) -&gt; HELLO World
WorkerID: 0 -&gt; (MSG_ID: 3) -&gt; HELLO World
WorkerID: 0 -&gt; (MSG_ID: 4) -&gt; HELLO World
WorkerID: 0 -&gt; (MSG_ID: 5) -&gt; HELLO World
WorkerID: 2 -&gt; (MSG_ID: 2) -&gt; HELLO World
WorkerID: 1 -&gt; (MSG_ID: 1) -&gt; HELLO World
WorkerID: 0 -&gt; (MSG_ID: 6) -&gt; HELLO World
WorkerID: 2 -&gt; (MSG_ID: 9) -&gt; HELLO World
WorkerID: 0 -&gt; (MSG_ID: 7) -&gt; HELLO World
WorkerID: 0 -&gt; (MSG_ID: 8) -&gt; HELLO World
</span></code></pre>
<p>Analicemos el primer mensaje:</p>
<ol class="num">
<li>
<p>Esto sería cero, por lo que el mensaje enviado es <code>(Msg_id: 0) -&gt; Hello</code>.</p>
</li>
<li>
<p>Entonces, el texto está en mayúscula, entonces ahora tenemos <code>(MSG_ID: 0) -&gt; HELLO</code>.</p>
</li>
<li>
<p>Después de aplicar una operación de adición con el texto <code>world</code>(tenga en cuenta el espacio al principio del texto) se hace. Esto nos dará el texto <code>(MSG_ID: 0) -&gt; HELLO World</code>.</p>
</li>
<li>
<p>Finalmente, el texto <code>WorkerID: 1</code>(en este caso, el primer
 trabajador tomó la tarea, pero podría ser cualquiera de ellos) se
agrega al texto del paso 3 para darnos el mensaje completo, <code>WorkerID: 1 -&gt; (MSG_ID: 0</code>-&gt; HELLO World).</p>
</li>
</ol>
</div>
<h4 id="no-tests?">Sin pruebas?</h4>
<div class="hBody-4">
<p>Las aplicaciones simultáneas son difíciles de probar, especialmente
si está realizando operaciones de red. Puede ser difícil, y el código
puede cambiar mucho solo para probarlo. En cualquier caso, no es
justificable no realizar pruebas. En este caso, no es especialmente
difícil probar nuestra pequeña aplicación. Cree una prueba y copie /
pegue los contenidos de la función <code>main</code> allí:</p>
<pre class="code"><code class="go">// workers_pipeline.go file
package main

import "testing"

func Test_Dispatcher(t *testing.T){
  // pasted code from main function
  bufferSize := 100

  var dispatcher Dispatcher = NewDispatcher(bufferSize)

  workers := 3

  for i := 0; i &lt; workers; i++
  {

    var w WorkerLauncher = &amp;PreffixSuffixWorker{

      prefixS: fmt.Sprintf("WorkerID: %d -&gt; ", i),
      suffixS: " World",
      id: i,
    }

    dispatcher.LaunchWorker(w)

  }

  // Simulate Requests

  requests := 10

  var wg
  sync.WaitGroup

  wg.Add(requests)
}
</code></pre>
<p>Ahora tenemos que volver a escribir nuestro controlador para probar
que los contenidos devueltos son los que estamos esperando. Vaya al <code>for</code> ciclo para modificar la función que estamos pasando como un controlador en cada uno <code>Request</code>:</p>
<pre class="code"><code class="go">for i := 0; i &lt; requests; i++ {
  req := Request{
    Data: fmt.Sprintf("(Msg_id: %d) -&gt; Hello", i),
    handler: func(i interface{})
    {
      s, ok := i.(string)
      defer wg.Done()
      if !ok
      {

        t.Fail()

      }

      ok, err := regexp.Match(`WorkerID\: \d* -\&gt; \(MSG_ID: \d*\) -&gt; [A-Z]*\sWorld`, []byte(s))

      if !ok || err != nil {
        t.Fail()
      }
    },
  }
  dispatcher.MakeRequest(req)
}
</code></pre>
<p>Vamos a usar expresiones regulares para probar el negocio. Si no está
 familiarizado con las expresiones regulares, son una característica
bastante poderosa que lo ayuda a emparejar el contenido dentro de una
cadena. Si recuerdas en nuestros ejercicios cuando estábamos usando el
paquete <code>strings</code>. <code>Contains</code> es la función para encontrar un texto dentro de una cadena. También podemos hacerlo con expresiones regulares.</p>
<p>El problema es que las expresiones regulares son bastante caras y consumen muchos recursos.</p>
<p>Estamos utilizando la función <code>Match</code> del paquete <code>regexp</code> para proporcionar una plantilla para que coincida. Nuestra plantilla es <code>WorkerID\: \d* -&gt; \(MSG_ID: \d\) -&gt; [A-Z]*\sWorld</code>(sin comillas). Específicamente, describe lo siguiente:</p>
<ul>
<li>
<p>Una cadena que tiene el contenido <q><code>WorkerID: \d* -&gt; (MSG_ID: \d*</code></q>, aquí <q><code>\d*</code></q>indica cualquier dígito escrito cero o más veces, por lo que coincidirá <q><code>WorkerID: 10 -&gt; (MSG_ID: 1</code></q>y <code><q>WorkerID: 1 -&gt; (MSG_ID: 10</q></code>.</p>
</li>
<li>
<p><q><code>\) -&gt; [A-Z]*\sWorld</code></q>(los paréntesis deben ser escapados usando barras diagonales inversas). <q><code>*</code></q>significa cualquier carácter en mayúscula escrito cero o más veces, por lo que <q><code>\s</code></q>es un espacio en blanco y debe terminar con el texto <code>World</code>, por <q><code>) -&gt; HELLO World</code></q>lo que coincidirá, pero <q><code>) -&gt; Hello World</code></q>no lo hará, porque <q><code>Hello</code></q>debe estar todo en mayúscula.</p>
</li>
</ul>
<p>Ejecutar esta prueba nos da el siguiente resultado:</p>
<pre class="srci"><code class="sh"><span class="in"><span class="prompt">&gt; </span>go test -v .
</span><span class="out">=== RUN   Test_Dispatcher
--- PASS: Test_Dispatcher (0.00s)
PASS
ok
</span></code></pre>
<p>No está mal, pero no estamos probando que el código se esté
ejecutando al mismo tiempo, por lo que esto es más una prueba de
negocios que una prueba unitaria. La prueba de simultaneidad nos
obligaría a escribir el código de una manera completamente diferente
para verificar que esté creando la cantidad adecuada de Goroutines y que
 la cartera esté siguiendo el flujo de trabajo esperado. Esto no está
mal, pero es bastante complejo y está fuera del contexto de este libro.</p>
</div>
<h3 id="wrapping-up-the-worker-pool">Rellenar el grupo de trabajadores</h3>
<div class="hBody-3">
<p>Con el grupo de trabajadores, tenemos nuestra primera aplicación
simultánea compleja que se puede usar en sistemas de producción del
mundo real. También tiene espacio para mejorar, pero es un patrón de
diseño muy bueno para crear aplicaciones acotadas concurrentes.</p>
<p>Es clave que siempre tengamos el número de Goroutines que se lanzan
bajo control. Si bien es fácil lanzar miles para lograr más paralelismo
en una aplicación, debemos tener mucho cuidado de que no tengan un
código que pueda colgarlos en un bucle infinito también.</p>
<p>Con el grupo de trabajadores, ahora podemos fragmentar una operación
simple en muchas tareas paralelas. Piénsalo; esto podría lograr el mismo
 resultado con una simple llamada a <code>fmt.Printf</code>, pero hemos
hecho una tubería con él; luego, lanzamos algunas instancias de esta
tubería y, finalmente, distribuimos la carga de trabajo entre todas esas
 tuberías.</p>
</div>
<h3 id="concurrent-publish/subscriber-design-pattern">Diseño concurrente / patrón de diseño de suscriptor</h3>
<div class="hBody-3">
<p>En esta sección, implementaremos el patrón de diseño del observador
que mostramos previamente en los patrones de comportamiento, pero con
una estructura y seguridad de subprocesos simultáneas.</p>
</div>
<h4 id="description">Descripción</h4>
<div class="hBody-4">
<p>Si recuerda de la explicación anterior, el patrón Observer mantiene
una lista de observadores o suscriptores que desean ser notificados de
un evento en particular. En este caso, cada suscriptor se ejecutará en
un Goroutine diferente, así como también en el editor. Tendremos nuevos
problemas para construir esta estructura:</p>
<ul>
<li>
<p>Ahora, el acceso a la lista de suscriptores debe ser serializado. Si
estamos leyendo la lista con un Goroutine, no podemos eliminar un
suscriptor de él o tendremos una carrera.</p>
</li>
<li>
<p>Cuando se elimina un suscriptor, el Goroutine del suscriptor debe
cerrarse también, o se repetirá para siempre y nos encontraremos con
fugas de Goroutine.</p>
</li>
<li>
<p>Al detener al editor, todos los suscriptores también deben detener sus Goroutines.</p>
</li>
</ul>
</div>
<h4 id="objectives">Objetivos</h4>
<div class="hBody-4">
<p>Los objetivos de esta publicación / suscriptor son los mismos que los
 que escribimos en el patrón Observer. La diferencia aquí es la forma en
 que la desarrollaremos. La idea es hacer una estructura concurrente
para lograr la misma funcionalidad, que es la siguiente:</p>
<ul>
<li>
<p>Proporcionar una arquitectura impulsada por eventos donde un evento puede desencadenar una o más acciones</p>
</li>
<li>
<p>Desacoplando las acciones que se realizan desde el evento que las desencadena</p>
</li>
<li>
<p>Proporcionar más de un evento fuente que desencadena la misma acción</p>
</li>
</ul>
<p>La idea es desacoplar a los remitentes de los receptores, ocultando
al remitente la identidad de los receptores que procesarán su evento, y
ocultando los receptores de la cantidad de remitentes que pueden
comunicarse con ellos.</p>
<p>En particular, si desarrollo un clic en un botón en alguna
aplicación, podría hacer algo (como iniciar sesión en algún lugar).
Semanas más tarde, podríamos decidir hacer que muestre una ventana
emergente también. Si, cada vez que queremos agregar alguna
funcionalidad a este botón, tenemos que cambiar el código donde maneja
la acción de hacer clic, esa función se volverá enorme y no muy portátil
 para otros proyectos. Si utilizamos un editor y un observador para cada
 acción, la función de clic solo necesita publicar un solo evento usando
 un editor, y solo escribiremos suscriptores a este evento cada vez que
queramos mejorar la funcionalidad. Esto es especialmente importante en
aplicaciones con interfaces de usuario donde muchas cosas que hacer en
una sola acción de IU pueden ralentizar la capacidad de respuesta de una
 interfaz, destruyendo por completo la experiencia del usuario.</p>
<p>Al usar una estructura concurrente para desarrollar el patrón
Observer, una IU no puede sentir todas las tareas que se están
ejecutando en el fondo si se define una estructura concurrente y el
dispositivo nos permite ejecutar tareas paralelas.</p>
</div>
<h4 id="example---a-concurrent-notifier">Ejemplo: un notificador simultáneo</h4>
<div class="hBody-4">
<p>Desarrollaremos un <i>notificador</i> similar al que desarrollamos en el <a href="https://nasciiboy.github.io/book4all/Go%20Design%20Patterns.html#chapter-7">Capítulo 7</a>, <i>Patrones de comportamiento: patrón de visitante, estado, mediador y diseño de observador</i>.
 Esto se enfoca en la naturaleza concurrente de la estructura en lugar
de detallar demasiadas cosas que ya se han explicado. Ya hemos
desarrollado un observador, por lo que estamos familiarizados con el
concepto.</p>
<p>Este notificador particular funcionará pasando valores <code>interface{}</code>,
 como en el ejemplo del grupo de trabajadores. De esta forma, podemos
usarlo para más de un tipo introduciendo un poco de sobrecarga cuando se
 conecta el receptor.</p>
<p>Trabajaremos con dos interfaces ahora. Primero, una interfaz <code>Subscriber</code>:</p>
<pre class="code"><code class="go">type Subscriber interface {
  Notify(interface{}) error
  Close()
}
</code></pre>
<p>Al igual que en el ejemplo anterior, debe tener un método <code>Notify</code> en la interfaz <code>Subscriber</code> de nuevos eventos. Este es el método <code>Notify</code> que acepta un valor <code>interface{}</code> y devuelve un error. El método <code>Close()</code>,
 sin embargo, es nuevo y debe desencadenar las acciones necesarias para
detener a Goroutine, donde el suscriptor está escuchando nuevos eventos.</p>
<p>La segunda y última interfaz es la interfaz <code>Publisher</code>:</p>
<pre class="code"><code class="go">type Publisher interface {
  start()
  AddSubscriberCh() chan&lt;- Subscriber
  RemoveSubscriberCh() chan&lt;- Subscriber
  PublishingCh() chan&lt;- interface{}
  Stop()
}
</code></pre>
<p>La interfaz <code>Publisher</code> tiene las mismas acciones que ya conocemos para un editor, pero para trabajar con canales. The <code>AddSubscriberCh</code>y <code>RemoveSubscriberCh</code> methods acepta una interfaz <code>Subscriber</code> (cualquier tipo que satisfaga la interfaz <code>Subscriber</code>). Debe tener un método para publicar mensajes y un método <code>Stop</code> para detenerlos a todos (editor y suscriptor Goroutines)</p>
</div>
<h4 id="acceptance-criteria">Criterios de aceptación</h4>
<div class="hBody-4">
<p>Los requisitos entre este ejemplo y el del <a href="https://nasciiboy.github.io/book4all/Go%20Design%20Patterns.html#chapter-7">Capítulo 7</a>, <i>Patrones de comportamiento: visitante, estado, mediador y patrones de diseño del observador</i>
 no deben cambiar. El objetivo en ambos ejemplos es el mismo, por lo que
 los requisitos también deben ser los mismos. En este caso, nuestros
requisitos son técnicos, por lo que debemos agregar algunos criterios de
 aceptación más:</p>
<ol class="num">
<li>
<p>Debemos tener un editor con un método <code>PublishingCh</code> que devuelva un canal para enviar mensajes y activa un método <code>Notify</code> para cada observador suscrito.</p>
</li>
<li>
<p>Debemos tener un método para agregar nuevos suscriptores al editor.</p>
</li>
<li>
<p>Debemos tener un método para eliminar nuevos suscriptores del editor.</p>
</li>
<li>
<p>Debemos tener un método para detener a un suscriptor.</p>
</li>
<li>
<p>Debemos tener un método para detener una interfaz <code>Publisher</code> que también detendrá a todos los suscriptores.</p>
</li>
<li>
<p>Toda la comunicación entre Goroutine debe estar sincronizada para que
 ningún Goroutine quede bloqueado esperando una respuesta. En tales
casos, se devuelve un error una vez transcurrido el período de tiempo de
 espera especificado.</p>
</li>
</ol>
<p>Bueno, estos criterios parecen bastante desalentadores. Hemos omitido
 algunos requisitos que agregarían aún más complejidad, como eliminar
suscriptores que no responden o cheques para monitorear que el editor
Goroutine esté siempre activo.</p>
</div>
<h4 id="unit-test">Prueba de unidad</h4>
<div class="hBody-4">
<p>Anteriormente hemos mencionado que probar aplicaciones concurrentes
puede ser difícil. Con el mecanismo correcto, todavía se puede hacer,
así que vamos a ver cuánto podemos probar sin grandes dolores de cabeza.</p>
</div>
<h4 id="testing-subscriber">Suscriptor de prueba</h4>
<div class="hBody-4">
<p>Comenzando por los suscriptores, que parecen tener una funcionalidad
más encapsulada, el primer suscriptor debe imprimir los mensajes
entrantes del editor a una interfaz <code>io.Writer</code>. Hemos mencionado que el suscriptor tiene una interfaz con dos métodos <code>Notify(interface{})</code> <code>error</code>y el método <code>Close()</code>:</p>
<pre class="code"><code class="go">// writer_sub.go file
package main

import "errors"

type writerSubscriber struct {
  id int
  Writer io.Writer
}

func (s *writerSubscriber) Notify(msg interface{}) error {
  return erorrs.NeW("Not implemented yet")
}
func (s *writerSubscriber) Close() {}
</code></pre>
<ol class="alpha">
<li>
<p>Este va a ser nuestro archivo <span class="file">writer_sub.go</span>. Crea el correspondiente</p>
</li>
</ol>
<p>archivo de prueba, llamado archivo <span class="file">writer_sub_test.go</span> :</p>
<pre class="code"><code class="go">package main
func TestStdoutPrinter(t *testing.T) {
</code></pre>
<p>Ahora, el primer problema que tenemos es que la funcionalidad se imprime en el <code>stdout</code>, por lo que no hay valor de retorno para verificar. Podemos resolverlo de tres maneras:</p>
<ul>
<li>
<p>Capturando el método <code>stdout</code>.</p>
</li>
<li>
<p>Inyectar una interfaz <code>io.Writer</code> para imprimir en ella. Esta es la solución preferida, ya que hace que el código sea más manejable.</p>
</li>
<li>
<p>Redirigir el método <code>stdout</code> a un archivo diferente.</p>
</li>
</ul>
<p>Tomaremos el segundo enfoque. La redirección también es una posibilidad. El <code>os.Stdout</code> es un puntero a un tipo <code>os.File</code>, lo que implica la sustitución de este archivo con un solo controlamos, y la lectura de ella:</p>
<pre class="code"><code class="go">func TestWriter(t *testing.T) {
  sub := NewWriterSubscriber(0, nil)
</code></pre>
<p>El <code>NewWriterSubscriber</code> suscriptor aún no está definido.
Debe ayudar en la creación de este suscriptor particular, devolviendo un
 tipo que satisfaga la interfaz <code>Subscriber</code>, así que vamos a declararlo rápidamente en el archivo <span class="file">writer_sub.go</span> :</p>
<pre class="code"><code class="go">func NewWriterSubscriber(id int, out io.Writer) Subscriber {
  return &amp;writerSubscriber{}
}
</code></pre>
<p>Idealmente, debe aceptar una identificación y una interfaz <code>io.Writer</code> como destino para sus escrituras. En este caso, necesitamos una interfaz <code>io.Writer</code> personalizada para nuestra prueba, por lo que crearemos una <code>mockWriter</code> en el archivo <span class="file">writer_sub_test.go</span> para ello:</p>
<pre class="code"><code class="go">type mockWriter struct {
  testingFunc func(string)
}

func (m *mockWriter) Write(p []byte) (n int, err error) {
  m.testingFunc(string(p))
  return len(p), nil
}
</code></pre>
<p>La estructura <code>mockWriter</code> aceptará a <code>testingFunc</code> como uno de sus campos. Este campo <code>testingFunc</code> acepta una cadena que representa los bytes escritos en la estructura <code>mockWriter</code>. Para implementar una interfaz <code>io.Writer</code>, necesitamos definir un método <code>Write([]byte) (int, error)</code>.
 En nuestra definición, pasamos los contenidos de p como una cadena
(recuerde que siempre debemos devolver los bytes leídos y un error, o
no, en cada método <code>Write</code>). Este enfoque delega la definición de <code>testingFunc</code> al alcance de la prueba.</p>
<p>Vamos a llamar al método <code>Notify</code> en la interfaz <code>Subcriber</code>, que debe escribir en la interfaz <code>io.Writer</code> como la estructura <code>mockWriter</code>. Entonces, definiremos el <code>testingFunc</code> de una estructura <code>mockWriter</code> antes de llamar al método <code>Notify</code>:</p>
<pre class="code"><code class="go">// writer_sub_test.go file
func TestPublisher(t *testing.T) {
  msg := "Hello"

  var wg sync.WaitGroup
  wg.Add(1)

  stdoutPrinter := sub.(*writerSubscriber)
  stdoutPrinter.Writer = &amp;mockWriter{
    testingFunc: func(res string) {
      if !strings.Contains(res, msg) {
        t.Fatal(fmt.Errorf("Incorrect string: %s", res))
      }
      wg.Done()
    },
  }
</code></pre>
<p>Vamos a enviar el mensaje <code>Hello</code>. Esto también significa que cualquiera que sea la interfaz <code>Subscriber</code>, eventualmente debe imprimir el mensaje <code>Hello</code> en la interfaz <code>io.Writer</code> proporcionada .</p>
<p>Entonces, si, eventualmente, recibimos una cadena en la función de prueba, necesitaremos sincronizar con la interfaz <code>Subscriber</code> para evitar condiciones de carrera en las pruebas. Es por eso que usamos mucho <code>WaitGroup</code>. Es un tipo muy práctico y fácil de usar para manejar este escenario. Una llamada <code>Notify</code> a un método deberá esperar una llamada al método <code>Done()</code>, por lo que llamaremos al método <code>Add(1)</code> (con una unidad).</p>
<p>Idealmente, la función <code>NewWriterSubscriber</code> debe devolver
 una interfaz, por lo que debemos escribirla en el tipo con el que
estamos trabajando durante la prueba, en este caso, el método <code>stdoutPrinter</code>.
 He omitido la comprobación de errores al hacer el casting a propósito,
solo para facilitar las cosas. Una vez que tenemos un tipo <code>writerSubscriber</code>, podemos acceder a su campo <code>Write</code> para reemplazarlo con la estructura <code>mockWriter</code>. Podríamos haber pasado directamente una interfaz <code>io.Writer</code> en la función <code>NewWriterSubscriber</code>, pero no cubriríamos el escenario donde se pasa un objeto nil y establece la instancia <code>os.Stdout</code> en un valor predeterminado.</p>
<p>Por lo tanto, la función de prueba recibirá finalmente una cadena que
 contiene lo que escribió el suscriptor. Solo necesitamos verificar si
la cadena recibida, la que <code>Subscriber</code> recibirá la interfaz, imprime la palabra <code>Hello</code> en algún momento y nada mejor que <code>strings.Contains</code>
 funcione para ella. Todo se define bajo el alcance de la función de
prueba, por lo que podemos usar el valor del objeto t para indicar
también que la prueba ha fallado.</p>
<p>Una vez que hemos hecho la verificación, debemos llamar al método <code>Done()</code> para indicar que ya hemos probado el resultado esperado:</p>
<pre class="code"><code class="go">err := sub.Notify(msg)
if err != nil {
    t.Fatal(err)
    }

    wg.Wait()
    sub.Close()
}
</code></pre>
<p>En realidad debemos llamar a los métodos <code>Notify</code>y <code>Wait</code> para la llamada al método <code>Done</code> para verificar que todo esté correcto.</p>
<div class="about">
<div class="about-dt">Nota</div>
<div class="about-dd">
<p>¿Te diste cuenta de que hemos definido el comportamiento en las
pruebas más o menos al revés? Esto es muy común en aplicaciones
concurrentes. A veces puede ser confuso, ya que es difícil saber qué
función podría estar haciendo si no podemos seguir llamadas linealmente,
 pero te acostumbras bastante rápido. En lugar de pensar "hace esto,
entonces esto, luego eso", es más como "se llamará esto al ejecutar
eso". Esto también se debe a que el orden de ejecución en una aplicación
 simultánea se desconoce hasta cierto punto, a menos que usemos
primitivas de sincronización (como WaitGroups y canales) para pausar la
ejecución en ciertos momentos.</p>
</div>
</div>
<p>Vamos a ejecutar la prueba para este tipo ahora:</p>
<pre class="srci"><code class="sh"><span class="in"><span class="prompt">&gt; </span>go test -cover -v -run=TestWriter .
</span><span class="out">=== RUN   TestWriter
--- FAIL: TestWriter (0.00s)
        writer_sub_test.go:40: Not implemented yet
FAIL
coverage: 6.7% of statements
exit status 1
FAIL
</span></code></pre>
<p>Ha salido rápido pero ha fallado. En realidad, la llamada al método <code>Done()</code> no se ha ejecutado, por lo que sería bueno cambiar la última parte de nuestra prueba a este:</p>
<pre class="code"><code class="go">  err := sub.Notify(msg)
  if err != nil {
    wg.Done()
    t.Error(err)
  }
  wg.Wait()
  sub.Close()
}
</code></pre>
<p>Ahora, no detiene la ejecución porque estamos llamando a la función <code>Error</code> en lugar de a la función <code>Fatal</code>, pero llamamos al método <code>Done()</code> y la prueba finaliza donde preferimos que finalice, después de <code>Wait()</code> que se llama al método. Puede intentar ejecutar las pruebas nuevamente, pero la salida será la misma.</p>
</div>
<h4 id="testing-publisher">Editor de pruebas</h4>
<div class="hBody-4">
<p>Ya hemos visto una interfaz <code>Publisher</code> y el tipo que satisfará cuál era el tipo <code>publisher</code>.
 Lo único que sabemos con certeza es que va a necesitar alguna forma de
almacenar suscriptores, por lo que al menos tendrá una porción <code>Subscribers</code>:</p>
<pre class="code"><code class="go">// publisher.go type
type publisher struct {
  subscribers []Subscriber
}
</code></pre>
<p>Para probar el tipo <code>publisher</code>, también necesitaremos un simulacro para la interfaz <code>Subscriber</code>:</p>
<pre class="code"><code class="go">// publisher_test.go
type mockSubscriber struct {
  notifyTestingFunc func(msg interface{})
  closeTestingFunc func()
}

func (m *mockSubscriber) Close() {
  m.closeTestingFunc()
}

func (m *mockSubscriber) Notify(msg interface{}) error {
  m.notifyTestingFunc(msg)
  return nil
}
</code></pre>
<p>El tipo <code>mockSubscriber</code> debe implementar la interfaz <code>Subscriber</code>, por lo que debe tener el método a <code>Close()</code>y a <code>Notify(interface{}</code>) <code>error</code>. Podemos incrustar un tipo existente que lo implemente, por ejemplo, <code>writerSubscriber</code>y anular solo el método que es interesante para nosotros, pero necesitaremos definir ambos, para no incrustar nada.</p>
<p>Por lo tanto, debemos anular los métodos <code>Notify</code>y <code>Close</code> en este caso para llamar a las funciones de prueba almacenadas en los campos del tipo de simulador de suscripción:</p>
<pre class="code"><code class="go">func TestPublisher(t *testing.T) {
  msg := "Hello"

  p := NewPublisher()
</code></pre>
<p>En primer lugar, enviaremos mensajes a través de canales
directamente, esto podría conducir a posibles interbloqueos no deseados,
 por lo que lo primero que debe definir es un controlador de pánico para
 casos como el envío de canales cerrados o la ausencia de escucha de
Goroutines en un canal. El mensaje que enviaremos a los suscriptores es <code>Hello</code>. Por lo tanto, cada suscriptor que se haya recibido utilizando el canal devuelto por el método <code>AddSubscriberCh</code> debe recibir este mensaje. También utilizaremos una función <i>nueva</i> para crear editores, llamada <code>NewPublisher</code>. Cambie el archivo <span class="file">publisher.go</span> ahora para escribirlo:</p>
<pre class="code"><code class="go">// publisher.go file
func NewPublisher() Publisher {
  return &amp;publisher{}
}
</code></pre>
<p>Ahora definiremos el <code>mockSubscriber</code> para agregarlo a la lista de editores de suscriptores conocidos. Volver al archivo <span class="file">publisher_test.go</span> :</p>
<pre class="code"><code class="go">var wg sync.WaitGroup

sub := &amp;mockSubscriber{
  notifyTestingFunc: func(msg interface{}) {
    defer wg.Done()

    s, ok := msg.(string)
    if !ok {
      t.Fatal(errors.New("Could not assert result"))
    }

    if s != msg {
      t.Fail()
    }
  },
  closeTestingFunc: func() {
    wg.Done()
  },
}
</code></pre>
<p>Como de costumbre, comenzamos con un WaitGroup. Primero, probar la función en nuestro suscriptor aplaza una llamada al método <code>Done()</code> al final de su ejecución. Luego necesita escribir la variable <code>msg</code> de conversión porque viene como una interfaz. Recuerde que de esta manera, podemos usar la interfaz <code>Publisher</code> con muchos tipos introduciendo la sobrecarga de la aserción de tipo. Esto se hace en línea <code>s, ok := msg.(string)</code>.</p>
<p>Una vez que tenemos el tipo de conversión <code>msg</code>a una
cadena, s, solo necesitamos verificar si el valor recibido en el
suscriptor es el mismo que el que enviamos, o no pasar la prueba si no
es así:</p>
<pre class="code"><code class="go">p.AddSubscriberCh() &lt;- sub
wg.Add(1)

p.PublishingCh() &lt;- msg
wg.Wait()
</code></pre>
<p>Agregamos el tipo <code>mockSubscriber</code> usando el método <code>AddSubscriberCh</code>.
 Publicamos nuestro mensaje justo después de prepararnos, agregando uno
al WaitGroup, y justo antes de configurar WaitGroup para que la prueba
no continúe hasta que el tipo <code>mockSubscriber</code> llame al método <code>Done()</code>.</p>
<p>Además, debemos verificar si el número de la interfaz <code>Subscriber</code> ha crecido después de llamar al método <code>AddSubscriberCh</code>, por lo que necesitaremos obtener la instancia concreta del editor en la prueba:</p>
<pre class="code"><code class="go">pubCon := p.(*publisher)
if len(pubCon.subscribers) != 1 {
  t.Error("Unexpected number of subscribers")
}
</code></pre>
<p>Type assertion es nuestro amigo hoy! Una vez que tenemos el tipo
concreto, podemos acceder a la porción subyacente de suscriptores para
la interfaz <code>Publisher</code>. La cantidad de suscriptores debe ser 1 después de llamar al método <code>AddSubscriberCh</code> una vez, o la prueba fallará. El siguiente paso es verificar todo lo contrario: cuando eliminamos una interfaz <code>Subscriber</code>, debe tomarse de esta lista:</p>
<pre class="code"><code class="go">   wg.Add(1)
   p.RemoveSubscriberCh() &lt;- sub
   wg.Wait()

   // Number of subscribers is restored to zero
   if len(pubCon.subscribers) != 0 {
         t.Error("Expected no subscribers")
   }

   p.Stop()
}
</code></pre>
<p>El último paso en nuestra prueba es detener al editor para que no se
puedan enviar más mensajes y se detengan todos los Goroutines.</p>
<p>La prueba ha finalizado, pero no podemos ejecutar pruebas hasta que el tipo <code>publisher</code> tenga todos los métodos implementados; este debe ser el resultado final:</p>
<pre class="code"><code class="go">type publisher struct {
  subscribers []Subscriber
  addSubCh    chan Subscriber
  removeSubCh chan Subscriber
  in          chan interface{}
  stop        chan struct{}
}

func (p *publisher) AddSubscriberCh() chan&lt;- Subscriber {
  return nil
}

func (p *publisher) RemoveSubscriberCh() chan&lt;- Subscriber
{
  return nil
}

func (p *publisher) PublishingCh() chan&lt;- interface{} {
  return nil
}

func (p *publisher) Stop(){}
</code></pre>
<p>Con esta implementación vacía, nada bueno puede suceder al ejecutar las pruebas:</p>
<pre class="srci"><code class="sh"><span class="in"><span class="prompt">&gt; </span>go test -cover -v -run=TestPublisher .
</span><span class="out">atal error: all goroutines are asleep - deadlock!
goroutine 1 [chan receive]:
testing.(*T).Run(0xc0420780c0, 0x5244c6, 0xd, 0x5335a0, 0xc042037d20)
      /usr/local/go/src/testing/testing.go:647 +0x31d
testing.RunTests.func1(0xc0420780c0)
      /usr/local/go/src/testing/testing.go:793 +0x74
testing.tRunner(0xc0420780c0, 0xc042037e10)
      /usr/local/go/src/testing/testing.go:610 +0x88
testing.RunTests(0x5335b8, 0x5ada40, 0x2, 0x2, 0x40d7e9)
      /usr/local/go/src/testing/testing.go:799 +0x2fc
testing.(*M).Run(0xc042037ed8, 0xc04200a4f0)
      /usr/local/go/src/testing/testing.go:743 +0x8c
main.main()
      go-design-
patterns/concurrency_3/pubsub/_test/_testmain.go:56 +0xcd
goroutine 5 [chan send (nil chan)]:
go-design-
patterns/concurrency_3/pubsub.TestPublisher(0xc042078180)
      go-design-
patterns/concurrency_3/pubsub/publisher_test.go:55 +0x372
testing.tRunner(0xc042078180, 0x5335a0)
      /usr/local/go/src/testing/testing.go:610 +0x88
created by testing.(*T).Run
      /usr/local/go/src/testing/testing.go:646 +0x2f3
exit status 2
FAIL  go-design-patterns/concurrency_3/pubsub   1.587s
</span></code></pre>
<p>Sí, ha fallado, pero no es un error controlado en absoluto. Esto se
hizo a propósito para mostrar un par de cosas de las que tener cuidado
en Go. En primer lugar, el error producido en esta prueba es un error <b>fatal</b>, que generalmente apunta a un error en el código. Esto es importante porque, aunque se puede recuperar un error de <b>pánico</b>, no se puede hacer lo mismo con un error fatal.</p>
<p>En este caso, el error nos dice el problema: <code>goroutine 5 [chan send (nil chan)]</code>
 un canal nulo, por lo que en realidad es un error en nuestro código.
¿Cómo podemos solucionar esto? Bueno, esto también es interesante.</p>
<p>El hecho de que tengamos un canal <code>nil</code> es causado por el
código que escribimos para compilar las pruebas unitarias, pero este
error en particular no se generará una vez que se haya escrito el código
 apropiado (porque en este caso nunca devolveremos un canal nulo).
Podríamos devolver un canal que nunca se utiliza. Causamos un error
fatal con un interbloqueo, que tampoco sería ningún progreso.</p>
<p>Una forma idiomática de resolverlo sería devolver un canal y un error
 para que pueda tener un paquete de error con un tipo que implementa la
interfaz <code>Error</code> que devuelve un error específico, como<code>NoGoroutinesListening</code> o <code>ChannelNotCreated</code>.
 Ya hemos visto muchas de estas implementaciones, así que las dejaremos
como un ejercicio para el lector y avanzaremos para mantener el foco en
la naturaleza concurrente del capítulo.</p>
<p>Nada sorprendente allí, por lo que podemos pasar a la fase de implementación.</p>
</div>
<h4 id="implementation">Implementación</h4>
<div class="hBody-4">
<p>Para recordar, el <code>writerSubscriber</code> debe recibir mensajes que escribirá en un tipo que satisfaga la interfaz <code>io.Writer</code>.</p>
<p>¿Así que por dónde empezamos? Bueno, cada suscriptor ejecutará su
propio Goroutine, y hemos visto que el mejor método para comunicarse con
 un Goroutine es un canal. Por lo tanto, necesitaremos un campo con un
canal en el tipo <code>Subscriber</code>. Podemos usar el mismo enfoque que en las tuberías para finalizar con la función <code>NewWriterSubscriber</code> y el tipo <code>writerSubscriber</code>:</p>
<pre class="code"><code class="go">type writerSubscriber struct {
  in     chan interface{}
  id     int
  Writer io.Writer
}

func NewWriterSubscriber(id int, out io.Writer) Subscriber {
  if out == nil {
    out = os.Stdout
  }

  s := &amp;writerSubscriber{
    id:     id,
    in:     make(chan interface{}),
    Writer: out,
  }

  go func(){
    for msg := range s.in {
      fmt.Fprintf(s.Writer, "(W%d): %v\n", s.id, msg)
    }
  }()

  return s
}
</code></pre>
<p>En el primer paso, si no se especifica ningún escritor (el argumento <code>out</code> es nulo), la interfaz <code>io.Writer</code> predeterminada es <code>stdout</code>. Luego, creamos un nuevo puntero al tipo <code>writerSubscriber</code> con la ID pasada en el primer argumento, el valor de out ( <code>os.Stdout</code>,
 o lo que sea que venga en el argumento si no fuera nulo), y un canal
llamado para mantener el mismo nombre como en ejemplos anteriores.</p>
<p>Entonces lanzamos un nuevo Goroutine; este es el mecanismo de
lanzamiento que mencionamos. Al igual que en las canalizaciones, el
suscriptor repetirá sobre el canal en cada vez que se reciba un mensaje
nuevo y formateará su contenido en una cadena, que también contiene el
ID del suscriptor actual.</p>
<p>Como aprendimos anteriormente, si el canal <code>in</code> está cerrado, el <code>for range</code> ciclo se detendrá y ese particular Goroutine terminará, por lo que lo único que tenemos que hacer en el método <code>Close</code> es cerrar el canal <code>in</code>:</p>
<pre class="code"><code class="go">func (s *writerSubscriber) Close() {
  close(s.in)
}
</code></pre>
<p>OK, solo queda el método <code>Notify</code>; el método <code>Notify</code>
 es un método conveniente para administrar un comportamiento particular
cuando se comunica, y usaremos un patrón que es común en muchas
llamadas:</p>
<pre class="code"><code class="go">func (s *writerSubscriber) Notify(msg interface{}) (err error) {
  defer func(){
    if rec := recover(); rec != nil {
      err = fmt.Errorf("%#v", rec)
    }
  }()

  select {
  case s.in &lt;- msg:
  case &lt;-time.After(time.Second):
    err = fmt.Errorf("Timeout\n")
  }

  return
}
</code></pre>
<p>Al comunicarse con un canal, hay dos comportamientos que generalmente
 debemos controlar: uno es el tiempo de espera y el otro es cuando el
canal está cerrado. La función diferida realmente funciona para
cualquier error de pánico que pueda ocurrir dentro de la función. Si el
Goroutine entra en pánico, todavía ejecutará la función diferida con el
método <code>recover()</code>. El método <code>recover()</code> devuelve
 una interfaz de lo que sea que haya sido el error, por lo que en
nuestro caso, establecemos el error de la variable de respuesta en el
valor formateado devuelto por <code>recover</code>(que es una interfaz). los<q><code>%#v</code></q>parámetro
 nos da la mayoría de la información sobre cualquier tipo cuando se
formatea en una cadena. El error devuelto será feo, pero contendrá la
mayor parte de la información que podemos extraer sobre el error. Para
un canal cerrado, por ejemplo, devolverá "enviar en un canal cerrado".
Bueno, esto parece lo suficientemente claro.</p>
<p>La segunda regla es sobre el tiempo de espera. Cuando enviamos un
valor sobre un canal, seremos bloqueados hasta que otro Goroutine tome
el valor del mismo (ocurrirá lo mismo con un canal amortiguado lleno).
No queremos quedar bloqueados para siempre, así que establecemos un
período de tiempo de espera de un segundo utilizando un controlador de
selección. En resumen, con select estamos diciendo: o tomas el valor en
menos de 1 segundo o lo descartaré y devolveré un error.</p>
<p>Tenemos los <code>Close</code>, <code>Notify</code>, y métodos <code>NewWriterSubscriber</code>, así que puedes probar nuestra prueba de nuevo:</p>
<pre class="srci"><code class="sh"><span class="in"><span class="prompt">&gt; </span>go test -run=TestWriter -v .
</span><span class="out">=== RUN   TestWriter
--- PASS: TestWriter (0.00s)
PASS
ok
</span></code></pre>
<p>Mucho mejor ahora. El <code>Writer</code> ha tomado el escritor
simulacro escribimos en la prueba y ha escrito para que el valor se pasa
 al método de notificación. Al mismo tiempo, cerrar probablemente cerró
el canal de manera efectiva, porque el método <code>Notify</code>
devuelve un error después de llamar al método Close. Una cosa para
mencionar es que no podemos verificar si un canal está cerrado o no sin
interactuar con él; es por eso que tuvimos que diferir la ejecución de
un cierre que verificará el contenido de la función <code>recover()</code> en el método <code>Notify</code>.</p>
</div>
<h4 id="implementing-the-publisher">Implementando el editor</h4>
<div class="hBody-4">
<p>De acuerdo, el editor necesitará también un mecanismo de lanzamiento,
 pero los principales problemas a tratar son las condiciones de carrera
que acceden a la lista de suscriptores. Podemos resolver este problema
con un objeto Mutex del paquete <code>sync</code>, pero ya hemos visto cómo usarlo, así que usaremos canales en su lugar.</p>
<p>Al usar canales, necesitaremos un canal para cada acción que pueda
considerarse peligrosa: agregar un suscriptor, eliminar un suscriptor,
recuperar la lista de suscriptores para <code>Notify</code> configurar
un mensaje para ellos y un canal para detener a todos los suscriptores.
También necesitamos un canal para los mensajes entrantes:</p>
<pre class="code"><code class="go">type publisher struct {
  subscribers []Subscriber
  addSubCh    chan Subscriber
  removeSubCh chan Subscriber
  in          chan interface{}
  stop        chan struct{}
}
</code></pre>
<p>Los nombres son autodescriptivos pero, en resumen, los suscriptores
mantienen la lista de suscriptores; esta es la porción que necesita
acceso multiplexado. La instancia <code>addSubCh</code> es el canal para
 comunicarse cuando desea agregar un nuevo suscriptor; es por eso que es
 un canal de suscriptores. La misma explicación se aplica al canal <code>removeSubCh</code>, pero este canal es para eliminar al suscriptor. El canal <code>in</code>
 manejará los mensajes entrantes que se deben transmitir a todos los
suscriptores. Finalmente, se debe llamar al canal de detención cuando
queremos matar a todos los Goroutines.</p>
<p>OK, vamos a empezar con las <code>AddSubscriberCh</code>, <code>RemoveSubscriber</code>y métodos <code>PublishingCh</code>, que deben regresar al canal para añadir y eliminar suscriptores y el canal para enviar mensajes a todos ellos:</p>
<pre class="code"><code class="go">func (p *publisher) AddSubscriber() {
  return p.addSubCh
}

func (p *publisher) RemoveSubscriberCh() {
  return p.removeSubCh
}
func (p *publisher) PublishMessage(){
  return p.in
}
</code></pre>
<p>La función <code>Stop()</code> para detener el canal cerrándolo. Esto distribuirá la señal de manera efectiva a cada escuchante de Goroutine:</p>
<pre class="code"><code class="go">func (p *publisher) Stop(){
  close(p.stop)
}
</code></pre>
<p>El método <code>Stop</code>, la función para detener al editor y a los suscriptores, también empuja a su canal respectivo, llamado stop.</p>
<p>Es posible que se pregunte por qué no simplemente dejamos los canales
 disponibles para que los usuarios accedan directamente a este canal en
lugar de usar la función de proxy. Bueno, la idea es que el usuario que
integra la biblioteca en su aplicación no tenga que lidiar con la
complejidad de la estructura simultánea asociada con la biblioteca, para
 que pueda enfocarse en su negocio mientras maximiza el rendimiento
tanto como sea posible.</p>
</div>
<h4 id="handling-channels-without-race-conditions">Manejo de canales sin condiciones de carrera</h4>
<div class="hBody-4">
<p>Hasta ahora, hemos reenviado los datos a los canales en el editor,
pero en realidad no hemos manejado ninguno de esos datos. El mecanismo
iniciador que va a lanzar un Goroutine diferente los manejará a todos.</p>
<p>Crearemos un método de lanzamiento que ejecutaremos utilizando la palabra clave <code>go</code> en lugar de incrustar toda la función dentro de la función <code>NewPublisher</code>:</p>
<pre class="code"><code class="go">func (p *publisher) start() {
  for {
    select {
    case msg := &lt;-p.in:
      for _, ch := range p.subscribers {
        sub.Notify(msg)
      }
</code></pre>
<p><code>Launch</code> es un método privado y no lo hemos probado.
Recuerde que los métodos privados generalmente se llaman desde métodos
públicos (los que hemos probado). Generalmente, si no se llama a un
método privado desde un método público, ¡no se puede invocar en
absoluto!</p>
<p>Lo primero que notamos con este método es que se trata de un bucle
for infinito que repetirá una operación de selección entre muchos
canales, pero solo uno de ellos se puede ejecutar cada vez. La primera
de estas operaciones es la que recibe un nuevo mensaje para publicar a
los suscriptores. El código <code>case msg := &lt;- p.in</code>: maneja esta operación entrante.</p>
<p>En este caso, estamos iterando sobre todos los suscriptores y estamos ejecutando su método <code>Notify</code>. Tal vez se pregunte por qué no agregamos la palabra clave <code>go</code> al frente para que el método <code>Notify</code>
 se ejecute como un Goroutine diferente y, por lo tanto, itere mucho más
 rápido. Bueno, esto porque no estamos demultiplexando las acciones de
recibir un mensaje y de cerrar el mensaje. Entonces, si lanzamos el
suscriptor en una nueva <code>Goroutine</code>y se cierra mientras el mensaje se procesa en el método <code>Notify</code>, tendremos una condición de carrera donde un mensaje intentará enviarse dentro del método <code>Notify</code> a un canal cerrado. De hecho, estamos considerando este escenario cuando desarrollamos el<code>Notify</code> método pero, aún así, no controlaremos el número de Goroutines lanzados si llamamos almétodo <code>Notify</code> en un nuevo Goroutine cada vez. Para simplificar, simplemente llamamos almétodo <code>Notify</code>, pero es un buen ejercicio controlar el número de Goroutines que esperan un retorno en la <code>Notify</code> ejecución de un método. Al almacenar el canal <code>in</code> en cada suscriptor, también podemos lograr una buena solución:</p>
<pre class="code"><code class="go">case sub := &lt;-p.addSubCh:
p.subscribers = append(p.subscribers, sub)
</code></pre>
<p>La siguiente operación es qué hacer cuando llega un valor al canal
para agregar suscriptores. En este caso, es simple: lo actualizamos y le
 agregamos el nuevo valor. Mientras se ejecuta este caso, no se pueden
ejecutar otras llamadas en esta selección:</p>
<pre class="code"><code class="go">case sub := &lt;-p.removeSubCh:
for i, candidate := range p.subscribers {
  if candidate == sub {
    p.subscribers = append(p.subscribers[:i], p.subscribers[i+1:]...)
    candidate.Close()
    break
  }
}
</code></pre>
<p>Cuando llega un valor al canal de eliminación, la operación es un poco más
  compleja porque tenemos que buscar el suscriptor en el sector. Utilizamos un
  enfoque <span class="math">O (N)</span> para ello, iterando desde el principio
  hasta que lo encontremos, pero el algoritmo de búsqueda podría mejorarse
  enormemente. Una vez que encontramos la interfaz <code>Subscriber</code>
 correspondiente , la eliminamos del segmento de suscriptores y la
detenimos. Una cosa para mencionar es que en las pruebas, estamos
accediendo a la longitud de la división de suscriptores directamente sin
 demultiplexar la operación. Esto es claramente una condición de
carrera, pero en general, no se refleja cuando se ejecuta el detector de
 carrera.</p>
<p>La solución será desarrollar un método solo para llamadas
multiplexadas para obtener la longitud del segmento, pero no pertenecerá
 a la interfaz pública. Nuevamente, para simplificar, lo dejaremos así, o
 este ejemplo puede volverse demasiado complejo de manejar:</p>
<pre class="code"><code class="go">    case &lt;-p.stop:
      for _, sub := range p.subscribers {
        sub.Close()
      }

      close(p.addSubCh)
      close(p.in)
      close(p.removeSubCh)

      return
    }
  }
}
</code></pre>
<p>La última operación para demultiplexar es la <code>stop</code>
operación, que debe detener a todos los Goroutines en el editor y los
suscriptores. Luego, debemos iterar a través de cada campo <code>Subscriber</code> almacenado en el campo de suscriptores para ejecutar su método <code>Close()</code>, para que sus Goroutines también estén cerrados. Finalmente, si devolvemos este Goroutine, terminará también.</p>
<p>OK, es hora de ejecutar todas las pruebas y ver cómo va:</p>
<pre class="srci"><code class="sh"><span class="in"><span class="prompt">&gt; </span>go test -race .
</span><span class="out">ok
</span></code></pre>
<p>No es tan malo. Todas las pruebas han pasado con éxito y tenemos
nuestro patrón Observer listo. Si bien el ejemplo aún se puede mejorar,
es un gran ejemplo de cómo debemos manejar un patrón Observer usando
canales en Go. Como ejercicio, le recomendamos que pruebe el mismo
ejemplo utilizando mutexes en lugar de canales para controlar el acceso.
 Es un poco más fácil y también le dará una idea de cómo trabajar con
mutexes.</p>
</div>
<h4 id="a-few-words-on-the-concurrent-observer-pattern">Algunas palabras en el patrón Observador concurrente</h4>
<div class="hBody-4">
<p>Este ejemplo ha demostrado cómo aprovechar las CPU multinúcleo para
crear un editor de mensajes simultáneos al implementar el patrón
Observer. Si bien el ejemplo fue largo, hemos intentado mostrar un
patrón común al desarrollar aplicaciones simultáneas en Go.</p>
</div>
<h3 id="summary">Resumen</h3>
<div class="hBody-3">
<p>Hemos visto pocos enfoques para desarrollar estructuras concurrentes
que puedan ejecutarse en paralelo. Hemos tratado de mostrar algunas
formas de resolver el mismo problema, uno sin primitivas de
simultaneidad y otro con ellos. Hemos visto cuán diferente se puede
comparar el ejemplo de publicación / suscriptor escrito con una
estructura concurrente con el clásico.</p>
<p>También hemos visto cómo crear una operación simultánea utilizando
una canalización y la hemos paralelizado utilizando un grupo de
trabajadores, un patrón de Go muy común para maximizar el paralelismo.</p>
<p>Ambos ejemplos fueron lo suficientemente simples como para captar, al
 mismo tiempo que profundizar tanto en la naturaleza del lenguaje Go en
lugar de en el problema en sí.</p>
</div>

</body></html>
