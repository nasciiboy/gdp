<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd" />
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en" >
<head>
  <title>Go Design Patterns</title>
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="author" content="Mario Castro Contreras" />
  <meta name="id" content="isbn-978-1-78646-620-4" />
  <meta name="date" content="02/2017" />
  <link rel="stylesheet" type="text/css" href="worg-data/worg.css" />
</head>

<body>
<div id="toc">
  <p>index</p>
  <div id="toc-contents">
  <ul>
  <li><a class="h2" href="#about-the-author" >About the Author</a></li>
  <li><a class="h2" href="#about-the-reviewer" >About the Reviewer</a></li>
  <li><a class="h2" href="#preface" >Preface</a></li>
    <ul>
    <li><a class="h3" href="#what-this-book-covers" >What this book covers</a></li>
    <li><a class="h3" href="#what-you-need-for-this-book" >What you need for this book</a></li>
    <li><a class="h3" href="#who-this-book-is-for" >Who this book is for</a></li>
      <ul>
      <li><a class="h4" href="#downloading-the-example-code" >Downloading the example code</a></li>
      <li><a class="h4" href="#errata" >Errata</a></li>
      <li><a class="h4" href="#questions" >Questions</a></li>
      </ul>
    </ul>
  <li><a class="h2" href="#chapter-1" >Ready... Steady... Go!</a></li>
    <ul>
    <li><a class="h3" href="#a-little-bit-of-history" >A little bit of history</a></li>
    <li><a class="h3" href="#installing-go" >Installing Go</a></li>
      <ul>
      <li><a class="h4" href="#linux" >Linux</a></li>
        <ul>
        <li><a class="h5" href="#go-linux-advanced-installation" >Go Linux advanced installation</a></li>
        </ul>
      <li><a class="h4" href="#windows" >Windows</a></li>
      <li><a class="h4" href="#mac-os-x" >Mac OS X</a></li>
      <li><a class="h4" href="#setting-the-workspace---linux-and-apple-os-x" >Setting the workspace - Linux and Apple OS X</a></li>
      </ul>
    <li><a class="h3" href="#starting-with-hello-world" >Starting with Hello World</a></li>
    <li><a class="h3" href="#integrated-development-environment---ide" >Integrated Development Environment - IDE</a></li>
    <li><a class="h3" href="#types" >Types</a></li>
    <li><a class="h3" href="#variables-and-constants" >Variables and constants</a></li>
    <li><a class="h3" href="#operators" >Operators</a></li>
    <li><a class="h3" href="#flow-control" >Flow control</a></li>
      <ul>
      <li><a class="h4" href="#the-if...-else-statement" >The if... else statement</a></li>
      <li><a class="h4" href="#the-switch-statement" >The switch statement</a></li>
      <li><a class="h4" href="#the-for…range-statement" >The for…range statement</a></li>
      </ul>
    <li><a class="h3" href="#functions" >Functions</a></li>
      <ul>
      <li><a class="h4" href="#what-does-a-function-look-like?" >What does a function look like?</a></li>
      <li><a class="h4" href="#what-is-an-anonymous-function?" >What is an anonymous function?</a></li>
      <li><a class="h4" href="#closures" >Closures</a></li>
      <li><a class="h4" href="#creating-errors,-handling-errors-and-returning-errors." >Creating errors, handling errors and returning errors.</a></li>
      <li><a class="h4" href="#function-with-undetermined-number-of-parameters" >Function with undetermined number of parameters</a></li>
        <ul>
        <li><a class="h5" href="#naming-returned-types" >Naming returned types</a></li>
        </ul>
      </ul>
    <li><a class="h3" href="#arrays,-slices,-and-maps" >Arrays, slices, and maps</a></li>
      <ul>
      <li><a class="h4" href="#arrays" >Arrays</a></li>
        <ul>
        <li><a class="h5" href="#zero-initialization" >Zero-initialization</a></li>
        </ul>
      <li><a class="h4" href="#slices" >Slices</a></li>
      <li><a class="h4" href="#maps" >Maps</a></li>
      </ul>
    <li><a class="h3" href="#visibility" >Visibility</a></li>
    <li><a class="h3" href="#zero-initialization" >Zero-initialization</a></li>
    <li><a class="h3" href="#pointers-and-structures" >Pointers and structures</a></li>
      <ul>
      <li><a class="h4" href="#what-is-a-pointer?-why-are-they-good?" >What is a pointer? Why are they good?</a></li>
      <li><a class="h4" href="#structs" >Structs</a></li>
      </ul>
    <li><a class="h3" href="#interfaces" >Interfaces</a></li>
      <ul>
      <li><a class="h4" href="#interfaces---signing-a-contract" >Interfaces - signing a contract</a></li>
      </ul>
    <li><a class="h3" href="#testing-and-tdd" >Testing and TDD</a></li>
      <ul>
      <li><a class="h4" href="#the-testing-package" >The testing package</a></li>
      <li><a class="h4" href="#what-is-tdd?" >What is TDD?</a></li>
      </ul>
    <li><a class="h3" href="#libraries" >Libraries</a></li>
    <li><a class="h3" href="#the-go-get-tool" >The Go get tool</a></li>
    <li><a class="h3" href="#managing-json-data" >Managing JSON data</a></li>
      <ul>
      <li><a class="h4" href="#the-encoding-package" >The encoding package</a></li>
      </ul>
    <li><a class="h3" href="#go-tools" >Go tools</a></li>
      <ul>
      <li><a class="h4" href="#the-golint-tool" >The golint tool</a></li>
      <li><a class="h4" href="#the-gofmt-tool" >the gofmt tool</a></li>
      <li><a class="h4" href="#the-godoc-tool" >The godoc tool</a></li>
      <li><a class="h4" href="#the-goimport-tool" >The goimport tool</a></li>
      </ul>
    <li><a class="h3" href="#contributing-to-go-open-source-projects-in-github" >Contributing to Go open source projects in GitHub</a></li>
    <li><a class="h3" href="#summary" >Summary</a></li>
    </ul>
  <li><a class="h2" href="#chapter-2" >Creational Patterns - Singleton, Builder, Factory, Prototype, and Abstract Factory Design Patterns</a></li>
    <ul>
    <li><a class="h3" href="#singleton-design-pattern---having-a-unique-instance-of-a-type-in-the-entire-program" >Singleton design pattern - having a unique instance of a type in the entire program</a></li>
      <ul>
      <li><a class="h4" href="#description" >Description</a></li>
      <li><a class="h4" href="#objectives" >Objectives</a></li>
      <li><a class="h4" href="#example---a-unique-counter" >Example - a unique counter</a></li>
      <li><a class="h4" href="#requirements-and-acceptance-criteria" >Requirements and acceptance criteria</a></li>
      <li><a class="h4" href="#writing-unit-tests-first" >Writing unit tests first</a></li>
      <li><a class="h4" href="#implementation" >Implementation</a></li>
      <li><a class="h4" href="#a-few-words-about-the-singleton-design-pattern" >A few words about the Singleton design pattern</a></li>
      </ul>
    <li><a class="h3" href="#builder-design-pattern---reusing-an-algorithm-to-create-many-implementations-of-an-interface" >Builder design pattern - reusing an algorithm to create many implementations of an interface</a></li>
      <ul>
      <li><a class="h4" href="#description" >Description</a></li>
      <li><a class="h4" href="#objectives" >Objectives</a></li>
      <li><a class="h4" href="#example---vehicle-manufacturing" >Example - vehicle manufacturing</a></li>
      <li><a class="h4" href="#requirements-and-acceptance-criteria" >Requirements and acceptance criteria</a></li>
      <li><a class="h4" href="#unit-test-for-the-vehicle-builder" >Unit test for the vehicle builder</a></li>
      <li><a class="h4" href="#implementation" >Implementation</a></li>
      <li><a class="h4" href="#wrapping-up-the-builder-design-pattern" >Wrapping up the Builder design pattern</a></li>
      </ul>
    <li><a class="h3" href="#factory-method---delegating-the-creation-of-different-types-of-payments" >Factory method - delegating the creation of different types of payments</a></li>
      <ul>
      <li><a class="h4" href="#description" >Description</a></li>
      <li><a class="h4" href="#objectives" >Objectives</a></li>
      <li><a class="h4" href="#the-example---a-factory-of-payment-methods-for-a-shop" >The example - a factory of payment methods for a shop</a></li>
      <li><a class="h4" href="#acceptance-criteria" >Acceptance criteria</a></li>
      <li><a class="h4" href="#first-unit-test" >First unit test</a></li>
      <li><a class="h4" href="#implementation" >Implementation</a></li>
      <li><a class="h4" href="#upgrading-the-debitcard-method-to-a-new-platform" >Upgrading the Debitcard method to a new platform</a></li>
      <li><a class="h4" href="#what-we-learned-about-the-factory-method" >What we learned about the Factory method</a></li>
      </ul>
    <li><a class="h3" href="#abstract-factory---a-factory-of-factories" >Abstract Factory - a factory of factories</a></li>
      <ul>
      <li><a class="h4" href="#description" >Description</a></li>
      <li><a class="h4" href="#the-objectives" >The objectives</a></li>
      <li><a class="h4" href="#the-vehicle-factory-example,-again?" >The vehicle factory example, again?</a></li>
      <li><a class="h4" href="#acceptance-criteria" >Acceptance criteria</a></li>
      <li><a class="h4" href="#unit-test" >Unit test</a></li>
      <li><a class="h4" href="#implementation" >Implementation</a></li>
      <li><a class="h4" href="#a-few-lines-about-the-abstract-factory-method" >A few lines about the Abstract Factory method</a></li>
      </ul>
    <li><a class="h3" href="#prototype-design-pattern" >Prototype design pattern</a></li>
      <ul>
      <li><a class="h4" href="#description" >Description</a></li>
      <li><a class="h4" href="#objective" >Objective</a></li>
      <li><a class="h4" href="#example" >Example</a></li>
      <li><a class="h4" href="#acceptance-criteria" >Acceptance criteria</a></li>
      <li><a class="h4" href="#unit-test" >Unit test</a></li>
      <li><a class="h4" href="#implementation" >Implementation</a></li>
      <li><a class="h4" href="#what-we-learned-about-the-prototype-design-pattern" >What we learned about the Prototype design pattern</a></li>
      </ul>
    <li><a class="h3" href="#summary" >Summary</a></li>
    </ul>
  <li><a class="h2" href="#chapter-3" >Structural Patterns - Composite, Adapter, and Bridge Design Patterns</a></li>
    <ul>
    <li><a class="h3" href="#composite-design-pattern" >Composite design pattern</a></li>
      <ul>
      <li><a class="h4" href="#description" >Description</a></li>
      <li><a class="h4" href="#objectives" >Objectives</a></li>
      <li><a class="h4" href="#the-swimmer-and-the-fish" >The swimmer and the fish</a></li>
      <li><a class="h4" href="#requirements-and-acceptance-criteria" >Requirements and acceptance criteria</a></li>
      <li><a class="h4" href="#creating-compositions" >Creating compositions</a></li>
      <li><a class="h4" href="#binary-tree-compositions" >Binary Tree compositions</a></li>
      <li><a class="h4" href="#composite-pattern-versus-inheritance" >Composite pattern versus inheritance</a></li>
      <li><a class="h4" href="#final-words-on-the-composite-pattern" >Final words on the Composite pattern</a></li>
      </ul>
    <li><a class="h3" href="#adapter-design-pattern" >Adapter design pattern</a></li>
      <ul>
      <li><a class="h4" href="#description" >Description</a></li>
      <li><a class="h4" href="#objectives" >Objectives</a></li>
      <li><a class="h4" href="#using-an-incompatible-interface-with-an-adapter-object" >Using an incompatible interface with an Adapter object</a></li>
      <li><a class="h4" href="#requirements-and-acceptance-criteria" >Requirements and acceptance criteria</a></li>
      <li><a class="h4" href="#unit-testing-our-printer-adapter" >Unit testing our Printer adapter</a></li>
      <li><a class="h4" href="#implementation" >Implementation</a></li>
      <li><a class="h4" href="#examples-of-the-adapter-pattern-in-go&#39;s-source-code" >Examples of the Adapter pattern in Go&#39;s source code</a></li>
      <li><a class="h4" href="#what-the-go-source-code-tells-us-about-the-adapter-pattern" >What the Go source code tells us about the Adapter pattern</a></li>
      </ul>
    <li><a class="h3" href="#bridge-design-pattern" >Bridge design pattern</a></li>
      <ul>
      <li><a class="h4" href="#description" >Description</a></li>
      <li><a class="h4" href="#objectives" >Objectives</a></li>
      <li><a class="h4" href="#two-printers-and-two-ways-of-printing-for-each" >Two printers and two ways of printing for each</a></li>
      <li><a class="h4" href="#requirements-and-acceptance-criteria" >Requirements and acceptance criteria</a></li>
      <li><a class="h4" href="#unit-testing-the-bridge-pattern" >Unit testing the Bridge pattern</a></li>
      <li><a class="h4" href="#implementation" >Implementation</a></li>
      <li><a class="h4" href="#reuse-everything-with-the-bridge-pattern" >Reuse everything with the Bridge pattern</a></li>
      </ul>
    <li><a class="h3" href="#summary" >Summary</a></li>
    </ul>
  <li><a class="h2" href="#chapter-4" >Structural Patterns - Proxy, Facade, Decorator, and Flyweight Design Patterns</a></li>
    <ul>
    <li><a class="h3" href="#proxy-design-pattern" >Proxy design pattern</a></li>
      <ul>
      <li><a class="h4" href="#description" >Description</a></li>
      <li><a class="h4" href="#objectives" >Objectives</a></li>
      <li><a class="h4" href="#example" >Example</a></li>
      <li><a class="h4" href="#acceptance-criteria" >Acceptance criteria</a></li>
      <li><a class="h4" href="#unit-test" >Unit test</a></li>
      <li><a class="h4" href="#implementation" >Implementation</a></li>
      <li><a class="h4" href="#proxying-around-actions" >Proxying around actions</a></li>
      </ul>
    <li><a class="h3" href="#decorator-design-pattern" >Decorator design pattern</a></li>
      <ul>
      <li><a class="h4" href="#description" >Description</a></li>
      <li><a class="h4" href="#objectives" >Objectives</a></li>
      <li><a class="h4" href="#example" >Example</a></li>
      <li><a class="h4" href="#acceptance-criteria" >Acceptance criteria</a></li>
      <li><a class="h4" href="#unit-test" >Unit test</a></li>
      <li><a class="h4" href="#implementation" >Implementation</a></li>
      <li><a class="h4" href="#a-real-life-example---server-middleware" >A real-life example - server middleware</a></li>
        <ul>
        <li><a class="h5" href="#starting-with-the-common-interface,-http.handler" >Starting with the common interface, http.Handler</a></li>
        </ul>
      <li><a class="h4" href="#a-few-words-about-go&#39;s-structural-typing" >A few words about Go&#39;s structural typing</a></li>
      <li><a class="h4" href="#summarizing-the-decorator-design-pattern---proxy-versus-decorator" >Summarizing the Decorator design pattern - Proxy versus Decorator</a></li>
      </ul>
    <li><a class="h3" href="#facade-design-pattern" >Facade design pattern</a></li>
      <ul>
      <li><a class="h4" href="#description" >Description</a></li>
      <li><a class="h4" href="#objectives" >Objectives</a></li>
      <li><a class="h4" href="#example" >Example</a></li>
      <li><a class="h4" href="#acceptance-criteria" >Acceptance criteria</a></li>
      <li><a class="h4" href="#unit-test" >Unit test</a></li>
      <li><a class="h4" href="#implementation" >Implementation</a></li>
      <li><a class="h4" href="#library-created-with-the-facade-pattern" >Library created with the Facade pattern</a></li>
      </ul>
    <li><a class="h3" href="#flyweight-design-pattern" >Flyweight design pattern</a></li>
      <ul>
      <li><a class="h4" href="#description" >Description</a></li>
      <li><a class="h4" href="#objectives" >Objectives</a></li>
      <li><a class="h4" href="#example" >Example</a></li>
      <li><a class="h4" href="#acceptance-criteria" >Acceptance criteria</a></li>
      <li><a class="h4" href="#basic-structs-and-tests" >Basic structs and tests</a></li>
      <li><a class="h4" href="#implementation" >Implementation</a></li>
      <li><a class="h4" href="#what&#39;s-the-difference-between-singleton-and-flyweight-then?" >What&#39;s the difference between Singleton and Flyweight then?</a></li>
      </ul>
    <li><a class="h3" href="#summary" >Summary</a></li>
    </ul>
  <li><a class="h2" href="#chapter-5" >Behavioral Patterns - Strategy, Chain of Responsibility, and Command Design Patterns</a></li>
    <ul>
    <li><a class="h3" href="#strategy-design-pattern" >Strategy design pattern</a></li>
      <ul>
      <li><a class="h4" href="#description" >Description</a></li>
      <li><a class="h4" href="#objectives" >Objectives</a></li>
      <li><a class="h4" href="#rendering-images-or-text" >Rendering images or text</a></li>
      <li><a class="h4" href="#acceptance-criteria" >Acceptance criteria</a></li>
      <li><a class="h4" href="#implementation" >Implementation</a></li>
      <li><a class="h4" href="#solving-small-issues-in-our-library" >Solving small issues in our library</a></li>
      <li><a class="h4" href="#final-words-on-the-strategy-pattern" >Final words on the Strategy pattern</a></li>
      </ul>
    <li><a class="h3" href="#chain-of-responsibility-design-pattern" >Chain of responsibility design pattern</a></li>
      <ul>
      <li><a class="h4" href="#description" >Description</a></li>
      <li><a class="h4" href="#objectives" >Objectives</a></li>
      <li><a class="h4" href="#a-multi-logger-chain" >A multi-logger chain</a></li>
      <li><a class="h4" href="#unit-test" >Unit test</a></li>
      <li><a class="h4" href="#implementation" >Implementation</a></li>
      <li><a class="h4" href="#what-about-a-closure?" >What about a closure?</a></li>
      <li><a class="h4" href="#putting-it-together" >Putting it together</a></li>
      </ul>
    <li><a class="h3" href="#command-design-pattern" >Command design pattern</a></li>
      <ul>
      <li><a class="h4" href="#description" >Description</a></li>
      <li><a class="h4" href="#objectives" >Objectives</a></li>
      <li><a class="h4" href="#a-simple-queue" >A simple queue</a></li>
      <li><a class="h4" href="#acceptance-criteria" >Acceptance criteria</a></li>
      <li><a class="h4" href="#implementation" >Implementation</a></li>
      <li><a class="h4" href="#more-examples" >More examples</a></li>
      <li><a class="h4" href="#chain-of-responsibility-of-commands" >Chain of responsibility of commands</a></li>
      <li><a class="h4" href="#rounding-up-the-command-pattern-up" >Rounding-up the Command pattern up</a></li>
      </ul>
    <li><a class="h3" href="#summary" >Summary</a></li>
    </ul>
  <li><a class="h2" href="#chapter-6" >Behavioral Patterns - Template, Memento, and Interpreter Design Patterns</a></li>
    <ul>
    <li><a class="h3" href="#template-design-pattern" >Template design pattern</a></li>
      <ul>
      <li><a class="h4" href="#description" >Description</a></li>
      <li><a class="h4" href="#objectives" >Objectives</a></li>
      <li><a class="h4" href="#example---a-simple-algorithm-with-a-deferred-step" >Example - a simple algorithm with a deferred step</a></li>
      <li><a class="h4" href="#requirements-and-acceptance-criteria" >Requirements and acceptance criteria</a></li>
      <li><a class="h4" href="#unit-tests-for-the-simple-algorithm" >Unit tests for the simple algorithm</a></li>
      <li><a class="h4" href="#implementing-the-template-pattern" >Implementing the Template pattern</a></li>
      <li><a class="h4" href="#anonymous-functions" >Anonymous functions</a></li>
      <li><a class="h4" href="#how-to-avoid-modifications-on-the-interface" >How to avoid modifications on the interface</a></li>
      <li><a class="h4" href="#looking-for-the-template-pattern-in-go&#39;s-source-code" >Looking for the Template pattern in Go&#39;s source code</a></li>
      <li><a class="h4" href="#summarizing-the-template-design-pattern" >Summarizing the Template design pattern</a></li>
      </ul>
    <li><a class="h3" href="#memento-design-pattern" >Memento design pattern</a></li>
      <ul>
      <li><a class="h4" href="#description" >Description</a></li>
      <li><a class="h4" href="#objectives" >Objectives</a></li>
      <li><a class="h4" href="#a-simple-example-with-strings" >A simple example with strings</a></li>
      <li><a class="h4" href="#requirements-and-acceptance-criteria" >Requirements and acceptance criteria</a></li>
      <li><a class="h4" href="#unit-test" >Unit test</a></li>
      <li><a class="h4" href="#implementing-the-memento-pattern" >Implementing the Memento pattern</a></li>
      <li><a class="h4" href="#another-example-using-the-command-and-facade-patterns" >Another example using the Command and Facade patterns</a></li>
      <li><a class="h4" href="#last-words-on-the-memento-pattern" >Last words on the Memento pattern</a></li>
      </ul>
    <li><a class="h3" href="#interpreter-design-pattern" >Interpreter design pattern</a></li>
      <ul>
      <li><a class="h4" href="#description" >Description</a></li>
      <li><a class="h4" href="#objectives" >Objectives</a></li>
      <li><a class="h4" href="#example---a-polish-notation-calculator" >Example - a polish notation calculator</a></li>
      <li><a class="h4" href="#acceptance-criteria-for-the-calculator" >Acceptance criteria for the calculator</a></li>
      <li><a class="h4" href="#unit-test-of-some-operations" >Unit test of some operations</a></li>
      <li><a class="h4" href="#implementation" >Implementation</a></li>
      <li><a class="h4" href="#complexity-with-the-interpreter-design-pattern" >Complexity with the Interpreter design pattern</a></li>
      <li><a class="h4" href="#interpreter-pattern-again---now-using-interfaces" >Interpreter pattern again - now using interfaces</a></li>
      <li><a class="h4" href="#the-power-of-the-interpreter-pattern" >The power of the Interpreter pattern</a></li>
      </ul>
    <li><a class="h3" href="#summary" >Summary</a></li>
    </ul>
  <li><a class="h2" href="#chapter-7" >Behavioral Patterns - Visitor, State, Mediator, and Observer Design Patterns</a></li>
    <ul>
    <li><a class="h3" href="#visitor-design-pattern" >Visitor design pattern</a></li>
      <ul>
      <li><a class="h4" href="#description" >Description</a></li>
      <li><a class="h4" href="#objectives" >Objectives</a></li>
      <li><a class="h4" href="#a-log-appender" >A log appender</a></li>
      <li><a class="h4" href="#acceptance-criteria" >Acceptance criteria</a></li>
      <li><a class="h4" href="#unit-tests" >Unit tests</a></li>
      <li><a class="h4" href="#implementation-of-visitor-pattern" >Implementation of Visitor pattern</a></li>
      <li><a class="h4" href="#another-example" >Another example</a></li>
      <li><a class="h4" href="#visitors-to-the-rescue!" >Visitors to the rescue!</a></li>
      </ul>
    <li><a class="h3" href="#state-design-pattern" >State design pattern</a></li>
      <ul>
      <li><a class="h4" href="#description" >Description</a></li>
      <li><a class="h4" href="#objectives" >Objectives</a></li>
      <li><a class="h4" href="#a-small-guess-the-number-game" >A small guess the number game</a></li>
      <li><a class="h4" href="#acceptance-criteria" >Acceptance criteria</a></li>
      <li><a class="h4" href="#implementation-of-state-pattern" >Implementation of State pattern</a></li>
      <li><a class="h4" href="#a-state-to-win-and-a-state-to-lose" >A state to win and a state to lose</a></li>
      <li><a class="h4" href="#the-game-built-using-the-state-pattern" >The game built using the State pattern</a></li>
      </ul>
    <li><a class="h3" href="#mediator-design-pattern" >Mediator design pattern</a></li>
      <ul>
      <li><a class="h4" href="#description" >Description</a></li>
      <li><a class="h4" href="#objectives" >Objectives</a></li>
      <li><a class="h4" href="#a-calculator" >A calculator</a></li>
      <li><a class="h4" href="#acceptance-criteria" >Acceptance criteria</a></li>
      <li><a class="h4" href="#implementation" >Implementation</a></li>
      <li><a class="h4" href="#uncoupling-two-types-with-the-mediator" >Uncoupling two types with the Mediator</a></li>
      </ul>
    <li><a class="h3" href="#observer-design-pattern" >Observer design pattern</a></li>
      <ul>
      <li><a class="h4" href="#description" >Description</a></li>
      <li><a class="h4" href="#objectives" >Objectives</a></li>
      <li><a class="h4" href="#the-notifier" >The notifier</a></li>
      <li><a class="h4" href="#acceptance-criteria" >Acceptance criteria</a></li>
      <li><a class="h4" href="#unit-tests" >Unit tests</a></li>
      <li><a class="h4" href="#implementation" >Implementation</a></li>
      <li><a class="h4" href="#summary" >Summary</a></li>
      </ul>
    </ul>
  <li><a class="h2" href="#chapter-8" >Introduction to Gos Concurrency</a></li>
    <ul>
    <li><a class="h3" href="#a-little-bit-of-history-and-theory" >A little bit of history and theory</a></li>
      <ul>
      <li><a class="h4" href="#concurrency-versus-parallelism" >Concurrency versus parallelism</a></li>
      <li><a class="h4" href="#csp-versus-actor-based-concurrency" >CSP versus actor-based concurrency</a></li>
      </ul>
    <li><a class="h3" href="#goroutines" >Goroutines</a></li>
      <ul>
      <li><a class="h4" href="#our-first-goroutine" >Our first Goroutine</a></li>
      <li><a class="h4" href="#anonymous-functions-launched-as-new-goroutines" >Anonymous functions launched as new Goroutines</a></li>
      <li><a class="h4" href="#waitgroups" >WaitGroups</a></li>
      </ul>
    <li><a class="h3" href="#callbacks" >Callbacks</a></li>
      <ul>
      <li><a class="h4" href="#callback-hell" >Callback hell</a></li>
      </ul>
    <li><a class="h3" href="#mutexes" >Mutexes</a></li>
      <ul>
      <li><a class="h4" href="#an-example-with-mutexes---concurrent-counter" >An example with mutexes - concurrent counter</a></li>
      <li><a class="h4" href="#presenting-the-race-detector" >Presenting the race detector</a></li>
      </ul>
    <li><a class="h3" href="#channels" >Channels</a></li>
      <ul>
      <li><a class="h4" href="#our-first-channel" >Our first channel</a></li>
      <li><a class="h4" href="#buffered-channels" >Buffered channels</a></li>
      <li><a class="h4" href="#directional-channels" >Directional channels</a></li>
      <li><a class="h4" href="#the-select-statement" >The select statement</a></li>
      <li><a class="h4" href="#ranging-over-channels-too!" >Ranging over channels too!</a></li>
      </ul>
    <li><a class="h3" href="#using-it-all---concurrent-singleton" >Using it all - concurrent singleton</a></li>
      <ul>
      <li><a class="h4" href="#unit-test" >Unit test</a></li>
      <li><a class="h4" href="#implementation" >Implementation</a></li>
      </ul>
    <li><a class="h3" href="#summary" >Summary</a></li>
    </ul>
  <li><a class="h2" href="#chapter-9" >Concurrency Patterns - Barrier, Future, and Pipeline Design Patterns</a></li>
    <ul>
    <li><a class="h3" href="#barrier-concurrency-pattern" >Barrier concurrency pattern</a></li>
      <ul>
      <li><a class="h4" href="#description" >Description</a></li>
      <li><a class="h4" href="#objectives" >Objectives</a></li>
      <li><a class="h4" href="#an-http-get-aggregator" >An HTTP GET aggregator</a></li>
      <li><a class="h4" href="#acceptance-criteria" >Acceptance criteria</a></li>
      <li><a class="h4" href="#unit-test---integration" >Unit test - integration</a></li>
      <li><a class="h4" href="#implementation" >Implementation</a></li>
      <li><a class="h4" href="#waiting-for-responses-with-the-barrier-design-pattern" >Waiting for responses with the Barrier design pattern</a></li>
      </ul>
    <li><a class="h3" href="#future-design-pattern" >Future design pattern</a></li>
      <ul>
      <li><a class="h4" href="#description" >Description</a></li>
      <li><a class="h4" href="#objectives" >Objectives</a></li>
      <li><a class="h4" href="#a-simple-asynchronous-requester" >A simple asynchronous requester</a></li>
      <li><a class="h4" href="#acceptance-criteria" >Acceptance criteria</a></li>
      <li><a class="h4" href="#unit-tests" >Unit tests</a></li>
      <li><a class="h4" href="#implementation" >Implementation</a></li>
      <li><a class="h4" href="#putting-the-future-together" >Putting the Future together</a></li>
      </ul>
    <li><a class="h3" href="#pipeline-design-pattern" >Pipeline design pattern</a></li>
      <ul>
      <li><a class="h4" href="#description" >Description</a></li>
      <li><a class="h4" href="#objectives" >Objectives</a></li>
      <li><a class="h4" href="#a-concurrent-multi-operation" >A concurrent multi-operation</a></li>
      <li><a class="h4" href="#acceptance-criteria" >Acceptance criteria</a></li>
      <li><a class="h4" href="#beginning-with-tests" >Beginning with tests</a></li>
      <li><a class="h4" href="#implementation" >Implementation</a></li>
        <ul>
        <li><a class="h5" href="#the-list-generator" >The list generator</a></li>
        <li><a class="h5" href="#raising-numbers-to-the-power-of-2" >Raising numbers to the power of 2</a></li>
        <li><a class="h5" href="#final-reduce-operation" >Final reduce operation</a></li>
        <li><a class="h5" href="#launching-the-pipeline-pattern" >Launching the Pipeline pattern</a></li>
        </ul>
      <li><a class="h4" href="#final-words-on-the-pipeline-pattern" >Final words on the Pipeline pattern</a></li>
      </ul>
    <li><a class="h3" href="#summary" >Summary</a></li>
    </ul>
  <li><a class="h2" href="#chapter-10" >Concurrency Patterns - Workers Pool and Publish/Subscriber Design Patterns</a></li>
    <ul>
    <li><a class="h3" href="#workers-pool" >Workers pool</a></li>
      <ul>
      <li><a class="h4" href="#description" >Description</a></li>
      <li><a class="h4" href="#objectives" >Objectives</a></li>
      <li><a class="h4" href="#a-pool-of-pipelines" >A pool of pipelines</a></li>
      <li><a class="h4" href="#acceptance-criteria" >Acceptance criteria</a></li>
      <li><a class="h4" href="#implementation" >Implementation</a></li>
        <ul>
        <li><a class="h5" href="#the-dispatcher" >The dispatcher</a></li>
        <li><a class="h5" href="#the-pipeline" >The pipeline</a></li>
        </ul>
      <li><a class="h4" href="#an-app-using-the-workers-pool" >An app using the workers pool</a></li>
      <li><a class="h4" href="#no-tests?" >No tests?</a></li>
      <li><a class="h4" href="#wrapping-up-the-worker-pool" >Wrapping up the Worker pool</a></li>
      </ul>
    <li><a class="h3" href="#concurrent-publish/subscriber-design-pattern" >Concurrent Publish/Subscriber design pattern</a></li>
      <ul>
      <li><a class="h4" href="#description" >Description</a></li>
      <li><a class="h4" href="#objectives" >Objectives</a></li>
      <li><a class="h4" href="#example---a-concurrent-notifier" >Example - a concurrent notifier</a></li>
      <li><a class="h4" href="#acceptance-criteria" >Acceptance criteria</a></li>
      <li><a class="h4" href="#unit-test" >Unit test</a></li>
        <ul>
        <li><a class="h5" href="#testing-subscriber" >Testing subscriber</a></li>
        <li><a class="h5" href="#testing-publisher" >Testing publisher</a></li>
        </ul>
      <li><a class="h4" href="#implementation" >Implementation</a></li>
        <ul>
        <li><a class="h5" href="#implementing-the-publisher" >Implementing the publisher</a></li>
        <li><a class="h5" href="#handling-channels-without-race-conditions" >Handling channels without race conditions</a></li>
        </ul>
      <li><a class="h4" href="#a-few-words-on-the-concurrent-observer-pattern" >A few words on the concurrent Observer pattern</a></li>
      </ul>
    <li><a class="h3" href="#summary" >Summary</a></li>
    </ul>
  </ul>
  </div>
</div>

<h1>Go Design Patterns</h1>
<h2 id="about-the-author" >About the Author</h2>
<div class="hBody-2" >
<p><b>Mario Castro Contreras</b> is a software engineer who has specialized in distributed systems and big data solutions. He works as a site reliability engineer, and now he is focused on containerized solutions and apps using most of Google Cloud suite; especially, Kubernetes. He has a wide experience in systems and solutions integration, and he has written many scalable and reliable 12 factor apps using Go and Docker. He has designed Big Data  architectures for financial services and media, and he has written data processing pipelines using event-driven architectures written purely in Go. He is also very active in the open source community, and you can find him on his GitHub account with the username <i>sayden</i>.  In the past, he has also written mobile applications and backends in Java.</p>
<p>Mario is passionate about programming languages, and he found the best balance between fun and productivity in Go; however, recently, he enjoys writing in Rust and embedded systems in C. He is also passionate about road cycling and winter sports.</p>
<blockquote>
<p>I&#39;d like to express my deep gratitude to my parents for supporting me in my journey through computers since I was 8. To Urszula, Tyrion and Tesla for their daily support and for being with me in the long nights writing this book.</p>
<p>I&#39;d like to thank Chaitanya, for her guidance at the beginning of the book, Zeeyan, for his patience and help on every chapter, and Pavan, for the help and explanations. But also to all the reviewers, especially to Shiju, and the entire team at Packt that made this book possible.</p>
</blockquote>
</div>
<h2 id="about-the-reviewer" >About the Reviewer</h2>
<div class="hBody-2" >
<p><b>Shiju Varghese</b> is a solutions architect focused on building highly scalable cloud native applications with a special interest in APIs, microservices, containerized architectures, and distributed systems. He currently specializes in Go, Google Cloud, and container technologies. He is an early adopter of the Go programming language and provides consultation and training for building backend systems and microservices with Go ecosystem. He has been a mentor to various start-ups and enterprises for the technology transformation to Go. He has been a speaker at numerous technology conferences, including GopherCon India.</p>
<p>Shiju has authored two books on Go, titled <i>Web Development with Go</i> and Go <i>Recipes</i>, both published by Apress.</p>
</div>
<h2 id="preface" >Preface</h2>
<div class="hBody-2" >
<p>Welcome to the book <i>Go Design Patterns</i>! With this book, you&#39;ll learn basic and advanced techniques and patterns with the Go language. Don&#39;t worry if you have never written Go code before; this book will gradually introduce you to the various concepts in Go programming. At the same time, experts will find many tips and tricks on the language, so I encourage you to not miss any chapter. If you already know the classic design patterns, you&#39;ll find this book very handy, not only as a reference book but also as a way to learn idiomatic Go approaches to solve common problems that you may already know. The book is divided in three sections:</p>
<p>Introduction to the Go language: This is the first part of the book, where you&#39;ll learn the basic syntax, the tools that comes with the binary distributions, basic testing, JSON parsing, and more. We leave concurrency for a later chapter to focus on the way that the syntax and the compiler work in a typical Go app.</p>
<p>Classic design patterns in idiomatic Go: The second section presents the classic design patterns but as we will see, they are quite different, partly because of the lack of inheritance in Go, but also because we have different and more optimal ways to solve the same problems. A newcomer to the language will find the examples in this section very useful as a way to understand the roots of Go and the idiomatic ways in which you can solve problems using Go in the same manner as you would solve in languages such as Java or C++.</p>
<p>Most examples are presented by using TDD and some of them even show examples within Go standard library that uses these patterns. Concurrency patterns: The focus in this section is learning about concurrent structures and parallel execution. You will learn most of the primitives in Go to write concurrent apps, and we will develop some of the classical design patterns with concurrent structures to maximize parallelism. Also, we will learn some of the typical structures to develop concurrent apps in Go. You learn how a classical pattern can become more complex if we need it to work in a concurrent way but the idea is to understand Go concurrent primitives so that the reader finishes the book knowing how to write their own concurrent design patterns by using the knowledge taken from the book.</p>
<p>The book will slowly raise the difficulty of some tasks. We have explained tips and tricks in every chapter.</p>
</div>
<h3 id="what-this-book-covers" >What this book covers</h3>
<div class="hBody-3" >
<p><a href="#chapter-1" >Chapter 1</a>, <i>Ready… Steady…Go!</i>, attempts to help newcomers to the Go programming language who have some background in any other programming language. It will begin by showing how to install the Go environment in a Linux machine, moving to syntax, type and flow control.</p>
<p><a href="#chapter-2" >Chapter 2</a>, <i>Creational Patterns - Singleton, Builder, Factory, Prototype, and Abstract Factory Design Patterns</i>, introduces the problems that can arise when an object creation or management is particularly complex or expensive using the Singleton, Builder, Factory, and Abstract Factory design patterns.</p>
<p><a href="#chapter-3" >Chapter 3</a>, <i>Structural Patterns - Composite, Adapter, and Bridge Design Patterns</i>, deals with the first set of Structural patterns about object composition to get some new functionality. Such as creating an intermediate object and using of various objects as if there is only one.</p>
<p><a href="#chapter-4" >Chapter 4</a>, <i>Structural Patterns - Proxy, Facade, Decorator, and Flyweight Design Patterns</i>, is less oriented to multi-object composition but focuses more on obtaining new functionality in existing objects. The Decorator pattern is commonly used to follow the open-closed principle. Facade is extensively used in API’s where you want a single source for many sources of information and actions. Flyweight is not so common but it’s a very useful pattern when the memory is becoming a problem caused by a large collection of similar objects. Finally, the Proxy pattern wraps on an object to provide the same functionality, but at the same time, adding something to the proxy’s functionality.</p>
<p><a href="#chapter-5" >Chapter 5</a>, <i> Behavioral patterns - Strategy, Chain of Responsibility, Command, and Mediator Design Patterns</i>, deals with the first behavioral pattern to make objects react in an expected or bounded way. We’ll start with the Strategy pattern, perhaps the most important design pattern in object-oriented programming, as many design patterns have something in common with it. Then we’ll move to the Chain of Responsibility to build <i>chains</i> of objects that can decide which between them must deal with a particular case. Finally, Command pattern to encapsulate actions that don’t necessarily need to be executed immediately or must be stored.</p>
<p><a href="#chapter-6" >Chapter 6</a>, <i>Behavioral Patterns - Template, Memento, and Interpreter Design Patterns</i>, continues with Behavioral patterns introducing the Interpreter pattern, a quite complex pattern to create small languages and Interpreters for them. It can be very useful when a problem can be solved by inventing a small language for it. The Memento pattern is in front of our eyes every day with the <b>Undo</b> button in apps. The Template pattern helps developers by defining an initial structure of an operation so that the final users of the code can finish it.</p>
<p><a href="#chapter-7" >Chapter 7</a>, <i>Behavioral Patterns - Visitor, State, Mediator, and Observer Design Patterns</i>, depicts the Observer pattern, an important pattern that is becoming tremendously popular in distributed systems and reactive programming. The Visitor pattern deals with complex hierarchies of objects where you need to apply a particular action depending on the object. Finally, the State pattern is commonly used in video games and finite state machines and allows an object to change its behavior depending on its own state.</p>
<p><a href="#chapter-8" >Chapter 8</a>, <i>Introduction to Go&#39;s Concurrency</i>, explains with more detail the CSP concurrency model used in Go by going through some examples using Goroutines and channels, as well as mutexes and syncs.</p>
<p><a href="#chapter-9" >Chapter 9</a>, <i>Concurrency Patterns - Barrier, Future, and Pipeline Design Patterns</i>, will introduce some of the CSP concurrency patterns that are idiomatic to the Go language by walking through some examples and explanations. These are small but really powerful patterns so we will provides a few examples of the use of each of them, as well as some schemas (if possible) that will make the understanding of each of them easier.</p>
<p><a href="Chapter-10" >Chapter 10</a>, <i> Concurrency Patterns -  Workers Pool, and Publish or Subscriber Design Patterns</i>, talks about a couple of patterns with concurrent structures. We will explain every step in detail so you can follow the examples carefully. The idea is to learn patterns to design concurrent applications in idiomatic Go. We are using channels and Goroutines heavily, instead of locks or sharing variables.</p>
</div>
<h3 id="what-you-need-for-this-book" >What you need for this book</h3>
<div class="hBody-3" >
<p>Most of the chapters in this book are written following a simple TDD approach, here the requirements are written first, followed by some unit tests and finally the code that satisfies those requirements. We will use only tools that comes with the standard library of Go as a way to better understand the language and its possibilities. This idea is key to follow the book and understanding the way that Go solves problems, especially in distributed systems and concurrent applications.</p>
</div>
<h3 id="who-this-book-is-for" >Who this book is for</h3>
<div class="hBody-3" >
<p>This book is for both beginners and advanced-level developers in the Go programming language. No knowledge of design patterns is expected.</p>
</div>
<h4 id="downloading-the-example-code" >Downloading the example code</h4>
<div class="hBody-4" >
<p>You can download the example code files for this book from your account at <a href="http://www.packtpub.com" >http://www.packtpub.com</a>. If you purchased this book elsewhere, you can visit <a href="http://www.packtpub.com/support" >http://www.packtpub.com/support</a> and register to have the files e-mailed directly to you.</p>
<p>You can download the code files by following these steps:</p>
<ol class="num" >
<li>
<p>Log in or register to our website using your e-mail address and password.</p>
</li>
<li>
<p>Hover the mouse pointer on the <b>SUPPORT</b> tab at the top.</p>
</li>
<li>
<p>Click on <b>Code Downloads &amp; Errata</b>.</p>
</li>
<li>
<p>Enter the name of the book in the <b>Search</b> box.</p>
</li>
<li>
<p>Select the book for which you&#39;re looking to download the code files.</p>
</li>
<li>
<p>Choose from the drop-down menu where you purchased this book from.</p>
</li>
<li>
<p>Click on <b>Code Download</b>.</p>
</li>
</ol>
<p>Once the file is downloaded, please make sure that you unzip or extract the folder using the latest version of:</p>
<ul>
<li>
<p>WinRAR / 7-Zip for Windows</p>
</li>
<li>
<p>Zipeg / iZip / UnRarX for Mac</p>
</li>
<li>
<p>7-Zip / PeaZip for Linux</p>
</li>
</ul>
<p>The code bundle for the book is also hosted on GitHub at <a href="https://github.com/PacktPublishing/Go-Design-Patterns" >https://github.com/PacktPublishing/Go-Design-Patterns</a>. We also have other code bundles from our rich catalog of books and videos available at <a href="https://github.com/PacktPublishing/" >https://github.com/PacktPublishing/</a>. Check them out!</p>
</div>
<h4 id="errata" >Errata</h4>
<div class="hBody-4" >
<p>Although we have taken every care to ensure the accuracy of our content, mistakes do happen. If you find a mistake in one of our books-maybe a mistake in the text or the code-we would be grateful if you could report this to us. By doing so, you can save other readers from frustration and help us improve subsequent versions of this book. If you find any errata, please report them by visiting <a href="http://www.packtpub.com/submit-errata" >http://www.packtpub.com/submit-errata</a>, selecting your book, clicking on the <b>Errata Submission Form</b> link, and entering the details of your errata. Once your errata are verified, your submission will be accepted and the errata will be uploaded to our website or added to any list of existing errata under the Errata section of that title.</p>
<p>To view the previously submitted errata, go to <a href="https://www.packtpub.com/books/content/support" >https://www.packtpub.com/books/content/support</a>and enter the name of the book in the search field. The required information will appear under the <b>Errata</b> section.</p>
</div>
<h4 id="questions" >Questions</h4>
<div class="hBody-4" >
<p>If you have a problem with any aspect of this book, you can contact us at <a href="mailto:questions@packtpub.com" >mailto:questions@packtpub.com</a>, and we will do our best to address the problem.</p>
</div>
<h2 id="chapter-1" >Ready... Steady... Go!</h2>
<div class="hBody-2" >
<p>Design Patterns have been the foundation for hundreds of thousands of pieces of software. Since the <i>Gang Of Four</i> (Erich Gamma, Richard Helm, Ralph Johnson and John Vlissides) wrote the book <i>Design Patterns: Elements of Reusable Object-Oriented Software</i> in 1994 with examples in C++ and Smalltalk, the twenty-three classic patterns have been re-implemented in most of major languages of today and they have been used in almost every project you know about.</p>
<p>The <i>Gang of Four</i> detected that many small architectures were present in many of their projects, they started to rewrite them in a more abstract way and they released the famous book.</p>
<p>This book is a comprehensive explanation and implementation of the most common design patterns from the <i>Gang of Four</i> and today&#39;s patterns plus some of the most idiomatic concurrency patterns in Go.</p>
<p>But what is Go...?</p>
</div>
<h3 id="a-little-bit-of-history" >A little bit of history</h3>
<div class="hBody-3" >
<p>On the last 20 years, we have lived an incredible growth in computer science. Storage spaces have been increased dramatically, RAM has suffered a substantial growth, and CPU&#39;s are... well... simply faster. Have they grown as much as storage and RAM memory? Not really, CPU industry has reached a limit in the speed that their CPU&#39;s can deliver, mainly because they have become so fast that they cannot get enough power to work while they dissipate enough heat. The CPU manufacturers are now shipping more cores on each computer. This situation crashes against the background of many systems programming languages that weren&#39;t designed for multi-processor CPUs or large distributed systems that act as a unique machine. In Google, they realized that this was becoming more than an issue while they were struggling to develop distributed applications in languages like Java or C++ that weren&#39;t designed with concurrency in mind.</p>
<p>At the same time, our programs were bigger, more complex, more difficult to maintain and with a lot of room for bad practices. While our computers had more cores and were faster, we were not faster when developing our code neither our distributed applications. This was Go&#39;s target.</p>
<p>Go design started in 2007 by three Googlers in the research of a programming language that could solve common issues in large scale distributed systems like the ones you can find at Google. The creators were:</p>
<ul>
<li>
<p>Rob Pike: Plan 9 and Inferno OS.</p>
</li>
<li>
<p>Robert Griesemer: Worked at Google&#39;s V8 JavaScript engine that powers Google Chrome.</p>
</li>
<li>
<p>Ken Thompson: Worked at Bell labs and the Unix team. It has been involved in designing of the Plan 9 operating system as well as the definition of the UTF-8 encoding.</p>
</li>
</ul>
<p>In 2008, the compiler was done and the team got the help of Russ Cox and Ian Lance Taylor. The team started their journey to open source the project in 2009 and in March 2012 they reached a version 1.0 after more than fifty releases.</p>
</div>
<h3 id="installing-go" >Installing Go</h3>
<div class="hBody-3" >
<p>Any Go Installation needs two basic things: the binaries of the language somewhere on your disk and a <code>GOPATH</code> path in your system where your projects and the projects that you download from other people will be stored.</p>
<p>In the following lines, we will explore how to install Go binaries in Linux, Windows and OS X. For a detailed explanation of how to install the latest version of Go, you can refer to the official documentation at <a href="https://golang.org/doc/install" >https://golang.org/doc/install</a>.</p>
</div>
<h4 id="linux" >Linux</h4>
<div class="hBody-4" >
<p>To install Go in Linux you have two options:</p>
<ul>
<li>
<p><b>Easy option</b>: Use your distribution package manager:</p>
<ul>
<li>
<p>RHEL/Fedora/Centos users with YUM/DNF:</p>
<pre class="code" ><code class="chroma" >sudo yum install -y golang
</code></pre>
</li>
<li>
<p>Ubuntu/Debian users using APT with:</p>
<pre class="code" ><code class="chroma" >sudo apt-get install -y golang
</code></pre>
</li>
</ul>
</li>
<li>
<p><b>Advanced</b>: Downloading the latest distribution from <a href="https://golang.org" >https://golang.org</a>.</p>
</li>
</ul>
<p>I recommend using the second and downloading a distribution. Go&#39;s updates maintains backward compatibility and you usually should not be worried about updating your Go binaries frequently.</p>
</div>
<h5 id="go-linux-advanced-installation" >Go Linux advanced installation</h5>
<div class="hBody-5" >
<p>The advanced installation of Go in Linux requires you to download the binaries from <b>golang</b> webpage. After entering <a href="https://golang.org" >https://golang.org</a>, click the <b>Download Go</b> button (usually at the right) some <b>Featured Downloads</b> option is available for each distribution. Select <b>Linux</b> distribution to download the latest stable version.</p>
<div class="about" >
<div class="about-dt" >Note</div>
<div class="about-dd" >
<p>At <a href="https://golang.org" >https://golang.org</a> you can also download beta versions of the language.</p>
</div>
</div>
<p>Let&#39;s say we have saved the tar.gz file in Downloads folder so let&#39;s extract it and move it to a different path. By convention, Go binaries are usually placed in /usr/local/go directory:</p>
<pre class="code" ><code class="chroma" >tar -zxvf go*.*.*.linux-amd64.tar.gz
sudo mv go /usr/local/go
</code></pre>
<p>On extraction remember to replace asterisks (*) with the version you have downloaded.</p>
<p>Now we have our Go installation in <code>/usr/local/go</code> path so now we have to add the bin subfolder to our <code>PATH</code> and the bin folder within our <code>GOPATH</code>.</p>
<pre class="code" ><code class="chroma" >mkdir -p <span class="nv">$HOME</span>/go/bin
</code></pre>
<p>With <code>-p</code> we are telling bash to create all directories that are necessary. Now we need to append bin folder paths to our <code>PATH</code>, append the following lines at the end of your <span class="file" >~/.bashrc</span>:</p>
<pre class="code" ><code class="chroma" ><span class="nb">export</span> <span class="nv">PATH</span><span class="o">=</span><span class="nv">$PATH</span>:/usr/local/go/bin
</code></pre>
<p>Check that our go/bin directory is available:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go version Go version go1.6.2 linux/amd64
</span></code></pre>
</div>
<h4 id="windows" >Windows</h4>
<div class="hBody-4" >
<p>To install Go in Windows, you will need administrator privileges. Open your favorite browser and navigate to https://golang.org . Once there click the <b>Download Go</b> button and select <b>Microsoft Windows</b> distribution. A <span class="file" >*.msi</span> file will start downloading.</p>
<p>Execute the MSI installer by double clicking it. An installer will appear asking you to accept the <b>End User License Agreement</b> (<span class="acronym" >EULA</span>) and select a target folder for your installation. We will continue with the default path that in my case was <span class="file" >C:\Go</span>.</p>
<p>Once the installation is finished you will have to add the <b>binary Go</b> folder, located in <span class="file" >C:\Go\bin</span> to your Path. For this, you must go to Control Panel and select <b>System</b> option. Once in System, select the <b>Advanced</b> tab and click the <b>Environment variables</b> button. Here you&#39;ll find a window with variables for your current user and system variables. In system variables, you&#39;ll find the <b>Path</b> variable. Click it and click the <b>Edit</b> button to open a text box. You can add your path by adding <code>;C:\Go/bin</code> at the end of the current line (note the semicolon at the beginning of the path). In recent Windows versions (Windows 10) you will have a manager to add variables easily.</p>
</div>
<h4 id="mac-os-x" >Mac OS X</h4>
<div class="hBody-4" >
<p>In Mac OS X the installation process is very similar to Linux. Open your favorite browser and navigate to <a href="https://golang.org" >https://golang.org</a>and click the <b>Download Go</b>. From the list of possible distributions that appear, select <b>Apple OS X</b>. This will download a <span class="file" >*.pkg</span> file to your download folder.</p>
<p>A window will guide you through the installation process where you have to type your administrator password so that it can put Go binary files in <span class="file" >/usr/local/go/bin</span> folder with the proper permissions. Now, open <b>Terminal</b> to test the installation by typing this on it:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go version
</span><span class="out" >Go version go1.6.2 darwin/amd64
</span></code></pre>
<p>If you see the installed version, everything was fine. If it doesn&#39;t work check that you have followed correctly every step or refer to the documentation at <a href="https://golang.org" >https://golang.org</a>.</p>
</div>
<h4 id="setting-the-workspace---linux-and-apple-os-x" >Setting the workspace - Linux and Apple OS X</h4>
<div class="hBody-4" >
<p>Go will always work under the same workspace. This helps the compiler to find packages and libraries that you could be using. This workspace is commonly called <code>GOPATH</code>.</p>
<p><code>GOPATH</code> has a very important role in your working environment while developing Go software. When you import a library in your code it will search for this library in your <span class="file" >$GOPATH/src</span>. The same when you install some Go apps, binaries will be stored in <span class="file" >$GOPATH/bin</span>.</p>
<p>At the same, all your source code must be stored in a valid route within $GOPATH/src folder. For example, I store my projects in GitHub and my username is <i>Sayden</i> so, for a project called <b>minimal-mesos-go-framework</b> I will have this folder structure like <span class="file" >$GOPATH/src/github.com/sayden/minimal-mesos-go-framework</span> which reflects the URI where this repo is stored at GitHub:</p>
<pre class="code" ><code class="chroma" >mkdir -p <span class="nv">$HOME</span>/go
</code></pre>
<p>The <span class="file" >$HOME/go</span> path is going to be the destination of our <code>$GOPATH</code>. We have to set an environment variable with our <code>$GOPATH</code> pointing to this folder. To set the environment variable, open again the file <code>$HOME/.bashrc</code> with your favorite text editor and add the following line at the end of it:</p>
<pre class="code" ><code class="chroma" ><span class="nb">export</span> <span class="nv">GOPATH</span><span class="o">=</span><span class="si">${</span><span class="nv">HOME</span><span class="si">}</span>/go
</code></pre>
<p>Save the file and open a new terminal. To check that everything is working, just write an echo to the <code>$GOPATH</code> variable like this:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span><span class="nb">echo</span> <span class="nv">$GOPATH</span>
</span><span class="out" >/home/mcastro/go
</span></code></pre>
<p>If the output of the preceding command points to your chosen Go path, everything is correct and you can continue to write your first program.</p>
</div>
<h3 id="starting-with-hello-world" >Starting with Hello World</h3>
<div class="hBody-3" >
<p>This wouldn&#39;t be a good book without a Hello World example. Our Hello World example can&#39;t be simpler, open your favorite text editor and create a file called <span class="file" >main.go</span> within our <code>$GOPATH/src/[your_name]/hello_world</code> with the following content:</p>
<pre class="code" ><code class="chroma" ><span class="kn">package</span> <span class="nx">main</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">(){</span>
  <span class="nb">println</span><span class="p">(</span><span class="s">&#34;Hello World!&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
<p>Save the file. To run our program, open the Terminal window of your operating system:</p>
<ul>
<li>
<p>In Linux, go to programs and find a program called <b>Terminal</b>.</p>
</li>
<li>
<p>In Windows, hit <kbd>Windows + R</kbd>, type <code class="command" >cmd</code> without quotes on the new window and hit <i>Enter</i>.</p>
</li>
<li>
<p>In Mac OS X, hit <kbd>Command + Space</kbd> to open a spotlight search, type <code>terminal</code> without quotes. The terminal app must be highlighted so hit Enter.</p>
</li>
</ul>
<p>Once we are in our terminal, navigate to the folder where we have created our <span class="file" >main.go</span> file. This should be under your <span class="file" >$GOPATH/src/[your_name]/hello_world</span> and execute it:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go run main.go
</span><span class="out" >Hello World!
</span></code></pre>
<p>That&#39;s all. The <code class="command" >go run [file]</code> command will compile and execute our application but it won&#39;t generate an executable file. If you want just to build it and get an executable file, you must build the app using the following command:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go build -o hello_world
</span></code></pre>
<p>Nothing happens. But if you search in the current directory (<code class="command" >ls</code> command in Linux and Mac OS X; and <code class="command" >dir</code> in Windows), you&#39;ll find an executable file with the name <span class="file" >hello_world</span>. We have given this name to the executable file when we wrote <code>-o hello_world</code> command while building. You can now execute this file:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>/hello_world
</span><span class="out" >Hello World!
</span></code></pre>
<p>And our message appeared! In Windows, you just need to type the name of the <span class="file" >.exe</span> file to get the same result.</p>
<div class="about" >
<div class="about-dt" >Tip</div>
<div class="about-dd" >
<p>The <code class="command" >go run [my_main_file.go]</code> command will build and execute the app without intermediate files. The <code class="command" >go build -o [filename]</code> command will create an executable file that I can take anywhere and has no dependencies.</p>
</div>
</div>
</div>
<h3 id="integrated-development-environment---ide" >Integrated Development Environment - IDE</h3>
<div class="hBody-3" >
<p>An <span class="acronym" >IDE</span> (<b>Integrated Development Environment</b>) is basically a user interface to help developers, code their programs by providing a set of tools to speed up common tasks during development process like compiling, building, or managing dependencies. The IDEs are powerful tools that take some time to master and the purpose of this book is not to explain them (an IDE like Eclipse has its own books).</p>
<p>In Go, you have many options but there are only two that are fully oriented to Go development <b>LiteIDE</b> and <b>Intellij Gogland</b>. LiteIDE is not the most powerful though but Intellij has put lots of efforts to make Gogland a very nice editor with completion, debugging, refactoring, testing, visual coverage, inspections, etc. Common IDEs or text editors that have a Go plugin/integration are as following:</p>
<ul>
<li>
<p>IntelliJ Idea</p>
</li>
<li>
<p>Sublime Text 2/3</p>
</li>
<li>
<p>Atom</p>
</li>
<li>
<p>Eclipse</p>
</li>
</ul>
<p>But you can also find Go plugins for:</p>
<ul>
<li>
<p>Emacs</p>
</li>
<li>
<p>Vim</p>
</li>
<li>
<p>Visual Studio and Visual Code</p>
</li>
</ul>
<p>The IntelliJ Idea and Atom IDEs, for the time of this writing, has the support for debugging using a plugin called <b>Delve</b>. The IntelliJ Idea is bundled with the official Go plugin. In Atom you&#39;ll have to download a plugin called <b>Go-plus</b> and a debugger that you can find searching the word <code>Delve</code>.</p>
</div>
<h3 id="types" >Types</h3>
<div class="hBody-3" >
<p>Types give the user the ability to store values in mnemonic names. All programming languages have types related with numbers (to store integers, negative numbers, or floating point for example) with characters (to store a single character) with strings (to store complete words) and so on. Go language has the common types found in most programming languages:</p>
<ul>
<li>
<p>The <code>bool</code> keyword is for Boolean type which represents a <em>True</em> or <em>False</em> state.</p>
</li>
<li>
<p>Many numeric types being the most common:</p>
<ul>
<li>
<p>The <code>int</code> type represents a number from 0 to 4294967295 in 32 bits machines and from 0 to 18446744073709551615 in 64 bits.</p>
</li>
<li>
<p>The <code>byte</code> type represents a number from 0 to 255.</p>
</li>
<li>
<p>The <code>float32</code> and <code>float64</code> types are the set of all IEEE-754 64/-bit floating-point numbers respectively.</p>
</li>
<li>
<p>You also have <code>signed int</code> type like <code>rune</code> which is an alias of <code>int32</code> type, a number that goes from -2147483648 to 2147483647 and <code>complex64</code> and <code>complex128</code> which are the set of all complex numbers with <code>float32</code>/<code>float64</code> real and imaginary parts like <span class="math" >2.0i</span>.</p>
</li>
</ul>
</li>
<li>
<p>The <code>string</code> keyword for string type represents an array of characters enclosed in quotes like <code>&#34;golang&#34;</code> or <code>&#34;computer&#34;</code>.</p>
</li>
<li>
<p>An <code>array</code> that is a numbered sequence of elements of a single type and a fixed size (more about arrays later in this chapter). A list of numbers or lists of words with a fixed size is considered arrays.</p>
</li>
<li>
<p>The <code>slice</code> type is a segment of an underlying array (more about this later in this chapter). This type is a bit confusing at the beginning because it seems like an array but we will see that actually, they are more powerful.</p>
</li>
<li>
<p>The structures that are the objects that are composed of another objects or types.</p>
</li>
<li>
<p>The pointers (more about this later in this chapter)are like directions in the memory of our program (yes, like mailboxes that you don&#39;t know what&#39;s inside).</p>
</li>
<li>
<p>The functions are interesting (more about this later in this chapter). You can also define functions as variables and pass them to other functions (yes, a function that uses a function, did you like Inception movie?).</p>
</li>
<li>
<p>The <code>interface</code> is incredibly important for the language as they provide many encapsulation and abstraction functionalities that we&#39;ll need often. We&#39;ll use interfaces extensively during the book and they are presented in greater detail later.</p>
</li>
<li>
<p>The <code>map</code> types are unordered key-value structures. So for a given key, you have an associated value.</p>
</li>
<li>
<p>The channels are the communication primitive in Go for concurrency programs. We&#39;ll look on channels with more detail on Chapter 8, <em>Dealing with Go&#39;s CSP concurrency</em>.</p>
</li>
</ul>
</div>
<h3 id="variables-and-constants" >Variables and constants</h3>
<div class="hBody-3" >
<p>Variables are spaces in computer&#39;s memory to store values that can be modified during the execution of the program. Variables and constants have a type like the ones described in preceding text. Although, you don&#39;t need to explicitly write the type of them (although you can do it). This property to avoid explicit type declaration is what is called <b>Inferred types</b>. For example:</p>
<pre class="code" ><code class="chroma" ><span class="c1">//Explicitly declaring a &#34;string&#34; variable
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">explicit</span> <span class="kt">string</span> <span class="p">=</span> <span class="s">&#34;Hello, I&#39;m a explicitly declared variable&#34;</span>
</code></pre>
<p>Here we are declaring a variable (with the keyword <code>var</code>) called <code>explicit</code> of string type. At the same time, we are defining the value to <code>Hello World!</code>.</p>
<pre class="code" ><code class="chroma" ><span class="c1">// Implicitly declaring a &#34;string&#34;. Type inferred
</span><span class="c1"></span><span class="nx">inferred</span> <span class="o">:=</span> <span class="s">&#34;, I&#39;m an inferred variable &#34;</span>
</code></pre>
<p>But here we are doing exactly the same thing. We have avoided the <code>var</code> keyword and the <code>string</code> type declaration. Internally, Go&#39;s compiler will infer (guess) the type of the variable to a string type. This way you have to write much less code for each variable definition.</p>
<p>The following lines use the <code>reflect</code> package to gather information about a variable. We are using it to print the type of (the <code>TypeOf</code> variable in the code) of both variables:</p>
<pre class="code" ><code class="chroma" ><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&#34;Variable &#39;explicit&#39; is of type:&#34;</span><span class="p">,</span>
    <span class="nx">reflect</span><span class="p">.</span><span class="nx">TypeOf</span><span class="p">(</span><span class="nx">explicit</span><span class="p">))</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&#34;Variable &#39;inferred&#39; is of type:&#34;</span><span class="p">,</span>
    <span class="nx">reflect</span><span class="p">.</span><span class="nx">TypeOf</span><span class="p">(</span><span class="nx">inferred</span><span class="p">))</span>
</code></pre>
<p>When we run the program, the result is the following:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go run main.go
</span><span class="out" >Hello, I&#39;m a explicitly declared variable
Hello, I&#39;m an inferred variable
Variable &#39;explicit&#39; is of type: string
Variable &#39;inferred&#39; is of type: string
</span></code></pre>
<p>As we expected, the compiler has inferred the type of the implicit variable to string too. Both have written the expected output to the console.</p>
</div>
<h3 id="operators" >Operators</h3>
<div class="hBody-3" >
<p>The operators are used to perform arithmetic operations and make comparisons between many things. The following operators are reserved by Go language.</p>
<div class="pre-block" >
<pre class="pre" >+    &amp;    +=   &amp;=    &amp;&amp;   ==   !=    (  )
-    |    -=   |=    ||   &lt;    &lt;=    [  ]
*    ^    *=   ^=    &lt;=   &gt;    &gt;=    {  }
/    &lt;&lt;   /=   &lt;&lt;=   ++   =    :=    ,  ;
%    &gt;&gt;   %=   &gt;&gt;=   --   !    ...   .  :
     &amp;^        &amp;^=
</pre>
</div>
<p>Most commonly used operators are the arithmetic operators and comparators. Arithmetic operators are as following:</p>
<ul>
<li>
<p>The <code>+</code> operator for sums</p>
</li>
<li>
<p>The <code>-</code> operator for subtractions</p>
</li>
<li>
<p>The <code>*</code> operator for multiplications</p>
</li>
<li>
<p>The <code>/</code> operator for divisions</p>
</li>
<li>
<p>The <code>%</code> operator for division remainders</p>
</li>
<li>
<p>The <code>++</code> operator to add 1 to the current variable</p>
</li>
<li>
<p>The <code>--</code> operator to subtract 1 to the current variable</p>
</li>
</ul>
<p>On the other side, comparators are used to check the differences between two statements:</p>
<ul>
<li>
<p>The <code>==</code> operator to check if two values are equal</p>
</li>
<li>
<p>The <code>!=</code> operator to check if two values are different</p>
</li>
<li>
<p>The <code>&gt;</code> operator to check if left value is higher than right value</p>
</li>
<li>
<p>The <code>&lt;</code> operator to check if left value is lower than right value</p>
</li>
<li>
<p>The <code>&gt;=</code> operator to check if left value is higher or equal to right value</p>
</li>
<li>
<p>The <code>&lt;=</code> operator to check if left value is lower or equal to right value</p>
</li>
<li>
<p>The <code>&amp;&amp;</code> operator to check if two values are <code>true</code></p>
</li>
</ul>
<p>You also have the shifters to perform a binary shift to left or right of a value and a negated operator to invert some value. We´ll use these operators a lot during the following chapters so don´t worry too much about them now, just keep in mind that you cannot set the name of any variable, field or function in your code like this operators.</p>
<div class="about" >
<div class="about-dt" >Tip</div>
<div class="about-dd" >
<p>What&#39;s the inverted value of 10? What&#39;s the negated value of 10? -10? Incorrect.. 10 in binary code is <code>1010</code> so if we negate every number we will have <code>0101</code> or <code>101</code> which is the number 5.</p>
</div>
</div>
</div>
<h3 id="flow-control" >Flow control</h3>
<div class="hBody-3" >
<p>Flow control is referred as the ability to decide which portion of code or how many times you execute some code on a condition. In Go, it is implemented using familiar imperative clauses like if, else, switch and for. The syntax is easy to grasp. Let´s review major flow control statements in Go.</p>
</div>
<h4 id="the-if...-else-statement" >The if... else statement</h4>
<div class="hBody-4" >
<p>Go language, like most programming languages, has if…else conditional statement for flow control. The Syntax is similar to other languages but you don&#39;t need to encapsulate the condition between parenthesis:</p>
<pre class="code" ><code class="chroma" ><span class="nx">ten</span> <span class="o">:=</span> <span class="mi">10</span>
<span class="k">if</span> <span class="nx">ten</span> <span class="o">==</span> <span class="mi">20</span> <span class="p">{</span>
  <span class="nb">println</span><span class="p">(</span><span class="s">&#34;This shouldn&#39;t be printed as 10 isn&#39;t equal to 20&#34;</span><span class="p">)</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
  <span class="nb">println</span><span class="p">(</span><span class="s">&#34;Ten is not equals to 20&#34;</span><span class="p">);</span>
<span class="p">}</span>
</code></pre>
<p>The <code>else...if</code> condition works in a similar fashion, you don&#39;t need parentheses either and they are declared as programmer would expect:</p>
<pre class="code" ><code class="chroma" ><span class="k">if</span> <span class="s">&#34;a&#34;</span> <span class="o">==</span> <span class="s">&#34;b&#34;</span> <span class="o">||</span>  <span class="mi">10</span> <span class="o">==</span> <span class="mi">10</span> <span class="o">||</span> <span class="kc">true</span> <span class="o">==</span> <span class="kc">false</span> <span class="p">{</span>
  <span class="nb">println</span><span class="p">(</span><span class="s">&#34;10 is equal to 10&#34;</span><span class="p">)</span>
<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="mi">11</span> <span class="o">==</span> <span class="mi">11</span> <span class="o">&amp;&amp;</span> <span class="s">&#34;go&#34;</span> <span class="o">==</span> <span class="s">&#34;go&#34;</span> <span class="p">{</span>
  <span class="nb">println</span><span class="p">(</span><span class="s">&#34;This isn&#39;t print because previous condition was satisfied&#34;</span><span class="p">);</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
  <span class="nb">println</span><span class="p">(</span><span class="s">&#34;In case no condition is satisfied, print this&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
<div class="about" >
<div class="about-dt" >Note</div>
<div class="about-dd" >
<p>Go does not have ternary conditions like condition <code>? true : false</code>.</p>
</div>
</div>
</div>
<h4 id="the-switch-statement" >The switch statement</h4>
<div class="hBody-4" >
<p>The <code>switch</code> statement is also similar to most imperative languages. You take a variable and check possible values for it:</p>
<pre class="code" ><code class="chroma" ><span class="nx">number</span> <span class="o">:=</span> <span class="mi">3</span>
<span class="k">switch</span><span class="p">(</span><span class="nx">number</span><span class="p">){</span>
<span class="k">case</span> <span class="mi">1</span><span class="p">:</span>
  <span class="nb">println</span><span class="p">(</span><span class="s">&#34;Number is 1&#34;</span><span class="p">)</span>
<span class="k">case</span> <span class="mi">2</span><span class="p">:</span>
  <span class="nb">println</span><span class="p">(</span><span class="s">&#34;Number is 2&#34;</span><span class="p">)</span>
<span class="k">case</span> <span class="mi">3</span><span class="p">:</span>
  <span class="nb">println</span><span class="p">(</span><span class="s">&#34;Number is 3&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
</div>
<h4 id="the-for…range-statement" >The for…range statement</h4>
<div class="hBody-4" >
<p>The <code>for</code> loop is also similar than in common programming languages but you don&#39;t use parentheses either</p>
<pre class="code" ><code class="chroma" ><span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span><span class="o">&lt;=</span><span class="mi">10</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
  <span class="nb">println</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
<p>As you have probably imagined if you have computer science background, we infer an <code>int</code> variable defined as 0 and execute the code between the brackets while the condition (<code>i&lt;=10</code>) is satisfied. Finally, for each execution, we added 1 to the value of <code>i</code>. This code will print the numbers from 0 to 10. You also have a special syntax to iterate over arrays or slices which is <code>range</code>:</p>
<pre class="code" ><code class="chroma" ><span class="k">for</span> <span class="nx">index</span><span class="p">,</span> <span class="nx">value</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">my_array</span> <span class="p">{</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&#34;Index is %d and value is %d&#34;</span><span class="p">,</span> <span class="nx">index</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
<p>First, the <code>fmt</code> (format) is a very common Go package that we will use extensively to give shape to the message that we will print in the console.</p>
<p>Regarding for, you can use the <code>range</code> keyword to retrieve every item in a collection like <code>my_array</code> and assign them to the value temporal variable. It will also give you an <code>index</code> variable to know the position of the value you&#39;re retrieving. It&#39;s equivalent to write the following:</p>
<pre class="code" ><code class="chroma" ><span class="k">for</span> <span class="nx">index</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">index</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">my_array</span><span class="p">);</span> <span class="nx">index</span><span class="o">++</span> <span class="p">{</span>
  <span class="nx">value</span> <span class="o">:=</span> <span class="nx">my_array</span><span class="p">[</span><span class="nx">index</span><span class="p">]</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&#34;Index is %d and value is %d&#34;</span><span class="p">,</span> <span class="nx">index</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
<div class="about" >
<div class="about-dt" >Tip</div>
<div class="about-dd" >
<p>The <code>len</code> method is used to know the length of a collection.</p>
</div>
</div>
<p>If you execute this code, you&#39;ll see that the result is the same.</p>
</div>
<h3 id="functions" >Functions</h3>
<div class="hBody-3" >
<p>A function is a small portion of code that surrounds some action you want to perform and returns one or more values (or nothing). They are the main tool for developer to maintain structure, encapsulation, and code readability but also allow an experienced programmer to develop proper unit tests against his or her functions.</p>
<p>Functions can be very simple or incredibly complex. Usually, you&#39;ll find that simpler functions are also easier to maintain, test and debug. There is also a very good advice in computer science world that says: <i>A function must do just one thing, but it must do it damn well</i>.</p>
</div>
<h4 id="what-does-a-function-look-like?" >What does a function look like?</h4>
<div class="hBody-4" >
<p>A function is a piece of code with its own variables and flow that doesn&#39;t affect anything outside of the opening and close brackets but global package or program variables. Functions in Go has the following composition:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="p">[</span><span class="nx">function_name</span><span class="p">]</span> <span class="p">(</span><span class="nx">param1</span> <span class="kd">type</span><span class="p">,</span> <span class="nx">param2</span> <span class="kd">type</span><span class="o">...</span><span class="p">)</span> <span class="p">(</span><span class="nx">returned</span> <span class="nx">type1</span><span class="p">,</span> <span class="nx">returned</span> <span class="nx">type2</span><span class="o">...</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">//Function body
</span><span class="c1"></span><span class="p">}</span>
</code></pre>
<p>Following the previous definition, we could have the following example:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">hello</span><span class="p">(</span><span class="nx">message</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&#34;Hello %s\n&#34;</span><span class="p">,</span> <span class="nx">message</span><span class="p">)</span>
  <span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre>
<p>Functions can call other functions. For example, in our previous <code>hello</code> function, we are receiving a message argument of type string and we are calling a different function <code>fmt.Printf(&#34;Hello %s\n&#34;, message)</code> with our argument as parameter. Functions can also be used as parameters when calling other functions or be returned.</p>
<p>It is very important to choose a good name for your function so that it is very clear what it is about without writing too many comments over it. This can look a bit trivial but choosing a good name is not so easy. A short name must show what the function does and let the reader imagine what error is it handling or if it&#39;s doing any kind of logging. Within your function, you want to do everything that a particular behavior need but also to control expected errors and wrapping them properly.</p>
<p>So, to write a function is more than simply throw a couple of lines that does what you need, that&#39;s why it is important to write a unit test, make them small and concise.</p>
</div>
<h4 id="what-is-an-anonymous-function?" >What is an anonymous function?</h4>
<div class="hBody-4" >
<p>An anonymous function is a function without a name. This is useful when you want to return a function from another function that doesn&#39;t need a context or when you want to pass a function to a different function. For example, we will create a function that accepts one number and returns a function that accepts a second number that it adds it to the first one. The second function does not have a declarative name (as we have assigned it to a variable) that is why it is said to be anonymous:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">main</span><span class="p">(){</span>
  <span class="nx">add</span> <span class="o">:=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">m</span> <span class="kt">int</span><span class="p">){</span>
    <span class="k">return</span> <span class="nx">m</span><span class="o">+</span><span class="mi">1</span>
  <span class="p">}</span>

  <span class="nx">result</span> <span class="o">:=</span> <span class="nx">add</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>

  <span class="c1">// 1 + 6 must print 7
</span><span class="c1"></span>  <span class="nb">println</span><span class="p">(</span><span class="nx">result</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
<p>The <code>add</code> variable points to an anonymous function that adds one to the specified parameter. As you can see, it can be used only for the scope its parent function <code>main</code> and cannot be called from anywhere else.</p>
<p>Anonymous functions are really powerful tools that we will use extensively on design patterns.</p>
</div>
<h4 id="closures" >Closures</h4>
<div class="hBody-4" >
<p>Closures are something very similar to anonymous functions but even more powerful. The key difference between them is that an anonymous function has no context within itself and a closure has. Let&#39;s rewrite the previous example to add an arbitrary number instead of one:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">main</span><span class="p">(){</span>
  <span class="nx">addN</span> <span class="o">:=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">m</span> <span class="kt">int</span><span class="p">){</span>
    <span class="k">return</span> <span class="kd">func</span><span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">){</span>
      <span class="k">return</span> <span class="nx">m</span><span class="o">+</span><span class="nx">n</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="nx">addFive</span> <span class="o">:=</span> <span class="nx">addN</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
  <span class="nx">result</span> <span class="o">:=</span> <span class="nx">addN</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
  <span class="c1">// 5 + 6 must print 7
</span><span class="c1"></span>
  <span class="nb">println</span><span class="p">(</span><span class="nx">result</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
<p>The <code>addN</code> variable points to a function that returns another function. But the returned function has the context of the <code>m</code> parameter within it. Every call to <code>addN</code> will create a new function with a fixed <code>m</code> value, so we can have main <code>addN</code> functions, each adding a different value.</p>
<p>This ability of closures is very useful to create libraries or deal with functions with unsupported types.</p>
</div>
<h4 id="creating-errors,-handling-errors-and-returning-errors." >Creating errors, handling errors and returning errors.</h4>
<div class="hBody-4" >
<p>Errors are extensively used in Go, probably thanks to its simplicity. To create an error simply make a call to <code>errors.New(string)</code> with the text you want to create on the error. For example:</p>
<pre class="code" ><code class="chroma" ><span class="nx">err</span> <span class="o">:=</span> <span class="nx">errors</span><span class="p">.</span><span class="nx">New</span><span class="p">(</span><span class="s">&#34;Error example&#34;</span><span class="p">)</span>
</code></pre>
<p>As we have seen before, we can return errors to a function. To handle an error you&#39;ll see the following pattern extensively in Go code:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">main</span><span class="p">(){</span>
  <span class="nx">err</span> <span class="o">:=</span> <span class="nx">doesReturnError</span><span class="p">()</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">doesReturnError</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span>
  <span class="nx">err</span> <span class="o">:=</span> <span class="nx">errors</span><span class="p">.</span><span class="nx">New</span><span class="p">(</span><span class="s">&#34;this function simply returns an error&#34;</span><span class="p">)</span>
  <span class="k">return</span> <span class="nx">err</span>
<span class="p">}</span>
</code></pre>
</div>
<h4 id="function-with-undetermined-number-of-parameters" >Function with undetermined number of parameters</h4>
<div class="hBody-4" >
<p>Functions can be declared as <i>variadic</i>. This means that its number of arguments can vary. What this does is to provide an array to the scope of the function that contains the arguments that the function was called with. This is convenient if you don&#39;t want to force the user to provide an array when using this function. For example:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&#34;%d\n&#34;</span><span class="p">,</span> <span class="nx">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&#34;%d\n&#34;</span><span class="p">,</span> <span class="nx">sum</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">))</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">sum</span><span class="p">(</span><span class="nx">args</span> <span class="o">...</span><span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="nx">result</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">args</span> <span class="p">{</span>
    <span class="nx">result</span> <span class="o">+=</span> <span class="nx">v</span>
  <span class="p">}</span>
  <span class="k">return</span>
<span class="p">}</span>
</code></pre>
<p>In this example, we have a <code>sum</code> function that will return the sum of all its arguments but take a closer look at the <code>main</code> function where we call <code>sum</code>. As you can see now, first we call <code>sum</code> with three arguments and then with five arguments. For <code>sum</code> functions, it doesn&#39;t matter how many arguments you pass as it treats its arguments as an array all in all. So on our <code>sum</code> definition, we simply iterate over the array to add each number to the <code>result</code> integer.</p>
</div>
<h5 id="naming-returned-types" >Naming returned types</h5>
<div class="hBody-5" >
<p>Have you realized that we have given a name to the returned type? Usually, our declaration would be written as <code>func sum(args int) int</code> but you can also name the variable that you&#39;ll use within the function as a return value. Naming the variable in the return type would also zero-value it (in this case, an <code>int</code> will be initialized as zero). At the end, you just need to return the function (without value) and it will take the respective variable from the scope as returned value. This also makes easier to follow the mutation that the returning variable is suffering as well as to ensure that you aren&#39;t returning a mutated argument.</p>
</div>
<h3 id="arrays,-slices,-and-maps" >Arrays, slices, and maps</h3>
<div class="hBody-3" >
<p>Arrays are one of the most widely used types of computer programming. They are lists of other types that you can access by using their position on the list. The only downside of an array is that its size cannot be modified. Slices allow the use of arrays with variable size. The <code>maps</code> type will let us have a dictionary like structures in Go. Let&#39;s see how each work.</p>
</div>
<h4 id="arrays" >Arrays</h4>
<div class="hBody-4" >
<p>An array is a numbered sequence of elements of a single type. You can store 100 different unsigned integers in a unique variable, three strings or 400 <code>bool</code> values. Their size cannot be changed.</p>
<p>You must declare the length of the array on its creation as well as the type. You can also assign some value on creation. For example here you have 100 <code>int</code> values all with <code>0</code> as value:</p>
<pre class="code" ><code class="chroma" ><span class="kd">var</span> <span class="nx">arr</span> <span class="p">[</span><span class="mi">100</span><span class="p">]</span><span class="kt">int</span>
</code></pre>
<p>Or an array of size 3 with <code>string</code>s already assigned:</p>
<pre class="code" ><code class="chroma" ><span class="nx">arr</span> <span class="o">:=</span> <span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;go&#34;</span><span class="p">,</span> <span class="s">&#34;is&#34;</span><span class="p">,</span> <span class="s">&#34;awesome&#34;</span><span class="p">}</span>
</code></pre>
<p>Here you have an array of 2 <code>bool</code> values that we initialize later:</p>
<pre class="code" ><code class="chroma" ><span class="kd">var</span> <span class="nx">arr</span> <span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="kt">bool</span>
<span class="nx">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">=</span> <span class="kc">true</span>
<span class="nx">arr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">=</span> <span class="kc">false</span>
</code></pre>
</div>
<h5 id="zero-initialization" >Zero-initialization</h5>
<div class="hBody-5" >
<p>In our previous example, we have initialized an <code>array</code> of <code>bool</code> values of size <code>2</code>. We wouldn&#39;t need to assign <code>arr[1]</code> to <code>false</code> because of the nature of zero-initialization in the language. Go will initialize every value in a <code>bool</code> array to <code>false</code>. We will look deeper to zero-initialization later in this chapter.</p>
</div>
<h4 id="slices" >Slices</h4>
<div class="hBody-4" >
<p>Slices are similar to arrays, but their size can be altered on runtime. This is achieved, thanks to the underlying structure of a slice that is an array. So, like arrays, you have to specify the type of the slice and its size. So, use the following line to create a slice:</p>
<pre class="code" ><code class="chroma" ><span class="nx">mySlice</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
</code></pre>
<p>This command has created an underlying array of ten elements. If we need to change the size of the slice by, for example, adding a new number, we would append the number to the slice:</p>
<pre class="code" ><code class="chroma" ><span class="nx">mySlice</span> <span class="o">:=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">mySlice</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
</code></pre>
<p>The syntax of append is of the form ([array to append an item to], [item to append]) and returns the new slice, it does not modify the actual slice. This is also true to delete an item. For example, let&#39;s delete the first item of the array as following:</p>
<pre class="code" ><code class="chroma" ><span class="nx">mySlice</span> <span class="o">:=</span> <span class="nx">mySlice</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
</code></pre>
<p>Yes, like in arrays. But what about deleting the second item? We use the same syntax:</p>
<pre class="code" ><code class="chroma" ><span class="nx">mySlice</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">mySlice</span><span class="p">[:</span><span class="mi">1</span><span class="p">],</span> <span class="nx">mySlice</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span><span class="o">...</span><span class="p">)</span>
</code></pre>
<p>We take all elements from zero index (included) to the first index (not included) and each element from the second index (included) to the end of the array, effectively deleting the value at the second position in the slice (index 1 as we start counting with 0). As you can see, we use the undetermined arguments syntax as the second parameter.</p>
</div>
<h4 id="maps" >Maps</h4>
<div class="hBody-4" >
<p>Maps are like dictionaries--for each word, we have a definition but we can use any type as word or definition and they&#39;ll never be ordered alphabetically. We can create maps of string that point to numbers, a string that points to <em>interfaces</em> and <em>structs</em> that point to <code>int</code> and <code>int</code> to <em>function</em>. You cannot use as key: slices, the functions, and maps. Finally, you create maps by using the keyword make and specifying the key type and the value type:</p>
<pre class="code" ><code class="chroma" ><span class="nx">myMap</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int</span><span class="p">)</span>
<span class="nx">myMap</span><span class="p">[</span><span class="s">&#34;one&#34;</span><span class="p">]</span> <span class="p">=</span> <span class="mi">1</span>
<span class="nx">myMap</span><span class="p">[</span><span class="s">&#34;two&#34;</span><span class="p">]</span> <span class="p">=</span> <span class="mi">2</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">myMap</span><span class="p">[</span><span class="s">&#34;one&#34;</span><span class="p">])</span>
</code></pre>
<p>When parsing JSON content, you can also use them to get a <code>string[interface]</code> map:</p>
<pre class="code" ><code class="chroma" ><span class="nx">myJsonMap</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kd">interface</span><span class="p">{})</span>
<span class="nx">jsonData</span> <span class="o">:=</span> <span class="p">[]</span><span class="nb">byte</span><span class="p">(</span><span class="s">`{&#34;hello&#34;:&#34;world&#34;}`</span><span class="p">)</span>
<span class="nx">err</span> <span class="o">:=</span> <span class="nx">json</span><span class="p">.</span><span class="nx">Unmarshal</span><span class="p">(</span><span class="nx">jsonData</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">myJsonMap</span><span class="p">)</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
  <span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
<span class="p">}</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&#34;%s\n&#34;</span><span class="p">,</span> <span class="nx">myJsonMap</span><span class="p">[</span><span class="s">&#34;hello&#34;</span><span class="p">])</span>
</code></pre>
<p>The <code>myJsonMap</code> variable is a map that will store the contents of JSON and that we will need to pass its pointer to the <code>Unmarshal</code> function. The <code>jsonData</code> variable declares an array of bytes with the typical content of a JSON object; we are using this as the mock object. Then, we unmarshal the contents of the JSON storing the result of the memory location of <code>myJsonMap</code> variable. After checking that the conversion was ok and the JSON byte array didn&#39;t have syntax mistakes, we can access the contents of the map in a JSON-like syntax.</p>
</div>
<h3 id="visibility" >Visibility</h3>
<div class="hBody-3" >
<p>Visibility is the attribute of a function or a variable to be visible to different parts of the program. So a variable can be used only in the function that is declared, in the entire package or in the entire program.</p>
<p>How can I set the visibility of a variable or function? Well, it can be confusing at the beginning but it cannot be simpler:</p>
<ul>
<li>
<p>Uppercase definitions are public (visible in the entire program).</p>
</li>
<li>
<p>Lowercase are private (not seen at the package level) and function definitions (variables within functions) are visible just in the scope of the function.</p>
</li>
</ul>
<p>Here you can see an example of a <em>public</em> function:</p>
<pre class="code" ><code class="chroma" ><span class="kn">package</span> <span class="nx">hello</span>

<span class="kd">func</span> <span class="nx">Hello_world</span><span class="p">(){</span>
  <span class="nb">println</span><span class="p">(</span><span class="s">&#34;Hello World!&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
<p>Here, <code>Hello_world</code> is a global function (a function that is visible across the entire source code and to third party users of your code). So, if our package is called <code>hello</code>, we could call this function from outside of this package by using <code>hello.Hello_world()</code> method.</p>
<pre class="code" ><code class="chroma" ><span class="kn">package</span> <span class="nx">different_package</span>

<span class="kn">import</span> <span class="s">&#34;github.com/sayden/go-design-patters/first_chapter/hello&#34;</span>

<span class="kd">func</span> <span class="nx">myLibraryFunc</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">hello</span><span class="p">.</span><span class="nx">Hello_world</span><span class="p">()</span>
<span class="p">}</span>
</code></pre>
<p>As you can see, we are in the <code>different_package</code> package. We have to import the package we want to use with the keyword import. The route then is the path within your <span class="file" >$GOPATH/src</span> that contains the package we are looking for. This path conveniently matches the URL of a GitHub account or any other <b>Concurrent Versions System</b> (<span class="acronym" >CVS</span>) repository.</p>
</div>
<h3 id="zero-initialization" >Zero-initialization</h3>
<div class="hBody-3" >
<p>Zero-initialization is a source of confusion sometimes. They are default values for many types that are assigned even if you don&#39;t provide a value for the definition. Following are the zero-initialization for various types:</p>
<ul>
<li>
<p>The <code>false</code> initialization for <code>bool</code> type.</p>
</li>
<li>
<p>Using <code>0</code> values for <code>int</code> type.</p>
</li>
<li>
<p>Using <code>0.0</code> for <code>float</code> type.</p>
</li>
<li>
<p>Using <code>&#34;&#34;</code> (empty strings) for <code>string</code> type.</p>
</li>
<li>
<p>Using <code>nil</code> keyword for pointers, functions, interfaces, slices, channels and maps.</p>
</li>
<li>
<p>Empty <code>struct</code> for structures without fields.</p>
</li>
<li>
<p>Zero-initialized <code>struct</code> for structures with fields. The zero value of a structure is defined as the structure that has its fields initialized as zero value too.</p>
</li>
</ul>
<p>Zero-initialization is important when programming in Go because you won&#39;t be able to return a <code>nil</code> value if you have to return an <code>int</code> type or a <code>struct</code>. Keep this in mind, for example, in functions where you have to return a <code>bool</code> value. Imagine that you want to know if a number is divisible by a different number but you pass <code>0</code> (zero) as the divisor.</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">res</span> <span class="o">:=</span> <span class="nx">divisibleBy</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&#34;%v\n&#34;</span><span class="p">,</span> <span class="nx">res</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">divisibleBy</span><span class="p">(</span><span class="nx">n</span><span class="p">,</span> <span class="nx">divisor</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
  <span class="k">if</span> <span class="nx">divisor</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
    <span class="c1">// You cannot divide by zero
</span><span class="c1"></span>    <span class="k">return</span> <span class="kc">false</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="p">(</span><span class="nx">n</span> <span class="o">%</span> <span class="nx">divisor</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
<p>The output of this program is <code>false</code> but this is incorrect. A number divided by zero is an error, it&#39;s not that 10 isn&#39;t divisible by zero but that a number cannot be divided by zero by definition. Zero-initialization is making things awkward in this situation. So, how can we solve this error? Consider the following code:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">res</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">divisibleBy</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">log</span><span class="p">.</span><span class="nx">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="nx">log</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&#34;%v\n&#34;</span><span class="p">,</span> <span class="nx">res</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">divisibleBy</span><span class="p">(</span><span class="nx">n</span><span class="p">,</span> <span class="nx">divisor</span> <span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="kt">bool</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="nx">divisor</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
    <span class="c1">// You cannot divide by zero
</span><span class="c1"></span>    <span class="k">return</span> <span class="kc">false</span><span class="p">,</span> <span class="nx">errors</span><span class="p">.</span><span class="nx">New</span><span class="p">(</span><span class="s">&#34;A number cannot be divided by zero&#34;</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="p">(</span><span class="nx">n</span> <span class="o">%</span> <span class="nx">divisor</span> <span class="o">==</span> <span class="mi">0</span><span class="p">),</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre>
<p>We&#39;re dividing <code>10</code> by <code>0</code> again but now the output of this function is <code>A number cannot be divided by zero</code>. Error captured, the program finished gracefully.</p>
</div>
<h3 id="pointers-and-structures" >Pointers and structures</h3>
<div class="hBody-3" >
<p>Pointers are the number one source of a headache of every C or C++ programmer. But they are one of the main tools to achieve high-performance code in non-garbage-collected languages. Fortunately for us, Go&#39;s pointers have achieved the best of both worlds by providing high-performance pointers with garbage-collector capabilities and easiness.</p>
<p>On the other side for its detractors, Go lacks inheritance in favor of composition. Instead of talking about the objects that <i>are</i> in Go, your objects <i>have other</i>. So, instead of having a <code>car</code> structure that inherits the class <code>vehicle</code> (a car is a vehicle), you could have a <code>vehicle</code> structure that contains a <code>car</code> structure within.</p>
</div>
<h4 id="what-is-a-pointer?-why-are-they-good?" >What is a pointer? Why are they good?</h4>
<div class="hBody-4" >
<p>Pointers are hated, loved, and very useful at the same time. To understand what a pointer is can be difficult so let&#39;s try with a real world explanation. As we mentioned earlier in this chapter, a pointer is a like a mailbox. Imagine a bunch of mailboxes in a building; all of them have the same size and shape but each refers to a different house within the building. Just because all mailboxes are the same size does not mean that each house will have the same size. We could even have a couple of houses joined, a house that was there but now has a license of commerce, or a house that is completely empty. So the pointers are the mailboxes, all of them of the same size and that refer to a house. The building is our memory and the houses are the types our pointers refer to and the memory they allocate. If you want to receive something in your house, it&#39;s far easier to simply send the address of your house (to send the pointer) instead of sending the entire house so that your package is deposited inside. But they have some drawbacks as if you send your address and your house (variable it refers to) disappears after sending, or its type owner change--you&#39;ll be in trouble.</p>
<p>How is this useful? Imagine that somehow you have 4 GB of data in a variable and you need to pass it to a different function. Without a pointer, the entire variable is cloned to the scope of the function that is going to use it. So, you&#39;ll have 8 GB of memory occupied by using this variable twice that, hopefully, the second function isn&#39;t going to use in a different function again to raise this number even more.</p>
<p>You could use a pointer to pass a very small reference to this chunk to the first function so that just the small reference is cloned and you can keep your memory usage low.</p>
<p>While this isn&#39;t the most academic nor exact explanation, it gives a good view of what a pointer is without explaining what a stack or a heap is or how they work in x86 architectures.</p>
<p>Pointers in Go are very limited compared with C or C++ pointers. You can&#39;t use pointer arithmetic nor can you create a pointer to reference an exact position in the stack.</p>
<p>Pointers in Go can be declared like this:</p>
<pre class="code" ><code class="chroma" ><span class="nx">number</span> <span class="o">:=</span> <span class="mi">5</span>
</code></pre>
<p>Here <code>number := 5</code> code represents our 4 GB variable and <code>pointer_to_number</code> contains the reference (represented by an ampersand) to this variable. It&#39;s the direction to the variable (the one that you put in the mailbox of this <span class="file" >house/type/variable</span>). Let&#39;s print the variable <code>pointer_to_number</code>, which is a simple variable:</p>
<pre class="code" ><code class="chroma" ><span class="nb">println</span><span class="p">(</span><span class="nx">pointer_to_number</span><span class="p">)</span>
<span class="mh">0x005651FA</span>
</code></pre>
<p>What&#39;s that number? Well, the direction to our variable in memory. And how can I print the actual value of the house? Well, with an asterisk (*) we tell the compiler to take the value that the pointer is referencing, which is our 4 GB variable.</p>
<pre class="code" ><code class="chroma" ><span class="nb">println</span><span class="p">(</span><span class="o">*</span><span class="nx">pointer_to_number</span><span class="p">)</span>
<span class="mi">5</span>
</code></pre>
</div>
<h4 id="structs" >Structs</h4>
<div class="hBody-4" >
<p>A struct is an object in Go. It has some similarities with classes in OOP as they have fields. Structs can implement interfaces and declare methods. But, for example, in Go, there&#39;s not inheritance. Lack of inheritance looks limiting but in fact, <i>composition over inheritance</i> was a requirement of the language.</p>
<p>To declare a structure, you have to prefix its name with the keyword <code>type</code> and suffix with the keyword <code>struct</code> and then you declare any field or method between brackets, for example:</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">Person</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">Name</span> <span class="kt">string</span>
  <span class="nx">Surname</span> <span class="kt">string</span>
  <span class="nx">Hobbies</span> <span class="p">[]</span><span class="kt">string</span>
  <span class="nx">id</span> <span class="kt">string</span>
<span class="p">}</span>
</code></pre>
<p>In this piece of code, we have declared a <code>Person</code> structure with three public fields (<code>Name</code>, <code>Age</code>, and <code>Hobbies</code>) and one private field (<code>id</code>, if you recall the <i>Visibility</i> section in this chapter, lowercase fields in Go refers to private fields are just visible within the same package). With this <code>struct</code>, we can now create as many instances of <code>Person</code> as we want. Now we will write a function called <code>GetFullName</code> that will give the composition of the name and the surname of the <code>struct</code> it belongs to:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="p">(</span><span class="nx">person</span> <span class="o">*</span><span class="nx">Person</span><span class="p">)</span> <span class="nx">GetFullName</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintf</span><span class="p">(</span><span class="s">&#34;%s %s&#34;</span><span class="p">,</span> <span class="nx">person</span><span class="p">.</span><span class="nx">Name</span><span class="p">,</span> <span class="nx">person</span><span class="p">.</span><span class="nx">Surname</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">p</span> <span class="o">:=</span> <span class="nx">Person</span><span class="p">{</span>
    <span class="nx">Name</span><span class="p">:</span> <span class="s">&#34;Mario&#34;</span><span class="p">,</span>
    <span class="nx">Surname</span><span class="p">:</span> <span class="s">&#34;Castro&#34;</span><span class="p">,</span>
    <span class="nx">Hobbies</span><span class="p">:</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;cycling&#34;</span><span class="p">,</span> <span class="s">&#34;electronics&#34;</span><span class="p">,</span> <span class="s">&#34;planes&#34;</span><span class="p">},</span>
    <span class="nx">id</span><span class="p">:</span> <span class="s">&#34;sa3-223-asd&#34;</span><span class="p">,</span>
  <span class="p">}</span>

  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&#34;%s likes %s, %s and %s\n&#34;</span><span class="p">,</span> <span class="nx">p</span><span class="p">.</span><span class="nx">GetFullName</span><span class="p">(),</span>
    <span class="nx">p</span><span class="p">.</span><span class="nx">Hobbies</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nx">p</span><span class="p">.</span><span class="nx">Hobbies</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nx">p</span><span class="p">.</span><span class="nx">Hobbies</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
<span class="p">}</span>
</code></pre>
<p>Methods are defined similarly to functions but in a slightly different way. There is a (<code>p *Person</code>) that refers to a pointer to the created instance of the <code>struct</code> (recall the <i>Pointers</i> section in this chapter). It&#39;s like using the keyword <code>this</code> in Java or <code>self</code> in Python when referring to the pointing object.</p>
<p>Maybe you are thinking why does (<code>p *Person</code>) have the pointer operator to reflect that <code>p</code> is actually a pointer and not a value? This is because you can also pass Person by value by removing the pointer signature, in which case a copy of the value of Person is passed to the function. This has some implications, for example, any change that you make in <code>p</code> if you pass it by value won&#39;t be reflected in source <code>p</code>. But what about our <code>GetFullName()</code> method?</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="p">(</span><span class="nx">person</span> <span class="nx">Person</span><span class="p">)</span> <span class="nx">GetFullName</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintf</span><span class="p">(</span><span class="s">&#34;%s %s&#34;</span><span class="p">,</span> <span class="nx">person</span><span class="p">.</span><span class="nx">Name</span><span class="p">,</span> <span class="nx">person</span><span class="p">.</span><span class="nx">Surname</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
<p>Its console output has no effect in appearance but a full copy was passed before evaluating the function. But if we modify <code>person</code> here, the source <code>p</code> won&#39;t be affected and the new <code>person</code> value will be available only on the scope of this function.</p>
<p>On the <code>main</code> function, we create an instance of our structure called <code>p</code>. As you can see, we have used implicit notation to create the variable (the <code>:=</code> symbol). To set the fields, you have to refer to the name of the field, colon, the value, and the comma (don&#39;t forget the comma at the end!). To access the fields of the instantiated structure, we just refer to them by their name like <code>p.Name</code> or <code>p.Surname</code>. You use the same syntax to access the methods of the structure like <code>p.GetFullName()</code>.</p>
<p>The output of this program is:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go run main.go
</span><span class="out" >Mario Castro likes cycling, electronics and planes
</span></code></pre>
<p>Structures can also contain another structure (composition) and implement interface methods apart from their own but, what&#39;s an interface method?</p>
</div>
<h3 id="interfaces" >Interfaces</h3>
<div class="hBody-3" >
<p>Interfaces are essential in object-oriented programming, in functional programming (<code>traits</code>) and, especially, in design patterns. Go&#39;s source code is full of interfaces everywhere because they provide the abstraction needed to deliver uncoupled code with the help of functions. As a programmer, you also need this type of abstraction when you write libraries but also when you write code that is going to be maintained in the future with new functionality.</p>
<p>Interfaces are something difficult to grasp at the beginning but very easy once you have understood their behavior and provide very elegant solutions for common problems. We will use them extensively during this book so put special focus on this section.</p>
</div>
<h4 id="interfaces---signing-a-contract" >Interfaces - signing a contract</h4>
<div class="hBody-4" >
<p>An interface is something really simple but powerful. It&#39;s usually defined as a contract between the objects that implement it but this explanation isn&#39;t clear enough in my honest opinion for newcomers to the interface world.</p>
<p>A water-pipe is a contract too; whatever you pass through it must be a liquid. Anyone can use the pipe, and the pipe will transport whatever liquid you put in it (without knowing the content). The water-pipe is the interface that enforces that the users must pass liquids (and not something else).</p>
<p>Let&#39;s think about another example: a train. The railroads of a train are like an interface. A train must construct (implement) its width with a specified value so that it can enter the railroad but the railroad never knows exactly what it&#39;s carrying (passengers or cargo). So for example, an interface of the railroad will have the following aspect:</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">RailroadWideChecker</span> <span class="kd">interface</span> <span class="p">{</span>
  <span class="nx">CheckRailsWidth</span><span class="p">()</span> <span class="kt">int</span>
<span class="p">}</span>
</code></pre>
<p>The <code>RailroadWideChecker</code> is the type our trains must implement to provide information about their width. The trains will verify that the train isn&#39;t too wide or too narrow to use its railroads:</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">Railroad</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">Width</span> <span class="kt">int</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">Railroad</span><span class="p">)</span> <span class="nx">IsCorrectSizeTrain</span><span class="p">(</span><span class="nx">r</span> <span class="nx">RailRoadWideChecker</span><span class="p">)</span>
<span class="kt">bool</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">r</span><span class="p">.</span><span class="nx">CheckRailsWidth</span><span class="p">()</span> <span class="o">!=</span> <span class="nx">r</span><span class="p">.</span><span class="nx">Width</span>
<span class="p">}</span>
</code></pre>
<p>The <code>Railroad</code> is implemented by an imaginary station object that contains the information about the width of the railroads in this station and that has a method to check whether a train fits the needs of the railroad with the <code>IsCorrectSizeTrain</code> method. The <code>IsCorrectSizeTrain</code> method receives an interface object which is a pointer to a train that implements this interface and returns a validation between the width of the train and the railroad:</p>
<pre class="code" ><code class="chroma" ><span class="nx">Type</span> <span class="nx">Train</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">TrainWidth</span> <span class="kt">int</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">Train</span><span class="p">)</span> <span class="nx">CheckRailsWidth</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">p</span><span class="p">.</span><span class="nx">TrainWidth</span>
<span class="p">}</span>
</code></pre>
<p>Now we have created a passenger&#39;s train. It has a field to contain its width and implements our <code>CheckRailsWidth</code> interface method. This structure is considered to fulfill the needs of a <code>RailRoadWideChecker</code> interface (because it has an implementation of the methods that the interfaces ask for).</p>
<p>So now, we&#39;ll create a railroad of <code>10</code> units wide and two trains--one of <code>10</code> units wide that fit the railroad size and another of <code>15</code> units that cannot use the railroad.</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">main</span><span class="p">(){</span>
  <span class="nx">railroad</span> <span class="o">:=</span> <span class="nx">Railroad</span><span class="p">{</span><span class="nx">Width</span><span class="p">:</span><span class="mi">10</span><span class="p">}</span>

  <span class="nx">passengerTrain</span> <span class="o">:=</span> <span class="nx">Train</span><span class="p">{</span><span class="nx">TrainWidth</span><span class="p">:</span> <span class="mi">10</span><span class="p">}</span>
  <span class="nx">cargoTrain</span> <span class="o">:=</span> <span class="nx">Train</span> <span class="p">{</span><span class="nx">TrainWidth</span><span class="p">:</span> <span class="mi">15</span><span class="p">}</span>

  <span class="nx">canPassengerTrainPass</span> <span class="o">:=</span> <span class="nx">railroad</span><span class="p">.</span><span class="nx">IsCorrectSizeTrain</span><span class="p">(</span><span class="nx">passengerTrain</span><span class="p">)</span>
  <span class="nx">canCargoTrainPass</span> <span class="o">:=</span> <span class="nx">railroad</span><span class="p">.</span><span class="nx">IsCorrectSizeTrain</span><span class="p">(</span><span class="nx">cargoTrain</span><span class="p">)</span>

  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&#34;Can passenger train pass? %b\n&#34;</span><span class="p">,</span> <span class="nx">canPassengerTrainPass</span><span class="p">)</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&#34;Can cargo train pass? %b\n&#34;</span><span class="p">,</span> <span class="nx">canCargoTrainPass</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
<p>Let&#39;s dissect this <code>main</code> function. First, we created a railroad object of <code>10</code> units called <code>railroad</code>. Then two trains, of <code>10</code> and <code>15</code> units&#39; width for passengers and cargo respectively. Then, we pass both objects to the railroad method that accepts interfaces of the <code>RailroadWideChecker</code> interface. The railroad itself does not know the width of each train separately (we&#39;ll have a huge list of trains) but it has an interface that trains must implement so that it can ask for each width and returns a value telling you if a train can or cannot use of the railroads. Finally, the output of the call to <code>printf</code> function is the following:</p>
<pre class="srci" ><code class="sh" ><span class="out" >Can passenger train pass? true
Can cargo train pass? false
</span></code></pre>
<p>As I mentioned earlier, interfaces are so widely used during this book that it doesn&#39;t matter if it still looks confusing for the reader as they&#39;ll be plenty of examples during the book.</p>
</div>
<h3 id="testing-and-tdd" >Testing and TDD</h3>
<div class="hBody-3" >
<p>When you write the first lines of some library, it&#39;s difficult to introduce many bugs. But once the source code gets bigger and bigger, it becomes easier to break things. The team grows and now many people are writing the same source code, new functionality is added on top of the code that you wrote at the beginning. And code stopped working by some modification in some function that now nobody can track down.</p>
<p>This is a common scenario in enterprises that testing tries to reduce (it doesn&#39;t completely solve it, it&#39;s not a holy grail). When you write unit tests during your development process, you can check whether some new feature is breaking something older or whether your current new feature is achieving everything expected in the requirements.</p>
<p>Go has a powerful testing package that allows you also to work in a TDD environment quite easily. It is also very convenient to check the portions of your code without the need to write an entire main application that uses it.</p>
</div>
<h4 id="the-testing-package" >The testing package</h4>
<div class="hBody-4" >
<p>Testing is very important in every programming language. Go creators knew it and decided to provide all libraries and packages needed for the test in the core package. You don&#39;t need any third-party library for testing or code coverage.</p>
<p>The package that allows for testing Go apps is called, conveniently, testing. We will create a small app that sums two numbers that we provide through the command line:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// Atoi converts a string to an int
</span><span class="c1"></span>  <span class="nx">a</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">strconv</span><span class="p">.</span><span class="nx">Atoi</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Args</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
  <span class="nx">b</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">strconv</span><span class="p">.</span><span class="nx">Atoi</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Args</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>

  <span class="nx">result</span> <span class="o">:=</span> <span class="nx">sum</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span><span class="nx">b</span><span class="p">)</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&#34;The sum of %d and %d is %d\n&#34;</span><span class="p">,</span> <span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">,</span> <span class="nx">result</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">sum</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">a</span> <span class="o">+</span> <span class="nx">b</span>
<span class="p">}</span>
</code></pre>
<p>Let&#39;s execute our program in the terminal to get the sum:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go run main.go <span class="m">3</span> <span class="m">4</span>
</span><span class="out" >The sum of 3 and 4 is 7
</span></code></pre>
<p>By the way, we&#39;re using the <code>strconv</code> package to convert strings to other types, in this case, to <code>int</code>. The method <code>Atoi</code> receives a string and returns an <code>int</code> and an <code>error</code> that, for simplicity, we are ignoring here (by using the underscore).</p>
<div class="about" >
<div class="about-dt" >Tip</div>
<div class="about-dd" >
<p>You can ignore variable returns by using the underscores if necessary, but usually, you don&#39;t want to ignore errors.</p>
</div>
</div>
<p>Ok, so let&#39;s write a test that checks the correct result of the sum. We&#39;re creating a new file called <span class="file" >main_test.go</span>. By convention, test files are named like the files they&#39;re testing plus the <code>_test</code> suffix:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">TestSum</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">a</span> <span class="o">:=</span> <span class="mi">5</span>
  <span class="nx">b</span> <span class="o">:=</span> <span class="mi">6</span>
  <span class="nx">expected</span> <span class="o">:=</span> <span class="mi">11</span>

  <span class="nx">res</span> <span class="o">:=</span> <span class="nx">sum</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span>
  <span class="k">if</span> <span class="nx">res</span> <span class="o">!=</span> <span class="nx">expected</span> <span class="p">{</span>
    <span class="nx">t</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&#34;Our sum function doens&#39;t work, %d+%d isn&#39;t %d\n&#34;</span><span class="p">,</span> <span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">,</span> <span class="nx">res</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>Testing in Go is used by writing methods started with the prefix <code>Test</code>, a test name, and the injection of the <code>testing.T</code> pointer called <code>t</code>. Contrary to other languages, there are no asserts nor special syntax for testing in Go. You can use Go syntax to check for errors and you call <code>t</code> with information about the error in case it fails. If the code reaches the end of the <code>Test</code> function without arising errors, the function has passed the tests.</p>
<p>To run a test in Go, you must use the <code class="command" >go test -v</code> command (<code>-v</code> is to receive verbose output from the test) keyword, as following:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go <span class="nb">test</span> -v
</span><span class="out" >=== RUN   TestSum
--- PASS: TestSum (0.00s)
PASS
ok   github.com/go-design-patterns/introduction/ex_xx_testing 0.001s
</span></code></pre>
<p>Our tests were correct. Let&#39;s see what happens if we break things on purpose and we change the expected value of the test from <code>11</code> to <code>10</code>:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go <span class="nb">test</span>
</span><span class="out" >--- FAIL: TestSum (0.00s)
    main_test.go:12: Our sum function doens&#39;t work, 5+6 isn&#39;t 10
FAIL
exit status 1
FAIL  github.com/sayden/go-design-patterns/introduction/ex_xx_testing 0.002s
</span></code></pre>
<p>The test has failed (as we expected). The testing package provides the information you set on the test. Let&#39;s make it work again and check test coverage. Change the value of the variable <code>expected</code> from <code>10</code> to <code>11</code> again and run the command <code class="command" >go test -cover</code> to see code coverage:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go <span class="nb">test</span> -cover
</span><span class="out" >PASS
coverage: 20.0% of statements
ok  github.com/sayden/go-design-patterns/introduction/ex_xx_testing 0.001s
</span></code></pre>
<p>The <code>-cover</code> options give us information about the code coverage for a given package. Unfortunately, it doesn&#39;t provide information about overall application coverage.</p>
</div>
<h4 id="what-is-tdd?" >What is TDD?</h4>
<div class="hBody-4" >
<p>TDD is the acronym for <b>Test Driven Development</b>. It consists of writing the tests first before writing the function (instead of what we did just before when we wrote the <code>sum</code> function first and then we wrote the test function).</p>
<p>TDD changes the way to write code and structure code so that it can be tested (a lot of code you can find in GitHub, even code that you have probably written in the past is probably very difficult, if not impossible, to test).</p>
<p>So, how does it work? Let&#39;s explain this with a real life example--imagine that you are in summer and you want to be refreshed somehow.  You can build a pool, fill it with cold water, and jump into it. But in TDD terms, the steps will be:</p>
<ol class="num" >
<li>
<p>You jump into a place where the pool will be built (you write a test that you know it will fail).</p>
</li>
<li>
<p>It hurts... and you aren&#39;t cool either (yes... the test failed, as we predicted).</p>
</li>
<li>
<p>You build a pool and fill it with cold water (you code the functionality).</p>
</li>
<li>
<p>You jump into the pool (you repeat the point 1 test again).</p>
</li>
<li>
<p>You&#39;re cold now. Awesome! Object completed (test passed).</p>
</li>
<li>
<p>Go to the fridge and take a beer to the pool. Drink. Double awesomeness (refactor the code).</p>
</li>
</ol>
<p>So let&#39;s repeat the previous example but with a multiplication. First, we will write the declaration of the function that we&#39;re going to test:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">multiply</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
  <span class="k">return</span> <span class="mi">0</span>
<span class="p">}</span>
</code></pre>
<p>Now let&#39;s write the test that will check the correctness of the previous function:</p>
<pre class="code" ><code class="chroma" ><span class="kn">import</span> <span class="s">&#34;testing&#34;</span>

<span class="kd">func</span> <span class="nx">TestMultiply</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">a</span> <span class="o">:=</span> <span class="mi">5</span>
  <span class="nx">b</span> <span class="o">:=</span> <span class="mi">6</span>
  <span class="nx">expected</span> <span class="o">:=</span> <span class="mi">30</span>

  <span class="nx">res</span> <span class="o">:=</span> <span class="nx">multiply</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span>
  <span class="k">if</span> <span class="nx">res</span> <span class="o">!=</span> <span class="nx">expected</span> <span class="p">{</span>
    <span class="nx">t</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&#34;Our multiply function doens&#39;t work, %d*%d isn&#39;t %d\n&#34;</span><span class="p">,</span> <span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">,</span> <span class="nx">res</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>And we test it through the command line:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go <span class="nb">test</span>
</span><span class="out" >--- FAIL: TestMultiply (0.00s)
main_test.go:12: Our multiply function doens&#39;t work, 5+6 isn&#39;t 0
FAIL
exit status 1
FAIL    github.com/sayden/go-designpatterns/introduction/ex_xx_testing/multiply

0.002s
</span></code></pre>
<p>Nice. Like in our pool example where the water wasn&#39;t there yet, our function returns an incorrect value too. So now we have a function declaration (but isn&#39;t defined yet) and the test that fails. Now we have to make the test pass by writing the function and executing the test to check:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">multiply</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">a</span><span class="o">*</span><span class="nx">b</span>
<span class="p">}</span>
</code></pre>
<p>And we execute again our testing suite. After writing our code correctly, the test should pass so we can continue to the refractoring process:</p>
<pre class="code" ><code class="chroma" ><span class="p">&gt;</span> <span class="k">go</span> <span class="nx">test</span>
<span class="nx">PASS</span>
<span class="nx">ok</span>      <span class="nx">github</span><span class="p">.</span><span class="nx">com</span><span class="o">/</span><span class="nx">sayden</span><span class="o">/</span><span class="k">go</span><span class="o">-</span><span class="nx">design</span><span class="o">-</span><span class="nx">patterns</span><span class="o">/</span><span class="nx">introduction</span><span class="o">/</span><span class="nx">ex_xx_testing</span><span class="o">/</span><span class="nx">multiply</span> <span class="mf">0.001</span><span class="nx">s</span>
</code></pre>
<p>Great! We have developed the <code>multiply</code> function following TDD. Now we must refactor our code but we cannot make it more simple or readable so the loop can be considered closed.</p>
<p>During this book, we will write many tests that define the functionality that we want to achieve in our patterns. TDD promotes encapsulation and abstraction (just like design patterns do).</p>
</div>
<h3 id="libraries" >Libraries</h3>
<div class="hBody-3" >
<p>Until now, most of our examples were applications. An application is defined by its <code>main</code> function and package. But with Go, you can also create pure libraries. In libraries, the package need not be called main nor do you need the <code>main</code> function.</p>
<p>As libraries aren&#39;t applications, you cannot build a binary file with them and you need the <code>main</code> package that is going to use them.</p>
<p>For example, let&#39;s create an arithmetic library to perform common operations on integers: sums, subtractions, multiplications, and divisions. We&#39;ll not get into many details about the implementation to focus on the particularities of Go&#39;s libraries:</p>
<pre class="code" ><code class="chroma" ><span class="kn">package</span> <span class="nx">arithmetic</span>

<span class="kd">func</span> <span class="nx">Sum</span><span class="p">(</span><span class="nx">args</span> <span class="o">...</span><span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="nx">res</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">args</span> <span class="p">{</span>
    <span class="nx">res</span> <span class="o">+=</span> <span class="nx">v</span>
  <span class="p">}</span>
  <span class="k">return</span>
<span class="p">}</span>
</code></pre>
<p>First, we need a name for our library; we set this name by giving a name to the entire package. This means that every file in this folder must have this package name too and the entire group of files composes the library called <b>arithmetic</b> too in this case (because it only contains one package). This way, we won&#39;t need to refer to the filenames for this library and to provide the library name and path will be enough to import and use it. We have defined a <code>Sum</code> function that takes as many arguments as you need and that will return an integer that, during the scope of the function, is going to be called <code>res</code>. This allows us to initialize to 0 the value we&#39;re returning. We defined a package (not the <code>main</code> package but a library one) and called it <code>arithmetic</code>. As this is a library package, we can&#39;t run it from the command line directly so we&#39;ll have to create the <code>main</code> function for it or a unit test file. For simplicity , we&#39;ll create a <code>main</code> function that runs some of the operations now but let&#39;s finish the library first:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">Subtract</span><span class="p">(</span><span class="nx">args</span> <span class="o">...</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">args</span><span class="p">)</span> <span class="p">&lt;</span> <span class="mi">2</span> <span class="p">{</span>
    <span class="k">return</span> <span class="mi">0</span>
  <span class="p">}</span>

  <span class="nx">res</span> <span class="o">:=</span> <span class="nx">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
  <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">args</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
    <span class="nx">res</span> <span class="o">-=</span> <span class="nx">args</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">res</span>
<span class="p">}</span>
</code></pre>
<p>The <code>Subtraction</code> code will return 0 if the number of arguments is less than zero and the subtraction of all its arguments if it has two arguments or more:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">Multiply</span><span class="p">(</span><span class="nx">args</span> <span class="o">...</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">args</span><span class="p">)</span> <span class="p">&lt;</span> <span class="mi">2</span> <span class="p">{</span>
    <span class="k">return</span> <span class="mi">0</span>
  <span class="p">}</span>

  <span class="nx">res</span> <span class="o">:=</span> <span class="mi">1</span>
  <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">args</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
    <span class="nx">res</span> <span class="o">*=</span> <span class="nx">args</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">res</span>
<span class="p">}</span>
</code></pre>
<p>The <code>Multiply</code> function works in a similar fashion. It returns 0 when arguments are less than two and the multiplication of all its arguments when it has two or more. Finally, the <code>Division</code> code changes a bit because it will return an error if you ask it to divided by zero:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">Divide</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="kt">float64</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="nx">b</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">errors</span><span class="p">.</span><span class="nx">New</span><span class="p">(</span><span class="s">&#34;You cannot divide by zero&#34;</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nb">float64</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float64</span><span class="p">(</span><span class="nx">b</span><span class="p">),</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre>
<p>So now we have our library finished, but we need a <code>main</code> function to use it as libraries cannot be converted to executable files directly. Our main function looks like the following:</p>
<pre class="code" ><code class="chroma" ><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
  <span class="s">&#34;fmt&#34;</span>

  <span class="s">&#34;bitbucket.org/mariocastro/go-design-patterns/introduction/libraries/arithmetic&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">sumRes</span> <span class="o">:=</span> <span class="nx">arithmetic</span><span class="p">.</span><span class="nx">Sum</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
  <span class="nx">subRes</span> <span class="o">:=</span> <span class="nx">arithmetic</span><span class="p">.</span><span class="nx">Subtract</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
  <span class="nx">multiplyRes</span> <span class="o">:=</span> <span class="nx">arithmetic</span><span class="p">.</span><span class="nx">Multiply</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">7</span><span class="p">)</span>
  <span class="nx">divideRes</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">arithmetic</span><span class="p">.</span><span class="nx">Divide</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&#34;5+6 is %d. 10-5 is %d, 8*7 is %d and 10/2 is %f\n&#34;</span><span class="p">,</span>
    <span class="nx">sumRes</span><span class="p">,</span> <span class="nx">subRes</span><span class="p">,</span> <span class="nx">multiplyRes</span><span class="p">,</span> <span class="nx">divideRes</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
<p>We are performing an operation over every function that we have defined. Take a closer look at the <code>import</code> clause. It is taking the library we have written from its folder within <code>$GOPATH</code> that matches its URL in <a href="https://bitbucket.org/" >https://bitbucket.org/</a>. Then, to use every one of the functions that are defined within a library, you have to name the package name that the library has before each method.</p>
<div class="about" >
<div class="about-dt" >Note</div>
<div class="about-dd" >
<p>Have you realized that we called our functions with uppercase names? Because of the visibility rules we have seen before, exported functions in a package must have uppercase names or they won&#39;t be visible outside of the scope of the package. So, with this rule in mind, you cannot call a lowercase function or variable within a package and package calls will always be followed by uppercase names.</p>
</div>
</div>
<p>Let&#39;s recall, some naming conventions about libraries:</p>
<ul>
<li>
<p>Each file in the same folder must contain the same package name. Files don&#39;t need to be named in any special way.</p>
</li>
<li>
<p>A folder represents a package name within a library. The folder name will be used on import paths and it doesn&#39;t need to reflect the package name (although it&#39;s recommended for the parent package).</p>
</li>
<li>
<p>A library is one or many packages representing a tree that you import by the parent of all packages folder.</p>
</li>
<li>
<p>You call things within a library by their package name.</p>
</li>
</ul>
</div>
<h3 id="the-go-get-tool" >The Go get tool</h3>
<div class="hBody-3" >
<p>Go get is a tool to get third party projects from CVS repositories. Instead of using the <code class="command" >git clone</code> command, you can use Go get to receive a series of added benefits. Let&#39;s write an example using CoreOS&#39;s <b>ETCD</b> project which is a famous distributed key-value store.</p>
<p>CoreOS&#39;s ETCD is hosted on GitHub at <a href="https://github.com/coreos/etcd.git" >https://github.com/coreos/etcd.git</a>. To download this project source code using the Go get tool, we must type in the Terminal it&#39;s resulting import path that it will have in our <code>GOPATH</code>:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go get github.com/coreos/etcd
</span></code></pre>
<p>Note that we have just typed the most relevant information so that Go get figures out the rest. You&#39;ll get some output, depending on the state of the project, but after, while, it will disappear. But what did happen?</p>
<ul>
<li>
<p>Go get has created a folder in <span class="file" >$GOPATH/src/github.com/coreos</span>.</p>
</li>
<li>
<p>It has cloned the project in that location, so now the source code of ETCD is available at <span class="file" >$GOPATH/src/github.com/coreos/etcd</span>.</p>
</li>
<li>
<p>Go get has cloned any repository that ETCD could need.</p>
</li>
<li>
<p>It has tried to install the project if it is not a library. This means, it has generated a binary file of ETCD and has put it in <span class="file" >$GOPATH/bin</span> folder.</p>
</li>
</ul>
<p>By simply typing the <code class="command" >go get [project]</code> command, you&#39;ll get all that material from a project in your system. Then in your Go apps, you can just use any library by importing the path within the source. So for the ETCD project, it will be:</p>
<pre class="code" ><code class="chroma" ><span class="kn">import</span> <span class="s">&#34;github.com/coreos/etcd&#34;</span>
</code></pre>
<p>It&#39;s very important that you get familiar with the use of the Go get tool and stop using <code class="command" >git clone</code> when you want a project from a Git repository. This will save you some headaches when trying to import a project that isn&#39;t contained within your <code>GOPATH</code>.</p>
</div>
<h3 id="managing-json-data" >Managing JSON data</h3>
<div class="hBody-3" >
<p>JSON is the acronym for <b>JavaScript Object Notation</b> and, like the name implies, it&#39;s natively JavaScript. It has become very popular and it&#39;s the most used format for communication today. Go has very good support for JSON serialization/deserialization with the <code>JSON</code> package that does most of the dirty work for you. First of all, there are two concepts to learn when working with JSON:</p>
<ul>
<li>
<p><b>Marshal</b>: When you marshal an instance of a structure or object, you are converting it to its JSON counterpart.</p>
</li>
<li>
<p><b>Unmarshal</b>: When you are unmarshaling some data, in the form of an array of bytes, you are trying to convert some JSON-expected-data to a known struct or object. You can also <i>unmarshal</i> to a <code>map[string]interface{}</code> in a fast but not very safe way to interpret the data as we&#39;ll see now.</p>
</li>
</ul>
<p>Let&#39;s see an example of marshaling a string:</p>
<pre class="code" ><code class="chroma" ><span class="kn">import</span> <span class="p">(</span>
  <span class="s">&#34;encoding/json&#34;</span>
  <span class="s">&#34;fmt&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">(){</span>
  <span class="nx">packt</span> <span class="o">:=</span> <span class="s">&#34;packt&#34;</span>
  <span class="nx">jsonPackt</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">json</span><span class="p">.</span><span class="nx">Marshal</span><span class="p">(</span><span class="nx">packt</span><span class="p">)</span>
  <span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
    <span class="nb">panic</span><span class="p">(</span><span class="s">&#34;Could not marshal object&#34;</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nb">string</span><span class="p">(</span><span class="nx">jsonPackt</span><span class="p">))</span>
<span class="p">}</span>
</code></pre>
<pre class="srci" ><code class="sh" ><span class="out" >&#34;pack&#34;
</span></code></pre>
<p>First, we have defined a variable called <code>packt</code> to hold the contents of the <code>packt</code> string. Then, we have used the <code>json</code> library to use the <code>Marshal</code> command with our new variable. This will return a new <code>bytearray</code> with the JSON and a flag to provide and <code>boolOK</code> result for the operation. When we print the contents of the bytes array (previous casting to string) the expected value appears. Note that <code>packt</code> appeared actually between quotes as the JSON representation would be.</p>
</div>
<h4 id="the-encoding-package" >The encoding package</h4>
<div class="hBody-4" >
<p>Have you realized that we have imported the package <code>encoding/json</code>? Why is it prefixed with the word <code>encoding</code>? If you take a look at Go&#39;s source code to the <span class="file" >src/encoding</span> folder you&#39;ll find many interesting packages for encoding/decoding such as, XML, HEX, binary, or even CSV.</p>
<p>Now something a bit more complicated:</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">MyObject</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">Number</span> <span class="kt">int</span> <span class="s">`json:&#34;number&#34;`</span>
  <span class="nx">Word</span> <span class="kt">string</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">(){</span>
  <span class="nx">object</span> <span class="o">:=</span> <span class="nx">MyObject</span><span class="p">{</span><span class="mi">5</span><span class="p">,</span> <span class="s">&#34;Packt&#34;</span><span class="p">}</span>
  <span class="nx">oJson</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">json</span><span class="p">.</span><span class="nx">Marshal</span><span class="p">(</span><span class="nx">object</span><span class="p">)</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&#34;%s\n&#34;</span><span class="p">,</span> <span class="nx">oJson</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
<pre class="srci" ><code class="sh" ><span class="out" >{&#34;Number&#34;:5,&#34;Word&#34;:&#34;Packt&#34;}
</span></code></pre>
<p>Conveniently, it also works pretty well with structures but what if I want to not use uppercase in the JSON data? You can define the output/input name of the JSON in the structure declaration:</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">MyObject</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">Number</span> <span class="kt">int</span>
  <span class="nx">Word</span> <span class="kt">string</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">(){</span>
  <span class="nx">object</span> <span class="o">:=</span> <span class="nx">MyObject</span><span class="p">{</span><span class="mi">5</span><span class="p">,</span> <span class="s">&#34;Packt&#34;</span><span class="p">}</span>
  <span class="nx">oJson</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">json</span><span class="p">.</span><span class="nx">Marshal</span><span class="p">(</span><span class="nx">object</span><span class="p">)</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&#34;%s\n&#34;</span><span class="p">,</span> <span class="nx">oJson</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
<pre class="srci" ><code class="sh" ><span class="out" >{&#34;number&#34;:5,&#34;string&#34;:&#34;Packt&#34;}
</span></code></pre>
<p>We have not only lowercased the names of the keys, but we have even changed the name of the <code>Word</code> key to string.</p>
<p>Enough of marshalling, we will receive JSON data as an array of bytes, but the process is very similar with some changes:</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">MyObject</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">Number</span> <span class="kt">int</span><span class="s">`json:&#34;number&#34;`</span>
  <span class="nx">Word</span> <span class="kt">string</span><span class="s">`json:&#34;string&#34;`</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">(){</span>
  <span class="nx">jsonBytes</span> <span class="o">:=</span> <span class="p">[]</span><span class="nb">byte</span><span class="p">(</span><span class="s">`{&#34;number&#34;:5, &#34;string&#34;:&#34;Packt&#34;}`</span><span class="p">)</span>
  <span class="kd">var</span> <span class="nx">object</span> <span class="nx">MyObject</span>
  <span class="nx">err</span> <span class="o">:=</span> <span class="nx">json</span><span class="p">.</span><span class="nx">Unmarshal</span><span class="p">(</span><span class="nx">jsonBytes</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">object</span><span class="p">)</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&#34;Number is %d, Word is %s\n&#34;</span><span class="p">,</span> <span class="nx">object</span><span class="p">.</span><span class="nx">Number</span><span class="p">,</span> <span class="nx">object</span><span class="p">.</span><span class="nx">Word</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
<p>The big difference here is that you have to allocate the space for the structure first (with a zero value) and the pass the reference to the method <code>Unmarshal</code> so that it tries to fill it. When you use <code>Unmarshal</code>, the first parameter is the array of bytes that contains the JSON information while the second parameter is the reference (that&#39;s why we are using an ampersand) to the structure we want to fill. Finally, let&#39;s use a generic <code>map[string]interface{}</code> method to hold the content of a JSON:</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">MyObject</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">Number</span> <span class="kt">int</span>     <span class="s">`json:&#34;number&#34;`</span>
  <span class="nx">Word</span> <span class="kt">string</span>    <span class="s">`json:&#34;string&#34;`</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">(){</span>
  <span class="nx">jsonBytes</span> <span class="o">:=</span> <span class="p">[]</span><span class="nb">byte</span><span class="p">(</span><span class="s">`{&#34;number&#34;:5, &#34;string&#34;:&#34;Packt&#34;}`</span><span class="p">)</span>
  <span class="kd">var</span> <span class="nx">dangerousObject</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kd">interface</span><span class="p">{}</span>
  <span class="nx">err</span> <span class="o">:=</span> <span class="nx">json</span><span class="p">.</span><span class="nx">Unmarshal</span><span class="p">(</span><span class="nx">jsonBytes</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">dangerousObject</span><span class="p">)</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&#34;Number is %d, &#34;</span><span class="p">,</span> <span class="nx">dangerousObject</span><span class="p">[</span><span class="s">&#34;number&#34;</span><span class="p">])</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&#34;Word is %s\n&#34;</span><span class="p">,</span> <span class="nx">dangerousObject</span><span class="p">[</span><span class="s">&#34;string&#34;</span><span class="p">])</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&#34;Error reference is %v\n&#34;</span><span class="p">,</span> <span class="nx">dangerousObject</span><span class="p">[</span><span class="s">&#34;nothing&#34;</span><span class="p">])</span>
<span class="p">}</span>
</code></pre>
<div class="example-block" >
<pre class="example" >&gt; Number is %!d(float64=5), Word is Packt
Error reference is &lt;nil&gt;
</pre>
</div>
<p>What happened in the result? This is why we described the object as dangerous. You can point to a <code>nil</code> location when using this mode if you call a non-existing key in the JSON. Not only this, like in the example, it could also interpret a value as a <code>float64</code> when it is simply a byte, wasting a lot of memory. So remember to just use <code>map[string]interface{}</code> when you need dirty quick access to JSON data that is fairly simple and you have under control the type of scenarios described previously.</p>
</div>
<h3 id="go-tools" >Go tools</h3>
<div class="hBody-3" >
<p>Go comes with a series of useful tools to ease the development process every day. Also in the golang page of GitHub, there are some tools that are supported by the Go team but they are not part of the compiler.</p>
<p>Most of the projects use tools such as <code class="command" >gofmt</code> so that all the code base looks similar. Godoc helps us to find useful information in Go&#39;s documentation and the <code class="command" >goimport</code> command to auto-import the packages we are using. Let&#39;s see them.</p>
</div>
<h4 id="the-golint-tool" >The golint tool</h4>
<div class="hBody-4" >
<p>A linter analyzes source code to detect errors or improvements. The <code class="command" >golint</code> linter is available on <a href="https://github.com/golang/lint" >https://github.com/golang/lint</a> for installation (it doesn&#39;t come bundled with the compiler). It is very easy to use and is integrated some IDEs to be run when you save a source code file (Atom or Sublime Text, for example). Do you remember the implicit/explicit code that we run when talking about variables? Let&#39;s lint it:</p>
<pre class="code" ><code class="chroma" ><span class="c1">// Explicitly declaring a &#34;string&#34; variable
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">explicit</span> <span class="kt">string</span> <span class="p">=</span> <span class="s">&#34;Hello, I&#39;m a explicitly declared variable&#34;</span>

<span class="c1">// Implicitly declaring a &#34;string&#34;.
</span><span class="c1"></span><span class="nx">Type</span> <span class="nx">inferred</span> <span class="nx">inferred</span> <span class="o">:=</span> <span class="s">&#34;, I&#39;m an inferred variable &#34;</span>
</code></pre>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>golint main.go
</span></code></pre>
<p>The <code>main.go:10:21:</code> command should omit the type string from the declaration of the <code>explicitString</code> variable; it will be inferred from the right-hand side.</p>
<p>It is telling us that Go compiler will actually infer this type of a variable from the code and you don&#39;t need to declare its type. What about the <code>Train</code> type on the interface section?</p>
<pre class="code" ><code class="chroma" ><span class="nx">Type</span> <span class="nx">Train</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">TrainWidth</span> <span class="kt">int</span>
<span class="p">}</span>
</code></pre>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>golint main.go
</span></code></pre>
<p>The <code>main.go:5:6:</code> type exported <code>train</code> type should have a comment or remain not exported.</p>
<p>in this case, it&#39;s pointing us that a public type such as <code>train</code> type must be commented so that users can read the generated documentation to know its behavior.</p>
</div>
<h4 id="the-gofmt-tool" >the gofmt tool</h4>
<div class="hBody-4" >
<p>the <code class="command" >gofmt</code> tool comes bundled with the compiler that already has access to it. its purpose is to provide a set of indentation, formatting, spacing and few other rules to achieve good-looking go code. for example, let&#39;s take the code of hello world and make it a bit weirder by inserting spaces everywhere:</p>
<pre class="code" ><code class="chroma" ><span class="kn">package</span> <span class="nx">main</span>
<span class="kd">func</span>  <span class="nx">main</span><span class="p">(){</span>
  <span class="nb">println</span><span class="p">(</span><span class="s">&#34;Hello World!&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>gofmt main.go
</span><span class="out" >package main

func main() {
    println(&#34;Hello World!&#34;)
}
</span></code></pre>
<p>The <code class="command" >gofmt</code> command prints it correctly again. What is more, we can use the <code>-w</code> flag to overwrite the original file:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>gofmt -w main.go
</span></code></pre>
<p>And now we&#39;ll have our file properly corrected.</p>
</div>
<h4 id="the-godoc-tool" >The godoc tool</h4>
<div class="hBody-4" >
<p>Go documentation is pretty extended and verbose. You can find detailed information about any topic you want to achieve. The <code class="command" >godoc</code> tool also helps you access this documentation directly from the command line. For example, we can query the package <code>encoding/json</code>:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>godoc cmd/encoding/json
</span><span class="out" >[...]
FUNCTIONS
func Compact(dst *bytes.Buffer, src []byte) error
Compact appends to dst the JSON-encoded src with insignificant
space
characters elided.
func HTMLEscape(dst *bytes.Buffer, src []byte)
[...]
</span></code></pre>
<p>You can also use <code class="command" >grep</code>, a bash utility for Linux and Mac, to find specific information about some functionality. For example, we&#39;ll use grep to look for text that mentions anything about parsing JSON files:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>godoc cmd/encoding/json <span class="p">|</span> grep parse
</span></code></pre>
<p>The <code>Unmarshal</code> command parses the JSON encoded data and stores the result in the object being parsed.</p>
<p>One of the things that the <code class="command" >golint</code> command warns about is to use the beginning of a comment with the same name of the function it describes. This way, if you don&#39;t remember the name of the function that parses JSON, you can use <code>godoc</code> with <code class="command" >grep</code> and search for parse so the beginning of the line will always be the function name like in the example preceding the <code>Unmarshal</code> command.</p>
</div>
<h4 id="the-goimport-tool" >The goimport tool</h4>
<div class="hBody-4" >
<p>The <code class="command" >goimport</code> tool is a must have in Go. Sometimes you remember your packages so well that you don&#39;t need to search much to remember their API but it&#39;s more difficult to remember the project they belong to when doing the import. The <code class="command" >goimport</code> command helps you by searching your <code>$GOPATH</code> for occurrences of a package that you could be using to provide you with the project <code>import</code> line automatically. This is very useful if you configure your IDE to run <code class="command" >goimport</code> on save so that all used packages in the source file are imported automatically if you used them. It also works the other way around--if you delete the function you were using from a package and the package isn&#39;t being used anymore, it will remove the <code>import</code> line.</p>
</div>
<h3 id="contributing-to-go-open-source-projects-in-github" >Contributing to Go open source projects in GitHub</h3>
<div class="hBody-3" >
<p>One important thing to mention about Go packaging system is that it needs to have a proper folder structure within the GOPATH. This introduces a small problem when working with GitHub projects. We are used to forking a project, cloning our fork and start working before committing the pull-request to the original project. Wrong!</p>
<p>When you fork a project, you create a new repository on GitHub within your username. If you clone this repository and start working with it, all new import references in the project will point to your repository instead of the original! Imagine the following case in the original repository:</p>
<pre class="code" ><code class="chroma" ><span class="kn">package</span> <span class="nx">main</span>
<span class="kn">import</span> <span class="s">&#34;github.com/original/a_library&#34;</span>
<span class="p">[</span><span class="nx">some</span> <span class="nx">code</span><span class="p">]</span>
</code></pre>
<p>Then, you make a fork and add a subfolder with a library called <code>a_library/my_library</code> that you want to use from the main package. The result is going to be the following:</p>
<pre class="code" ><code class="chroma" ><span class="kn">package</span> <span class="nx">main</span>
<span class="kn">import</span> <span class="p">(</span>
  <span class="s">&#34;github.com/original/a_library&#34;</span>
  <span class="s">&#34;github.com/myaccount/a_library/my_library&#34;</span>
<span class="p">)</span>
</code></pre>
<p>Now if you commit this line, the original repository that contains the code you have pushed will download this code anyways from your account again and it will use the references downloaded! Not the ones contained in the project!</p>
<p>So, the solution to this is simply to replace the git clone command with a <code class="command" >go get</code> pointing to the original library:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go get github.com/original/a_library
</span><span class="in" ><span class="prompt" >&gt; </span><span class="nb">cd</span> <span class="nv">$GOPATH</span>/src/github.com/original/a_library
</span><span class="in" ><span class="prompt" >&gt; </span>git remote add my_origin
</span><span class="out" >https://github.com/myaccount/a_libbrary
</span></code></pre>
<p>With this modification, you can work normally in the original code without fear as the references will stay correct. Once you are done you just have to commit and push to your remote.</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>git push my_origin my_brach
</span></code></pre>
<p>This way, you can now access the GitHub web user interface and open the pull request without polluting the actual original code with references to your account.</p>
</div>
<h3 id="summary" >Summary</h3>
<div class="hBody-3" >
<p>After this first chapter, you must be familiar with the syntax of Go and some of the command-line tools that come bundled with the compiler.  We have left apart concurrency capabilities for a later chapter as they are large and pretty complex to grasp at the beginning so that the reader learns the syntax of the language first, becomes familiar and confident with it, and then they can jump to understanding <b>Communicating Sequential Processes</b> (<span class="acronym" >CSP</span>) concurrency patterns and distributed applications. The next steps are to start with the creational design patterns.</p>
</div>
<h2 id="chapter-2" >Creational Patterns - Singleton, Builder, Factory, Prototype, and Abstract Factory Design Patterns</h2>
<div class="hBody-2" >
<p>We have defined two types of cars-luxury and family. The car Factory will have to return The first groups of design patterns that we are going to cover are the Creational patterns. As the name implies, it groups common practices for creating objects, so object creation is more encapsulated from the users that need those objects. Mainly, creational patterns try to give ready-to-use objects to users instead of asking for their creation, which, in some cases, could be complex, or which would couple your code with the concrete implementations of the functionality that should be defined in an interface.</p>
</div>
<h3 id="singleton-design-pattern---having-a-unique-instance-of-a-type-in-the-entire-program" >Singleton design pattern - having a unique instance of a type in the entire program</h3>
<div class="hBody-3" >
<p>Have you ever done interviews for software engineers? It&#39;s interesting that when you ask them about design patterns, more than 80% will mention <b>Singleton</b> design pattern. Why is that? Maybe it&#39;s because it is one of the most used design patterns out there or one of the easiest to grasp. We will start our journey on creational design patterns because of the latter reason.</p>
</div>
<h4 id="description" >Description</h4>
<div class="hBody-4" >
<p>The Singleton pattern is easy to remember. As the name implies, it will provide you with a single instance of an object, and guarantee that there are no duplicates.</p>
<p>At the first call to use the instance, it is created and then reused between all the parts in the application that need to use that particular behavior.</p>
<p>You&#39;ll use the Singleton pattern in many different situations. For example:</p>
<ul>
<li>
<p>When you want to use the same connection to a database to make every query</p>
</li>
<li>
<p>When you open a <b>Secure Shell</b> (<span class="acronym" >SSH</span>) connection to a server to do a few tasks, and don&#39;t want to reopen the connection for each task</p>
</li>
<li>
<p>If you need to limit the access to some variable or space, you use a Singleton as the door to this variable (we&#39;ll see in the following chapters that this is more achievable in Go using channels anyway)</p>
</li>
<li>
<p>If you need to limit the number of calls to some places, you create a Singleton instance to make the calls in the accepted window</p>
</li>
</ul>
<p>The possibilities are endless, and we have just mentioned some of them.</p>
</div>
<h4 id="objectives" >Objectives</h4>
<div class="hBody-4" >
<p>As a general guide, we consider using the Singleton pattern when the following rule applies:</p>
<ul>
<li>
<p>We need a single, shared value, of some particular type.</p>
</li>
<li>
<p>We need to restrict object creation of some type to a single unit along the entire program.</p>
</li>
</ul>
</div>
<h4 id="example---a-unique-counter" >Example - a unique counter</h4>
<div class="hBody-4" >
<p>As an example of an object of which we must ensure that there is only one instance, we will write a counter that holds the number of times it has been called during program execution. It shouldn&#39;t matter how many instances we have of the counter, all of them must <i>count</i> the same value and it must be consistent between the instances.</p>
</div>
<h4 id="requirements-and-acceptance-criteria" >Requirements and acceptance criteria</h4>
<div class="hBody-4" >
<p>There are some requirements and acceptance criteria to write the described single counter. They are as follows:</p>
<ul>
<li>
<p>When no counter has been created before, a new one is created with the value 0</p>
</li>
<li>
<p>If a counter has already been created, return this instance that holds the actual count</p>
</li>
<li>
<p>If we call the method <code>AddOne</code>, the count must be incremented by 1</p>
</li>
</ul>
<p>We have a scenario with three tests to check in our unit tests.</p>
</div>
<h4 id="writing-unit-tests-first" >Writing unit tests first</h4>
<div class="hBody-4" >
<p>Go&#39;s implementation of this pattern is slightly different from what you&#39;ll find in pure object-oriented languages such as Java or C++, where you have static members. In Go, there&#39;s nothing like static members, but we have package scope to deliver a similar result.</p>
<p>To set up our project, we must create a new folder within our <span class="file" >$GOPATH/src</span> directory. The general rule as we mentioned in the <a href="#chapter-1" >Chapter 1</a> (<i>Ready... Steady... Go!</i>), is to create a subfolder with the VCS provider (such as GitHub), the username, and the name of the project.</p>
<p>For example, in my case, I use GitHub as my VCS and my username is <i>sayden,</i> so I will create the path <code>$GOPATH/src/github.com/sayden/go-design-patterns/creational/singleton</code>. The <code>go-design-patterns</code> instance in the path is the project name, the creational subfolder will also be our library name, and singleton the name of this particular package and subfolder:</p>
<pre class="code" ><code class="chroma" >mkdir -p <span class="nv">$GOPATH</span>/src/github.com/sayden/go-design-patterns/creational/singleton
<span class="nb">cd</span> <span class="nv">$GOPATH</span>/src/github.com/sayden/go-design-patterns/creational/singleton
</code></pre>
<p>Create a new file inside the singleton folder called <span class="file" >singleton.go</span> to also reflect the name of the package and write the following package declarations for the <code>singleton</code> type:</p>
<pre class="code" ><code class="chroma" ><span class="kn">package</span> <span class="nx">singleton</span>

<span class="kd">type</span> <span class="nx">Singleton</span> <span class="kd">interface</span> <span class="p">{</span>
  <span class="nx">AddOne</span><span class="p">()</span> <span class="kt">int</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">singleton</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">count</span> <span class="kt">int</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">instance</span> <span class="o">*</span><span class="nx">singleton</span>

<span class="kd">func</span> <span class="nx">GetInstance</span><span class="p">()</span> <span class="nx">Singleton</span> <span class="p">{</span>
  <span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">singleton</span><span class="p">)</span> <span class="nx">AddOne</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
  <span class="k">return</span> <span class="mi">0</span>
<span class="p">}</span>
</code></pre>
<p>As we are following a TDD approach while writing the code, let&#39;s code the tests that use the functions we have just declared. The tests are going to be defined by following the acceptance criteria that we have written earlier. By convention in test files, we must create a file with the same name as the file to test, suffixed with <span class="file" >_test.go</span>. Both must reside in the same folder:</p>
<pre class="code" ><code class="chroma" ><span class="kn">package</span> <span class="nx">singleton</span>

<span class="kn">import</span> <span class="s">&#34;testing&#34;</span>

<span class="kd">func</span> <span class="nx">TestGetInstance</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">counter1</span> <span class="o">:=</span> <span class="nx">GetInstance</span><span class="p">()</span>

  <span class="k">if</span> <span class="nx">counter1</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="c1">// Test of acceptance criteria 1 failed
</span><span class="c1"></span>    <span class="nx">t</span><span class="p">.</span><span class="nx">Error</span><span class="p">(</span><span class="s">&#34;expected pointer to Singleton after calling GetInstance(), not nil&#34;</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="nx">expectedCounter</span> <span class="o">:=</span> <span class="nx">counter1</span>
<span class="p">}</span>
</code></pre>
<p>The first test checks something obvious, but no less important, in complex applications. We actually receive something when we ask for an instance of the counter. We have to think of it as a Creational pattern--we delegate the creation of the object to an unknown package that could fail in the creation or retrieval of the object. We also store the current counter in the <code>expectedCounter</code> variable to make a comparison later:</p>
<pre class="code" ><code class="chroma" ><span class="nx">currentCount</span> <span class="o">:=</span> <span class="nx">counter1</span><span class="p">.</span><span class="nx">AddOne</span><span class="p">()</span>
<span class="k">if</span> <span class="nx">currentCount</span> <span class="o">!=</span> <span class="mi">1</span> <span class="p">{</span>
  <span class="nx">t</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&#34;After calling for the first time to count, the count must be 1 but it is %d\n&#34;</span><span class="p">,</span> <span class="nx">currentCount</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
<p>Now we take advantage of the zero-initialization feature of Go. Remember that integer types in Go cannot be nil and as we know, that this is the first call to the counter, and it is an integer type of variable, and we also know that it is zero-initialized. So after the first call to the <code>AddOne()</code> function, the value of the count must be 1.</p>
<p>The test that checks the second condition proves that the <code>expectedConnection</code> variable is not different to the returned connection that we requested later. If they were different, the message <code>Singleton instances must be different</code> will cause the test to fail:</p>
<pre class="code" ><code class="chroma" ><span class="nx">counter2</span> <span class="o">:=</span> <span class="nx">GetInstance</span><span class="p">()</span>
<span class="k">if</span> <span class="nx">counter2</span> <span class="o">!=</span> <span class="nx">expectedCounter</span> <span class="p">{</span>
  <span class="c1">// Test 2 failed
</span><span class="c1"></span>  <span class="nx">t</span><span class="p">.</span><span class="nx">Error</span><span class="p">(</span><span class="s">&#34;Expected same instance in counter2 but it got a different instance&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
<p>The last test is simply counting 1 again with the second instance. The previous result was 1, so now it must give us 2:</p>
<pre class="code" ><code class="chroma" ><span class="nx">currentCount</span> <span class="p">=</span> <span class="nx">counter2</span><span class="p">.</span><span class="nx">AddOne</span><span class="p">()</span>
<span class="k">if</span> <span class="nx">currentCount</span> <span class="o">!=</span> <span class="mi">2</span> <span class="p">{</span>
  <span class="nx">t</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&#34;After calling &#39;AddOne&#39; using the second counter, the current count must be 2 but was %d\n&#34;</span><span class="p">,</span> <span class="nx">currentCount</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
<p>The last thing we have to do to finish our test part is to execute the tests to make sure that they are failing before implementation. If one of them doesn&#39;t fail, it implies that we have done something wrong, and we have to reconsider that particular test. We must open the terminal and navigate to the path of the singleton package to execute:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go <span class="nb">test</span> -v .
</span><span class="out" >=== RUN   TestGetInstance
--- FAIL: TestGetInstance (0.00s)
        singleton_test.go:9: expected pointer to Singleton after calling GetInstance(), not nil
        singleton_test.go:15: After calling for the first time to count, the count must be 1 but it is 0
        singleton_test.go:27: After calling &#39;AddOne&#39; using the second counter, the current count must be 2 but was 0
FAIL
exit status 1
FAIL
</span></code></pre>
</div>
<h4 id="implementation" >Implementation</h4>
<div class="hBody-4" >
<p>Finally, we have to implement the Singleton pattern. As we mentioned earlier, we&#39;ll usually write a <code>static</code> method and instance to retrieve the Singleton instance in languages such as Java or C++. In Go, we don&#39;t have the keyword <code>static</code>, but we can achieve the same result by using the scope of the package. First, we create a <code>struct</code> that contains the object which we want to guarantee to be a Singleton during the execution of the program:</p>
<pre class="code" ><code class="chroma" ><span class="kn">package</span> <span class="nx">creational</span>

<span class="kd">type</span> <span class="nx">singleton</span> <span class="kd">struct</span><span class="p">{</span>
  <span class="nx">count</span> <span class="kt">int</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">instance</span> <span class="o">*</span><span class="nx">singleton</span>

<span class="kd">func</span> <span class="nx">GetInstance</span><span class="p">()</span> <span class="o">*</span><span class="nx">singleton</span> <span class="p">{</span>
  <span class="k">if</span> <span class="nx">instance</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">instance</span> <span class="p">=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">singleton</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">instance</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">singleton</span><span class="p">)</span> <span class="nx">AddOne</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
  <span class="nx">s</span><span class="p">.</span><span class="nx">count</span><span class="o">++</span>
  <span class="k">return</span> <span class="nx">s</span><span class="p">.</span><span class="nx">count</span>
<span class="p">}</span>
</code></pre>
<p>We must pay close attention to this piece of code. In languages such as Java or C++, the variable instance would be initialized to NULL at the beginning of the program. In Go, you can initialize a pointer to a struct as <code>nil</code>, but you cannot initialize a structure to <code>nil</code> (the equivalent of NULL). So the <code>var instance *singleton</code> line defines a pointer to a struct of type Singleton as nil, and the variable called <code>instance</code>.</p>
<p>We created a <code>GetInstance</code> method that checks if the instance has not been initialized already (<code>instance == nil</code>), and creates an instance in the space already allocated in the line <code>instance = new(singleton)</code>. Remember, when we use the keyword <code>new</code>, we are creating a pointer to an instance of the type between the parentheses.</p>
<p>The <code>AddOne</code> method will take the count of the variable instance, raise it by 1, and return the current value of the counter. Let&#39;s run now our unit tests again:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go <span class="nb">test</span> -v -run<span class="o">=</span>GetInstance
</span><span class="out" >=== RUN   TestGetInstance
--- PASS: TestGetInstance (0.00s)
PASS
ok
</span></code></pre>
</div>
<h4 id="a-few-words-about-the-singleton-design-pattern" >A few words about the Singleton design pattern</h4>
<div class="hBody-4" >
<p>We have seen a very simple example of the Singleton pattern, partially applied to some situation, that is, a simple counter. Just keep in mind that the Singleton pattern will give you the power to have a unique instance of some struct in your application and that no package can create any clone of this struct.</p>
<p>With Singleton, you are also hiding the complexity of creating the object, in case it requires some computation, and the pitfall of creating it every time you need an instance of it if all of them are similar. All this code writing, checking if the variable already exists, and storage, are encapsulated in the singleton and you won&#39;t need to repeat it everywhere if you use a global variable.</p>
<p>Here we are learning the classic singleton implementation for single threaded context. We will see a concurrent singleton implementation when we reach the chapters about concurrency because this implementation is not thread safe!</p>
</div>
<h3 id="builder-design-pattern---reusing-an-algorithm-to-create-many-implementations-of-an-interface" >Builder design pattern - reusing an algorithm to create many implementations of an interface</h3>
<div class="hBody-3" >
<p>Talking about <b>Creational</b> design patterns, it looks pretty semantic to have a <b>Builder</b> design pattern. The Builder pattern helps us construct complex objects without directly instantiating their struct, or writing the logic they require. Imagine an object that could have dozens of fields that are more complex structs themselves. Now imagine that you have many objects with these characteristics, and you could have more. We don&#39;t want to write the logic to create all these objects in the package that just needs to use the objects.</p>
</div>
<h4 id="description" >Description</h4>
<div class="hBody-4" >
<p>Instance creation can be as simple as providing the opening and closing braces <code>{}</code> and leaving the instance with zero values, or as complex as an object that needs to make some API calls, check states, and create objects for its fields. You could also have an object that is composed of many objects, something that&#39;s really idiomatic in Go, as it doesn&#39;t support inheritance.</p>
<p>At the same time, you could be using the same technique to create many types of objects. For example, you&#39;ll use almost the same technique to build a car as you would build a bus, except that they&#39;ll be of different sizes and number of seats, so why don&#39;t we reuse the construction process? This is where the Builder pattern comes to the rescue.</p>
</div>
<h4 id="objectives" >Objectives</h4>
<div class="hBody-4" >
<p>A Builder design pattern tries to:</p>
<ul>
<li>
<p>Abstract complex creations so that object creation is separated from the object user</p>
</li>
<li>
<p>Create an object step by step by filling its fields and creating the embedded objects</p>
</li>
<li>
<p>Reuse the object creation algorithm between many objects</p>
</li>
</ul>
</div>
<h4 id="example---vehicle-manufacturing" >Example - vehicle manufacturing</h4>
<div class="hBody-4" >
<p>The Builder design pattern has been commonly described as the relationship between a director, a few Builders, and the product they build. Continuing with our example of the car, we&#39;ll create a vehicle Builder. The process (widely described as the algorithm) of creating a vehicle (the product) is more or less the same for every kind of vehicle--choose vehicle type, assemble the structure, place the wheels, and place the seats. If you think about it, you could build a car and a motorbike (two Builders) with this description, so we are reusing the description to create cars in manufacturing. The director is represented by the <code>ManufacturingDirector</code> type in our example.</p>
</div>
<h4 id="requirements-and-acceptance-criteria" >Requirements and acceptance criteria</h4>
<div class="hBody-4" >
<p>As far as we have described, we must dispose of a Builder of type Car and <code>Motorbike</code> and a unique director called <code>ManufacturingDirector</code> to take builders and construct products. So the requirements for a <code>Vehicle</code> builder example would be the following:</p>
<ul>
<li>
<p>I must have a manufacturing type that constructs everything that a vehicle needs</p>
</li>
<li>
<p>When using a car builder, the <code>VehicleProduct</code> with four wheels, five seats, and a structure defined as <code>Car</code> must be returned</p>
</li>
<li>
<p>When using a motorbike builder, the <code>VehicleProduct</code> with two wheels, two seats, and a structure defined as <code>Motorbike</code> must be returned</p>
</li>
<li>
<p>A <code>VehicleProduct</code> built by any <code>BuildProcess</code> builder must be open to modifications</p>
</li>
</ul>
</div>
<h4 id="unit-test-for-the-vehicle-builder" >Unit test for the vehicle builder</h4>
<div class="hBody-4" >
<p>With the previous acceptance criteria, we will create a director variable, the <code>ManufacturingDirector</code> type, to use the build processes represented by the product builder variables for a car and motorbike. The director is the one in charge of construction of the objects, but the builders are the ones that return the actual vehicle. So our builder declaration will look as follows:</p>
<pre class="code" ><code class="chroma" ><span class="kn">package</span> <span class="nx">creational</span>

<span class="kd">type</span> <span class="nx">BuildProcess</span> <span class="kd">interface</span> <span class="p">{</span>
  <span class="nx">SetWheels</span><span class="p">()</span> <span class="nx">BuildProcess</span>
  <span class="nx">SetSeats</span><span class="p">()</span> <span class="nx">BuildProcess</span>
  <span class="nx">SetStructure</span><span class="p">()</span> <span class="nx">BuildProcess</span>
  <span class="nx">GetVehicle</span><span class="p">()</span> <span class="nx">VehicleProduct</span>
<span class="p">}</span>
</code></pre>
<p>This preceding interface defines the steps that are necessary to build a vehicle. Every builder must implement this <code>interface</code> if they are to be used by the manufacturing. On every <em>Set</em> step, we return the same build process, so we can chain various steps together in the same statement, as we&#39;ll see later. Finally, we&#39;ll need a <code>GetVehicle</code> method to retrieve the <code>Vehicle</code> instance from the builder:</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">ManufacturingDirector</span> <span class="kd">struct</span> <span class="p">{}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">f</span> <span class="o">*</span><span class="nx">ManufacturingDirector</span><span class="p">)</span> <span class="nx">Construct</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// Implementation goes here
</span><span class="c1"></span><span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">f</span> <span class="o">*</span><span class="nx">ManufacturingDirector</span><span class="p">)</span> <span class="nx">SetBuilder</span><span class="p">(</span><span class="nx">b</span> <span class="nx">BuildProcess</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Implementation goes here
</span><span class="c1"></span><span class="p">}</span>
</code></pre>
<p>The <code>ManufacturingDirector</code> director variable is the one in charge of accepting the builders. It has a <code>Construct</code> method that will use the builder that is stored in <code>Manufacturing</code>, and will reproduce the required steps. The <code>SetBuilder</code> method will allow us to change the builder that is being used in the <code>Manufacturing</code> director:</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">VehicleProduct</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">Wheels</span>    <span class="kt">int</span>
  <span class="nx">Seats</span>     <span class="kt">int</span>
  <span class="nx">Structure</span> <span class="kt">string</span>
<span class="p">}</span>
</code></pre>
<p>The product is the final object that we want to retrieve while using the manufacturing. In this case, a vehicle is composed of wheels, seats, and a structure:</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">CarBuilder</span> <span class="kd">struct</span> <span class="p">{}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">CarBuilder</span><span class="p">)</span> <span class="nx">SetWheels</span><span class="p">()</span> <span class="nx">BuildProcess</span> <span class="p">{</span>
  <span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">CarBuilder</span><span class="p">)</span> <span class="nx">SetSeats</span><span class="p">()</span> <span class="nx">BuildProcess</span> <span class="p">{</span>
  <span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">CarBuilder</span><span class="p">)</span> <span class="nx">SetStructure</span><span class="p">()</span> <span class="nx">BuildProcess</span> <span class="p">{</span>
  <span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">CarBuilder</span><span class="p">)</span> <span class="nx">Build</span><span class="p">()</span> <span class="nx">VehicleProduct</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">VehicleProduct</span><span class="p">{}</span>
<span class="p">}</span>
</code></pre>
<p>The first Builder is the <code>Car</code> builder. It must implement every method defined in the <code>BuildProcess</code> interface. This is where we&#39;ll set the information for this particular builder:</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">BikeBuilder</span> <span class="kd">struct</span> <span class="p">{}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">BikeBuilder</span><span class="p">)</span> <span class="nx">SetWheels</span><span class="p">()</span> <span class="nx">BuildProcess</span> <span class="p">{</span>
  <span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">BikeBuilder</span><span class="p">)</span> <span class="nx">SetSeats</span><span class="p">()</span> <span class="nx">BuildProcess</span> <span class="p">{</span>
  <span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">BikeBuilder</span><span class="p">)</span> <span class="nx">SetStructure</span><span class="p">()</span> <span class="nx">BuildProcess</span> <span class="p">{</span>
  <span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">BikeBuilder</span><span class="p">)</span> <span class="nx">Build</span><span class="p">()</span> <span class="nx">VehicleProduct</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">VehicleProduct</span><span class="p">{}</span>
<span class="p">}</span>
</code></pre>
<p>The <code>Motorbike</code> structure must be the same as the <code>Car</code> structure, as they are all Builder implementations, but keep in mind that the process of building each can be very different. With this declaration of objects, we can create the following tests:</p>
<pre class="code" ><code class="chroma" ><span class="kn">package</span> <span class="nx">creational</span>

<span class="kn">import</span> <span class="s">&#34;testing&#34;</span>

<span class="kd">func</span> <span class="nx">TestBuilderPattern</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">manufacturingComplex</span> <span class="o">:=</span> <span class="nx">ManufacturingDirector</span><span class="p">{}</span>

  <span class="nx">carBuilder</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">CarBuilder</span><span class="p">{}</span>
  <span class="nx">manufacturingComplex</span><span class="p">.</span><span class="nx">SetBuilder</span><span class="p">(</span><span class="nx">carBuilder</span><span class="p">)</span>
  <span class="nx">manufacturingComplex</span><span class="p">.</span><span class="nx">Construct</span><span class="p">()</span>

  <span class="nx">car</span> <span class="o">:=</span> <span class="nx">carBuilder</span><span class="p">.</span><span class="nx">Build</span><span class="p">()</span>

  <span class="c1">// code continues here...
</span><span class="c1"></span></code></pre>
<p>We will start with the <code>Manufacturing</code> director and the <code>Car</code> Builder to fulfill the first two acceptance criteria. In the preceding code, we are creating our <code>Manufacturing</code> director that will be in charge of the creation of every vehicle during the test. After creating the <code>Manufacturing</code> director, we created a <code>CarBuilder</code> that we then passed to manufacturing by using the <code>SetBuilder</code> method. Once the <code>Manufacturing</code> director knows what it has to construct now, we can call the <code>Construct</code> method to create the <code>VehicleProduct</code> using <code>CarBuilder</code>. Finally, once we have all the pieces for our car, we call the <code>GetVehicle</code> method on <code>CarBuilder</code> to retrieve a <code>Car</code> instance:</p>
<pre class="code" ><code class="chroma" ><span class="k">if</span> <span class="nx">car</span><span class="p">.</span><span class="nx">Wheels</span> <span class="o">!=</span> <span class="mi">4</span> <span class="p">{</span>
  <span class="nx">t</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&#34;Wheels on a car must be 4 and they were %d\n&#34;</span><span class="p">,</span> <span class="nx">car</span><span class="p">.</span><span class="nx">Wheels</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">if</span> <span class="nx">car</span><span class="p">.</span><span class="nx">Structure</span> <span class="o">!=</span> <span class="s">&#34;Car&#34;</span> <span class="p">{</span>
  <span class="nx">t</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&#34;Structure on a car must be &#39;Car&#39; and was %s\n&#34;</span><span class="p">,</span> <span class="nx">car</span><span class="p">.</span><span class="nx">Structure</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">if</span> <span class="nx">car</span><span class="p">.</span><span class="nx">Seats</span> <span class="o">!=</span> <span class="mi">5</span> <span class="p">{</span>
  <span class="nx">t</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&#34;Seats on a car must be 5 and they were %d\n&#34;</span><span class="p">,</span> <span class="nx">car</span><span class="p">.</span><span class="nx">Seats</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
<p>We have written three small tests to check if the outcome is a car. We checked that the car has four wheels, the structure has the description <code>Car</code>, and the number of seats is five. We have enough data to execute the tests and make sure that they are failing so that we can consider them reliable:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go <span class="nb">test</span> -v -run<span class="o">=</span>TestBuilder .
</span><span class="out" >=== RUN   TestBuilderPattern
--- FAIL: TestBuilderPattern (0.00s)
        builder_test.go:15: Wheels on a car must be 4 and they were 0
        builder_test.go:19: Structure on a car must be &#39;Car&#39; and was
        builder_test.go:23: Seats on a car must be 5 and they were 0
FAIL
</span></code></pre>
<p>Perfect! Now we will create tests for a <code>Motorbike</code> builder that covers the third and fourth acceptance criteria:</p>
<pre class="code" ><code class="chroma" ><span class="nx">bikeBuilder</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">BikeBuilder</span><span class="p">{}</span>

<span class="nx">manufacturingComplex</span><span class="p">.</span><span class="nx">SetBuilder</span><span class="p">(</span><span class="nx">bikeBuilder</span><span class="p">)</span>
<span class="nx">manufacturingComplex</span><span class="p">.</span><span class="nx">Construct</span><span class="p">()</span>

<span class="nx">motorbike</span> <span class="o">:=</span> <span class="nx">bikeBuilder</span><span class="p">.</span><span class="nx">GetVehicle</span><span class="p">()</span>
<span class="nx">motorbike</span><span class="p">.</span><span class="nx">Seats</span> <span class="p">=</span> <span class="mi">1</span>

<span class="k">if</span> <span class="nx">motorbike</span><span class="p">.</span><span class="nx">Wheels</span> <span class="o">!=</span> <span class="mi">2</span> <span class="p">{</span>
  <span class="nx">t</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&#34;Wheels on a motorbike must be 2 and they were %d\n&#34;</span><span class="p">,</span>
    <span class="nx">motorbike</span><span class="p">.</span><span class="nx">Wheels</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">if</span> <span class="nx">motorbike</span><span class="p">.</span><span class="nx">Structure</span> <span class="o">!=</span> <span class="s">&#34;Motorbike&#34;</span> <span class="p">{</span>
  <span class="nx">t</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&#34;Structure on a motorbike must be &#39;Motorbike&#39; and was %s\n&#34;</span><span class="p">,</span>
    <span class="nx">motorbike</span><span class="p">.</span><span class="nx">Structure</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
<p>The preceding code is a continuation of the car tests. As you can see, we reuse the previously created manufacturing to create the bike now by passing the <code>Motorbike</code> builder to it. Then we hit the <code>construct</code> button again to create the necessary parts, and call the builder <code>GetVehicle</code> method to retrieve the motorbike instance.</p>
<p>Take a quick look, because we have changed the default number of seats for this particular motorbike to 1. What we want to show here is that even while having a builder, you must also be able to change the default information in the returned instance to fit some specific needs. As we set the wheels manually, we won&#39;t test this feature.</p>
<p>Re-running the tests triggers the expected behavior:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go <span class="nb">test</span> -v -run<span class="o">=</span>Builder .
</span><span class="out" >=== RUN   TestBuilderPattern
--- FAIL: TestBuilderPattern (0.00s)
        builder_test.go:15: Wheels on a car must be 4 and they were 0
        builder_test.go:19: Structure on a car must be &#39;Car&#39; and was
        builder_test.go:23: Seats on a car must be 5 and they were 0
        builder_test.go:35: Wheels on a motorbike must be 2 and they were 0
        builder_test.go:39: Structure on a motorbike must be &#39;Motorbike&#39; and was
FAIL
</span></code></pre>
</div>
<h4 id="implementation" >Implementation</h4>
<div class="hBody-4" >
<p>We will start implementing the manufacturing. As we said earlier (and as we set in our unit tests), the <code>Manufacturing</code> director must accept a builder and construct a vehicle using the provided builder. To recall, the <code>BuildProcess</code> interface will define the common steps needed to construct any vehicle and the <code>Manufacturing</code> director must accept builders and construct vehicles together with them:</p>
<pre class="code" ><code class="chroma" ><span class="kn">package</span> <span class="nx">creational</span>

<span class="kd">type</span> <span class="nx">ManufacturingDirector</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">builder</span> <span class="nx">BuildProcess</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">f</span> <span class="o">*</span><span class="nx">ManufacturingDirector</span><span class="p">)</span> <span class="nx">SetBuilder</span><span class="p">(</span><span class="nx">b</span> <span class="nx">BuildProcess</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">f</span><span class="p">.</span><span class="nx">builder</span> <span class="p">=</span> <span class="nx">b</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">f</span> <span class="o">*</span><span class="nx">ManufacturingDirector</span><span class="p">)</span> <span class="nx">Construct</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">f</span><span class="p">.</span><span class="nx">builder</span><span class="p">.</span><span class="nx">SetSeats</span><span class="p">().</span><span class="nx">SetStructure</span><span class="p">().</span><span class="nx">SetWheels</span><span class="p">()</span>
<span class="p">}</span>
</code></pre>
<p>Our <code>ManufacturingDirector</code> needs a field to store the builder in use; this field will be called <em>builder</em>. The <code>SetBuilder</code> method will replace the stored builder with the one provided in the arguments. Finally, take a closer look at the <code>Construct</code> method. It takes the builder that has been stored and reproduces the <code>BuildProcess</code> method that will create a full vehicle of some unknown type. As you can see, we have used all the setting calls in the same line thanks to returning the <code>BuildProcess</code> interface on each of the calls. This way the code is more compact:</p>
<div class="about" >
<div class="about-dt" >Tip</div>
<div class="about-dd" >
<p>Have you realized that the director entity in the Builder pattern is a clear candidate for a Singleton pattern too? In some scenarios, it could be critical that just an instance of the Director is available, and that is where you&#39;ll create a Singleton pattern for the Director of the Builder only. Design patterns composition is a very common technique and a very powerful one!</p>
</div>
</div>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">CarBuilder</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">v</span> <span class="nx">VehicleProduct</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">CarBuilder</span><span class="p">)</span> <span class="nx">SetWheels</span><span class="p">()</span> <span class="nx">BuildProcess</span> <span class="p">{</span>
  <span class="nx">c</span><span class="p">.</span><span class="nx">v</span><span class="p">.</span><span class="nx">Wheels</span> <span class="p">=</span> <span class="mi">4</span>
  <span class="k">return</span> <span class="nx">c</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">CarBuilder</span><span class="p">)</span> <span class="nx">SetSeats</span><span class="p">()</span> <span class="nx">BuildProcess</span> <span class="p">{</span>
  <span class="nx">c</span><span class="p">.</span><span class="nx">v</span><span class="p">.</span><span class="nx">Seats</span> <span class="p">=</span> <span class="mi">5</span>
  <span class="k">return</span> <span class="nx">c</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">CarBuilder</span><span class="p">)</span> <span class="nx">SetStructure</span><span class="p">()</span> <span class="nx">BuildProcess</span> <span class="p">{</span>
  <span class="nx">c</span><span class="p">.</span><span class="nx">v</span><span class="p">.</span><span class="nx">Structure</span> <span class="p">=</span> <span class="s">&#34;Car&#34;</span>
  <span class="k">return</span> <span class="nx">c</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">CarBuilder</span><span class="p">)</span> <span class="nx">GetVehicle</span><span class="p">()</span> <span class="nx">VehicleProduct</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">c</span><span class="p">.</span><span class="nx">v</span>
<span class="p">}</span>
</code></pre>
<p>Here is our first builder, the <code>car</code> builder. A builder will need to store a <code>VehicleProduct</code> object, which here we have named v. Then we set the specific needs that a car has in our business--four wheels, five seats, and a structure defined as <code>Car</code>. In the <code>GetVehicle</code> method, we just return the <code>VehicleProduct</code> stored within the Builder that must be already constructed by the <code>ManufacturingDirector</code> type.</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">BikeBuilder</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">v</span> <span class="nx">VehicleProduct</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">BikeBuilder</span><span class="p">)</span> <span class="nx">SetWheels</span><span class="p">()</span> <span class="nx">BuildProcess</span> <span class="p">{</span>
  <span class="nx">b</span><span class="p">.</span><span class="nx">v</span><span class="p">.</span><span class="nx">Wheels</span> <span class="p">=</span> <span class="mi">2</span>
  <span class="k">return</span> <span class="nx">b</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">BikeBuilder</span><span class="p">)</span> <span class="nx">SetSeats</span><span class="p">()</span> <span class="nx">BuildProcess</span> <span class="p">{</span>
  <span class="nx">b</span><span class="p">.</span><span class="nx">v</span><span class="p">.</span><span class="nx">Seats</span> <span class="p">=</span> <span class="mi">2</span>
  <span class="k">return</span> <span class="nx">b</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">BikeBuilder</span><span class="p">)</span> <span class="nx">SetStructure</span><span class="p">()</span> <span class="nx">BuildProcess</span> <span class="p">{</span>
  <span class="nx">b</span><span class="p">.</span><span class="nx">v</span><span class="p">.</span><span class="nx">Structure</span> <span class="p">=</span> <span class="s">&#34;Motorbike&#34;</span>
  <span class="k">return</span> <span class="nx">b</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">BikeBuilder</span><span class="p">)</span> <span class="nx">GetVehicle</span><span class="p">()</span> <span class="nx">VehicleProduct</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">b</span><span class="p">.</span><span class="nx">v</span>
<span class="p">}</span>
</code></pre>
<p>The <code>Motorbike</code> Builder is the same as the <code>car</code> builder. We defined a motorbike to have two wheels, two seats, and a structure called <code>Motorbike</code>. It&#39;s very similar to the <code>car</code> object, but imagine that you want to differentiate between a sports motorbike (with only one seat) and a cruise motorbike (with two seats). You could simply create a new structure for sports motorbikes that implements the build process.</p>
<p>You can see that it&#39;s a repetitive pattern, but within the scope of every method of the <code>BuildProcess</code> interface, you could encapsulate as much complexity as you want such that the user need not know the details about the object creation.</p>
<p>With the definition of all the objects, let&#39;s run the tests again:</p>
<pre class="srci" ><code class="sh" ><span class="out" >=== RUN   TestBuilderPattern
--- PASS: TestBuilderPattern (0.00s)
PASS
ok  _/home/mcastro/pers/go-design-patterns/creational 0.001s
</span></code></pre>
<p>Well done! Think how easy it could be to add new vehicles to the <code>ManufacturingDirector</code> director just create a new class encapsulating the data for the new vehicle. For example, let´s add a <code>BusBuilder</code> struct:</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">BusBuilder</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">v</span> <span class="nx">VehicleProduct</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">BusBuilder</span><span class="p">)</span> <span class="nx">SetWheels</span><span class="p">()</span> <span class="nx">BuildProcess</span> <span class="p">{</span>
  <span class="nx">b</span><span class="p">.</span><span class="nx">v</span><span class="p">.</span><span class="nx">Wheels</span> <span class="p">=</span> <span class="mi">4</span><span class="o">*</span><span class="mi">2</span>
  <span class="k">return</span> <span class="nx">b</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">BusBuilder</span><span class="p">)</span> <span class="nx">SetSeats</span><span class="p">()</span> <span class="nx">BuildProcess</span> <span class="p">{</span>
  <span class="nx">b</span><span class="p">.</span><span class="nx">v</span><span class="p">.</span><span class="nx">Seats</span> <span class="p">=</span> <span class="mi">30</span>
  <span class="k">return</span> <span class="nx">b</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">BusBuilder</span><span class="p">)</span> <span class="nx">SetStructure</span><span class="p">()</span> <span class="nx">BuildProcess</span> <span class="p">{</span>
  <span class="nx">b</span><span class="p">.</span><span class="nx">v</span><span class="p">.</span><span class="nx">Structure</span> <span class="p">=</span> <span class="s">&#34;Bus&#34;</span>
  <span class="k">return</span> <span class="nx">b</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">BusBuilder</span><span class="p">)</span> <span class="nx">GetVehicle</span><span class="p">()</span> <span class="nx">VehicleProduct</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">b</span><span class="p">.</span><span class="nx">v</span>
<span class="p">}</span>
</code></pre>
<p>That&#39;s all; your <code>ManufacturingDirector</code> would be ready to use the new product by following the Builder design pattern.</p>
</div>
<h4 id="wrapping-up-the-builder-design-pattern" >Wrapping up the Builder design pattern</h4>
<div class="hBody-4" >
<p>The Builder design pattern helps us maintain an unpredictable number of products by using a common construction algorithm that is used by the director. The construction process is always abstracted from the user of the product.</p>
<p>At the same time, having a defined construction pattern helps when a newcomer to our source code needs to add a new product to the <i>pipeline</i>. The <code>BuildProcess</code> interface specifies what he must comply to be part of the possible builders.</p>
<p>However, try to avoid the Builder pattern when you are not completely sure that the algorithm is going to be more or less stable because any small change in this interface will affect all your builders and it could be awkward if you add a new method that some of your builders need and others Builders do not.</p>
</div>
<h3 id="factory-method---delegating-the-creation-of-different-types-of-payments" >Factory method - delegating the creation of different types of payments</h3>
<div class="hBody-3" >
<p>The Factory method pattern (or simply, Factory) is probably the second-best known and used design pattern in the industry. Its purpose is to abstract the user from the knowledge of the struct he needs to achieve for a specific purpose, such as retrieving some value, maybe from a web service or a database. The user only needs an interface that provides him this value. By delegating this decision to a Factory, this Factory can provide an interface that fits the user needs. It also eases the process of downgrading or upgrading of the implementation of the underlying type if needed.</p>
</div>
<h4 id="description" >Description</h4>
<div class="hBody-4" >
<p>When using the Factory method design pattern, we gain an extra layer of encapsulation so that our program can grow in a controlled environment. With the Factory method, we delegate the creation of families of objects to a different package or object to abstract us from the knowledge of the pool of possible objects we could use. Imagine that you want to organize your holidays using a trip agency. You don&#39;t deal with hotels and traveling and you just tell the agency the destination you are interested in so that they provide you with everything you need. The trip agency represents a Factory of trips.</p>
</div>
<h4 id="objectives" >Objectives</h4>
<div class="hBody-4" >
<p>After the previous description, the following objectives of the Factory Method design pattern must be clear to you:</p>
<ul>
<li>
<p>Delegating the creation of new instances of structures to a different part of the program</p>
</li>
<li>
<p>Working at the interface level instead of with concrete implementations</p>
</li>
<li>
<p>Grouping families of objects to obtain a family object creator</p>
</li>
</ul>
</div>
<h4 id="the-example---a-factory-of-payment-methods-for-a-shop" >The example - a factory of payment methods for a shop</h4>
<div class="hBody-4" >
<p>For our example, we are going to implement a payments method Factory, which is going to provide us with different ways of paying at a shop. In the beginning, we will have two methods of paying--cash and credit card. We&#39;ll also have an interface with the method, <code>Pay</code>, which every struct that wants to be used as a payment method must implement.</p>
</div>
<h4 id="acceptance-criteria" >Acceptance criteria</h4>
<div class="hBody-4" >
<p>Using the previous description, the requirements for the acceptance criteria are the following:</p>
<ul>
<li>
<p>To have a common method for every payment method called Pay</p>
</li>
<li>
<p>To be able to delegate the creation of payments methods to the Factory</p>
</li>
<li>
<p>To be able to add more payment methods to the library by just adding it to the factory method</p>
</li>
</ul>
</div>
<h4 id="first-unit-test" >First unit test</h4>
<div class="hBody-4" >
<p>A Factory method has a very simple structure; we just need to identify how many implementations of our interface we are storing, and then provide a method, <code>GetPaymentMethod</code>, where you can pass a type of payment as an argument:</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">PaymentMethod</span> <span class="kd">interface</span> <span class="p">{</span>
  <span class="nx">Pay</span><span class="p">(</span><span class="nx">amount</span> <span class="kt">float32</span><span class="p">)</span> <span class="kt">string</span>
<span class="p">}</span>
</code></pre>
<p>The preceding lines define the interface of the payment method. They define a way of making a payment at the shop. The Factory method will return instances of types that implement this interface:</p>
<pre class="code" ><code class="chroma" ><span class="kd">const</span> <span class="p">(</span>
  <span class="nx">Cash</span>      <span class="p">=</span> <span class="mi">1</span>
  <span class="nx">DebitCard</span> <span class="p">=</span> <span class="mi">2</span>
<span class="p">)</span>
</code></pre>
<p>We have to define the identified payment methods of the Factory as constants so that we can call and check the possible payment methods from outside of the package.</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">GetPaymentMethod</span><span class="p">(</span><span class="nx">m</span> <span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="nx">PaymentMethod</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">errors</span><span class="p">.</span><span class="nx">New</span><span class="p">(</span><span class="s">&#34;Not implemented yet&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
<p>The preceding code is the function that will create the objects for us. It returns a pointer, which must have an object that implements the <code>PaymentMethod</code> interface, and an error if asked for a method which is not registered.</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">CashPM</span> <span class="kd">struct</span><span class="p">{}</span>
<span class="kd">type</span> <span class="nx">DebitCardPM</span> <span class="kd">struct</span><span class="p">{}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">CashPM</span><span class="p">)</span> <span class="nx">Pay</span><span class="p">(</span><span class="nx">amount</span> <span class="kt">float32</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
  <span class="k">return</span> <span class="s">&#34;&#34;</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">DebitCardPM</span><span class="p">)</span> <span class="nx">Pay</span><span class="p">(</span><span class="nx">amount</span> <span class="kt">float32</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
  <span class="k">return</span> <span class="s">&#34;&#34;</span>
<span class="p">}</span>
</code></pre>
<p>To finish the declaration of the Factory, we create the two payment methods. As you can see, the <code>CashPM</code> and <code>DebitCardPM</code> structs implement the <code>PaymentMethod</code> interface by declaring a method, <code>Pay(amount float32) string</code>. The returned string will contain information about the payment.</p>
<p>With this declaration, we will start by writing the tests for the first acceptance criteria: to have a common method to retrieve objects that implement the <code>PaymentMethod</code> interface:</p>
<pre class="code" ><code class="chroma" ><span class="kn">package</span> <span class="nx">creational</span>
<span class="kn">import</span> <span class="p">(</span>
  <span class="s">&#34;strings&#34;</span>
  <span class="s">&#34;testing&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nx">TestCreatePaymentMethodCash</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">payment</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">GetPaymentMethod</span><span class="p">(</span><span class="nx">Cash</span><span class="p">)</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">t</span><span class="p">.</span><span class="nx">Fatal</span><span class="p">(</span><span class="s">&#34;A payment method of type &#39;Cash&#39; must exist&#34;</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="nx">msg</span> <span class="o">:=</span> <span class="nx">payment</span><span class="p">.</span><span class="nx">Pay</span><span class="p">(</span><span class="mf">10.30</span><span class="p">)</span>
  <span class="k">if</span> <span class="p">!</span><span class="nx">strings</span><span class="p">.</span><span class="nx">Contains</span><span class="p">(</span><span class="nx">msg</span><span class="p">,</span> <span class="s">&#34;paid using cash&#34;</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">t</span><span class="p">.</span><span class="nx">Error</span><span class="p">(</span><span class="s">&#34;The cash payment method message wasn&#39;t correct&#34;</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="nx">t</span><span class="p">.</span><span class="nx">Log</span><span class="p">(</span><span class="s">&#34;LOG:&#34;</span><span class="p">,</span> <span class="nx">msg</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
<p>Now we&#39;ll have to separate the tests among a few of the test functions. <code>GetPaymentMethod</code> is a common method to retrieve methods of payment. We use the constant <code>Cash</code>, which we have defined in the implementation file (if we were using this constant outside for the scope of the package, we would call it using the name of the package as the prefix, so the syntax would be <code>creational.Cash</code>). We also check that we have not received an error when asking for a payment method. Observe that if we receive the error when asking for a payment method, we call <code>t.Fatal</code> to stop the execution of the tests; if we called just <code>t.Error</code> like in the previous tests, we would have a problem in the next lines when trying to access the <code>Pay</code> method of a nil object, and our tests would crash execution. We continue by using the <code>Pay</code> method of the interface by passing 10.30 as the amount. The returned message will have to contain the text <code>paid using cash</code>. The <code>t.Log(string)</code> method is a special method in testing. This struct allows us to write some logs when we run the tests if we pass the <code>-v</code> flag.</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">TestGetPaymentMethodDebitCard</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">payment</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">GetPaymentMethod</span><span class="p">(</span><span class="nx">Debit9Card</span><span class="p">)</span>

  <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">t</span><span class="p">.</span><span class="nx">Error</span><span class="p">(</span><span class="s">&#34;A payment method of type &#39;DebitCard&#39; must exist&#34;</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="nx">msg</span> <span class="p">=</span> <span class="nx">payment</span><span class="p">.</span><span class="nx">Pay</span><span class="p">(</span><span class="mf">22.30</span><span class="p">)</span>

  <span class="k">if</span> <span class="p">!</span><span class="nx">strings</span><span class="p">.</span><span class="nx">Contains</span><span class="p">(</span><span class="nx">msg</span><span class="p">,</span> <span class="s">&#34;paid using debit card&#34;</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">t</span><span class="p">.</span><span class="nx">Error</span><span class="p">(</span><span class="s">&#34;The debit card payment method message wasn&#39;t correct&#34;</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="nx">t</span><span class="p">.</span><span class="nx">Log</span><span class="p">(</span><span class="s">&#34;LOG:&#34;</span><span class="p">,</span> <span class="nx">msg</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
<p>We repeat the same operation with the debit card method. We ask for the payment method defined with the constant <code>DebitCard</code>, and the returned message, when paying with debit card, must contain the <code>paid using debit card</code> string.</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">TestGetPaymentMethodNonExistent</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">payment</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">GetPaymentMethod</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>

  <span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">t</span><span class="p">.</span><span class="nx">Error</span><span class="p">(</span><span class="s">&#34;A payment method with ID 20 must return an error&#34;</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="nx">t</span><span class="p">.</span><span class="nx">Log</span><span class="p">(</span><span class="s">&#34;LOG:&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
<p>Finally, we are going to test the situation when we request a payment method that doesn´t exist (represented by the number 20, which doesn&#39;t match any recognized constant in the Factory). We will check if an error message (any) is returned when asking for an unknown payment method.</p>
<p>Let&#39;s check whether all tests are failing:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go <span class="nb">test</span> -v -run<span class="o">=</span>GetPaymentMethod .
</span><span class="out" >=== RUN   TestGetPaymentMethodCash
--- FAIL: TestGetPaymentMethodCash (0.00s)
        factory_test.go:11: A payment method of type &#39;Cash&#39; must exist
=== RUN   TestGetPaymentMethodDebitCard
--- FAIL: TestGetPaymentMethodDebitCard (0.00s)
        factory_test.go:24: A payment method of type &#39;DebitCard&#39; must exist
=== RUN   TestGetPaymentMethodNonExistent
--- PASS: TestGetPaymentMethodNonExistent (0.00s)
        factory_test.go:38: LOG: Not implemented yet
FAIL
exit status 1
FAIL
</span></code></pre>
<p>As you can see in this example, we can only see tests that return the <code>PaymentMethod</code> interfaces failing. In this case, we&#39;ll have to implement just a part of the code, and then test again before continuing.</p>
</div>
<h4 id="implementation" >Implementation</h4>
<div class="hBody-4" >
<p>We will start with the <code>GetPaymentMethod</code> method. It must receive an integer that matches with one of the defined constants of the same file to know which implementation it should return.</p>
<pre class="code" ><code class="chroma" ><span class="kn">package</span> <span class="nx">creational</span>

<span class="kn">import</span> <span class="p">(</span>
  <span class="s">&#34;errors&#34;</span>
  <span class="s">&#34;fmt&#34;</span>
<span class="p">)</span>

<span class="kd">type</span> <span class="nx">PaymentMethod</span> <span class="kd">interface</span> <span class="p">{</span>
  <span class="nx">Pay</span><span class="p">(</span><span class="nx">amount</span> <span class="kt">float32</span><span class="p">)</span> <span class="kt">string</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="p">(</span>
  <span class="nx">Cash</span>      <span class="p">=</span> <span class="mi">1</span>
  <span class="nx">DebitCard</span> <span class="p">=</span> <span class="mi">2</span>
<span class="p">)</span>
<span class="kd">type</span> <span class="nx">CashPM</span> <span class="kd">struct</span><span class="p">{}</span>
<span class="kd">type</span> <span class="nx">DebitCardPM</span> <span class="kd">struct</span><span class="p">{}</span>

<span class="kd">func</span> <span class="nx">GetPaymentMethod</span><span class="p">(</span><span class="nx">m</span> <span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="nx">PaymentMethod</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">switch</span> <span class="nx">m</span> <span class="p">{</span>
  <span class="k">case</span> <span class="nx">Cash</span><span class="p">:</span>
    <span class="k">return</span> <span class="nb">new</span><span class="p">(</span><span class="nx">CashPM</span><span class="p">),</span> <span class="kc">nil</span>
  <span class="k">case</span> <span class="nx">DebitCard</span><span class="p">:</span>
    <span class="k">return</span> <span class="nb">new</span><span class="p">(</span><span class="nx">DebitCardPM</span><span class="p">),</span> <span class="kc">nil</span>
  <span class="k">default</span><span class="p">:</span>
    <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">errors</span><span class="p">.</span><span class="nx">New</span><span class="p">(</span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintf</span><span class="p">(</span><span class="s">&#34;Payment method %d not recognized\n&#34;</span><span class="p">,</span> <span class="nx">m</span><span class="p">))</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>We use a plain switch to check the contents of the argument <code>m</code> (method). If it matches any of the known methods--cash or debit card, it returns a new instance of them. Otherwise, it will return a nil and an error indicating that the payment method has not been recognized. Now we can run our tests again to check the second part of the unit tests:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go <span class="nb">test</span> -v -run<span class="o">=</span>GetPaymentMethod .
</span><span class="out" >=== RUN   TestGetPaymentMethodCash
--- FAIL: TestGetPaymentMethodCash (0.00s)
        factory_test.go:16: The cash payment method message wasn&#39;t correct
        factory_test.go:18: LOG:
=== RUN   TestGetPaymentMethodDebitCard
--- FAIL: TestGetPaymentMethodDebitCard (0.00s)
        factory_test.go:28: The debit card payment method message wasn&#39;t correct
        factory_test.go:30: LOG:
=== RUN   TestGetPaymentMethodNonExistent
--- PASS: TestGetPaymentMethodNonExistent (0.00s)
        factory_test.go:38: LOG: Payment method 20 not recognized
FAIL
exit status 1
FAIL
</span></code></pre>
<p>Now we do not get the errors saying it couldn&#39;t find the type of payment methods. Instead, we receive a <code>message not correct</code> error when it tries to use any of the methods that it covers. We also got rid of the <code>Not implemented</code> message that was being returned when we asked for an unknown payment method. Let&#39;s implement the structs now:</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">CashPM</span> <span class="kd">struct</span><span class="p">{}</span>
<span class="kd">type</span> <span class="nx">DebitCardPM</span> <span class="kd">struct</span><span class="p">{}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">CashPM</span><span class="p">)</span> <span class="nx">Pay</span><span class="p">(</span><span class="nx">amount</span> <span class="kt">float32</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintf</span><span class="p">(</span><span class="s">&#34;%0.2f paid using cash\n&#34;</span><span class="p">,</span> <span class="nx">amount</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">DebitCardPM</span><span class="p">)</span> <span class="nx">Pay</span><span class="p">(</span><span class="nx">amount</span> <span class="kt">float32</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintf</span><span class="p">(</span><span class="s">&#34;%#0.2f paid using debit card\n&#34;</span><span class="p">,</span> <span class="nx">amount</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
<p>We just get the amount, printing it in a nicely formatted message. With this implementation, the tests will all be passing now:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go <span class="nb">test</span> -v -run<span class="o">=</span>GetPaymentMethod .
</span><span class="out" >=== RUN   TestGetPaymentMethodCash
--- PASS: TestGetPaymentMethodCash (0.00s)
        factory_test.go:18: LOG: 10.30 paid using cash
=== RUN   TestGetPaymentMethodDebitCard
--- PASS: TestGetPaymentMethodDebitCard (0.00s)
        factory_test.go:30: LOG: 22.30 paid using debit card
=== RUN   TestGetPaymentMethodNonExistent
--- PASS: TestGetPaymentMethodNonExistent (0.00s)
        factory_test.go:38: LOG: Payment method 20 not recognized
PASS
ok
</span></code></pre>
<p>Do you see the <code>LOG:</code> messages? They aren&#39;t errors, we just print some information that we receive when using the package under test. These messages can be omitted unless you pass the <code>-v</code> flag to the test command:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go <span class="nb">test</span> -run<span class="o">=</span>GetPaymentMethod .
</span><span class="out" >ok
</span></code></pre>
</div>
<h4 id="upgrading-the-debitcard-method-to-a-new-platform" >Upgrading the Debitcard method to a new platform</h4>
<div class="hBody-4" >
<p>Now imagine that your <code>DebitCard</code> payment method has changed for some reason, and you need a new struct for it. To achieve this scenario, you will only need to create the new struct and replace the old one when the user asks for the <code>DebitCard</code> payment method:</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">CreditCardPM</span> <span class="kd">struct</span> <span class="p">{}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">d</span> <span class="o">*</span><span class="nx">CreditCardPM</span><span class="p">)</span> <span class="nx">Pay</span><span class="p">(</span><span class="nx">amount</span> <span class="kt">float32</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintf</span><span class="p">(</span><span class="s">&#34;%#0.2f paid using new credit card implementation\n&#34;</span><span class="p">,</span> <span class="nx">amount</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
<p>This is our new type that will replace the <code>DebitCardPM</code> structure. The <code>CreditCardPM</code> implements the same <code>PaymentMethod</code> interface as the debit card. We haven&#39;t deleted the previous one in case we need it in the future. The only difference lies in the returned message that now contains the information about the new type. We also have to modify the method to retrieve the payment methods:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">GetPaymentMethod</span><span class="p">(</span><span class="nx">m</span> <span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="nx">PaymentMethod</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">switch</span> <span class="nx">m</span> <span class="p">{</span>
  <span class="k">case</span> <span class="nx">Cash</span><span class="p">:</span>
    <span class="k">return</span> <span class="nb">new</span><span class="p">(</span><span class="nx">CashPM</span><span class="p">),</span> <span class="kc">nil</span>
  <span class="k">case</span> <span class="nx">DebitCard</span><span class="p">:</span>
    <span class="k">return</span> <span class="nb">new</span><span class="p">(</span><span class="nx">CreditCardPM</span><span class="p">),</span> <span class="kc">nil</span>
  <span class="k">default</span><span class="p">:</span>
    <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">errors</span><span class="p">.</span><span class="nx">New</span><span class="p">(</span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintf</span><span class="p">(</span><span class="s">&#34;Payment method %d not recognized\n&#34;</span><span class="p">,</span> <span class="nx">m</span><span class="p">))</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>The only modification is in the line where we create the new debit card that now points to the newly created struct. Let&#39;s run the tests to see if everything is still correct:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go <span class="nb">test</span> -v -run<span class="o">=</span>GetPaymentMethod .
</span><span class="out" >=== RUN   TestGetPaymentMethodCash
--- PASS: TestGetPaymentMethodCash (0.00s)
        factory_test.go:18: LOG: 10.30 paid using cash
=== RUN   TestGetPaymentMethodDebitCard
--- FAIL: TestGetPaymentMethodDebitCard (0.00s)
        factory_test.go:28: The debit card payment method message wasn&#39;t correct
        factory_test.go:30: LOG: 22.30 paid using new debit card implementation
=== RUN   TestGetPaymentMethodNonExistent
--- PASS: TestGetPaymentMethodNonExistent (0.00s)
        factory_test.go:38: LOG: Payment method 20 not recognized
FAIL
exit status 1
FAIL
</span></code></pre>
<p>Uh, oh! Something has gone wrong. The expected message when paying with a credit card does not match the returned message. Does it mean that our code isn&#39;t correct? Generally speaking, yes, you shouldn&#39;t modify your tests to make your program work. When defining tests, you should be also aware of not defining them too much because you could achieve some coupling in the tests that you didn&#39;t have in your code. With the message restriction, we have a few grammatically correct possibilities for the message, so we&#39;ll change it to the following:</p>
<pre class="code" ><code class="chroma" ><span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintf</span><span class="p">(</span><span class="s">&#34;%#0.2f paid using debit card (new)\n&#34;</span><span class="p">,</span> <span class="nx">amount</span><span class="p">)</span>
</code></pre>
<p>We run the tests again now:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go <span class="nb">test</span> -v -run<span class="o">=</span>GetPaymentMethod .
</span><span class="out" >=== RUN   TestGetPaymentMethodCash
--- PASS: TestGetPaymentMethodCash (0.00s)
        factory_test.go:18: LOG: 10.30 paid using cash
=== RUN   TestGetPaymentMethodDebitCard
--- PASS: TestGetPaymentMethodDebitCard (0.00s)
        factory_test.go:30: LOG: 22.30 paid using debit card (new)
=== RUN   TestGetPaymentMethodNonExistent
--- PASS: TestGetPaymentMethodNonExistent (0.00s)
        factory_test.go:38: LOG: Payment method 20 not recognized
PASS
ok
</span></code></pre>
<p>Everything is okay again. This was just a small example of how to write good unit tests, too. When we wanted to check that a debit card payment method returns a message that contains <code>paid using debit card</code> string, we were probably being a bit restrictive, and it would be better to check for those words separately or define a better formatting for the returned messages.</p>
</div>
<h4 id="what-we-learned-about-the-factory-method" >What we learned about the Factory method</h4>
<div class="hBody-4" >
<p>With the Factory method pattern, we have learned how to group families of objects so that their implementation is outside of our scope. We have also learned what to do when we need to upgrade an implementation of a used structs. Finally, we have seen that tests must be written with care if you don&#39;t want to tie yourself to certain implementations that don&#39;t have anything to do with the tests directly.</p>
</div>
<h3 id="abstract-factory---a-factory-of-factories" >Abstract Factory - a factory of factories</h3>
<div class="hBody-3" >
<p>After learning about the factory design pattern, where we grouped a family of related objects in our case payment methods, one can be quick to think--what if I group families of objects in a more structured hierarchy of families?</p>
</div>
<h4 id="description" >Description</h4>
<div class="hBody-4" >
<p>The Abstract Factory design pattern is a new layer of grouping to achieve a bigger (and more complex) composite object, which is used through its interfaces. The idea behind grouping objects in families and grouping families is to have big factories that can be interchangeable and can grow more easily. In the early stages of development, it is also easier to work with factories and abstract factories than to wait until all concrete implementations are done to start your code. Also, you won&#39;t write an Abstract Factory from the beginning unless you know that your object&#39;s inventory for a particular field is going to be very large and it could be easily grouped into families.</p>
</div>
<h4 id="the-objectives" >The objectives</h4>
<div class="hBody-4" >
<p>Grouping related families of objects is very convenient when your object number is growing so much that creating a unique point to get them all seems the only way to gain the flexibility of the runtime object creation. The following objectives of the Abstract Factory method must be clear to you:</p>
<ul>
<li>
<p>Provide a new layer of encapsulation for Factory methods that return a common interface for all factories</p>
</li>
<li>
<p>Group common factories into a <i>super Factory</i> (also called a factory of factories)</p>
</li>
</ul>
</div>
<h4 id="the-vehicle-factory-example,-again?" >The vehicle factory example, again?</h4>
<div class="hBody-4" >
<p>For our example, we are going to reuse the Factory we created in the Builder design pattern. We want to show the similarities to solve the same problem using a different approach so that you can see the strengths and weaknesses of each approach. This is going to show you the power of implicit interfaces in Go, as we won&#39;t have to touch almost anything. Finally, we are going to create a new Factory to create shipment orders.</p>
</div>
<h4 id="acceptance-criteria" >Acceptance criteria</h4>
<div class="hBody-4" >
<p>The following are the acceptance criteria for using the Vehicle object&#39;s Factory method:</p>
<ul>
<li>
<p>We must retrieve a <code>Vehicle</code> object using a factory returned by the abstract factory.</p>
</li>
<li>
<p>The vehicle must be a concrete implementation of a <code>Motorbike</code> or a <code>Car</code> that implements both interfaces (<code>Vehicle</code> and <code>Car</code> or <code>Vehicle</code> and <code>Motorbike</code>).</p>
</li>
</ul>
</div>
<h4 id="unit-test" >Unit test</h4>
<div class="hBody-4" >
<p>This is going to be a long example, so pay attention, please. We will have the following entities:</p>
<ul>
<li>
<p><code>Vehicle</code>: The interface that all objects in our factories must implement:</p>
<ul>
<li>
<p><code>Motorbike</code>: An interface for motorbikes of the types sport (one seat) and cruise (two seats).</p>
</li>
<li>
<p><code>Car</code>: An interface for cars of types luxury (with four doors) and family (with five doors).</p>
</li>
</ul>
</li>
<li>
<p><code>VehicleFactory</code>: An interface (the Abstract Factory) to retrieve factories that implement the <code>VehicleFactory</code> method:</p>
<ul>
<li>
<p><code>Motorbike</code> Factory: A factory that implements the <code>VehicleFactory</code> interface to return vehicle that implements the <code>Vehicle</code> and <code>Motorbike</code> interfaces.</p>
</li>
<li>
<p><code>Car</code> Factory: Another factory that implements the <code>VehicleFactory</code> interface to return vehicles that implement the <code>Vehicle</code> and <code>Car</code> interfaces.</p>
</li>
</ul>
</li>
</ul>
<p>For clarity, we are going to separate each entity into a different file. We will start with the <code>Vehicle</code> interface, which will be in the <span class="file" >vehicle.go</span> file:</p>
<pre class="code" ><code class="chroma" ><span class="kn">package</span> <span class="nx">abstract_factory</span>

<span class="kd">type</span> <span class="nx">Vehicle</span> <span class="kd">interface</span> <span class="p">{</span>
  <span class="nx">NumWheels</span><span class="p">()</span> <span class="kt">int</span>
  <span class="nx">NumSeats</span><span class="p">()</span> <span class="kt">int</span>
<span class="p">}</span>
</code></pre>
<p>The <code>Car</code> and <code>Motorbike</code> interfaces will be in the <span class="file" >car.go</span> and <span class="file" >motorbike.go</span> files, respectively:</p>
<pre class="code" ><code class="chroma" ><span class="c1">// Package abstract_factory file: car.go
</span><span class="c1"></span><span class="kn">package</span> <span class="nx">abstract_factory</span>

<span class="kd">type</span> <span class="nx">Car</span> <span class="kd">interface</span> <span class="p">{</span>
  <span class="nx">NumDoors</span><span class="p">()</span> <span class="kt">int</span>
<span class="p">}</span>
<span class="c1">// Package abstract_factory file: motorbike.go
</span><span class="c1"></span><span class="kn">package</span> <span class="nx">abstract_factory</span>

<span class="kd">type</span> <span class="nx">Motorbike</span> <span class="kd">interface</span> <span class="p">{</span>
  <span class="nx">GetMotorbikeType</span><span class="p">()</span> <span class="kt">int</span>
<span class="p">}</span>
</code></pre>
<p>We have one last interface, the one that each factory must implement. This will be in the <span class="file" >vehicle_factory.go</span> file:</p>
<pre class="code" ><code class="chroma" ><span class="kn">package</span> <span class="nx">abstract_factory</span>

<span class="kd">type</span> <span class="nx">VehicleFactory</span> <span class="kd">interface</span> <span class="p">{</span>
  <span class="nx">NewVehicle</span><span class="p">(</span><span class="nx">v</span> <span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="nx">Vehicle</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
<p>So, now we are going to declare the car factory. It must implement the <code>VehicleFactory</code> interface defined previously to return <code>Vehicles</code> instances:</p>
<pre class="code" ><code class="chroma" ><span class="kd">const</span> <span class="p">(</span>
  <span class="nx">LuxuryCarType</span> <span class="p">=</span> <span class="mi">1</span>
  <span class="nx">FamilyCarType</span> <span class="p">=</span> <span class="mi">2</span>
<span class="p">)</span>

<span class="kd">type</span> <span class="nx">CarFactory</span> <span class="kd">struct</span><span class="p">{}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">CarFactory</span><span class="p">)</span> <span class="nx">NewVehicle</span><span class="p">(</span><span class="nx">v</span> <span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="nx">Vehicle</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">switch</span> <span class="nx">v</span> <span class="p">{</span>
  <span class="k">case</span> <span class="nx">LuxuryCarType</span><span class="p">:</span>
    <span class="k">return</span> <span class="nb">new</span><span class="p">(</span><span class="nx">LuxuryCar</span><span class="p">),</span> <span class="kc">nil</span>
  <span class="k">case</span> <span class="nx">FamilyCarType</span><span class="p">:</span>
    <span class="k">return</span> <span class="nb">new</span><span class="p">(</span><span class="nx">FamilyCar</span><span class="p">),</span> <span class="kc">nil</span>
  <span class="k">default</span><span class="p">:</span>
    <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">errors</span><span class="p">.</span><span class="nx">New</span><span class="p">(</span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintf</span><span class="p">(</span><span class="s">&#34;Vehicle of type %d not recognized\n&#34;</span><span class="p">,</span> <span class="nx">v</span><span class="p">))</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>We have defined two types of cars--luxury and family. The car Factory will have to return cars that implement the <code>Car</code> and the <code>Vehicle</code> interfaces, so we need two concrete implementations:</p>
<pre class="code" ><code class="chroma" ><span class="c1">// luxury_car.go
</span><span class="c1"></span><span class="kn">package</span> <span class="nx">abstract_factory</span>

<span class="kd">type</span> <span class="nx">LuxuryCar</span> <span class="kd">struct</span><span class="p">{}</span>

<span class="kd">func</span> <span class="p">(</span><span class="o">*</span><span class="nx">LuxuryCar</span><span class="p">)</span> <span class="nx">NumDoors</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
  <span class="k">return</span> <span class="mi">4</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="o">*</span><span class="nx">LuxuryCar</span><span class="p">)</span> <span class="nx">NumWheels</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
  <span class="k">return</span> <span class="mi">4</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="o">*</span><span class="nx">LuxuryCar</span><span class="p">)</span> <span class="nx">NumSeats</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
  <span class="k">return</span> <span class="mi">5</span>
<span class="p">}</span>
</code></pre>
<pre class="code" ><code class="chroma" ><span class="kn">package</span> <span class="nx">abstract_factory</span>

<span class="kd">type</span> <span class="nx">FamilyCar</span> <span class="kd">struct</span><span class="p">{}</span>

<span class="kd">func</span> <span class="p">(</span><span class="o">*</span><span class="nx">FamilyCar</span><span class="p">)</span> <span class="nx">NumDoors</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
  <span class="k">return</span> <span class="mi">5</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="o">*</span><span class="nx">FamilyCar</span><span class="p">)</span> <span class="nx">NumWheels</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
  <span class="k">return</span> <span class="mi">4</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="o">*</span><span class="nx">FamilyCar</span><span class="p">)</span> <span class="nx">NumSeats</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
  <span class="k">return</span> <span class="mi">5</span>
<span class="p">}</span>
</code></pre>
<p>That&#39;s all for cars. Now we need the motorbike factory, which, like the car factory, must implement the <code>VehicleFactory</code> interface:</p>
<pre class="code" ><code class="chroma" ><span class="kd">const</span> <span class="p">(</span>
  <span class="nx">SportMotorbikeType</span> <span class="p">=</span> <span class="mi">1</span>
  <span class="nx">CruiseMotorbikeType</span> <span class="p">=</span> <span class="mi">2</span>
<span class="p">)</span>

<span class="kd">type</span> <span class="nx">MotorbikeFactory</span> <span class="kd">struct</span><span class="p">{}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">MotorbikeFactory</span><span class="p">)</span> <span class="nx">Build</span><span class="p">(</span><span class="nx">v</span> <span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="nx">Vehicle</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">switch</span> <span class="nx">v</span> <span class="p">{</span>
  <span class="k">case</span> <span class="nx">SportMotorbikeType</span><span class="p">:</span>
    <span class="k">return</span> <span class="nb">new</span><span class="p">(</span><span class="nx">SportMotorbike</span><span class="p">),</span> <span class="kc">nil</span>
  <span class="k">case</span> <span class="nx">CruiseMotorbikeType</span><span class="p">:</span>
    <span class="k">return</span> <span class="nb">new</span><span class="p">(</span><span class="nx">CruiseMotorbike</span><span class="p">),</span> <span class="kc">nil</span>
  <span class="k">default</span><span class="p">:</span>
    <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">errors</span><span class="p">.</span><span class="nx">New</span><span class="p">(</span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintf</span><span class="p">(</span><span class="s">&#34;Vehicle of type %d not recognized\n&#34;</span><span class="p">,</span> <span class="nx">v</span><span class="p">))</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>For the motorbike Factory, we have also defined two types of motorbikes using the <code>const</code> keywords: <code>SportMotorbikeType</code> and <code>CruiseMotorbikeType</code>. We will switch over the v argument in the <code>Build</code> method to know which type shall be returned. Let&#39;s write the two concrete motorbikes:</p>
<pre class="code" ><code class="chroma" ><span class="c1">// sport_motorbike.go
</span><span class="c1"></span><span class="kn">package</span> <span class="nx">abstract_factory</span>

<span class="kd">type</span> <span class="nx">SportMotorbike</span> <span class="kd">struct</span><span class="p">{}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">SportMotorbike</span><span class="p">)</span> <span class="nx">NumWheels</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
  <span class="k">return</span> <span class="mi">2</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">SportMotorbike</span><span class="p">)</span> <span class="nx">NumSeats</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
  <span class="k">return</span> <span class="mi">1</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">SportMotorbike</span><span class="p">)</span> <span class="nx">GetMotorbikeType</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">SportMotorbikeType</span>
<span class="p">}</span>
</code></pre>
<pre class="code" ><code class="chroma" ><span class="c1">// cruise_motorbike.go
</span><span class="c1"></span><span class="kn">package</span> <span class="nx">abstract_factory</span>

<span class="kd">type</span> <span class="nx">CruiseMotorbike</span> <span class="kd">struct</span><span class="p">{}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">CruiseMotorbike</span><span class="p">)</span> <span class="nx">NumWheels</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
  <span class="k">return</span> <span class="mi">2</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">CruiseMotorbike</span><span class="p">)</span> <span class="nx">NumSeats</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
  <span class="k">return</span> <span class="mi">2</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">CruiseMotorbike</span><span class="p">)</span> <span class="nx">GetMotorbikeType</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">CruiseMotorbikeType</span>
<span class="p">}</span>
</code></pre>
<p>To finish, we need the abstract factory itself, which we will put in the previously created <span class="file" >vehicle_factory.go</span> file:</p>
<pre class="code" ><code class="chroma" ><span class="kn">package</span> <span class="nx">abstract_factory</span>

<span class="kn">import</span> <span class="p">(</span>
  <span class="s">&#34;fmt&#34;</span>
  <span class="s">&#34;errors&#34;</span>
<span class="p">)</span>

<span class="kd">type</span> <span class="nx">VehicleFactory</span> <span class="kd">interface</span> <span class="p">{</span>
  <span class="nx">Build</span><span class="p">(</span><span class="nx">v</span> <span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="nx">Vehicle</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="p">(</span>
  <span class="nx">CarFactoryType</span> <span class="p">=</span> <span class="mi">1</span>
  <span class="nx">MotorbikeFactoryType</span> <span class="p">=</span> <span class="mi">2</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nx">BuildFactory</span><span class="p">(</span><span class="nx">f</span> <span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="nx">VehicleFactory</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">switch</span> <span class="nx">f</span> <span class="p">{</span>
  <span class="k">default</span><span class="p">:</span>
    <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">errors</span><span class="p">.</span><span class="nx">New</span><span class="p">(</span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintf</span><span class="p">(</span><span class="s">&#34;Factory with id %d not recognized\n&#34;</span><span class="p">,</span> <span class="nx">f</span><span class="p">))</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>We are going to write enough tests to make a reliable check as the scope of the book doesn&#39;t cover 100% of the statements. It will be a good exercise for the reader to finish these tests. First, a <code>motorbike</code> Factory test:</p>
<pre class="code" ><code class="chroma" ><span class="kn">package</span> <span class="nx">abstract_factory</span>

<span class="kn">import</span> <span class="s">&#34;testing&#34;</span>

<span class="kd">func</span> <span class="nx">TestMotorbikeFactory</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">motorbikeF</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">BuildFactory</span><span class="p">(</span><span class="nx">MotorbikeFactoryType</span><span class="p">)</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">t</span><span class="p">.</span><span class="nx">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="nx">motorbikeVehicle</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span>
    <span class="nx">motorbikeF</span><span class="p">.</span><span class="nx">Build</span><span class="p">(</span><span class="nx">SportMotorbikeType</span><span class="p">)</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">t</span><span class="p">.</span><span class="nx">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="nx">t</span><span class="p">.</span><span class="nx">Logf</span><span class="p">(</span><span class="s">&#34;Motorbike vehicle has %d wheels\n&#34;</span><span class="p">,</span> <span class="nx">motorbikeVehicle</span><span class="p">.</span><span class="nx">NumWheels</span><span class="p">())</span>

  <span class="nx">sportBike</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">motorbikeVehicle</span><span class="p">.(</span><span class="nx">Motorbike</span><span class="p">)</span>
  <span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
    <span class="nx">t</span><span class="p">.</span><span class="nx">Fatal</span><span class="p">(</span><span class="s">&#34;Struct assertion has failed&#34;</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="nx">t</span><span class="p">.</span><span class="nx">Logf</span><span class="p">(</span><span class="s">&#34;Sport motorbike has type %d\n&#34;</span><span class="p">,</span> <span class="nx">sportBike</span><span class="p">.</span><span class="nx">GetMotorbikeType</span><span class="p">())</span>
<span class="p">}</span>
</code></pre>
<p>We use the package method, <code>BuildFactory</code> , to retrieve a motorbike Factory (passing the <code>MotorbikeFactory</code> ID in the parameters), and check if we get any error. Then, already with the motorbike factory, we ask for a vehicle of the type <code>SportMotorbikeType</code> and check for errors again. With the returned vehicle, we can ask for methods of the vehicle interface (<code>NumWheels</code> and <code>NumSeats</code>). We know that it is a motorbike, but we cannot ask for the type of motorbike without using the type assertion. We use the type assertion on the vehicle to retrieve the motorbike that the <code>motorbikeVehicle</code> represents in the code line sportBike, <code>found := motorbikeVehicle.(Motorbike)</code>, and we must check that the type we have received is correct.</p>
<p>Finally, now we have a motorbike instance, we can ask for the bike type by using the <code>GetMotorbikeType</code> method. Now we are going to write a test that checks the car factory in the same manner:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">TestCarFactory</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">carF</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">BuildFactory</span><span class="p">(</span><span class="nx">CarFactoryType</span><span class="p">)</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">t</span><span class="p">.</span><span class="nx">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="nx">carVehicle</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">carF</span><span class="p">.</span><span class="nx">Build</span><span class="p">(</span><span class="nx">LuxuryCarType</span><span class="p">)</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">t</span><span class="p">.</span><span class="nx">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="nx">t</span><span class="p">.</span><span class="nx">Logf</span><span class="p">(</span><span class="s">&#34;Car vehicle has %d seats\n&#34;</span><span class="p">,</span>
    <span class="nx">carVehicle</span><span class="p">.</span><span class="nx">NumWheels</span><span class="p">())</span>

  <span class="nx">luxuryCar</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">carVehicle</span><span class="p">.(</span><span class="nx">Car</span><span class="p">)</span>
  <span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
    <span class="nx">t</span><span class="p">.</span><span class="nx">Fatal</span><span class="p">(</span><span class="s">&#34;Struct assertion has failed&#34;</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="nx">t</span><span class="p">.</span><span class="nx">Logf</span><span class="p">(</span><span class="s">&#34;Luxury car has %d doors.\n&#34;</span><span class="p">,</span> <span class="nx">luxuryCar</span><span class="p">.</span><span class="nx">NumDoors</span><span class="p">())</span>
<span class="p">}</span>
</code></pre>
<p>Again, we use the <code>BuildFactory</code> method to retrieve a <code>Car</code> Factory by using the <code>CarFactoryType</code> in the parameters. With this factory, we want a car of the <code>Luxury</code> type so that it returns a <code>vehicle</code> instance. We again do the type assertion to point to a car instance so that we can ask for the number of doors using the <code>NumDoors</code> method.</p>
<p>Let&#39;s run the unit tests:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go <span class="nb">test</span> -v -run<span class="o">=</span>Factory .
</span><span class="out" >=== RUN   TestMotorbikeFactory
--- FAIL: TestMotorbikeFactory (0.00s)
        vehicle_factory_test.go:8: Factory with id 2 not recognized
=== RUN   TestCarFactory
--- FAIL: TestCarFactory (0.00s)
        vehicle_factory_test.go:28: Factory with id 1 not recognized
FAIL
exit status 1
FAIL
</span></code></pre>
<p>Done. It can&#39;t recognize any factory as their implementation is still not done.</p>
</div>
<h4 id="implementation" >Implementation</h4>
<div class="hBody-4" >
<p>The implementation of every factory is already done for the sake of brevity. They are very similar to the Factory method with the only difference being that in the Factory method, we don&#39;t use an instance of the Factory method because we use the package functions directly. The implementation of the <code>vehicle</code> Factory is as follows:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">BuildFactory</span><span class="p">(</span><span class="nx">f</span> <span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="nx">VehicleFactory</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">switch</span> <span class="nx">f</span> <span class="p">{</span>
  <span class="k">case</span> <span class="nx">CarFactoryType</span><span class="p">:</span>
    <span class="k">return</span> <span class="nb">new</span><span class="p">(</span><span class="nx">CarFactory</span><span class="p">),</span> <span class="kc">nil</span>
  <span class="k">case</span> <span class="nx">MotorbikeFactoryType</span><span class="p">:</span>
    <span class="k">return</span> <span class="nb">new</span><span class="p">(</span><span class="nx">MotorbikeFactory</span><span class="p">),</span> <span class="kc">nil</span>
  <span class="k">default</span><span class="p">:</span>
    <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">errors</span><span class="p">.</span><span class="nx">New</span><span class="p">(</span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintf</span><span class="p">(</span><span class="s">&#34;Factory with id %d not recognized\n&#34;</span><span class="p">,</span> <span class="nx">f</span><span class="p">))</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>Like in any factory, we switched between the factory possibilities to return the one that was demanded. As we have already implemented all concrete vehicles, the tests must run too:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go <span class="nb">test</span> -v -run<span class="o">=</span>Factory -cover .
</span><span class="out" >=== RUN   TestMotorbikeFactory
--- PASS: TestMotorbikeFactory (0.00s)
        vehicle_factory_test.go:16: Motorbike vehicle has 2 wheels
        vehicle_factory_test.go:22: Sport motorbike has type 1
=== RUN   TestCarFactory
--- PASS: TestCarFactory (0.00s)
        vehicle_factory_test.go:36: Car vehicle has 4 seats
        vehicle_factory_test.go:42: Luxury car has 4 doors.
PASS
coverage: 45.8% of statements
ok
</span></code></pre>
<p>All of them passed. Take a close look and note that we have used the <code>-cover</code> flag when running the tests to return a coverage percentage of the package: 45.8%. What this tells us is that 45.8% of the lines are covered by the tests we have written, but 54.2% are still not under the tests. This is because we haven&#39;t covered the cruise motorbike and the family car with the tests. If you write those tests, the result should rise to around 70.8%.</p>
<div class="about" >
<div class="about-dt" >Tip</div>
<div class="about-dd" >
<p>Type assertion is also known as <b>casting</b> in other languages. When you have an interface instance, which is essentially a pointer to a struct, you just have access to the interface methods. With type assertion, you can tell the compiler the type of the pointed struct, so you can access the entire struct fields and methods.</p>
</div>
</div>
</div>
<h4 id="a-few-lines-about-the-abstract-factory-method" >A few lines about the Abstract Factory method</h4>
<div class="hBody-4" >
<p>We have learned how to write a factory of factories that provides us with a very generic object of vehicle type. This pattern is commonly used in many applications and libraries, such as cross-platform GUI libraries. Think of a button, a generic object, and button factory that provides you with a factory for Microsoft Windows buttons while you have another factory for Mac OS X buttons. You don&#39;t want to deal with the implementation details of each platform, but you just want to implement the actions for some specific behavior raised by a button.</p>
<p>Also, we have seen the differences when approaching the same problem with two different solutions--the Abstract factory and the Builder pattern. As you have seen, with the Builder pattern, we had an unstructured list of objects (cars with motorbikes in the same factory). Also, we encouraged reusing the building algorithm in the Builder pattern. In the Abstract factory, we have a very structured list of vehicles (the factory for motorbikes and a factory for cars). We also didn&#39;t mix the creation of cars with motorbikes, providing more flexibility in the creation process. The Abstract factory and Builder patterns can both resolve the same problem, but your particular needs will help you find the slight differences that should lead you to take one solution or the other.</p>
</div>
<h3 id="prototype-design-pattern" >Prototype design pattern</h3>
<div class="hBody-3" >
<p>The last pattern we will see in this chapter is the <b>Prototype</b> pattern. Like all creational patterns, this too comes in handy when creating objects, and it is very common to see the Prototype pattern surrounded by more patterns.</p>
<p>While with the Builder pattern, we are dealing with repetitive building algorithms and with the factories we are simplifying the creation of many types of objects; with the Prototype pattern, we will use an already created instance of some type to clone it and complete it with the particular needs of each context. Let&#39;s see it in detail.</p>
</div>
<h4 id="description" >Description</h4>
<div class="hBody-4" >
<p>The aim of the Prototype pattern is to have an object or a set of objects that is already created at compilation time, but which you can clone as many times as you want at runtime. This is useful, for example, as a default template for a user who has just registered with your webpage or a default pricing plan in some service. The key difference between this and a Builder pattern is that objects are cloned for the user instead of building them at runtime. You can also build a cache-like solution, storing information using a prototype.</p>
</div>
<h4 id="objective" >Objective</h4>
<div class="hBody-4" >
<p>The main objective for the Prototype design pattern is to avoid repetitive object creation. Imagine a default object composed of dozens of fields and embedded types. We don&#39;t want to write everything needed by this type every time that we use the object, especially if we can mess it up by creating instances with different <i>foundations</i>:</p>
<ul>
<li>
<p>Maintain a set of objects that will be cloned to create new instances</p>
</li>
<li>
<p>Provide a default value of some type to start working on top of it</p>
</li>
<li>
<p>Free CPU of complex object initialization to take more memory resources</p>
</li>
</ul>
</div>
<h4 id="example" >Example</h4>
<div class="hBody-4" >
<p>We will build a small component of an imaginary customized shirts shop that will have a few shirts with their default colors and prices. Each shirt will also have a <b>Stock Keeping Unit</b> (<span class="acronym" >SKU</span>), a system to identify items stored at a specific location) that will need an update.</p>
</div>
<h4 id="acceptance-criteria" >Acceptance criteria</h4>
<div class="hBody-4" >
<p>To achieve what is described in the example, we will use a prototype of shirts. Each time we need a new shirt we will take this prototype, clone it and work with it. In particular, those are the acceptance criteria for using the Prototype pattern design method in this example:</p>
<ul>
<li>
<p>To have a shirt-cloner object and interface to ask for different types of shirts (white, black, and blue at 15.00, 16.00, and 17.00 dollars respectively)</p>
</li>
<li>
<p>When you ask for a white shirt, a clone of the white shirt must be made, and the new instance must be different from the original one</p>
</li>
<li>
<p>The SKU of the created object shouldn&#39;t affect new object creation</p>
</li>
<li>
<p>An info method must give me all the information available on the instance fields, including the updated SKU</p>
</li>
</ul>
</div>
<h4 id="unit-test" >Unit test</h4>
<div class="hBody-4" >
<p>First, we will need a <code>ShirtCloner</code> interface and an object that implements it. Also, we need a package-level function called <code>GetShirtsCloner</code> to retrieve a new instance of the cloner:</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">ShirtCloner</span> <span class="kd">interface</span> <span class="p">{</span>
  <span class="nx">GetClone</span><span class="p">(</span><span class="nx">s</span> <span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="nx">ItemInfoGetter</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="p">(</span>
  <span class="nx">White</span> <span class="p">=</span> <span class="mi">1</span>
  <span class="nx">Black</span> <span class="p">=</span> <span class="mi">2</span>
  <span class="nx">Blue</span>  <span class="p">=</span> <span class="mi">3</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nx">GetShirtsCloner</span><span class="p">()</span> <span class="nx">ShirtCloner</span> <span class="p">{</span>
  <span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">ShirtsCache</span> <span class="kd">struct</span> <span class="p">{}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">ShirtsCache</span><span class="p">)</span><span class="nx">GetClone</span><span class="p">(</span><span class="nx">s</span> <span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="nx">ItemInfoGetter</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">errors</span><span class="p">.</span><span class="nx">New</span><span class="p">(</span><span class="s">&#34;Not implemented yet&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
<p>Now we need an object struct to clone, which implements an interface to retrieve the information of its fields. We will call the object <code>Shirt</code> and the <code>ItemInfoGetter</code> interface:</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">ItemInfoGetter</span> <span class="kd">interface</span> <span class="p">{</span>
  <span class="nx">GetInfo</span><span class="p">()</span> <span class="kt">string</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">ShirtColor</span> <span class="kt">byte</span>

<span class="kd">type</span> <span class="nx">Shirt</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">Price</span> <span class="kt">float32</span>
  <span class="nx">SKU</span>   <span class="kt">string</span>
  <span class="nx">Color</span> <span class="nx">ShirtColor</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">Shirt</span><span class="p">)</span> <span class="nx">GetInfo</span><span class="p">()</span><span class="kt">string</span> <span class="p">{</span>
  <span class="k">return</span> <span class="s">&#34;&#34;</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">GetShirtsCloner</span><span class="p">()</span> <span class="nx">ShirtCloner</span> <span class="p">{</span>
  <span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">whitePrototype</span> <span class="o">*</span><span class="nx">Shirt</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">Shirt</span><span class="p">{</span>
  <span class="nx">Price</span><span class="p">:</span> <span class="mf">15.00</span><span class="p">,</span>
  <span class="nx">SKU</span><span class="p">:</span>   <span class="s">&#34;empty&#34;</span><span class="p">,</span>
  <span class="nx">Color</span><span class="p">:</span> <span class="nx">White</span><span class="p">,</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">i</span> <span class="o">*</span><span class="nx">Shirt</span><span class="p">)</span> <span class="nx">GetPrice</span><span class="p">()</span> <span class="kt">float32</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">i</span><span class="p">.</span><span class="nx">Price</span>
<span class="p">}</span>
</code></pre>
<div class="about" >
<div class="about-dt" >Tip</div>
<div class="about-dd" >
<p>Have you realized that the type called <code>ShirtColor</code> that we defined is just a <code>byte</code> type? Maybe you are wondering why we haven&#39;t simply used the byte <code>type</code>. We could, but this way we created an easily readable struct, which we can upgrade with some methods in the future if required. For example, we could write a <code>String()</code> method that returns the color in the string format (<code>White</code> for type 1, <code>Black</code> for type 2, and <code>Blue</code> for type 3).</p>
</div>
</div>
<p>With this code, we can already write our first tests:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">TestClone</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">shirtCache</span> <span class="o">:=</span> <span class="nx">GetShirtsCloner</span><span class="p">()</span>
  <span class="k">if</span> <span class="nx">shirtCache</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">t</span><span class="p">.</span><span class="nx">Fatal</span><span class="p">(</span><span class="s">&#34;Received cache was nil&#34;</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="nx">item1</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">shirtCache</span><span class="p">.</span><span class="nx">GetClone</span><span class="p">(</span><span class="nx">White</span><span class="p">)</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">t</span><span class="p">.</span><span class="nx">Error</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="c1">// more code continues here...
</span><span class="c1"></span></code></pre>
<p>We will cover the first case of our scenario, where we need a cloner object that we can use to ask for different shirt colors.</p>
<p>For the second case, we will take the original object (which we can access because we are in the scope of the package), and we will compare it with our <code>shirt1</code> instance.</p>
<pre class="code" ><code class="chroma" ><span class="k">if</span> <span class="nx">item1</span> <span class="o">==</span> <span class="nx">whitePrototype</span> <span class="p">{</span>
  <span class="nx">t</span><span class="p">.</span><span class="nx">Error</span><span class="p">(</span><span class="s">&#34;item1 cannot be equal to the white prototype&#34;</span><span class="p">);</span>
<span class="p">}</span>
</code></pre>
<p>Now, for the third case. First, we will type assert <code>item1</code> to a shirt so that we can set an SKU. We will create a second shirt, also white, and we will type assert it too to check that the SKUs are different:</p>
<pre class="code" ><code class="chroma" ><span class="nx">shirt1</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">item1</span><span class="p">.(</span><span class="o">*</span><span class="nx">Shirt</span><span class="p">)</span>
<span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
  <span class="nx">t</span><span class="p">.</span><span class="nx">Fatal</span><span class="p">(</span><span class="s">&#34;Type assertion for shirt1 couldn&#39;t be done successfully&#34;</span><span class="p">)</span>
<span class="p">}</span>
<span class="nx">shirt1</span><span class="p">.</span><span class="nx">SKU</span> <span class="p">=</span> <span class="s">&#34;abbcc&#34;</span>

<span class="nx">item2</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">shirtCache</span><span class="p">.</span><span class="nx">GetClone</span><span class="p">(</span><span class="nx">White</span><span class="p">)</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
  <span class="nx">t</span><span class="p">.</span><span class="nx">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
<span class="p">}</span>

<span class="nx">shirt2</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">item2</span><span class="p">.(</span><span class="o">*</span><span class="nx">Shirt</span><span class="p">)</span>
<span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
  <span class="nx">t</span><span class="p">.</span><span class="nx">Fatal</span><span class="p">(</span><span class="s">&#34;Type assertion for shirt1 couldn&#39;t be done successfully&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">if</span> <span class="nx">shirt1</span><span class="p">.</span><span class="nx">SKU</span> <span class="o">==</span> <span class="nx">shirt2</span><span class="p">.</span><span class="nx">SKU</span> <span class="p">{</span>
  <span class="nx">t</span><span class="p">.</span><span class="nx">Error</span><span class="p">(</span><span class="s">&#34;SKU&#39;s of shirt1 and shirt2 must be different&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">if</span> <span class="nx">shirt1</span> <span class="o">==</span> <span class="nx">shirt2</span> <span class="p">{</span>
  <span class="nx">t</span><span class="p">.</span><span class="nx">Error</span><span class="p">(</span><span class="s">&#34;Shirt 1 cannot be equal to Shirt 2&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
<p>Finally, for the fourth case, we log the info of the first and second shirts:</p>
<pre class="code" ><code class="chroma" ><span class="nx">t</span><span class="p">.</span><span class="nx">Logf</span><span class="p">(</span><span class="s">&#34;LOG: %s&#34;</span><span class="p">,</span> <span class="nx">shirt1</span><span class="p">.</span><span class="nx">GetInfo</span><span class="p">())</span>
<span class="nx">t</span><span class="p">.</span><span class="nx">Logf</span><span class="p">(</span><span class="s">&#34;LOG: %s&#34;</span><span class="p">,</span> <span class="nx">shirt2</span><span class="p">.</span><span class="nx">GetInfo</span><span class="p">())</span>
</code></pre>
<p>We will be printing the memory positions of both shirts, so we make this assertion at a more physical level:</p>
<pre class="code" ><code class="chroma" ><span class="nx">t</span><span class="p">.</span><span class="nx">Logf</span><span class="p">(</span><span class="s">&#34;LOG: The memory positions of the shirts are different %p != %p \n\n&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">shirt1</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">shirt2</span><span class="p">)</span>
</code></pre>
<p>Finally, we run the tests so we can check that it fails:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go <span class="nb">test</span> -run<span class="o">=</span>TestClone .
</span><span class="out" >--- FAIL: TestClone (0.00s)
prototype_test.go:10: Not implemented yet
FAIL
FAIL
</span></code></pre>
<p>We have to stop there so that the tests don&#39;t panic if we try to use a nil object that is returned by the <code>GetShirtsCloner</code> function.</p>
</div>
<h4 id="implementation" >Implementation</h4>
<div class="hBody-4" >
<p>We will start with the <code>GetClone</code> method. This method should return an item of the specified type and we have three type: white, black and blue:</p>
<pre class="code" ><code class="chroma" ><span class="kd">var</span> <span class="nx">whitePrototype</span> <span class="o">*</span><span class="nx">Shirt</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">Shirt</span><span class="p">{</span>
  <span class="nx">Price</span><span class="p">:</span> <span class="mf">15.00</span><span class="p">,</span>
  <span class="nx">SKU</span><span class="p">:</span>   <span class="s">&#34;empty&#34;</span><span class="p">,</span>
  <span class="nx">Color</span><span class="p">:</span> <span class="nx">White</span><span class="p">,</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">blackPrototype</span> <span class="o">*</span><span class="nx">Shirt</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">Shirt</span><span class="p">{</span>
  <span class="nx">Price</span><span class="p">:</span> <span class="mf">16.00</span><span class="p">,</span>
  <span class="nx">SKU</span><span class="p">:</span>   <span class="s">&#34;empty&#34;</span><span class="p">,</span>
  <span class="nx">Color</span><span class="p">:</span> <span class="nx">Black</span><span class="p">,</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">bluePrototype</span> <span class="o">*</span><span class="nx">Shirt</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">Shirt</span><span class="p">{</span>
  <span class="nx">Price</span><span class="p">:</span> <span class="mf">17.00</span><span class="p">,</span>
  <span class="nx">SKU</span><span class="p">:</span>   <span class="s">&#34;empty&#34;</span><span class="p">,</span>
  <span class="nx">Color</span><span class="p">:</span> <span class="nx">Blue</span><span class="p">,</span>
<span class="p">}</span>
</code></pre>
<p>So now that we have the three prototypes to work over we can implement <code>GetClone(s int)</code> method:</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">ShirtsCache</span> <span class="kd">struct</span> <span class="p">{}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">ShirtsCache</span><span class="p">)</span><span class="nx">GetClone</span><span class="p">(</span><span class="nx">s</span> <span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="nx">ItemInfoGetter</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">switch</span> <span class="nx">m</span> <span class="p">{</span>
  <span class="k">case</span> <span class="nx">White</span><span class="p">:</span>
    <span class="nx">newItem</span> <span class="o">:=</span> <span class="o">*</span><span class="nx">whitePrototype</span>
    <span class="k">return</span> <span class="o">&amp;</span><span class="nx">newItem</span><span class="p">,</span> <span class="kc">nil</span>
  <span class="k">case</span> <span class="nx">Black</span><span class="p">:</span>
    <span class="nx">newItem</span> <span class="o">:=</span> <span class="o">*</span><span class="nx">blackPrototype</span>
    <span class="k">return</span> <span class="o">&amp;</span><span class="nx">newItem</span><span class="p">,</span> <span class="kc">nil</span>
  <span class="k">case</span> <span class="nx">Blue</span><span class="p">:</span>
    <span class="nx">newItem</span> <span class="o">:=</span> <span class="o">*</span><span class="nx">bluePrototype</span>
    <span class="k">return</span> <span class="o">&amp;</span><span class="nx">newItem</span><span class="p">,</span> <span class="kc">nil</span>
  <span class="k">default</span><span class="p">:</span>
    <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">errors</span><span class="p">.</span><span class="nx">New</span><span class="p">(</span><span class="s">&#34;Shirt model not recognized&#34;</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>The <code>Shirt</code> structure also needs a <code>GetInfo</code> implementation to print the contents of the instances.</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">ShirtColor</span> <span class="kt">byte</span>

<span class="kd">type</span> <span class="nx">Shirt</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">Price</span> <span class="kt">float32</span>
  <span class="nx">SKU</span>   <span class="kt">string</span>
  <span class="nx">Color</span> <span class="nx">ShirtColor</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">Shirt</span><span class="p">)</span> <span class="nx">GetInfo</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintf</span><span class="p">(</span><span class="s">&#34;Shirt with SKU &#39;%s&#39; and Color id %d that costs %f\n&#34;</span><span class="p">,</span>
    <span class="nx">s</span><span class="p">.</span><span class="nx">SKU</span><span class="p">,</span> <span class="nx">s</span><span class="p">.</span><span class="nx">Color</span><span class="p">,</span> <span class="nx">s</span><span class="p">.</span><span class="nx">Price</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
<p>Finally, let&#39;s run the tests to see that everything is now working:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go <span class="nb">test</span> -run<span class="o">=</span>TestClone -v .
</span><span class="out" >=== RUN   TestClone
--- PASS: TestClone (0.00s)
        prototype_test.go:41: LOG: Shirt with SKU &#39;abbcc&#39; and Color id 1 that costs 15.000000
        prototype_test.go:42: LOG: Shirt with SKU &#39;empty&#39; and Color id 1 that costs 15.000000
        prototype_test.go:44: LOG: The memory positions of the shirts are different 0xc42002c038 != 0xc42002c040

PASS
ok
</span></code></pre>
<p>In the log, (remember to set the <code>-v</code> flag when running the tests) you can check that <code>shirt1</code> and <code>shirt2</code> have different SKUs. Also, we can see the memory positions of both objects. Take into account that the positions shown on your computer will probably be different.</p>
</div>
<h4 id="what-we-learned-about-the-prototype-design-pattern" >What we learned about the Prototype design pattern</h4>
<div class="hBody-4" >
<p>The Prototype pattern is a powerful tool to build caches and default objects. You have probably realized too that some patterns can overlap a bit, but they have small differences that make them more appropriate in some cases and not so much in others.</p>
</div>
<h3 id="summary" >Summary</h3>
<div class="hBody-3" >
<p>We have seen the five main creational design patterns commonly used in the software industry. Their purpose is to abstract the user from the creation of objects for complexity or maintainability purposes. They have been the foundation of thousands of applications and libraries since the 1990s, and most of the software we use today has many of these creational patterns under the hood.</p>
<p>It&#39;s worth mentioning that these patterns are not thread-free. In a more advanced chapter, we will see concurrent programming in Go, and how to create some of the more critical design patterns using a concurrent approach.</p>
</div>
<h2 id="chapter-3" >Structural Patterns - Composite, Adapter, and Bridge Design Patterns</h2>
<div class="hBody-2" >
<p>We are going to start our journey through the world of structural patterns. Structural patterns, as the name implies, help us to shape our applications with commonly used structures and relationships.</p>
<p>The Go language, by nature, encourages use of composition almost exclusively by its lack of inheritance. Because of this, we have been using the <b>Composite</b> design pattern extensively until now, so let&#39;s start by defining the Composite design pattern.</p>
</div>
<h3 id="composite-design-pattern" >Composite design pattern</h3>
<div class="hBody-3" >
<p>The Composite design pattern favors composition (commonly defined as a <i>has a</i> relationship) over inheritance (an <i>is a</i> relationship). The <i>composition over inheritance</i> approach has been a source of discussions among engineers since the nineties. We will learn how to create object structures by using a <i>has a</i> approach. All in all, Go doesn&#39;t have inheritance because it doesn&#39;t need it!</p>
</div>
<h4 id="description" >Description</h4>
<div class="hBody-4" >
<p>In the Composite design pattern, you will create hierarchies and trees of objects. Objects have different objects with their own fields and methods inside them. This approach is very powerful and solves many problems of inheritance and multiple inheritances. For example, a typical inheritance problem is when you have an entity that inherits from two completely different classes, which have absolutely no relationship between them. Imagine an athlete who trains, and who is a swimmer who swims:</p>
<ul>
<li>
<p>The <code>Athlete</code> class has a <code>Train()</code> method</p>
</li>
<li>
<p>The <code>Swimmer</code> class has a <code>Swim()</code> method</p>
</li>
</ul>
<p>The <code>Swimmer</code> class inherits from the <code>Athlete</code> class, so it inherits its <code>Train</code> method and declares its own <code>Swim</code> method. You could also have a cyclist who is also an athlete, and declares a <code>Ride</code> method.</p>
<p>But now imagine an animal that eats, like a dog that also barks:</p>
<ul>
<li>
<p>The <code>Cyclist</code> class has a <code>Ride()</code> method</p>
</li>
<li>
<p>The <code>Animal</code> class has <code>Eat()</code>, <code>Dog()</code>, and <code>Bark()</code> methods</p>
</li>
</ul>
<p>Nothing fancy. You could also have a fish that is an animal, and yes, swims! So, how do you solve it? A fish cannot be a swimmer that also trains. Fish don&#39;t train (as far as I know!). You could make a <code>Swimmer</code> interface with a <code>Swim</code> method, and make the swimmer athlete and fish implement it. This would be the best approach, but you still would have to implement <code>swim</code> method twice, so code reusability would be affected. What about a triathlete? They are athletes who swim, run, and ride. With multiple inheritances, you could have a sort of solution, but that will become complex and not maintainable very soon.</p>
</div>
<h4 id="objectives" >Objectives</h4>
<div class="hBody-4" >
<p>As you have probably imagined already, the objective of the composition is to avoid this type of hierarchy hell where the complexity of an application could grow too much, and the clarity of the code is affected.</p>
</div>
<h4 id="the-swimmer-and-the-fish" >The swimmer and the fish</h4>
<div class="hBody-4" >
<p>We will solve the described problem of the athlete and the fish that swims in a very idiomatic Go way. With Go, we can use two types of composition--the <b>direct</b> composition and the <b>embedding</b> composition. We will first solve this problem by using direct composition which is having everything that is needed as fields within the struct.</p>
</div>
<h4 id="requirements-and-acceptance-criteria" >Requirements and acceptance criteria</h4>
<div class="hBody-4" >
<p>Requirements are like the ones described previously. We&#39;ll have an athlete and a swimmer. We will also have an animal and a fish. The <code>Swimmer</code> and the <code>Fish</code> methods must share the code. The athlete must train, and the animal must eat:</p>
<ul>
<li>
<p>We must have an <code>Athlete</code> struct with a <code>Train</code> method</p>
</li>
<li>
<p>We must have a <code>Swimmer</code> with a <code>Swim</code> method</p>
</li>
<li>
<p>We must have an <code>Animal</code> struct with an <code>Eat</code> method</p>
</li>
<li>
<p>We must have a <code>Fish</code> struct with a <code>Swim</code> method that is shared with the <code>Swimmer</code>, and not have inheritance or hierarchy issues</p>
</li>
</ul>
</div>
<h4 id="creating-compositions" >Creating compositions</h4>
<div class="hBody-4" >
<p>The Composite design pattern is a pure structural pattern, and it doesn&#39;t have much to test apart from the structure itself. We won&#39;t write unit tests in this case, and we&#39;ll simply describe the ways to create those compositions in Go.</p>
<p>First, we&#39;ll start with the <code>Athlete</code> structure and its <code>Train</code> method:</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">Athlete</span> <span class="kd">struct</span><span class="p">{}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">Athlete</span><span class="p">)</span> <span class="nx">Train</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&#34;Training&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
<p>The preceding code is pretty straightforward. Its <code>Train</code> method prints the word <code>Training</code> and a new line. We&#39;ll create a composite swimmer that has an <code>Athlete</code> struct inside it:</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">CompositeSwimmerA</span> <span class="kd">struct</span><span class="p">{</span>
  <span class="nx">MyAthlete</span> <span class="nx">Athlete</span>
  <span class="nx">MySwim</span> <span class="kd">func</span><span class="p">()</span>
<span class="p">}</span>
</code></pre>
<p>The <code>CompositeSwimmerA</code> type has a <code>MyAthlete</code> field of type <code>Athlete</code>. It also stores a <code>func()</code> type. Remember that in Go, functions are first-class citizens and they can be used as parameters, fields, or arguments just like any variable. So <code>CompositeSwimmerA</code> has a <code>MySwim</code> field that stores a <b>closure</b>, which takes no arguments and returns nothing. How can I assign a function to it? Well, let&#39;s create a function that matches the <code>func()</code> signature (no arguments, no return):</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">Swim</span><span class="p">(){</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&#34;Swimming!&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
<p>That&#39;s all! The <code>Swim()</code> function takes no arguments and returns nothing, so it can be used as the <code>MySwim</code> field in the <code>CompositeSwimmerA</code> struct:</p>
<pre class="code" ><code class="chroma" ><span class="nx">swimmer</span> <span class="o">:=</span> <span class="nx">CompositeSwimmerA</span><span class="p">{</span>
  <span class="nx">MySwim</span><span class="p">:</span> <span class="nx">Swim</span><span class="p">,</span>
<span class="p">}</span>
<span class="nx">swimmer</span><span class="p">.</span><span class="nx">MyAthlete</span><span class="p">.</span><span class="nx">Train</span><span class="p">()</span>
<span class="nx">swimmer</span><span class="p">.</span><span class="nx">MySwim</span><span class="p">()</span>
</code></pre>
<p>Because we have a function called <code>Swim()</code>, we can assign it to the <code>MySwim</code> field. Note that the <code>Swim</code> type doesn&#39;t have the parenthesis that will execute its contents. This way we take the entire function and copy it to <code>MySwim</code> method.</p>
<p>But wait. We haven&#39;t passed any athlete to the <code>MyAthlete</code> field and we are using it! It&#39;s going to fail! Let&#39;s see what happens when we execute this snippet:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go run main.go
</span><span class="out" >Training
Swimming!
</span></code></pre>
<p>That&#39;s weird, isn&#39;t it? Not really because of the nature of zero-initialization in Go. If you don&#39;t pass an <code>Athlete</code> struct to the <code>CompositeSwimmerA</code> type, the compiler will create one with its values zero-initialized, that is, an <code>Athlete</code> struct with its fields initialized to zero. Check out <a href="#chapter-1" >Chapter 1</a>, <i>Ready... Steady... Go!</i> to recall zero-initialization if this seems confusing. Consider the <code>CompositeSwimmerA</code> struct code again:</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">CompositeSwimmerA</span> <span class="kd">struct</span><span class="p">{</span>
  <span class="nx">MyAthlete</span> <span class="nx">Athlete</span>
  <span class="nx">MySwim</span>    <span class="kd">func</span><span class="p">()</span>
<span class="p">}</span>
</code></pre>
<p>Now we have a pointer to a function stored in the <code>MySwim</code> field. We can assign the <code>Swim</code> function the same way, but with an extra step:</p>
<pre class="code" ><code class="chroma" ><span class="nx">localSwim</span> <span class="o">:=</span> <span class="nx">Swim</span>

<span class="nx">swimmer</span> <span class="o">:=</span> <span class="nx">CompositeSwimmerA</span><span class="p">{</span>
  <span class="nx">MySwim</span><span class="p">:</span> <span class="nx">localSwim</span><span class="p">,</span>
<span class="p">}</span>

<span class="nx">swimmer</span><span class="p">.</span><span class="nx">MyAthlete</span><span class="p">.</span><span class="nx">Train</span><span class="p">()</span>
<span class="nx">swimmer</span><span class="p">.</span><span class="nx">MySwim</span> <span class="p">()</span>
</code></pre>
<p>First, we need a variable that contains the function <code>Swim</code>. This is because a function doesn&#39;t have an address to pass it to the <code>CompositeSwimmerA</code> type. Then, to use this function within the struct, we have to make a two-step call.</p>
<p>What about our fish problem? With our <code>Swim</code> function, it is not a problem anymore. First, we create the <code>Animal</code> struct:</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">Animal</span> <span class="kd">struct</span><span class="p">{}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">Animal</span><span class="p">)</span><span class="nx">Eat</span><span class="p">()</span> <span class="p">{</span>
  <span class="nb">println</span><span class="p">(</span><span class="s">&#34;Eating&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
<p>Then we&#39;ll create a Shark object that embeds the <code>Animal</code> object:</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">Shark</span> <span class="kd">struct</span><span class="p">{</span>
  <span class="nx">Animal</span>
  <span class="nx">Swim</span> <span class="kd">func</span><span class="p">()</span>
<span class="p">}</span>
</code></pre>
<p>Wait a second! Where is the field name of the <code>Animal</code> type? Did you realize that I used the word <i>embed</i> in the previous paragraph? This is because, in Go, you can also embed objects within objects to make it look a lot like inheritance. That is, we won&#39;t have to explicitly call the field name to have access to its fields and method because they&#39;ll be part of us. So the following code will be perfectly okay:</p>
<pre class="code" ><code class="chroma" ><span class="nx">fish</span> <span class="o">:=</span> <span class="nx">Shark</span><span class="p">{</span>
  <span class="nx">Swim</span><span class="p">:</span> <span class="nx">Swim</span><span class="p">,</span>
<span class="p">}</span>

<span class="nx">fish</span><span class="p">.</span><span class="nx">Eat</span><span class="p">()</span>
<span class="nx">fish</span><span class="p">.</span><span class="nx">Swim</span><span class="p">()</span>
</code></pre>
<p>Now we have an <code>Animal</code> type, which is zero-initialized and embedded. This is why I can call the <code>Eat</code> method of the <code>Animal</code> struct without creating it or using the intermediate field name. The output of this snippet is the following:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go run main.go
</span><span class="out" >Eating
Swimming!
</span></code></pre>
<p>Finally, there is a third method to use the Composite pattern. We could create a <code>Swimmer</code> interface with a <code>Swim</code> method and a <code>SwimmerImpl</code> type to embed it in the athlete swimmer:</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">Swimmer</span> <span class="kd">interface</span> <span class="p">{</span>
  <span class="nx">Swim</span><span class="p">()</span>
<span class="p">}</span>
<span class="kd">type</span> <span class="nx">Trainer</span> <span class="kd">interface</span> <span class="p">{</span>
  <span class="nx">Train</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">SwimmerImpl</span> <span class="kd">struct</span><span class="p">{}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">SwimmerImpl</span><span class="p">)</span> <span class="nx">Swim</span><span class="p">(){</span>
  <span class="nb">println</span><span class="p">(</span><span class="s">&#34;Swimming!&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">CompositeSwimmerB</span> <span class="kd">struct</span><span class="p">{</span>
  <span class="nx">Trainer</span>
  <span class="nx">Swimmer</span>
<span class="p">}</span>
</code></pre>
<p>With this method, you have more explicit control over object creation. The <code>Swimmer</code> field is embedded, but won&#39;t be zero-initialized as it is a pointer to an interface. The correct use of this approach will be the following:</p>
<pre class="code" ><code class="chroma" ><span class="nx">swimmer</span> <span class="o">:=</span> <span class="nx">CompositeSwimmerB</span><span class="p">{</span>
  <span class="o">&amp;</span><span class="nx">Athlete</span><span class="p">{},</span>
  <span class="o">&amp;</span><span class="nx">SwimmerImpl</span><span class="p">{},</span>
<span class="p">}</span>

<span class="nx">swimmer</span><span class="p">.</span><span class="nx">Train</span><span class="p">()</span>
<span class="nx">swimmer</span><span class="p">.</span><span class="nx">Swim</span><span class="p">()</span>
</code></pre>
<p>And the output for <code>CompositeSwimmerB</code> is the following, as expected:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go run main.go
</span><span class="out" >Training
Swimming!
</span></code></pre>
<p>Which approach is better? Well, I have a personal preference, which shouldn&#39;t be considered the rule of thumb. In my opinion, the <i>interfaces</i> approach is the best for quite a few reasons, but mainly for explicitness.  First of all, you are working with interfaces which are preferred instead of structs. Second, you aren&#39;t leaving parts of your code to the zero-initialization feature of the compiler. It&#39;s a really powerful feature, but one that must be used with care, because it can lead to runtime problems which you&#39;ll find at compile time when working with interfaces. In different situations, zero-initialization will save you at runtime, in fact!  But I prefer to work with interfaces as much as possible, so this is not actually one of the options.</p>
</div>
<h4 id="binary-tree-compositions" >Binary Tree compositions</h4>
<div class="hBody-4" >
<p>Another very common approach to the Composite pattern is when working with Binary Tree structures. In a Binary Tree, you need to store instances of itself in a field:</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">Tree</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">LeafValue</span> <span class="kt">int</span>
  <span class="nx">Right</span>     <span class="o">*</span><span class="nx">Tree</span>
  <span class="nx">Left</span>      <span class="o">*</span><span class="nx">Tree</span>
<span class="p">}</span>
</code></pre>
<p>This is some kind of recursive compositing, and, because of the nature of recursivity, we must use pointers so that the compiler knows how much memory it must reserve for this struct. Our <code>Tree</code> struct stored a <code>LeafValue</code> object for each instance and a new <code>Tree</code> in its <code>Right</code> and <code>Left</code> fields.</p>
<p>With this structure, we could create an object like this:</p>
<pre class="code" ><code class="chroma" ><span class="nx">root</span> <span class="o">:=</span> <span class="nx">Tree</span><span class="p">{</span>
  <span class="nx">LeafValue</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
  <span class="nx">Right</span><span class="p">:</span><span class="o">&amp;</span><span class="nx">Tree</span><span class="p">{</span>
    <span class="nx">LeafValue</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span>
    <span class="nx">Right</span><span class="p">:</span> <span class="o">&amp;</span><span class="mi">1</span><span class="nx">Tree</span><span class="p">{</span> <span class="mi">6</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">nil</span> <span class="p">},</span>
    <span class="nx">Left</span><span class="p">:</span> <span class="kc">nil</span><span class="p">,</span>
  <span class="p">},</span>
  <span class="nx">Left</span><span class="p">:</span><span class="o">&amp;</span><span class="nx">Tree</span><span class="p">{</span> <span class="mi">4</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">nil</span> <span class="p">},</span>
<span class="p">}</span>
</code></pre>
<p>We can print the contents of its deepest branch like this:</p>
<pre class="code" ><code class="chroma" ><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">root</span><span class="p">.</span><span class="nx">Right</span><span class="p">.</span><span class="nx">Right</span><span class="p">.</span><span class="nx">LeafValue</span><span class="p">)</span>
</code></pre>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go run main.go
</span><span class="out" >6
</span></code></pre>
</div>
<h4 id="composite-pattern-versus-inheritance" >Composite pattern versus inheritance</h4>
<div class="hBody-4" >
<p>When using the Composite design pattern in Go, you must be very careful not to confuse it with inheritance. For example, when you embed a <code>Parent</code> struct within a <code>Son</code> struct, like in the following example:</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">Parent</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">SomeField</span> <span class="kt">int</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">Son</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">Parent</span>
<span class="p">}</span>
</code></pre>
<p>You cannot consider that the <code>Son</code> struct is also the <code>Parent</code> struct. What this means is that you cannot pass an instance of the <code>Son</code> struct to a function that is expecting a <code>Parent</code> struct like the following:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">GetParentField</span><span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">Parent</span><span class="p">)</span> <span class="kt">int</span><span class="p">{</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">p</span><span class="p">.</span><span class="nx">SomeField</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
<p>When you try to pass a Son instance to the GetParentField method, you will get the following error message:</p>
<pre class="srci" ><code class="sh" ><span class="out" >cannot use son (type Son) as type Parent in argument to GetParentField
</span></code></pre>
<p>This, in fact, makes a lot of sense. What&#39;s the solution for this? Well, you can simply composite the <code>Son</code> struct with the parent without embedding so that you can access the <code>Parent</code> instance later:</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">Son</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">P</span> <span class="nx">Parent</span>
<span class="p">}</span>
</code></pre>
<p>So now you could use the P field to pass it to the <code>GetParentField</code> method:</p>
<pre class="code" ><code class="chroma" ><span class="nx">son</span> <span class="o">:=</span> <span class="nx">Son</span><span class="p">{}</span>
<span class="nx">GetParentField</span><span class="p">(</span><span class="nx">son</span><span class="p">.</span><span class="nx">P</span><span class="p">)</span>
</code></pre>
</div>
<h4 id="final-words-on-the-composite-pattern" >Final words on the Composite pattern</h4>
<div class="hBody-4" >
<p>At this point, you should be really comfortable using the Composite design pattern. It&#39;s a very idiomatic Go feature, and the switch from a pure object-oriented language is not very painful. The Composite design pattern makes our structures predictable but also allows us to create most of the design patterns as we will see in later chapters.</p>
</div>
<h3 id="adapter-design-pattern" >Adapter design pattern</h3>
<div class="hBody-3" >
<p>One of the most commonly used structural patterns is the <b>Adapter</b> pattern. Like in real life, where you have plug adapters and bolt adapters, in Go, an adapter will allow us to use something that wasn&#39;t built for a specific task at the beginning.</p>
</div>
<h4 id="description" >Description</h4>
<div class="hBody-4" >
<p>The Adapter pattern is very useful when, for example, an interface gets outdated and it&#39;s not possible to replace it easily or fast. Instead, you create a new interface to deal with the current needs of your application, which, under the hood, uses implementations of the old interface.</p>
<p>Adapter also helps us to maintain the <i>open/closed principle</i> in our apps, making them more predictable too. They also allow us to write code which uses some base that we can&#39;t modify.</p>
<div class="about" >
<div class="about-dt" >Note</div>
<div class="about-dd" >
<p>The open/closed principle was first stated by Bertrand Meyer in his book <i>Object-Oriented Software Construction</i>. He stated that code should be open to new functionality, but closed to modifications. What does it mean? Well, it implies a few things. On one hand, we should try to write code that is extensible and not only one that works. At the same time, we should try not to modify the source code (yours or other people&#39;s) as much as we can, because we aren&#39;t always aware of the implications of this modification. Just keep in mind that extensibility in code is only possible through the use of design patterns and interface-oriented programming.</p>
</div>
</div>
</div>
<h4 id="objectives" >Objectives</h4>
<div class="hBody-4" >
<p>The Adapter design pattern will help you fit the needs of two parts of the code that are incompatible at first. This is the key to being kept in mind when deciding if the Adapter pattern is a good design for your problem--two interfaces that are incompatible, but which must work together, are good candidates for an Adapter pattern (but they could also use the facade pattern, for example).</p>
</div>
<h4 id="using-an-incompatible-interface-with-an-adapter-object" >Using an incompatible interface with an Adapter object</h4>
<div class="hBody-4" >
<p>For our example, we will have an old <code>Printer</code> interface and a new one. Users of the new interface don&#39;t expect the signature that the old one has, and we need an Adapter so that users can still use old implementations if necessary (to work with some legacy code, for example).</p>
</div>
<h4 id="requirements-and-acceptance-criteria" >Requirements and acceptance criteria</h4>
<div class="hBody-4" >
<p>Having an old interface called <code>LegacyPrinter</code> and a new one called <code>ModernPrinter</code>, create a structure that implements the <code>ModernPrinter</code> interface and can use the <code>LegacyPrinter</code> interface as described in the following steps:</p>
<ol class="num" >
<li>
<p>Create an Adapter object that implements the <code>ModernPrinter</code> interface.</p>
</li>
<li>
<p>The new Adapter object must contain an instance of the <code>LegacyPrinter</code> interface.</p>
</li>
<li>
<p>When using <code>ModernPrinter</code>, it must call the <code>LegacyPrinter</code> interface under the hood, prefixing it with the text <code>Adapter</code>.</p>
</li>
</ol>
</div>
<h4 id="unit-testing-our-printer-adapter" >Unit testing our Printer adapter</h4>
<div class="hBody-4" >
<p>We will write the legacy code first, but we won&#39;t test it as we should imagine that it isn&#39;t our code:</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">LegacyPrinter</span> <span class="kd">interface</span> <span class="p">{</span>
  <span class="nx">Print</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">string</span>
<span class="p">}</span>
<span class="kd">type</span> <span class="nx">MyLegacyPrinter</span> <span class="kd">struct</span> <span class="p">{}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">l</span> <span class="o">*</span><span class="nx">MyLegacyPrinter</span><span class="p">)</span> <span class="nx">Print</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">newMsg</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">newMsg</span> <span class="p">=</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintf</span><span class="p">(</span><span class="s">&#34;Legacy Printer: %s\n&#34;</span><span class="p">,</span> <span class="nx">s</span><span class="p">)</span>
  <span class="nb">println</span><span class="p">(</span><span class="nx">newMsg</span><span class="p">)</span>
  <span class="k">return</span>
<span class="p">}</span>
</code></pre>
<p>The legacy interface called <code>LegacyPrinter</code> has a <code>Print</code> method that accepts a string and returns a message. Our <code>MyLegacyPrinter</code> struct implements the <code>LegacyPrinter</code> interface and modifies the passed string by prefixing the text <code>Legacy Printer:</code>. After modifying the text, the <code>MyLegacyPrinter</code> struct prints the text on the console, and then returns it.</p>
<p>Now we&#39;ll declare the new interface that we&#39;ll have to adapt:</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">ModernPrinter</span> <span class="kd">interface</span> <span class="p">{</span>
  <span class="nx">PrintStored</span><span class="p">()</span> <span class="kt">string</span>
<span class="p">}</span>
</code></pre>
<p>In this case, the new <code>PrintStored</code> method doesn&#39;t accept any string as an argument, because it will have to be stored in the implementers in advance. We will call our Adapter pattern&#39;s <code>PrinterAdapter</code> interface:</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">PrinterAdapter</span> <span class="kd">struct</span><span class="p">{</span>
  <span class="nx">OldPrinter</span> <span class="nx">LegacyPrinter</span>
  <span class="nx">Msg</span>        <span class="kt">string</span>
<span class="p">}</span>
<span class="kd">func</span><span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">PrinterAdapter</span><span class="p">)</span> <span class="nx">PrintStored</span><span class="p">()</span> <span class="p">(</span><span class="nx">newMsg</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span>
<span class="p">}</span>
</code></pre>
<p>As mentioned earlier, the <code>PrinterAdapter</code> adapter must have a field to store the string to print. It must also have a field to store an instance of the <code>LegacyPrinter</code> adapter. So let&#39;s write the unit tests:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">TestAdapter</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">){</span>
  <span class="nx">msg</span> <span class="o">:=</span> <span class="s">&#34;Hello World!&#34;</span>
</code></pre>
<p>We will use the message <code>Hello World!</code> for our adapter. When using this message with an instance of the <code>MyLegacyPrinter</code> struct, it prints the text <code>Legacy Printer: Hello World!</code>:</p>
<pre class="code" ><code class="chroma" ><span class="nx">adapter</span> <span class="o">:=</span> <span class="nx">PrinterAdapter</span><span class="p">{</span><span class="nx">OldPrinter</span><span class="p">:</span> <span class="o">&amp;</span><span class="nx">MyLegacyPrinter</span><span class="p">{},</span> <span class="nx">Msg</span><span class="p">:</span> <span class="nx">msg</span><span class="p">}</span>
</code></pre>
<p>We created an instance of the <code>PrinterAdapter</code> interface called <code>adapter</code>. We passed an instance of the <code>MyLegacyPrinter</code> struct as the <code>LegacyPrinter</code> field called <code>OldPrinter</code>. Also, we set the message we want to print in the <code>Msg</code> field:</p>
<pre class="code" ><code class="chroma" ><span class="nx">returnedMsg</span> <span class="o">:=</span> <span class="nx">adapter</span><span class="p">.</span><span class="nx">PrintStored</span><span class="p">()</span>
<span class="k">if</span> <span class="nx">returnedMsg</span> <span class="o">!=</span> <span class="s">&#34;Legacy Printer: Adapter: Hello World!\n&#34;</span> <span class="p">{</span>
  <span class="nx">t</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&#34;Message didn&#39;t match: %s\n&#34;</span><span class="p">,</span> <span class="nx">returnedMsg</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
<p>Then we used the <code>PrintStored</code> method of the <code>ModernPrinter</code> interface; this method doesn&#39;t accept any argument and must return the modified string. We know that the <code>MyLegacyPrinter</code> struct returns the passed string prefixed with the text <code>LegacyPrinter</code>:, and the adapter will prefix it with the text <code>Adapter:</code> So, in the end, we must have the text <code>Legacy Printer: Adapter: Hello World!\n</code>.</p>
<p>As we are storing an instance of an interface, we must also check that we handle the situation where the pointer is nil. This is done with the following test:</p>
<pre class="code" ><code class="chroma" ><span class="nx">adapter</span> <span class="p">=</span> <span class="nx">PrinterAdapter</span><span class="p">{</span><span class="nx">OldPrinter</span><span class="p">:</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">Msg</span><span class="p">:</span> <span class="nx">msg</span><span class="p">}</span>
<span class="nx">returnedMsg</span> <span class="p">=</span> <span class="nx">adapter</span><span class="p">.</span><span class="nx">PrintStored</span><span class="p">()</span>
<span class="k">if</span> <span class="nx">returnedMsg</span> <span class="o">!=</span> <span class="s">&#34;Hello World!&#34;</span> <span class="p">{</span>
  <span class="nx">t</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&#34;Message didn&#39;t match: %s\n&#34;</span><span class="p">,</span> <span class="nx">returnedMsg</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
<p>If we don&#39;t pass an instance of the <code>LegacyPrinter</code> interface, the Adapter must ignore its adapt nature, and simply print and return the original message. Time to run our tests; consider the following:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go <span class="nb">test</span> -v .
</span><span class="out" >=== RUN   TestAdapter
--- FAIL: TestAdapter (0.00s)
        adapter_test.go:11: Message didn&#39;t match:
        adapter_test.go:17: Message didn&#39;t match:
FAIL
exit status 1
FAIL
</span></code></pre>
</div>
<h4 id="implementation" >Implementation</h4>
<div class="hBody-4" >
<p>To make our single test pass, we must reuse the old <code>MyLegacyPrinter</code> that is stored in <code>PrinterAdapter</code> struct:</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">PrinterAdapter</span> <span class="kd">struct</span><span class="p">{</span>
  <span class="nx">OldPrinter</span> <span class="nx">LegacyPrinter</span>
  <span class="nx">Msg</span>        <span class="kt">string</span>
<span class="p">}</span>

<span class="kd">func</span><span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">PrinterAdapter</span><span class="p">)</span> <span class="nx">PrintStored</span><span class="p">()</span> <span class="p">(</span><span class="nx">newMsg</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="nx">p</span><span class="p">.</span><span class="nx">OldPrinter</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">newMsg</span> <span class="p">=</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintf</span><span class="p">(</span><span class="s">&#34;Adapter: %s&#34;</span><span class="p">,</span> <span class="nx">p</span><span class="p">.</span><span class="nx">Msg</span><span class="p">)</span>
    <span class="nx">newMsg</span> <span class="p">=</span> <span class="nx">p</span><span class="p">.</span><span class="nx">OldPrinter</span><span class="p">.</span><span class="nx">Print</span><span class="p">(</span><span class="nx">newMsg</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="k">else</span> <span class="p">{</span>
    <span class="nx">newMsg</span> <span class="p">=</span> <span class="nx">p</span><span class="p">.</span><span class="nx">Msg</span>
  <span class="p">}</span>
  <span class="k">return</span>
<span class="p">}</span>
</code></pre>
<p>In the <code>PrintStored</code> method, we check whether we actually have an instance of a <code>LegacyPrinter</code>. In this case, we compose a new string with the stored message and the <code>Adapter</code> prefix to store it in the returning variable (called <code>newMsg</code>). Then we use the pointer to the <code>MyLegacyPrinter</code> struct to print the composed message using the <code>LegacyPrinter</code> interface.</p>
<p>In case there is no <code>LegacyPrinter</code> instance stored in the <code>OldPrinter</code> field, we simply assign the stored message to the returning variable <code>newMsg</code> and return the method. This should be enough to pass our tests:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go <span class="nb">test</span> -v .
</span><span class="out" >=== RUN   TestAdapter
Legacy Printer: Adapter: Hello World!
--- PASS: TestAdapter (0.00s)
PASS
ok
</span></code></pre>
<p>Perfect! Now we can still use the old <code>LegacyPrinter</code> interface by using this <code>Adapter</code> while we use the <code>ModernPrinter</code> interface for future implementations. Just keep in mind that the Adapter pattern must ideally just provide the way to use the old <code>LegacyPrinter</code> and nothing else. This way, its scope will be more encapsulated and more maintainable in the future.</p>
</div>
<h4 id="examples-of-the-adapter-pattern-in-go&#39;s-source-code" >Examples of the Adapter pattern in Go&#39;s source code</h4>
<div class="hBody-4" >
<p>You can find Adapter implementations at many places in the Go language&#39;s source code. The famous <code>http.Handler</code> interface has a very interesting adapter implementation. A very simple, <code>Hello World</code> server in Go is usually done like this:</p>
<pre class="code" ><code class="chroma" ><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
  <span class="s">&#34;fmt&#34;</span>
  <span class="s">&#34;log&#34;</span>
  <span class="s">&#34;net/http&#34;</span>
<span class="p">)</span>
<span class="kd">type</span> <span class="nx">MyServer</span> <span class="kd">struct</span><span class="p">{</span>
  <span class="nx">Msg</span> <span class="kt">string</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">MyServer</span><span class="p">)</span> <span class="nx">ServeHTTP</span><span class="p">(</span><span class="nx">w</span> <span class="nx">http</span><span class="p">.</span><span class="nx">ResponseWriter</span><span class="p">,</span><span class="nx">r</span>
  <span class="o">*</span><span class="nx">http</span><span class="p">.</span><span class="nx">Request</span><span class="p">){</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Fprintf</span><span class="p">(</span><span class="nx">w</span><span class="p">,</span> <span class="s">&#34;Hello, World&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">server</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">MyServer</span><span class="p">{</span>
    <span class="nx">Msg</span><span class="p">:</span><span class="s">&#34;Hello, World&#34;</span><span class="p">,</span>
  <span class="p">}</span>

  <span class="nx">http</span><span class="p">.</span><span class="nx">Handle</span><span class="p">(</span><span class="s">&#34;/&#34;</span><span class="p">,</span> <span class="nx">server</span><span class="p">)</span>
  <span class="nx">log</span><span class="p">.</span><span class="nx">Fatal</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">ListenAndServe</span><span class="p">(</span><span class="s">&#34;:8080&#34;</span><span class="p">,</span> <span class="kc">nil</span><span class="p">))</span>
<span class="p">}</span>
</code></pre>
<p>The HTTP package has a function called <code>Handle</code> (like a <code>static</code> method in Java) that accepts two parameters--a string to represent the route and a <code>Handler</code> interface. The <code>Handler</code> interface is like the following:</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">Handler</span> <span class="kd">interface</span> <span class="p">{</span>
  <span class="nx">ServeHTTP</span><span class="p">(</span><span class="nx">ResponseWriter</span><span class="p">,</span> <span class="o">*</span><span class="nx">Request</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
<p>We need to implement a <code>ServeHTTP</code> method that the server side of an HTTP connection will use to execute its context. But there is also a function <code>HandlerFunc</code> that allows you to define some endpoint behavior:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">http</span><span class="p">.</span><span class="nx">HandleFunc</span><span class="p">(</span><span class="s">&#34;/&#34;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">w</span> <span class="nx">http</span><span class="p">.</span><span class="nx">ResponseWriter</span><span class="p">,</span> <span class="nx">r</span>
    <span class="o">*</span><span class="nx">http</span><span class="p">.</span><span class="nx">Request</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">fmt</span><span class="p">.</span><span class="nx">Fprintf</span><span class="p">(</span><span class="nx">w</span><span class="p">,</span> <span class="s">&#34;Hello, World&#34;</span><span class="p">)</span>
    <span class="p">})</span>

  <span class="nx">log</span><span class="p">.</span><span class="nx">Fatal</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">ListenAndServe</span><span class="p">(</span><span class="s">&#34;:8080&#34;</span><span class="p">,</span> <span class="kc">nil</span><span class="p">))</span>
<span class="p">}</span>
</code></pre>
<p>The <code>HandleFunc</code> function is actually part of an adapter for using functions directly as <code>ServeHTTP</code> implementations. Read the last sentence slowly again--can you guess how it is done?</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">HandlerFunc</span> <span class="kd">func</span><span class="p">(</span><span class="nx">ResponseWriter</span><span class="p">,</span> <span class="o">*</span><span class="nx">Request</span><span class="p">)</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">f</span> <span class="nx">HandlerFunc</span><span class="p">)</span> <span class="nx">ServeHTTP</span><span class="p">(</span><span class="nx">w</span> <span class="nx">ResponseWriter</span><span class="p">,</span> <span class="nx">r</span> <span class="o">*</span><span class="nx">Request</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">f</span><span class="p">(</span><span class="nx">w</span><span class="p">,</span> <span class="nx">r</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
<p>We can define a type that is a function in the same way that we define a struct. We make this function-type to implement the <code>ServeHTTP</code> method. Finally, from the <code>ServeHTTP</code> function, we call the receiver itself <code>f(w, r)</code>.</p>
<p>You have to think about the implicit interface implementation of Go. When we define a function like <code>func(ResponseWriter, *Request)</code>, it is implicitly being recognized as <code>HandlerFunc</code>. And because the <code>HandleFunc</code> function implements the <code>Handler</code> interface, our function implements the <code>Handler</code> interface implicitly too. Does this sound familiar to you? If <i>A = B</i> and <i>B = C</i>, then <i>A = C</i>. Implicit implementation gives a lot of flexibility and power to Go, but you must also be careful, because you don&#39;t know if a method or function could be implementing some interface that could provoke undesirable behaviors.</p>
<p>We can find more examples in Go&#39;s source code. The <code>io</code> package has another powerful example with the use of pipes. A pipe in Linux is a flow mechanism that takes something on the input and outputs something else on the output. The io package has two interfaces, which are used everywhere in Go&#39;s source code--the <code>io.Reader</code> and the <code>io.Writer</code> interface:</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">Reader</span> <span class="kd">interface</span> <span class="p">{</span>
  <span class="nx">Read</span><span class="p">(</span><span class="nx">p</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">Writer</span> <span class="kd">interface</span> <span class="p">{</span>
  <span class="nx">Write</span><span class="p">(</span><span class="nx">p</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
<p>We use <code>io.Reader</code> everywhere, for example, when you open a file using <code>os.OpenFile</code>, it returns a file, which, in fact, implements the <code>io.Reader</code> interface. Why is it useful? Imagine that you write a <code>Counter</code> struct that counts from the number you provide to zero:</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">Counter</span> <span class="kd">struct</span> <span class="p">{}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">f</span> <span class="o">*</span><span class="nx">Counter</span><span class="p">)</span> <span class="nx">Count</span><span class="p">(</span><span class="nx">n</span> <span class="kt">uint64</span><span class="p">)</span> <span class="kt">uint64</span> <span class="p">{</span>
  <span class="k">if</span> <span class="nx">n</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
    <span class="nb">println</span><span class="p">(</span><span class="nx">strconv</span><span class="p">.</span><span class="nx">Itoa</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
    <span class="k">return</span> <span class="mi">0</span>
  <span class="p">}</span>

  <span class="nx">cur</span> <span class="o">:=</span> <span class="nx">n</span>
  <span class="nb">println</span><span class="p">(</span><span class="nx">strconv</span><span class="p">.</span><span class="nx">FormatUint</span><span class="p">(</span><span class="nx">cur</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>
  <span class="k">return</span> <span class="nx">f</span><span class="p">.</span><span class="nx">Count</span><span class="p">(</span><span class="nx">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
<p>If you provide the number 3 to this small snippet, it will print the following:</p>
<pre class="srci" ><code class="sh" ><span class="out" >3
2
1
</span></code></pre>
<p>Well, not really impressive! What if I want to write to a file instead of printing? We can implement this method too. What if I want to print to a file and to the console? Well, we can implement this method too. We must modularize it a bit more by using the <code>io.Writer</code> interface:</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">Counter</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">Writer</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Writer</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">f</span> <span class="o">*</span><span class="nx">Counter</span><span class="p">)</span> <span class="nx">Count</span><span class="p">(</span><span class="nx">n</span> <span class="kt">uint64</span><span class="p">)</span> <span class="kt">uint64</span> <span class="p">{</span>
  <span class="k">if</span> <span class="nx">n</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
    <span class="nx">f</span><span class="p">.</span><span class="nx">Writer</span><span class="p">.</span><span class="nx">Write</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="nx">strconv</span><span class="p">.</span><span class="nx">Itoa</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="s">&#34;\n&#34;</span><span class="p">))</span>
    <span class="k">return</span> <span class="mi">0</span>
  <span class="p">}</span>

  <span class="nx">cur</span> <span class="o">:=</span> <span class="nx">n</span>
  <span class="nx">f</span><span class="p">.</span><span class="nx">Writer</span><span class="p">.</span><span class="nx">Write</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="nx">strconv</span><span class="p">.</span><span class="nx">FormatUint</span><span class="p">(</span><span class="nx">cur</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span> <span class="o">+</span> <span class="s">&#34;\n&#34;</span><span class="p">))</span>
  <span class="k">return</span> <span class="nx">f</span><span class="p">.</span><span class="nx">Count</span><span class="p">(</span><span class="nx">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
<p>Now we provide an <code>io.Writer</code> in the <code>Writer</code> field. This way, we could create the counter like this: <code>c := Counter{os.Stdout}</code>, and we will get a console <code>Writer</code>. But wait a second, we haven&#39;t solved the issue where we wanted to take the count to many <code>Writer</code> consoles. But we can write a new <code>Adapter</code> with an <code>io.Writer</code> and, using a <code>Pipe()</code> to connect a reader with a writer, we can read on the opposite extreme. This way, you can solve the issue where these two interfaces, <code>Reader</code> and <code>Writer</code>, which are incompatible, can be used together.</p>
<p>In fact, we don&#39;t need to write the Adapter--the Go&#39;s <code>io</code> library has one for us in <code>io.Pipe()</code>. The pipe will allow us to convert a <code>Reader</code> to a Writer interface. The <code>io.Pipe()</code> method will provide us a <code>Writer</code> (the entrance of the pipe) and a <code>Reader</code> (the exit) to play with. So let&#39;s create a pipe, and assign the provided writer to the <code>Counter</code> of the preceding example:</p>
<pre class="code" ><code class="chroma" ><span class="nx">pipeReader</span><span class="p">,</span> <span class="nx">pipeWriter</span> <span class="o">:=</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Pipe</span><span class="p">()</span>
<span class="k">defer</span> <span class="nx">pw</span><span class="p">.</span><span class="nx">Close</span><span class="p">()</span>
<span class="k">defer</span> <span class="nx">pr</span><span class="p">.</span><span class="nx">Close</span><span class="p">()</span>

<span class="nx">counter</span> <span class="o">:=</span> <span class="nx">Counter</span><span class="p">{</span>
  <span class="nx">Writer</span><span class="p">:</span> <span class="nx">pipeWriter</span><span class="p">,</span>
<span class="p">}</span>
</code></pre>
<p>Now we have a <code>Reader</code> interface where we previously had a <code>Writer</code>. Where can we use the <code>Reader</code>? The <code>io.TeeReader</code> function helps us to copy the stream of data from a <code>Reader</code> interface to the <code>Writer</code> interface and, it returns a new <code>Reader</code> that you can still use to stream data again to a second writer. So we will stream the data from the same reader to two writers--the <code>file</code> and the <code>Stdout</code>.</p>
<pre class="code" ><code class="chroma" ><span class="nx">tee</span> <span class="o">:=</span> <span class="nx">io</span><span class="p">.</span><span class="nx">TeeReader</span><span class="p">(</span><span class="nx">pipeReader</span><span class="p">,</span> <span class="nx">file</span><span class="p">)</span>
</code></pre>
<p>So now we know that we are writing to a file that we have passed to the <code>TeeReader</code> function. We still need to print to the console. The <code>io.Copy</code> adapter can be used like <code>TeeReader</code>--it takes a reader and writes its contents to a writer:</p>
<pre class="code" ><code class="chroma" ><span class="k">go</span> <span class="kd">func</span><span class="p">(){</span>
  <span class="nx">io</span><span class="p">.</span><span class="nx">Copy</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Stdout</span><span class="p">,</span> <span class="nx">tee</span><span class="p">)</span>
<span class="p">}()</span>
</code></pre>
<p>We have to launch the <code>Copy</code> function in a different Go routine so that the writes are performed concurrently, and one read/write doesn&#39;t block a different read/write. Let&#39;s modify the <code>counter</code> variable to make it count till 5 again:</p>
<pre class="code" ><code class="chroma" ><span class="nx">counter</span><span class="p">.</span><span class="nx">Count</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
</code></pre>
<p>With this modification to the code, we get the following output:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go run counter.go
</span><span class="out" >5
4
3
2
1
0
</span></code></pre>
<p>Okay, the count has been printed on the console. What about the file?</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>cat /tmp/pipe
</span><span class="out" >5
4
3
2
1
0
</span></code></pre>
<p>Awesome! By using the <code>io.Pipe()</code> adapter provided in the Go native library, we have uncoupled our counter from its output, and we have adapted a <code>Writer</code> interface to a <code>Reader</code> one.</p>
</div>
<h4 id="what-the-go-source-code-tells-us-about-the-adapter-pattern" >What the Go source code tells us about the Adapter pattern</h4>
<div class="hBody-4" >
<p>With the Adapter design pattern, you have learned a quick way to achieve the open/close principle in your applications. Instead of modifying your old source code (something which could not be possible in some situations), you have created a way to use the old functionality with a new signature.</p>
</div>
<h3 id="bridge-design-pattern" >Bridge design pattern</h3>
<div class="hBody-3" >
<p>The <b>Bridge</b> pattern is a design with a slightly cryptic definition from the original <i>Gang of Four</i> book. It decouples an abstraction from its implementation so that the two can vary independently. This cryptic explanation just means that you could even decouple the most basic form of functionality: decouple an object from what it does.</p>
</div>
<h4 id="description" >Description</h4>
<div class="hBody-4" >
<p>The Bridge pattern tries to decouple things as usual with design patterns. It decouples abstraction (an object) from its implementation (the thing that the object does). This way, we can change what an object does as much as we want. It also allows us to change the abstracted object while reusing the same implementation.</p>
</div>
<h4 id="objectives" >Objectives</h4>
<div class="hBody-4" >
<p>The objective of the Bridge pattern is to bring flexibility to a struct that change often. Knowing the inputs and outputs of a method, it allows us to change code without knowing too much about it and leaving the freedom for both sides to be modified more easily.</p>
</div>
<h4 id="two-printers-and-two-ways-of-printing-for-each" >Two printers and two ways of printing for each</h4>
<div class="hBody-4" >
<p>For our example, we will go to a console printer abstraction to keep it simple. We will have two implementations. The first will write to the console. Having learned about the <code>io.Writer</code> interface in the previous section, we will make the second write to an <code>io.Writer</code> interface to provide more flexibility to the solution. We will also have two abstracted object users of the implementations--a <code>Normal</code> object, which will use each implementation in a straightforward manner, and a <code>Packt</code> implementation, which will append the sentence <code>Message from Packt</code>: to the printing message.</p>
<p>At the end of this section, we will have two abstraction objects, which have two different implementations of their functionality. So, actually, we will have 2² possible combinations of object functionality.</p>
</div>
<h4 id="requirements-and-acceptance-criteria" >Requirements and acceptance criteria</h4>
<div class="hBody-4" >
<p>As we mentioned previously, we will have two objects (<code>Packt</code> and <code>Normal</code> printer) and two implementations (<code>PrinterImpl1</code> and <code>PrinterImpl2</code>) that we will join by using the Bridge design pattern. More or less, we will have the following requirements and acceptance criteria:</p>
<ul>
<li>
<p>A <code>PrinterAPI</code> that accepts a message to print</p>
</li>
<li>
<p>An implementation of the API that simply prints the message to the console</p>
</li>
<li>
<p>An implementation of the API that prints to an io.Writer interface</p>
</li>
<li>
<p>A <code>Printer</code> abstraction with a <code>Print</code> method to implement in printing types</p>
</li>
<li>
<p>A <code>normal</code> printer object, which will implement the Printer and the <code>PrinterAPI</code> interface</p>
</li>
<li>
<p>The <code>normal</code> printer will forward the message directly to the implementation</p>
</li>
<li>
<p>A <code>Packt</code> printer, which will implement the <code>Printer</code> abstraction and the <code>PrinterAPI</code> interface</p>
</li>
<li>
<p>The <code>Packt</code> printer will append the message <code>Message from Packt</code>: to all prints</p>
</li>
</ul>
</div>
<h4 id="unit-testing-the-bridge-pattern" >Unit testing the Bridge pattern</h4>
<div class="hBody-4" >
<p>Let&#39;s start with <i>acceptance criteria 1</i>, the <code>PrinterAPI</code> interface. Implementers of this interface must provide a <code>PrintMessage(string)</code> method that will print the message passed as an argument:</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">PrinterAPI</span> <span class="kd">interface</span> <span class="p">{</span>
  <span class="nx">PrintMessage</span><span class="p">(</span><span class="kt">string</span><span class="p">)</span> <span class="kt">error</span>
<span class="p">}</span>
</code></pre>
<p>We will pass to <i>acceptance criteria 2</i> with an implementation of the previous API:</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">PrinterImpl1</span> <span class="kd">struct</span><span class="p">{}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">PrinterImpl1</span><span class="p">)</span> <span class="nx">PrintMessage</span><span class="p">(</span><span class="nx">msg</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">errors</span><span class="p">.</span><span class="nx">New</span><span class="p">(</span><span class="s">&#34;Not implemented yet&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
<p>Our <code>PrinterImpl1</code> is a type that implements the <code>PrinterAPI</code> interface by providing an implementation of the <code>PrintMessage</code> method. The <code>PrintMessage</code> method is not implemented yet, and returns an error. This is enough to write our first unit test to cover <code>PrinterImpl1</code>:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">TestPrintAPI1</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">){</span>
  <span class="nx">api1</span> <span class="o">:=</span> <span class="nx">PrinterImpl1</span><span class="p">{}</span>

  <span class="nx">err</span> <span class="o">:=</span> <span class="nx">api1</span><span class="p">.</span><span class="nx">PrintMessage</span><span class="p">(</span><span class="s">&#34;Hello&#34;</span><span class="p">)</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">t</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&#34;Error trying to use the API1 implementation: Message: %s\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">.</span><span class="nx">Error</span><span class="p">())</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>In our test to cover <code>PrintAPI1</code>, we created an instance of <code>PrinterImpl1</code> type. Then we used its <code>PrintMessage</code> method to print the message <code>Hello</code> to the console. As we have no implementation yet, it must return the error srring <code>Not implemented yet</code>:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go <span class="nb">test</span> -v -run<span class="o">=</span>TestPrintAPI1 .
</span><span class="out" >=== RUN   TestPrintAPI1
--- FAIL: TestPrintAPI1 (0.00s)
        bridge_test.go:14: Error trying to use the API1 implementation: Message: Not implemented yet
FAIL
exit status 1
FAIL    _/C_/Users/mario/Desktop/go-design-patterns/structural/bridge/traditional
</span></code></pre>
<p>Okay. Now we have to write the second API test that will work with an <code>io.Writer</code> interface:</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">PrinterImpl2</span> <span class="kd">struct</span><span class="p">{</span>
  <span class="nx">Writer</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Writer</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">d</span> <span class="o">*</span><span class="nx">PrinterImpl2</span><span class="p">)</span> <span class="nx">PrintMessage</span><span class="p">(</span><span class="nx">msg</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">errors</span><span class="p">.</span><span class="nx">New</span><span class="p">(</span><span class="s">&#34;Not implemented yet&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
<p>As you can see, our <code>PrinterImpl2</code> struct stores an io.Writer implementer. Also, our <code>PrintMessage</code> method follows the <code>PrinterAPI</code> interface.</p>
<p>Now that we are familiar with the <code>io.Writer</code> interface, we are going to make a test object that implements this interface, and stores whatever is written to it in a local field. This will help us check the contents that are being sent through the writer:</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">TestWriter</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">Msg</span> <span class="kt">string</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">TestWriter</span><span class="p">)</span> <span class="nx">Write</span><span class="p">(</span><span class="nx">p</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">n</span> <span class="p">=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span>
  <span class="k">if</span> <span class="nx">n</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
    <span class="nx">t</span><span class="p">.</span><span class="nx">Msg</span> <span class="p">=</span> <span class="nb">string</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span>
    <span class="k">return</span> <span class="nx">n</span><span class="p">,</span> <span class="kc">nil</span>
  <span class="p">}</span>
  <span class="nx">err</span> <span class="p">=</span> <span class="nx">errors</span><span class="p">.</span><span class="nx">New</span><span class="p">(</span><span class="s">&#34;Content received on Writer was empty&#34;</span><span class="p">)</span>
  <span class="k">return</span>
<span class="p">}</span>
</code></pre>
<p>In our test object, we checked that the content isn&#39;t empty before writing it to the local field. If it&#39;s empty, we return the error, and if not, we write the contents of p in the <code>Msg</code> field. We will use this small struct in the following tests for the second API:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">TestPrintAPI2</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">){</span>
  <span class="nx">api2</span> <span class="o">:=</span> <span class="nx">PrinterImpl2</span><span class="p">{}</span>

  <span class="nx">err</span> <span class="o">:=</span> <span class="nx">api2</span><span class="p">.</span><span class="nx">PrintMessage</span><span class="p">(</span><span class="s">&#34;Hello&#34;</span><span class="p">)</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">expectedErrorMessage</span> <span class="o">:=</span> <span class="s">&#34;You need to pass an io.Writer to PrinterImpl2&#34;</span>
    <span class="k">if</span> <span class="p">!</span><span class="nx">strings</span><span class="p">.</span><span class="nx">Contains</span><span class="p">(</span><span class="nx">err</span><span class="p">.</span><span class="nx">Error</span><span class="p">(),</span> <span class="nx">expectedErrorMessage</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">t</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&#34;Error message was not correct.\n Actual: %s\nExpected: %s\n&#34;</span><span class="p">,</span>
        <span class="nx">err</span><span class="p">.</span><span class="nx">Error</span><span class="p">(),</span> <span class="nx">expectedErrorMessage</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">}</span>
</code></pre>
<p>Let&#39;s stop for a second here. We create an instance of <code>PrinterImpl2</code> called <code>api2</code> in the first line of the preceding code. We haven&#39;t passed any instance of <code>io.Writer</code> on purpose, so we also checked that we actually receive an error first. Then we try to use its <code>PrintMessage</code> method, but we must get an error because it doesn&#39;t have any <code>io.Writer</code> instance stored in the <code>Writer</code> field. The error must be <code>You need to pass an io.Writer to PrinterImpl2</code>, and we implicitly check the contents of the error. Let&#39;s continue with the test:</p>
<pre class="code" ><code class="chroma" >  <span class="nx">testWriter</span> <span class="o">:=</span> <span class="nx">TestWriter</span><span class="p">{}</span>
  <span class="nx">api2</span> <span class="p">=</span> <span class="nx">PrinterImpl2</span><span class="p">{</span>
    <span class="nx">Writer</span><span class="p">:</span> <span class="o">&amp;</span><span class="nx">testWriter</span><span class="p">,</span>
  <span class="p">}</span>

  <span class="nx">expectedMessage</span> <span class="o">:=</span> <span class="s">&#34;Hello&#34;</span>
  <span class="nx">err</span> <span class="p">=</span> <span class="nx">api2</span><span class="p">.</span><span class="nx">PrintMessage</span><span class="p">(</span><span class="nx">expectedMessage</span><span class="p">)</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">t</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&#34;Error trying to use the API2 implementation: %s\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">.</span><span class="nx">Error</span><span class="p">())</span>
  <span class="p">}</span>

  <span class="k">if</span> <span class="nx">testWriter</span><span class="p">.</span><span class="nx">Msg</span> <span class="o">!=</span>  <span class="nx">expectedMessage</span> <span class="p">{</span>
    <span class="nx">t</span><span class="p">.</span><span class="nx">Fatalf</span><span class="p">(</span><span class="s">&#34;API2 did not write correctly on the io.Writer. \n Actual: %s\nExpected: %s\n&#34;</span><span class="p">,</span>
      <span class="nx">testWriter</span><span class="p">.</span><span class="nx">Msg</span><span class="p">,</span> <span class="nx">expectedMessage</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>For the second part of this unit test, we use an instance of the <code>TestWriter</code> object as an <code>io.Writer</code> interface, <code>testWriter</code>. We passed the message <code>Hello</code> to <code>api2</code>, and checked whether we receive any error. Then, we check the contents of the <code>testWriter.Msg</code> field--remember that we have written an <code>io.Writer</code> interface that stored any bytes passed to its <code>Write</code> method in the <code>Msg</code> field. If everything is correct, the message should contain the word <code>Hello</code>.</p>
<p>Those were our tests for <code>PrinterImpl2</code>. As we don&#39;t have any implementations yet, we should get a few errors when running this test:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go <span class="nb">test</span> -v -run<span class="o">=</span>TestPrintAPI2 .
</span><span class="out" >=== RUN   TestPrintAPI2
--- FAIL: TestPrintAPI2 (0.00s)
bridge_test.go:39: Error message was not correct.
Actual: Not implemented yet
Expected: You need to pass an io.Writer to PrinterImpl2
bridge_test.go:52: Error trying to use the API2 implementation: Not implemented yet
bridge_test.go:57: API2 did not write correctly on the io.Writer.
Actual: Expected: Hello
FAIL
exit status 1
FAIL
</span></code></pre>
<p>At least one test passes--the one that checks that an error message (any) is being returned when using the <code>PrintMessage</code> without <code>io.Writer</code> being stored. Everything else fails, as expected at this stage.</p>
<p>Now we need a printer abstraction for objects that can use <code>PrinterAPI</code> implementers. We will define this as the <code>PrinterAbstraction</code> interface with a <code>Print</code> method. This covers the <i>acceptance criteria 4</i>:</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">PrinterAbstraction</span> <span class="kd">interface</span> <span class="p">{</span>
  <span class="nx">Print</span><span class="p">()</span> <span class="kt">error</span>
<span class="p">}</span>
</code></pre>
<p>For <i>acceptance criteria 5</i>, we need a normal printer. A <code>Printer</code> abstraction will need a field to store a <code>PrinterAPI</code>. So our the <code>NormalPrinter</code> could look like the following:</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">NormalPrinter</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">Msg</span>     <span class="kt">string</span>
  <span class="nx">Printer</span> <span class="nx">PrinterAPI</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">NormalPrinter</span><span class="p">)</span> <span class="nx">Print</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">errors</span><span class="p">.</span><span class="nx">New</span><span class="p">(</span><span class="s">&#34;Not implemented yet&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
<p>This is enough to write a unit test for the <code>Print()</code> method:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">TestNormalPrinter_Print</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">expectedMessage</span> <span class="o">:=</span> <span class="s">&#34;Hello io.Writer&#34;</span>

  <span class="nx">normal</span> <span class="o">:=</span> <span class="nx">NormalPrinter</span><span class="p">{</span>
    <span class="nx">Msg</span><span class="p">:</span><span class="nx">expectedMessage</span><span class="p">,</span>
    <span class="nx">Printer</span><span class="p">:</span> <span class="o">&amp;</span><span class="nx">PrinterImpl1</span><span class="p">{},</span>
  <span class="p">}</span>

  <span class="nx">err</span> <span class="o">:=</span> <span class="nx">normal</span><span class="p">.</span><span class="nx">Print</span><span class="p">()</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">t</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="nx">err</span><span class="p">.</span><span class="nx">Error</span><span class="p">())</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>The first part of the test checks that the <code>Print()</code> method isn&#39;t implemented yet when using <code>PrinterImpl1 PrinterAPI</code> interface. The message we&#39;ll use along this test is <code>Hello io.Writer</code>. With the <code>PrinterImpl1</code>, we don&#39;t have an easy way to check the contents of the message, as we print directly to the console. Checking, in this case, is visual, so we can check <i>acceptance criteria 6:</i></p>
<pre class="code" ><code class="chroma" >  <span class="nx">testWriter</span> <span class="o">:=</span> <span class="nx">TestWriter</span><span class="p">{}</span>
  <span class="nx">normal</span> <span class="p">=</span> <span class="nx">NormalPrinter</span><span class="p">{</span>
    <span class="nx">Msg</span><span class="p">:</span> <span class="nx">expectedMessage</span><span class="p">,</span>
    <span class="nx">Printer</span><span class="p">:</span> <span class="o">&amp;</span><span class="nx">PrinterImpl2</span><span class="p">{</span>
      <span class="nx">Writer</span><span class="p">:</span><span class="o">&amp;</span><span class="nx">testWriter</span><span class="p">,</span>
    <span class="p">},</span>
  <span class="p">}</span>

  <span class="nx">err</span> <span class="p">=</span> <span class="nx">normal</span><span class="p">.</span><span class="nx">Print</span><span class="p">()</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">t</span><span class="p">.</span><span class="nx">Error</span><span class="p">(</span><span class="nx">err</span><span class="p">.</span><span class="nx">Error</span><span class="p">())</span>
  <span class="p">}</span>

  <span class="k">if</span> <span class="nx">testWriter</span><span class="p">.</span><span class="nx">Msg</span> <span class="o">!=</span> <span class="nx">expectedMessage</span> <span class="p">{</span>
    <span class="nx">t</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&#34;The expected message on the io.Writer doesn&#39;t match actual.\n  Actual: %s\nExpected: %s\n&#34;</span><span class="p">,</span>
      <span class="nx">testWriter</span><span class="p">.</span><span class="nx">Msg</span><span class="p">,</span> <span class="nx">expectedMessage</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>The second part of <code>NormalPrinter</code> tests uses <code>PrinterImpl2</code>, the one that needs an <code>io.Writer</code> interface implementer. We reuse our <code>TestWriter</code> struct here to check the contents of the message. So, in short, we want a <code>NormalPrinter</code> struct that accepts a <code>Msg</code> of type string and a Printer of type <code>PrinterAPI</code>. At this point, if I use the <code>Print</code> method, I shouldn&#39;t get any error, and the <code>Msg</code> field on <code>TestWriter</code> must contain the message we passed to <code>NormalPrinter</code> on its initialization.</p>
<p>Let&#39;s run the tests:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go <span class="nb">test</span> -v -run<span class="o">=</span>TestNormalPrinter_Print .
</span><span class="out" >=== RUN   TestNormalPrinter_Print
--- FAIL: TestNormalPrinter_Print (0.00s)
    bridge_test.go:72: Not implemented yet
    bridge_test.go:85: Not implemented yet
    bridge_test.go:89: The expected message on the io.Writer doesn&#39;t match actual.
             Actual:
             Expected: Hello io.Writer
FAIL
exit status 1
FAIL
</span></code></pre>
<p>There is a trick to quickly check the validity of a unit test--the number of times we called <code>t.Error</code> or <code>t.Errorf</code> must match the number of messages of error on the console and the lines where they were produced. In the preceding test results, there are three errors at <i>lines 72</i>, <i>85</i>, and <i>89</i>, which exactly match the checks we wrote.</p>
<p>Our <code>PacktPrinter</code> struct will have a very similar definition to <code>NormalPrinter</code> at this point:</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">PacktPrinter</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">Msg</span>     <span class="kt">string</span>
  <span class="nx">Printer</span> <span class="nx">PrinterAPI</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">PacktPrinter</span><span class="p">)</span> <span class="nx">Print</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">errors</span><span class="p">.</span><span class="nx">New</span><span class="p">(</span><span class="s">&#34;Not implemented yet&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
<p>This covers <i>acceptance criteria 7</i>. And we can almost copy and paste the contents of the previous test with a few changes:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">TestPacktPrinter_Print</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">passedMessage</span> <span class="o">:=</span> <span class="s">&#34;Hello io.Writer&#34;</span>
  <span class="nx">expectedMessage</span> <span class="o">:=</span> <span class="s">&#34;Message from Packt: Hello io.Writer&#34;</span>

  <span class="nx">packt</span> <span class="o">:=</span> <span class="nx">PacktPrinter</span><span class="p">{</span>
    <span class="nx">Msg</span><span class="p">:</span><span class="nx">passedMessage</span><span class="p">,</span>
    <span class="nx">Printer</span><span class="p">:</span> <span class="o">&amp;</span><span class="nx">PrinterImpl1</span><span class="p">{},</span>
  <span class="p">}</span>

  <span class="nx">err</span> <span class="o">:=</span> <span class="nx">packt</span><span class="p">.</span><span class="nx">Print</span><span class="p">()</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">t</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="nx">err</span><span class="p">.</span><span class="nx">Error</span><span class="p">())</span>
  <span class="p">}</span>

  <span class="nx">testWriter</span> <span class="o">:=</span> <span class="nx">TestWriter</span><span class="p">{}</span>
  <span class="nx">packt</span> <span class="p">=</span> <span class="nx">PacktPrinter</span><span class="p">{</span>
    <span class="nx">Msg</span><span class="p">:</span> <span class="nx">passedMessage</span><span class="p">,</span>
    <span class="nx">Printer</span><span class="p">:</span><span class="o">&amp;</span><span class="nx">PrinterImpl2</span><span class="p">{</span>
      <span class="nx">Writer</span><span class="p">:</span><span class="o">&amp;</span><span class="nx">testWriter</span><span class="p">,</span>
    <span class="p">},</span>
  <span class="p">}</span>

  <span class="nx">err</span> <span class="p">=</span> <span class="nx">packt</span><span class="p">.</span><span class="nx">Print</span><span class="p">()</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">t</span><span class="p">.</span><span class="nx">Error</span><span class="p">(</span><span class="nx">err</span><span class="p">.</span><span class="nx">Error</span><span class="p">())</span>
  <span class="p">}</span>

  <span class="k">if</span> <span class="nx">testWriter</span><span class="p">.</span><span class="nx">Msg</span> <span class="o">!=</span> <span class="nx">expectedMessage</span> <span class="p">{</span>
    <span class="nx">t</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&#34;The expected message on the io.Writer doesn&#39;t match actual.\n  Actual: %s\nExpected: %s\n&#34;</span><span class="p">,</span>
      <span class="nx">testWriter</span><span class="p">.</span><span class="nx">Msg</span><span class="p">,</span><span class="nx">expectedMessage</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>What have we changed here? Now we have <code>passedMessage</code>, which represents the message we are passing to <code>PackPrinter</code>. We also have an expected message that contains the prefixed message from <code>Packt</code>. If you remember <i>acceptance criteria 8</i>, this abstraction must prefix the text <code>Message from Packt</code>: to any message that is passed to it, and, at the same time, it must be able to use any implementation of a <code>PrinterAPI</code> interface.</p>
<p>The second change is that we actually create <code>PacktPrinter</code> structs instead of the <code>NormalPrinter</code> structs; everything else is the same:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go <span class="nb">test</span> -v -run<span class="o">=</span>TestPacktPrinter_Print .
</span><span class="out" >=== RUN   TestPacktPrinter_Print
--- FAIL: TestPacktPrinter_Print (0.00s)
    bridge_test.go:104: Not implemented yet
    bridge_test.go:117: Not implemented yet
    bridge_test.go:121: The expected message on the io.Writer doesn&#39;t match actual.
        Actual:
        Expected: Message from Packt: Hello io.Writer
FAIL
exit status 1
FAIL
</span></code></pre>
<p>Three checks, three errors. All tests have been covered, and we can finally move on to the implementation.</p>
</div>
<h4 id="implementation" >Implementation</h4>
<div class="hBody-4" >
<p>We will start implementing in the same order that we created our tests, first with the <code>PrinterImpl1</code> definition:</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">PrinterImpl1</span> <span class="kd">struct</span><span class="p">{}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">d</span> <span class="o">*</span><span class="nx">PrinterImpl1</span><span class="p">)</span> <span class="nx">PrintMessage</span><span class="p">(</span><span class="nx">msg</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&#34;%s\n&#34;</span><span class="p">,</span> <span class="nx">msg</span><span class="p">)</span>
  <span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre>
<p>Our first API takes the message <code>msg</code> and prints it to the console. In the case of an empty string, nothing will be printed. This is enough to pass the first test:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go <span class="nb">test</span> -v -run<span class="o">=</span>TestPrintAPI1 .
</span><span class="out" >=== RUN   TestPrintAPI1
Hello
--- PASS: TestPrintAPI1 (0.00s)
PASS
ok
</span></code></pre>
<p>You can see the <code>Hello</code> message in the second line of the output of the test, just after the <code>RUN</code> message.</p>
<p>The <code>PrinterImpl2</code> struct isn&#39;t very complex either. The difference is that instead of printing to the console, we are going to write on an <code>io.Writer</code> interface, which must be stored in the struct:</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">PrinterImpl2</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">Writer</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Writer</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">d</span> <span class="o">*</span><span class="nx">PrinterImpl2</span><span class="p">)</span> <span class="nx">PrintMessage</span><span class="p">(</span><span class="nx">msg</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
  <span class="k">if</span> <span class="nx">d</span><span class="p">.</span><span class="nx">Writer</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">errors</span><span class="p">.</span><span class="nx">New</span><span class="p">(</span><span class="s">&#34;You need to pass an io.Writer to PrinterImpl2&#34;</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Fprintf</span><span class="p">(</span><span class="nx">d</span><span class="p">.</span><span class="nx">Writer</span><span class="p">,</span> <span class="s">&#34;%s&#34;</span><span class="p">,</span> <span class="nx">msg</span><span class="p">)</span>
  <span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre>
<p>As defined in our tests, we checked the contents of the <code>Writer</code> field first and returned the expected error message <b>You need to pass an io.Writer to PrinterImpl2</b>, if nothing is stored. This is the message we&#39;ll check later in the test. Then, the <code>fmt.Fprintf</code> method takes an <code>io.Writer</code> interface as the first field and a message formatted as the rest, so we simply forward the contents of the <code>msg</code> argument to the <code>io.Writer</code> provided:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go <span class="nb">test</span> -v -run<span class="o">=</span>TestPrintAPI2 .
</span><span class="out" >=== RUN   TestPrintAPI2
--- PASS: TestPrintAPI2 (0.00s)
PASS
ok
</span></code></pre>
<p>Now we&#39;ll continue with the normal printer. This printer must simply forward the message to the <code>PrinterAPI</code> interface stored without any modification. In our test, we are using two implementations of <code>PrinterAPI</code>--one that prints to the console and one that writes to an <code>io.Writer</code> interface:</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">NormalPrinter</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">Msg</span>     <span class="kt">string</span>
  <span class="nx">Printer</span> <span class="nx">PrinterAPI</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">NormalPrinter</span><span class="p">)</span> <span class="nx">Print</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span>
  <span class="nx">c</span><span class="p">.</span><span class="nx">Printer</span><span class="p">.</span><span class="nx">PrintMessage</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">Msg</span><span class="p">)</span>
  <span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre>
<p>We returned nil as no error has occurred. This should be enough to pass the unit tests:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go <span class="nb">test</span> -v -run<span class="o">=</span>TestNormalPrinter_Print .
</span><span class="out" >=== RUN   TestNormalPrinter_Print
Hello io.Writer
--- PASS: TestNormalPrinter_Print (0.00s)
PASS
ok
</span></code></pre>
<p>In the preceding output, you can see the <code>Hello io.Writer</code> message that the <code>PrinterImpl1</code> struct writes to <code>stdout</code>. We can consider this check as having passed:</p>
<p>Finally, the <code>PackPrinter</code> method is similar to <code>NormalPrinter</code>, but just prefixes every message with the text <code>Message from Packt:</code>:</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">PacktPrinter</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">Msg</span>     <span class="kt">string</span>
  <span class="nx">Printer</span> <span class="nx">PrinterAPI</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">PacktPrinter</span><span class="p">)</span> <span class="nx">Print</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span>
  <span class="nx">c</span><span class="p">.</span><span class="nx">Printer</span><span class="p">.</span><span class="nx">PrintMessage</span><span class="p">(</span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintf</span><span class="p">(</span><span class="s">&#34;Message from Packt: %s&#34;</span><span class="p">,</span>
    <span class="nx">c</span><span class="p">.</span><span class="nx">Msg</span><span class="p">))</span>
  <span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre>
<p>Like in the <code>NormalPrinter</code> method, we accepted a <code>Msg</code> string and a <code>PrinterAPI</code> implementation in the <code>Printer</code> field. Then we used the <code>fmt.Sprintf</code> method to compose a new string with the text <code>Message from Packt</code>: and the provided message. We took the composed text and passed it to the <code>PrintMessage</code> method of <code>PrinterAPI</code> stored in the <code>Printer</code> field of the <code>PacktPrinter</code> struct:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go <span class="nb">test</span> -v -run<span class="o">=</span>TestPacktPrinter_Print .
</span><span class="out" >=== RUN   TestPacktPrinter_Print
Message from Packt: Hello io.Writer
--- PASS: TestPacktPrinter_Print (0.00s)
PASS
ok
</span></code></pre>
<p>Again, you can see the results of using <code>PrinterImpl1</code> for writing to <code>stdout</code> with the text <code>Message from Packt: Hello io.Writer</code>. This last test should cover all of our code in the Bridge pattern. As you have seen previously, you can check the coverage by using the <code>-cover</code> flag:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go <span class="nb">test</span> -cover .
</span><span class="out" >ok
2.622s  coverage: 100.0% of statements
</span></code></pre>
<p>Wow! 100% coverage-this looks good. However, this doesn&#39;t mean that the code is perfect. We haven&#39;t checked that the contents of the messages weren&#39;t empty, maybe something that should be avoided, but it isn&#39;t a part of our requirements, which is also an important point. Just because some feature isn&#39;t in the requirements or the acceptance criteria doesn&#39;t mean that it shouldn&#39;t be covered.</p>
</div>
<h4 id="reuse-everything-with-the-bridge-pattern" >Reuse everything with the Bridge pattern</h4>
<div class="hBody-4" >
<p>With the Bridge pattern, we have learned how to uncouple an object and its implementation for the <code>PrintMessage</code> method. This way, we can reuse its abstractions as well as its implementations. We can swap the printer abstractions as well as the printer APIs as much as we want without affecting the user code.</p>
<p>We have also tried to keep things as simple as possible, but I&#39;m sure that you have realized that all implementations of the <code>PrinterAPI</code> interface could have been created using a factory. This would be very natural, and you could find many implementations that have followed this approach. However, we shouldn&#39;t get into over-engineering, but should analyze each problem to make a precise design of its needs and finds the best way to create a reusable, maintainable, and <i>readable</i> source code. Readable code is commonly forgotten, but a robust and uncoupled source code is useless if nobody can understand it to maintain it. It&#39;s like a book of the tenth century--it could be a precious story but pretty frustrating if we have difficulty understanding its grammar.</p>
</div>
<h3 id="summary" >Summary</h3>
<div class="hBody-3" >
<p>We have seen the power of composition in this chapter and many of the ways that Go takes advantage of it by its own nature. We have seen that the Adapter pattern can help us make two incompatible interfaces work together by using an <code>Adapter</code> object in between. At the same time, we have seen some real-life examples in Go&#39;s source code, where the creators of the language used this design pattern to improve the possibilities of some particular piece of the standard library. Finally, we have seen the Bridge pattern and its possibilities, allowing us to create swapping structures with complete reusability between objects and their implementations.</p>
<p>Also, we have used the Composite design pattern throughout the chapter, not only when explaining it. We have mentioned it earlier but design patterns make use of each other very frequently. We have used pure composition instead of embedding to increase readability, but, as you have learned, you can use both interchangeably according to your needs. We will keep using the Composite pattern in the following chapters, as it is the foundation for building relationships in the Go programming language.</p>
</div>
<h2 id="chapter-4" >Structural Patterns - Proxy, Facade, Decorator, and Flyweight Design Patterns</h2>
<div class="hBody-2" >
<p>With this chapter, we will finish with the Structural patterns. We have left some of the most complex ones till the end so that you get more used to the mechanics of design patterns, and the features of Go language.</p>
<p>In this chapter, we will work at writing a cache to access a database, a library to gather weather data, a server with runtime middleware, and discuss a way to save memory by saving shareable states between the types values.</p>
</div>
<h3 id="proxy-design-pattern" >Proxy design pattern</h3>
<div class="hBody-3" >
<p>We&#39;ll start the final chapter on structural patterns with the Proxy pattern. It&#39;s a simple pattern that provides interesting features and possibilities with very little effort.</p>
</div>
<h4 id="description" >Description</h4>
<div class="hBody-4" >
<p>The Proxy pattern usually wraps an object to hide some of its characteristics. These characteristics could be the fact that it is a remote object (remote proxy), a very heavy object such as a very big image or the dump of a terabyte database (virtual proxy), or a restricted access object (protection proxy).</p>
</div>
<h4 id="objectives" >Objectives</h4>
<div class="hBody-4" >
<p>The possibilities of the Proxy pattern are many, but in general, they all try to provide the same following functionalities:</p>
<ul>
<li>
<p>Hide an object behind the proxy so the features can be hidden, restricted, and so on</p>
</li>
<li>
<p>Provide a new abstraction layer that is easy to work with, and can be changed easily</p>
</li>
</ul>
</div>
<h4 id="example" >Example</h4>
<div class="hBody-4" >
<p>For our example, we are going to create a remote proxy, which is going to be a cache of objects before accessing a database. Let&#39;s imagine that we have a database with many users, but instead of accessing the database each time we want information about a user, we will have a <b>First In First Out</b> (<span class="acronym" >FIFO</span>) stack of users in a Proxy pattern (FIFO is a way of saying that when the cache needs to be emptied, it will delete the first object that entered first).</p>
</div>
<h4 id="acceptance-criteria" >Acceptance criteria</h4>
<div class="hBody-4" >
<p>We will wrap an imaginary database, represented by a slice, with our Proxy pattern. Then, the pattern will have to stick to the following acceptance criteria:</p>
<ol class="num" >
<li>
<p>All accesse to the database of users will be done through the Proxy type.</p>
</li>
<li>
<p>A stack of n number of recent users will be kept in the Proxy.</p>
</li>
<li>
<p>If a user already exists in the stack, it won&#39;t query the database, and will return the stored one</p>
</li>
<li>
<p>If the queried user doesn&#39;t exist in the stack, it will query the database, remove the oldest user in the stack if it&#39;s full, store the new one, and return it.</p>
</li>
</ol>
</div>
<h4 id="unit-test" >Unit test</h4>
<div class="hBody-4" >
<p>Since version 1.7 of Go, we can embed tests within tests by using closures so we can group them in a more human-readable way, and reduce the number of <code>Test_</code> functions. Refer to <a href="#chapter-1" >Chapter 1</a>, <i>Ready... Steady... Go!</i> to learn how to install the new version of Go if your current version is older than version 1.7.</p>
<p>The types for this pattern will be the proxy user and user list structs as well as a <code>UserFinder</code> interface that the database and the Proxy will implement. This is key because the Proxy must implement the same interfaces as the features of the type it tries to wrap:</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">UserFinder</span> <span class="kd">interface</span> <span class="p">{</span>
  <span class="nx">FindUser</span><span class="p">(</span><span class="nx">id</span> <span class="kt">int32</span><span class="p">)</span> <span class="p">(</span><span class="nx">User</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
<p>The <code>UserFinder</code> is the interface that the database and the Proxy implement. The <code>User</code> is a type with a member called <code>ID</code>, which is <code>int32</code> type:</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">User</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">ID</span> <span class="kt">int32</span>
<span class="p">}</span>
</code></pre>
<p>Finally, the <code>UserList</code> is a type of a slice of users. Consider the following syntax for that:</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">UserList</span> <span class="p">[]</span><span class="nx">User</span>
</code></pre>
<p>If you are asking why we aren&#39;t using a slice of users directly, the answer is that by declaring a sequence of users this way, we can implement the <code>UserFinder</code> interface but with a slice, we can&#39;t.</p>
<p>Finally, the Proxy type, called <code>UserListProxy</code> will be composed of a <code>UserList</code> slice, which will be our database representation. The <code>StackCache</code> members which will also be of <code>UserList</code> type for simplicity, <code>StackCapacity</code> to give our stack the size we want.</p>
<p>We will cheat a bit for the purpose of this tutorial and declare a Boolean state on a field called <code>DidDidLastSearchUsedCache</code> that will hold if the last performed search has used the cache, or has accessed the database:</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">UserListProxy</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">SomeDatabase</span> <span class="nx">UserList</span>
  <span class="nx">StackCache</span> <span class="nx">UserList</span>
  <span class="nx">StackCapacity</span> <span class="kt">int</span>
  <span class="nx">DidDidLastSearchUsedCache</span> <span class="kt">bool</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">u</span> <span class="o">*</span><span class="nx">UserListProxy</span><span class="p">)</span> <span class="nx">FindUser</span><span class="p">(</span><span class="nx">id</span> <span class="kt">int32</span><span class="p">)</span> <span class="p">(</span><span class="nx">User</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">User</span><span class="p">{},</span> <span class="nx">errors</span><span class="p">.</span><span class="nx">New</span><span class="p">(</span><span class="s">&#34;Not implemented yet&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
<p>The <code>UserListProxy</code> type will cache a maximum of <code>StackCapacity</code> users, and rotate the cache if it reaches this limit. The <code>StackCache</code> members will be populated from objects from <code>SomeDatabase</code> type.</p>
<p>The first test is called <code>TestUserListProxy</code>, and is listed next:</p>
<pre class="code" ><code class="chroma" ><span class="kn">import</span> <span class="p">(</span>
  <span class="s">&#34;math/rand&#34;</span>
  <span class="s">&#34;testing&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nx">Test_UserListProxy</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">someDatabase</span> <span class="o">:=</span> <span class="nx">UserList</span><span class="p">{}</span>

  <span class="nx">rand</span><span class="p">.</span><span class="nx">Seed</span><span class="p">(</span><span class="mi">2342342</span><span class="p">)</span>
  <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">1000000</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
    <span class="nx">n</span> <span class="o">:=</span> <span class="nx">rand</span><span class="p">.</span><span class="nx">Int31</span><span class="p">()</span>
    <span class="nx">someDatabase</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">someDatabase</span><span class="p">,</span> <span class="nx">User</span><span class="p">{</span><span class="nx">ID</span><span class="p">:</span> <span class="nx">n</span><span class="p">})</span>
  <span class="p">}</span>
</code></pre>
<p>The preceding test creates a user list of 1 million users with random names. To do so, we feed the random number generator by calling the <code>Seed()</code> function with some constant seed so our randomized results are also constant; and the user IDs are generated from it. It might have some duplicates, but it serves our purpose.</p>
<p>Next, we need a proxy with a reference to <code>someDatabase</code>, which we have just created:</p>
<pre class="code" ><code class="chroma" ><span class="nx">proxy</span> <span class="o">:=</span> <span class="nx">UserListProxy</span><span class="p">{</span>
  <span class="nx">SomeDatabase</span><span class="p">:</span>  <span class="o">&amp;</span><span class="nx">someDatabase</span><span class="p">,</span>
  <span class="nx">StackCapacity</span><span class="p">:</span>  <span class="mi">2</span><span class="p">,</span>
  <span class="nx">StackCache</span><span class="p">:</span> <span class="nx">UserList</span><span class="p">{},</span>
<span class="p">}</span>
</code></pre>
<p>At this point, we have a <code>proxy</code> object composed of a mock database with 1 million users, and a cache implemented as a FIFO stack with a size of 2. Now we will get three random IDs from <code>someDatabase</code> to use in our stack:</p>
<pre class="code" ><code class="chroma" ><span class="nx">knownIDs</span> <span class="o">:=</span> <span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="kt">int32</span> <span class="p">{</span><span class="nx">someDatabase</span><span class="p">[</span><span class="mi">3</span><span class="p">].</span><span class="nx">ID</span><span class="p">,</span>
<span class="nx">someDatabase</span><span class="p">[</span><span class="mi">4</span><span class="p">].</span><span class="nx">ID</span><span class="p">,</span><span class="nx">someDatabase</span><span class="p">[</span><span class="mi">5</span><span class="p">].</span><span class="nx">ID</span><span class="p">}</span>
</code></pre>
<p>We took the fourth, fifth, and sixth IDs from the slice (remember that arrays and slices start with 0, so the index 3 is actually the fourth position in the slice).</p>
<p>This is going to be our starting point before launching the embedded tests. To create an embedded test, we have to call the <code>Run</code> method of the <code>testing.T</code> pointer, with a description and a closure with the <code>func(t *testing.T)</code> signature:</p>
<pre class="code" ><code class="chroma" ><span class="nx">t</span><span class="p">.</span><span class="nx">Run</span><span class="p">(</span><span class="s">&#34;FindUser - Empty cache&#34;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">user</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">proxy</span><span class="p">.</span><span class="nx">FindUser</span><span class="p">(</span><span class="nx">knownIDs</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">t</span><span class="p">.</span><span class="nx">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
  <span class="p">}</span>
</code></pre>
<p>For example, in the preceding code snippet, we give the description <code>FindUser - Empty cache</code>. Then we define our closure. First it tries to find a user with a known ID, and checks for errors. As the description implies, the cache is empty at this point, and the user will have to be retrieved from the <code>someDatabase</code> array:</p>
<pre class="code" ><code class="chroma" >  <span class="k">if</span> <span class="nx">user</span><span class="p">.</span><span class="nx">ID</span> <span class="o">!=</span> <span class="nx">knownIDs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">{</span>
    <span class="nx">t</span><span class="p">.</span><span class="nx">Error</span><span class="p">(</span><span class="s">&#34;Returned user name doesn&#39;t match with expected&#34;</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">proxy</span><span class="p">.</span><span class="nx">StackCache</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span> <span class="p">{</span>
    <span class="nx">t</span><span class="p">.</span><span class="nx">Error</span><span class="p">(</span><span class="s">&#34;After one successful search in an empty cache, the size of it must be one&#34;</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="k">if</span> <span class="nx">proxy</span><span class="p">.</span><span class="nx">DidLastSearchUsedCache</span> <span class="p">{</span>
    <span class="nx">t</span><span class="p">.</span><span class="nx">Error</span><span class="p">(</span><span class="s">&#34;No user can be returned from an empty cache&#34;</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>Finally, we check whether the returned user has the same ID as that of the expected user at index 0 of the <code>knownIDs</code> slice, and that the proxy cache now has a size of 1. The state of the member <code>DidLastSearchUsedCache</code> proxy must not be <code>true</code>, or we will not pass the test. Remember, this member tells us whether the last search has been retrieved from the slice that represents a database, or from the cache.</p>
<p>The second embedded test for the Proxy pattern is to ask for the same user as before, which must now be returned from the cache. It&#39;s very similar to the previous test, but now we have to check if the user is returned from the cache:</p>
<pre class="code" ><code class="chroma" ><span class="nx">t</span><span class="p">.</span><span class="nx">Run</span><span class="p">(</span><span class="s">&#34;FindUser - One user, ask for the same user&#34;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">user</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">proxy</span><span class="p">.</span><span class="nx">FindUser</span><span class="p">(</span><span class="nx">knownIDs</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">t</span><span class="p">.</span><span class="nx">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="k">if</span> <span class="nx">user</span><span class="p">.</span><span class="nx">ID</span> <span class="o">!=</span> <span class="nx">knownIDs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">{</span>
    <span class="nx">t</span><span class="p">.</span><span class="nx">Error</span><span class="p">(</span><span class="s">&#34;Returned user name doesn&#39;t match with expected&#34;</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">proxy</span><span class="p">.</span><span class="nx">StackCache</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span> <span class="p">{</span>
    <span class="nx">t</span><span class="p">.</span><span class="nx">Error</span><span class="p">(</span><span class="s">&#34;Cache must not grow if we asked for an object that is stored on it&#34;</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="k">if</span> <span class="p">!</span><span class="nx">proxy</span><span class="p">.</span><span class="nx">DidLastSearchUsedCache</span> <span class="p">{</span>
    <span class="nx">t</span><span class="p">.</span><span class="nx">Error</span><span class="p">(</span><span class="s">&#34;The user should have been returned from the cache&#34;</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">})</span>
</code></pre>
<p>So, again we ask for the first known ID. The proxy cache must maintain a size of 1 after this search, and the <code>DidLastSearchUsedCache</code> member must be true this time, or the test will fail.</p>
<p>The last test will overflow the <code>StackCache</code> array on the <code>proxy</code> type. We will search for two new users that our <code>proxy</code> type will have to retrieve from the database. Our stack has a size of 2, so it will have to remove the first user to allocate space for the second and third users:</p>
<pre class="code" ><code class="chroma" ><span class="nx">user1</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">proxy</span><span class="p">.</span><span class="nx">FindUser</span><span class="p">(</span><span class="nx">knownIDs</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
  <span class="nx">t</span><span class="p">.</span><span class="nx">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
<span class="p">}</span>

<span class="nx">user2</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">proxy</span><span class="p">.</span><span class="nx">FindUser</span><span class="p">(</span><span class="nx">knownIDs</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="k">if</span> <span class="nx">proxy</span><span class="p">.</span><span class="nx">DidLastSearchUsedCache</span> <span class="p">{</span>
  <span class="nx">t</span><span class="p">.</span><span class="nx">Error</span><span class="p">(</span><span class="s">&#34;The user wasn&#39;t stored on the proxy cache yet&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="nx">user3</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">proxy</span><span class="p">.</span><span class="nx">FindUser</span><span class="p">(</span><span class="nx">knownIDs</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
<span class="k">if</span> <span class="nx">proxy</span><span class="p">.</span><span class="nx">DidLastSearchUsedCache</span> <span class="p">{</span>
  <span class="nx">t</span><span class="p">.</span><span class="nx">Error</span><span class="p">(</span><span class="s">&#34;The user wasn&#39;t stored on the proxy cache yet&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
<p>We have retrieved the first three users. We aren&#39;t checking for errors because that was the purpose of the previous tests. This is important to recall that there is no need to over-test your code. If there is any error here, it will arise in the previous tests. Also, we have checked that the <code>user2</code> and <code>user3</code> queries do not use the cache; they shouldn&#39;t be stored there yet.</p>
<p>Now we are going to look for the <code>user1</code> query in the Proxy. It shouldn&#39;t exist, as the stack has a size of 2, and <code>user1</code> was the first to enter, hence, the first to go out:</p>
<pre class="code" ><code class="chroma" ><span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">proxy</span><span class="p">.</span><span class="nx">StackCache</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
  <span class="k">if</span> <span class="nx">proxy</span><span class="p">.</span><span class="nx">StackCache</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">ID</span> <span class="o">==</span> <span class="nx">user1</span><span class="p">.</span><span class="nx">ID</span> <span class="p">{</span>
    <span class="nx">t</span><span class="p">.</span><span class="nx">Error</span><span class="p">(</span><span class="s">&#34;User that should be gone was found&#34;</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">proxy</span><span class="p">.</span><span class="nx">StackCache</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span> <span class="p">{</span>
  <span class="nx">t</span><span class="p">.</span><span class="nx">Error</span><span class="p">(</span><span class="s">&#34;After inserting 3 users the cache should not grow&#34;</span> <span class="o">+</span>
    <span class="s">&#34; more than to two&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
<p>It doesn&#39;t matter if we ask for a thousand users; our cache can&#39;t be bigger than our configured size.</p>
<p>Finally, we are going to again range over the users stored in the cache, and compare them with the last two we queried. This way, we will check that just those users are stored in the cache. Both must be found on it:</p>
<pre class="code" ><code class="chroma" >  <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">proxy</span><span class="p">.</span><span class="nx">StackCache</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">v</span> <span class="o">!=</span> <span class="nx">user2</span> <span class="o">&amp;&amp;</span> <span class="nx">v</span> <span class="o">!=</span> <span class="nx">user3</span> <span class="p">{</span>
      <span class="nx">t</span><span class="p">.</span><span class="nx">Error</span><span class="p">(</span><span class="s">&#34;A non expected user was found on the cache&#34;</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>Running the tests now should give some errors, as usual. Let&#39;s run them now:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go <span class="nb">test</span> -v .
</span><span class="out" >=== RUN   Test_UserListProxy
=== RUN   Test_UserListProxy/FindUser_-_Empty_cache
=== RUN   Test_UserListProxy/FindUser_-_One_user,_ask_for_the_same_user
=== RUN   Test_UserListProxy/FindUser_-_overflowing_the_stack
--- FAIL: Test_UserListProxy (0.06s)
    --- FAIL: Test_UserListProxy/FindUser_-_Empty_cache (0.00s)
        proxy_test.go:28: Not implemented yet
    --- FAIL: Test_UserListProxy/FindUser_-_One_user,_ask_for_the_same_user (0.00s)
        proxy_test.go:47: Not implemented yet
    --- FAIL: Test_UserListProxy/FindUser_-_overflowing_the_stack (0.00s)
        proxy_test.go:66: Not implemented yet
FAIL
exit status 1
FAIL
</span></code></pre>
<p>So, let&#39;s implement the <code>FindUser</code> method to act as our Proxy.</p>
</div>
<h4 id="implementation" >Implementation</h4>
<div class="hBody-4" >
<p>In our Proxy, the <code>FindUser</code> method will search for a specified ID in the cache list. If it finds it, it will return the ID. If not, it will search in the database. Finally, if it&#39;s not in the database list, it will return an error.</p>
<p>If you remember, our Proxy pattern is composed of two <code>UserList</code> types (one of them a pointer), which are actually slices of <code>User</code> type. We will implement a <code>FindUser</code> method in <code>User</code> type too, which, by the way, has the same signature as the <code>UserFinder</code> interface:</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">UserList</span> <span class="p">[]</span><span class="nx">User</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">UserList</span><span class="p">)</span> <span class="nx">FindUser</span><span class="p">(</span><span class="nx">id</span> <span class="kt">int32</span><span class="p">)</span> <span class="p">(</span><span class="nx">User</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="o">*</span><span class="nx">t</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="nx">t</span><span class="p">)[</span><span class="nx">i</span><span class="p">].</span><span class="nx">ID</span> <span class="o">==</span> <span class="nx">id</span> <span class="p">{</span>
      <span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="nx">t</span><span class="p">)[</span><span class="nx">i</span><span class="p">],</span> <span class="kc">nil</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">User</span><span class="p">{},</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&#34;User %s could not be found\n&#34;</span><span class="p">,</span> <span class="nx">id</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
<p>The <code>FindUser</code> method in the <code>UserList</code> slice will iterate over the list to try and find a user with the same ID as the <code>id</code> argument, or return an error if it can&#39;t find it.</p>
<p>You may be wondering why the pointer <code>t</code> is between parentheses. This is to dereference the underlying array before accessing its indexes. Without it, you&#39;ll have a compilation error, because the compiler tries to search the index before dereferencing the pointer.</p>
<p>So, the first part of the proxy <code>FindUser</code> method can be written as follows:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="p">(</span><span class="nx">u</span> <span class="o">*</span><span class="nx">UserListProxy</span><span class="p">)</span> <span class="nx">FindUser</span><span class="p">(</span><span class="nx">id</span> <span class="kt">int32</span><span class="p">)</span> <span class="p">(</span><span class="nx">User</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">user</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">u</span><span class="p">.</span><span class="nx">StackCache</span><span class="p">.</span><span class="nx">FindUser</span><span class="p">(</span><span class="nx">id</span><span class="p">)</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&#34;Returning user from cache&#34;</span><span class="p">)</span>
    <span class="nx">u</span><span class="p">.</span><span class="nx">DidLastSearchUsedCache</span> <span class="p">=</span> <span class="kc">true</span>
    <span class="k">return</span> <span class="nx">user</span><span class="p">,</span> <span class="kc">nil</span>
  <span class="p">}</span>
</code></pre>
<p>We use the preceding method to search for a user in the <code>StackCache</code> member. The error will be nil if it can find it, so we check this to print a message to the console, change the state of <code>DidLastSearchUsedCache</code> to <code>true</code> so that the test can check whether the user was retrieved from cache, and finally, return the user.</p>
<p>So, if the error was not nil, it means that it couldn&#39;t find the user in the stack. So, the next step is to search in the database:</p>
<pre class="code" ><code class="chroma" ><span class="nx">user</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">u</span><span class="p">.</span><span class="nx">SomeDatabase</span><span class="p">.</span><span class="nx">FindUser</span><span class="p">(</span><span class="nx">id</span><span class="p">)</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">User</span><span class="p">{},</span> <span class="nx">err</span>
<span class="p">}</span>
</code></pre>
<p>We can reuse the <code>FindUser</code> method we wrote for <code>UserList</code> database in this case, because both have the same type for the purpose of this example. Again, it searches the user in the database represented  by the <code>UserList</code> slice, but in this case, if the user isn&#39;t found, it returns the error generated in <code>UserList</code>.</p>
<p>When the user is found (<code>err</code> is nil), we have to add the user to the stack. For this purpose, we write a dedicated private method that receives a pointer of type <code>UserListProxy</code>:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="p">(</span><span class="nx">u</span> <span class="o">*</span><span class="nx">UserListProxy</span><span class="p">)</span> <span class="nx">addUserToStack</span><span class="p">(</span><span class="nx">user</span> <span class="nx">User</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">u</span><span class="p">.</span><span class="nx">StackCache</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="nx">u</span><span class="p">.</span><span class="nx">StackCapacity</span> <span class="p">{</span>
    <span class="nx">u</span><span class="p">.</span><span class="nx">StackCache</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">u</span><span class="p">.</span><span class="nx">StackCache</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="nx">user</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="k">else</span> <span class="p">{</span>
    <span class="nx">u</span><span class="p">.</span><span class="nx">StackCache</span><span class="p">.</span><span class="nx">addUser</span><span class="p">(</span><span class="nx">user</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">UserList</span><span class="p">)</span> <span class="nx">addUser</span><span class="p">(</span><span class="nx">newUser</span> <span class="nx">User</span><span class="p">)</span> <span class="p">{</span>
  <span class="o">*</span><span class="nx">t</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="o">*</span><span class="nx">t</span><span class="p">,</span> <span class="nx">newUser</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
<p>The <code>addUserToStack</code> method takes the user argument, and adds it to the stack in place. If the stack is full, it removes the first element in it before adding. We have also written an <code>addUser</code> method to <code>UserList</code> to help us in this. So, now in <code>FindUser</code> method, we just have to add one line:</p>
<pre class="code" ><code class="chroma" ><span class="nx">u</span><span class="p">.</span><span class="nx">addUserToStack</span><span class="p">(</span><span class="nx">user</span><span class="p">)</span>
</code></pre>
<p>This adds the new user to the stack, removing the last if necessary.</p>
<p>Finally, we just have to return the new user of the stack, and set the appropriate value on <code>DidLastSearchUsedCache</code> variable. We also write a message to the console to help in the testing process:</p>
<pre class="code" ><code class="chroma" >  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&#34;Returning user from database&#34;</span><span class="p">)</span>
  <span class="nx">u</span><span class="p">.</span><span class="nx">DidLastSearchUsedCache</span> <span class="p">=</span> <span class="kc">false</span>
  <span class="k">return</span> <span class="nx">user</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre>
<p>With this, we have enough to pass our tests:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go <span class="nb">test</span> -v .
</span><span class="out" >=== RUN   Test_UserListProxy
=== RUN   Test_UserListProxy/FindUser_-_Empty_cache
Returning user from database
=== RUN   Test_UserListProxy/FindUser_-_One_user,_ask_for_the_same_user
Returning user from cache
=== RUN   Test_UserListProxy/FindUser_-_overflowing_the_stack
Returning user from cache
Returning user from database
Returning user from database
--- PASS: Test_UserListProxy (0.09s)
--- PASS: Test_UserListProxy/FindUser_-_Empty_cache (0.00s)
--- PASS: Test_UserListProxy/FindUser_-_One_user,_ask_for_the_same_user (0.00s)
--- PASS: Test_UserListProxy/FindUser_-_overflowing_the_stack (0.00s)
PASS
ok
</span></code></pre>
<p>You can see in the preceding messages that our Proxy has worked flawlessly. It has returned the first search from the database. Then, when we search for the same user again, it uses the cache. Finally, we made a new test that calls three different users and we can observe, by looking at the console output, that just the first was returned from the cache and that the other two were fetched from the database.</p>
</div>
<h4 id="proxying-around-actions" >Proxying around actions</h4>
<div class="hBody-4" >
<p>Wrap proxies around types that need some intermediate action, like giving authorization to the user or providing access to a database, like in our example.</p>
<p>Our example is a good way to separate application needs from database needs. If our application accesses the database too much, a solution for this is not in your database. Remember that the Proxy uses the same interface as the type it wraps, and, for the user, there shouldn&#39;t be any difference between the two.</p>
</div>
<h3 id="decorator-design-pattern" >Decorator design pattern</h3>
<div class="hBody-3" >
<p>We&#39;ll continue this chapter with the big brother of the Proxy pattern, and maybe, one of the most powerful design patterns of all. The <b>Decorator</b> pattern is pretty simple, but, for instance, it provides a lot of benefits when working with legacy code.</p>
</div>
<h4 id="description" >Description</h4>
<div class="hBody-4" >
<p>The Decorator design pattern allows you to decorate an already existing type with more functional features without actually touching it. How is it possible? Well, it uses an approach similar to <i>matryoshka dolls</i>, where you have a small doll that you can put inside a doll of the same shape but bigger, and so on and so forth.</p>
<p>The Decorator type implements the same interface of the type it decorates, and stores an instance of that type in its members. This way, you can stack as many decorators (dolls) as you want by simply storing the old decorator in a field of the new one.</p>
</div>
<h4 id="objectives" >Objectives</h4>
<div class="hBody-4" >
<p>When you think about extending legacy code without the risk of breaking something, you should think of the Decorator pattern first. It&#39;s a really powerful approach to deal with this particular problem.</p>
<p>A different field where the Decorator is very powerful may not be so obvious though it reveals itself when creating types with lots of features based on user inputs, preferences, or similar inputs. Like in a Swiss knife, you have a base type (the frame of the knife), and from there you unfold its functionalities.</p>
<p>So, precisely when are we going to use the Decorator pattern? Answer to this question:</p>
<ul>
<li>
<p>When you need to add functionality to some code that you don&#39;t have access to, or you don&#39;t want to modify to avoid a negative effect on the code, and follow the open/close principle (like legacy code)</p>
</li>
<li>
<p>When you want the functionality of an object to be created or altered dynamically, and the number of features is unknown and could grow fast</p>
</li>
</ul>
</div>
<h4 id="example" >Example</h4>
<div class="hBody-4" >
<p>In our example, we will prepare a <code>Pizza</code> type, where the core is the pizza and the ingredients are the decorating types. We will have a couple of ingredients for our pizza-onion and meat.</p>
</div>
<h4 id="acceptance-criteria" >Acceptance criteria</h4>
<div class="hBody-4" >
<p>The acceptance criteria for a Decorator pattern is to have a common interface and a core type, the one that all layers will be built over:</p>
<ul>
<li>
<p>We must have the main interface that all decorators will implement. This interface will be called <code>IngredientAdd</code>, and it will have the <code>AddIngredient() string</code> method.</p>
</li>
<li>
<p>We must have a core <code>PizzaDecorator</code> type (the decorator) that we will add ingredients to.</p>
</li>
<li>
<p>We must have an ingredient &#34;onion&#34;  implementing the same <code>IngredientAdd</code> interface that will add the string <code>onion</code> to the returned pizza.</p>
</li>
<li>
<p>We must have a ingredient &#34;meat&#34; implementing the <code>IngredientAdd</code> interface that will add the string <code>meat</code> to the returned pizza.</p>
</li>
<li>
<p>When calling <code>AddIngredient</code> method on the top object, it must return a fully decorated <code>pizza</code> with the text <code>Pizza with the following ingredients: meat, onion</code>.</p>
</li>
</ul>
</div>
<h4 id="unit-test" >Unit test</h4>
<div class="hBody-4" >
<p>To launch our unit tests, we must first create the basic structures described in accordance with the acceptance criteria. To begin with, the interface that all decorating types must implement is as follows:</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">IngredientAdd</span> <span class="kd">interface</span> <span class="p">{</span>
  <span class="nx">AddIngredient</span><span class="p">()</span> <span class="p">(</span><span class="kt">string</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
<p>The following code defines the <code>PizzaDecorator</code> type, which must have <code>IngredientAdd</code> inside, and which implements <code>IngredientAdd</code> too:</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">PizzaDecorator</span> <span class="kd">struct</span><span class="p">{</span>
  <span class="nx">Ingredient</span> <span class="nx">IngredientAdd</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">PizzaDecorator</span><span class="p">)</span> <span class="nx">AddIngredient</span><span class="p">()</span> <span class="p">(</span><span class="kt">string</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="s">&#34;&#34;</span><span class="p">,</span> <span class="nx">errors</span><span class="p">.</span><span class="nx">New</span><span class="p">(</span><span class="s">&#34;Not implemented yet&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
<p>The definition of the <code>Meat</code> type will be very similar to that of the <code>PizzaDecorator</code> structure:</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">Meat</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">Ingredient</span> <span class="nx">IngredientAdd</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">Meat</span><span class="p">)</span> <span class="nx">AddIngredient</span><span class="p">()</span> <span class="p">(</span><span class="kt">string</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="s">&#34;&#34;</span><span class="p">,</span> <span class="nx">errors</span><span class="p">.</span><span class="nx">New</span><span class="p">(</span><span class="s">&#34;Not implemented yet&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
<p>Now we define the <code>Onion</code> struct in a similar fashion:</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">Onion</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">Ingredient</span> <span class="nx">IngredientAdd</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">o</span> <span class="o">*</span><span class="nx">Onion</span><span class="p">)</span> <span class="nx">AddIngredient</span><span class="p">()</span> <span class="p">(</span><span class="kt">string</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="s">&#34;&#34;</span><span class="p">,</span> <span class="nx">errors</span><span class="p">.</span><span class="nx">New</span><span class="p">(</span><span class="s">&#34;Not implemented yet&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
<p>This is enough to implement the first unit test, and to allow the compiler to run them without any compiling errors:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">TestPizzaDecorator_AddIngredient</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">pizza</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">PizzaDecorator</span><span class="p">{}</span>
  <span class="nx">pizzaResult</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">pizza</span><span class="p">.</span><span class="nx">AddIngredient</span><span class="p">()</span>
  <span class="nx">expectedText</span> <span class="o">:=</span> <span class="s">&#34;Pizza with the following ingredients:&#34;</span>
  <span class="k">if</span> <span class="p">!</span><span class="nx">strings</span><span class="p">.</span><span class="nx">Contains</span><span class="p">(</span><span class="nx">pizzaResult</span><span class="p">,</span> <span class="nx">expectedText</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">t</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&#34;When calling the add ingredient of the pizza decorator it must return the text %sthe expected text, not &#39;%s&#39;&#34;</span><span class="p">,</span>
      <span class="nx">pizzaResult</span><span class="p">,</span> <span class="nx">expectedText</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>Now it must compile without problems, so we can check that the test fails:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go <span class="nb">test</span> -v -run<span class="o">=</span>TestPizzaDecorator .
</span><span class="out" >=== RUN   TestPizzaDecorator_AddIngredient
--- FAIL: TestPizzaDecorator_AddIngredient (0.00s)
decorator_test.go:29: Not implemented yet
decorator_test.go:34: When the the AddIngredient method of the pizza decorator object is called, it must return the text
Pizza with the following ingredients:
FAIL
exit status 1
FAIL
</span></code></pre>
<p>Our first test is done, and we can see that the <code>PizzaDecorator</code> struct isn&#39;t returning anything yet, that&#39;s why it fails. We can now move on to the <code>Onion</code> type. The test of the <code>Onion</code> type is quite similar to that of the <code>Pizza</code> decorator, but we must also make sure that we actually add the ingredient to the <code>IngredientAdd</code> method and not to a nil pointer:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">TestOnion_AddIngredient</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">onion</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">Onion</span><span class="p">{}</span>
  <span class="nx">onionResult</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">onion</span><span class="p">.</span><span class="nx">AddIngredient</span><span class="p">()</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">t</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&#34;When calling AddIngredient on the onion decorator without&#34;</span> <span class="o">+</span>
      <span class="s">&#34;an IngredientAdd on its Ingredient field must return an error, not a string with &#39;%s&#39;&#34;</span><span class="p">,</span>
      <span class="nx">onionResult</span><span class="p">)</span>
  <span class="p">}</span>
</code></pre>
<p>The first half of the preceding test examines the returning error when no <code>IngredientAdd</code> method is passed to the <code>Onion</code> struct initializer. As no pizza is available to add the ingredient, an error must be returned:</p>
<pre class="code" ><code class="chroma" >  <span class="nx">onion</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">Onion</span><span class="p">{</span><span class="o">&amp;</span><span class="nx">PizzaDecorator</span><span class="p">{}}</span>
  <span class="nx">onionResult</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">onion</span><span class="p">.</span><span class="nx">AddIngredient</span><span class="p">()</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">t</span><span class="p">.</span><span class="nx">Error</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="p">!</span><span class="nx">strings</span><span class="p">.</span><span class="nx">Contains</span><span class="p">(</span><span class="nx">onionResult</span><span class="p">,</span> <span class="s">&#34;onion&#34;</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">t</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&#34;When calling the add ingredient of the onion decorator it&#34;</span> <span class="o">+</span>
    <span class="s">&#34;must return a text with the word &#39;onion&#39;, not &#39;%s&#39;&#34;</span><span class="p">,</span>
    <span class="nx">onionResult</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>The second part of the <code>Onion</code> type test actually passes <code>PizzaDecorator</code> structure to the initializer. Then, we check whether no error is being returned, and also whether the returning string contains the word <code>onion</code> in it. This way, we can ensure that onion has been added to the pizza.</p>
<p>Finally for the <code>Onion</code> type, the console output of this test with our current implementation will be the following:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go <span class="nb">test</span> -v -run<span class="o">=</span>TestOnion_AddIngredient .
</span><span class="out" >=== RUN   TestOnion_AddIngredient
--- FAIL: TestOnion_AddIngredient (0.00s)
decorator_test.go:48: Not implemented yet
decorator_test.go:52: When calling the add ingredient of the onion decorator it must return a text with the word &#39;onion&#39;, not &#39;&#39;
FAIL
exit status 1
FAIL
</span></code></pre>
<p>The <code>meat</code> ingredient is exactly the same, but we change the type to meat instead of onion:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">TestMeat_AddIngredient</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">meat</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">Meat</span><span class="p">{}</span>
  <span class="nx">meatResult</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">meat</span><span class="p">.</span><span class="nx">AddIngredient</span><span class="p">()</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">t</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&#34;When calling AddIngredient on the meat decorator without&#34;</span> <span class="o">+</span>
      <span class="s">&#34;an IngredientAdd in its Ingredient field must return an error,&#34;</span> <span class="o">+</span>
      <span class="s">&#34;not a string with &#39;%s&#39;&#34;</span><span class="p">,</span> <span class="nx">meatResult</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="nx">meat</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">Meat</span><span class="p">{</span><span class="o">&amp;</span><span class="nx">PizzaDecorator</span><span class="p">{}}</span>
  <span class="nx">meatResult</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">meat</span><span class="p">.</span><span class="nx">AddIngredient</span><span class="p">()</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">t</span><span class="p">.</span><span class="nx">Error</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="p">!</span><span class="nx">strings</span><span class="p">.</span><span class="nx">Contains</span><span class="p">(</span><span class="nx">meatResult</span><span class="p">,</span> <span class="s">&#34;meat&#34;</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">t</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&#34;When calling the add ingredient of the meat decorator it&#34;</span> <span class="o">+</span>
      <span class="s">&#34;must return a text with the word &#39;meat&#39;, not &#39;%s&#39;&#34;</span><span class="p">,</span> <span class="nx">meatResult</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>So, the result of the tests will be similar:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go <span class="nb">test</span> -v -run<span class="o">=</span>TestMeat_AddIngredient .
</span><span class="out" >=== RUN   TestMeat_AddIngredient
--- FAIL: TestMeat_AddIngredient (0.00s)
decorator_test.go:68: Not implemented yet
decorator_test.go:72: When calling the add ingredient of the meat decorator it must return a text with the word &#39;meat&#39;, not &#39;&#39;
FAIL
exit status 1
FAIL
</span></code></pre>
<p>Finally, we must check the full stack test. Creating a pizza with onion and meat must return the text <code>Pizza with the following ingredients: meat, onion</code>:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">TestPizzaDecorator_FullStack</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">pizza</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">Onion</span><span class="p">{</span><span class="o">&amp;</span><span class="nx">Meat</span><span class="p">{</span><span class="o">&amp;</span><span class="nx">PizzaDecorator</span><span class="p">{}}}</span>
  <span class="nx">pizzaResult</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">pizza</span><span class="p">.</span><span class="nx">AddIngredient</span><span class="p">()</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">t</span><span class="p">.</span><span class="nx">Error</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="nx">expectedText</span> <span class="o">:=</span> <span class="s">&#34;Pizza with the following ingredients: meat, onion&#34;</span>
  <span class="k">if</span> <span class="p">!</span><span class="nx">strings</span><span class="p">.</span><span class="nx">Contains</span><span class="p">(</span><span class="nx">pizzaResult</span><span class="p">,</span> <span class="nx">expectedText</span><span class="p">){</span>
    <span class="nx">t</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&#34;When asking for a pizza with onion and meat the returned &#34;</span> <span class="o">+</span>
      <span class="s">&#34;string must contain the text &#39;%s&#39; but &#39;%s&#39; didn&#39;t have it&#34;</span><span class="p">,</span>
      <span class="nx">expectedText</span><span class="p">,</span><span class="nx">pizzaResult</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="nx">t</span><span class="p">.</span><span class="nx">Log</span><span class="p">(</span><span class="nx">pizzaResult</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
<p>Our test creates a variable called <code>pizza</code> which, like the <i>matryoshka dolls</i>, embeds types of the <code>IngredientAdd</code> method in several levels.</p>
<p>Calling the <code>AddIngredient</code> method executes the method at the &#34;onion&#34; level, which executes the &#34;meat&#34; one, which, finally, executes that of the <code>PizzaDecorator</code> struct. After checking that no error had been returned, we check whether the returned text follows the needs of the <i>acceptance criteria 5</i>. The tests are run with the following command:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go <span class="nb">test</span> -v -run<span class="o">=</span>TestPizzaDecorator_FullStack .
</span><span class="out" >=== RUN   TestPizzaDecorator_FullStack
--- FAIL: TestPizzaDecorator_FullStack (0.
decorator_test.go:80: Not implemented yet
decorator_test.go:87: When asking for a pizza with onion and meat the returned string must contain the text &#39;Pizza with the following ingredients: meat, onion&#39; but &#39;&#39; didn&#39;t have it
FAIL
exit status 1
FAIL
</span></code></pre>
<p>From the preceding output, we can see that the tests now return an empty string for our decorated type. This is, of course, because no implementation has been done yet. This was the last test to check the fully decorated implementation. Let&#39;s look closely at the implementation then.</p>
</div>
<h4 id="implementation" >Implementation</h4>
<div class="hBody-4" >
<p>We are going to start implementing the <code>PizzaDecorator</code> type. Its role is to provide the initial text of the full pizza:</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">PizzaDecorator</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">Ingredient</span> <span class="nx">IngredientAdd</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">PizzaDecorator</span><span class="p">)</span> <span class="nx">AddIngredient</span><span class="p">()</span> <span class="p">(</span><span class="kt">string</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="s">&#34;Pizza with the following ingredients:&#34;</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre>
<p>A single line change on the return of the <code>AddIngredient</code> method was enough to pass the test:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go <span class="nb">test</span> -v -run<span class="o">=</span>TestPizzaDecorator_Add .
</span><span class="out" >=== RUN   TestPizzaDecorator_AddIngredient
--- PASS: TestPizzaDecorator_AddIngredient (0.00s)
PASS
ok
</span></code></pre>
<p>Moving on to the <code>Onion</code> struct implementation, we must take the beginning of our <code>IngredientAdd</code> returned string, and add the word <code>onion</code> at the end of it in order to get a composed pizza in return:</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">Onion</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">Ingredient</span> <span class="nx">IngredientAdd</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">o</span> <span class="o">*</span><span class="nx">Onion</span><span class="p">)</span> <span class="nx">AddIngredient</span><span class="p">()</span> <span class="p">(</span><span class="kt">string</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="nx">o</span><span class="p">.</span><span class="nx">Ingredient</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="k">return</span> <span class="s">&#34;&#34;</span><span class="p">,</span> <span class="nx">errors</span><span class="p">.</span><span class="nx">New</span><span class="p">(</span><span class="s">&#34;An IngredientAdd is needed in the Ingredient field of the Onion&#34;</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="nx">s</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">o</span><span class="p">.</span><span class="nx">Ingredient</span><span class="p">.</span><span class="nx">AddIngredient</span><span class="p">()</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="k">return</span> <span class="s">&#34;&#34;</span><span class="p">,</span> <span class="nx">err</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintf</span><span class="p">(</span><span class="s">&#34;%s %s,&#34;</span><span class="p">,</span> <span class="nx">s</span><span class="p">,</span> <span class="s">&#34;onion&#34;</span><span class="p">),</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre>
<p>Checking that we actually have a pointer to <code>IngredientAdd</code> first, we use the contents of the inner <code>IngredientAdd</code>, and check it for errors. If no errors occur, we receive a new string composed of this content, a space, and the word <code>onion</code> (and no errors). Looks good enough to run the tests:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go <span class="nb">test</span> -v -run<span class="o">=</span>TestOnion_AddIngredient .
</span><span class="out" >=== RUN   TestOnion_AddIngredient
--- PASS: TestOnion_AddIngredient (0.00s)
PASS
ok
</span></code></pre>
<p>Implementation of the <code>Meat</code> struct is very similar:</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">Meat</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">Ingredient</span> <span class="nx">IngredientAdd</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">Meat</span><span class="p">)</span> <span class="nx">AddIngredient</span><span class="p">()</span> <span class="p">(</span><span class="kt">string</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="nx">m</span><span class="p">.</span><span class="nx">Ingredient</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="k">return</span> <span class="s">&#34;&#34;</span><span class="p">,</span> <span class="nx">errors</span><span class="p">.</span><span class="nx">New</span><span class="p">(</span><span class="s">&#34;An IngredientAdd is needed in the Ingredient field of the Meat&#34;</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="nx">s</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">m</span><span class="p">.</span><span class="nx">Ingredient</span><span class="p">.</span><span class="nx">AddIngredient</span><span class="p">()</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="k">return</span> <span class="s">&#34;&#34;</span><span class="p">,</span> <span class="nx">err</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintf</span><span class="p">(</span><span class="s">&#34;%s %s,&#34;</span><span class="p">,</span> <span class="nx">s</span><span class="p">,</span> <span class="s">&#34;meat&#34;</span><span class="p">),</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre>
<p>And here goes their test execution:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go <span class="nb">test</span> -v -run<span class="o">=</span>TestMeat_AddIngredient .
</span><span class="out" >=== RUN   TestMeat_AddIngredient
--- PASS: TestMeat_AddIngredient (0.00s)
PASS
ok
</span></code></pre>
<p>Okay. So, now all the pieces are to be tested separately. If everything is okay, the test of the <i>full stacked</i> solution must be passing smoothly:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go <span class="nb">test</span> -v -run<span class="o">=</span>TestPizzaDecorator_FullStack .
</span><span class="out" >=== RUN   TestPizzaDecorator_FullStack
--- PASS: TestPizzaDecorator_FullStack (0.00s)
decorator_test.go:92: Pizza with the following ingredients: meat, onion,
PASS
ok
</span></code></pre>
<p>Awesome! With the Decorator pattern, we could keep stacking <code>IngredientAdds</code> which call their inner pointer to add functionality to <code>PizzaDecorator</code>. We aren&#39;t touching the core type either, nor modifying or implementing new things. All the new features are implemented by an external type.</p>
</div>
<h4 id="a-real-life-example---server-middleware" >A real-life example - server middleware</h4>
<div class="hBody-4" >
<p>By now, you should have understood how the Decorator pattern works. Now we can try a more advanced example using the small HTTP server that we designed in the Adapter pattern section. You learned that an HTTP server can be created by using the <code>http</code> package, and implementing the <code>http.Handler</code> interface. This interface has only one method called <code>ServeHTTP(http.ResponseWriter, http.Request)</code>. Can we use the Decorator pattern to add more functionality to a server? Of course!</p>
<p>We will add a couple of pieces to this server. First, we are going to log every connection made to it to the <code>io.Writer</code> interface (for the sake of simplicity, we&#39;ll use the <code>io.Writer</code> implementation of the <code>os.Stdout</code> interface so that it outputs to the console). The second piece will add basic HTTP authentication to every request made to the server. If the authentication passes, a <code>Hello Decorator!</code> message will appear. Finally, the user will be able to select the number of decoration items that he/she wants in the server, and the server will be structured and created at runtime.</p>
</div>
<h5 id="starting-with-the-common-interface,-http.handler" >Starting with the common interface, http.Handler</h5>
<div class="hBody-5" >
<p>We already have the common interface that we will decorate using nested types. We first need to create our core type, which is going to be the <code>Handler</code> that returns the sentence <code>Hello Decorator!</code>:</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">MyServer</span> <span class="kd">struct</span><span class="p">{}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">MyServer</span><span class="p">)</span> <span class="nx">ServeHTTP</span><span class="p">(</span><span class="nx">w</span> <span class="nx">http</span><span class="p">.</span><span class="nx">ResponseWriter</span><span class="p">,</span> <span class="nx">r</span> <span class="o">*</span><span class="nx">http</span><span class="p">.</span><span class="nx">Request</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Fprintln</span><span class="p">(</span><span class="nx">w</span><span class="p">,</span> <span class="s">&#34;Hello Decorator!&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
<p>This handler can be attributed to the <code>http.Handle</code> method to define our first endpoint. Let&#39;s check this now by creating the package&#39;s main function, and sending a <code>GET</code> request to it:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">http</span><span class="p">.</span><span class="nx">Handle</span><span class="p">(</span><span class="s">&#34;/&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">MyServer</span><span class="p">{})</span>

  <span class="nx">log</span><span class="p">.</span><span class="nx">Fatal</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">ListenAndServe</span><span class="p">(</span><span class="s">&#34;:8080&#34;</span><span class="p">,</span> <span class="kc">nil</span><span class="p">))</span>
<span class="p">}</span>
</code></pre>
<p>Execute the server using the Terminal to execute the  <code class="command" >go run main.go</code> command. Then, open a new Terminal to make the <code>GET</code> request. We&#39;ll use the <code class="command" >curl</code> command to make our requests:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>curl http://localhost:8080
</span><span class="out" >Hello Decorator!
</span></code></pre>
<p>We have crossed the first milestone of our decorated server. The next step is to decorate it with logging capabilities. To do so, we must implement the <code>http.Handler</code> interface, in a new type, as follows:</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">LoggerServer</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">Handler</span>   <span class="nx">http</span><span class="p">.</span><span class="nx">Handler</span>
  <span class="nx">LogWriter</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Writer</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">LoggerServer</span><span class="p">)</span> <span class="nx">ServeHTTP</span><span class="p">(</span><span class="nx">w</span> <span class="nx">http</span><span class="p">.</span><span class="nx">ResponseWriter</span><span class="p">,</span> <span class="nx">r</span>
  <span class="o">*</span><span class="nx">http</span><span class="p">.</span><span class="nx">Request</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Fprintf</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">LogWriter</span><span class="p">,</span> <span class="s">&#34;Request URI: %s\n&#34;</span><span class="p">,</span> <span class="nx">r</span><span class="p">.</span><span class="nx">RequestURI</span><span class="p">)</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Fprintf</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">LogWriter</span><span class="p">,</span> <span class="s">&#34;Host: %s\n&#34;</span><span class="p">,</span> <span class="nx">r</span><span class="p">.</span><span class="nx">Host</span><span class="p">)</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Fprintf</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">LogWriter</span><span class="p">,</span> <span class="s">&#34;Content Length: %d\n&#34;</span><span class="p">,</span> <span class="nx">r</span><span class="p">.</span><span class="nx">ContentLength</span><span class="p">)</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Fprintf</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">LogWriter</span><span class="p">,</span> <span class="s">&#34;Method: %s\n&#34;</span><span class="p">,</span> <span class="nx">r</span><span class="p">.</span><span class="nx">Method</span><span class="p">)</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Fprintf</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">LogWriter</span><span class="p">,</span> <span class="s">&#34;---------------------------- ----\n&#34;</span><span class="p">)</span>

  <span class="nx">s</span><span class="p">.</span><span class="nx">Handler</span><span class="p">.</span><span class="nx">ServeHTTP</span><span class="p">(</span><span class="nx">w</span><span class="p">,</span> <span class="nx">r</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
<p>We call this type <code>LoggerServer</code>. As you can see, it stores not only a <code>Handler</code>, but also <code>io</code>.Writer to write the output of the log. Our implementation of the <code>ServeHTTP</code> method prints the request URI, the host, the content length, and the used method <code>io.Writer</code>. Once printing is finished, it calls the <code>ServeHTTP</code> function of its inner <code>Handler</code> field.</p>
<p>We can decorate <code>MyServer</code> with this <code>LoggerMiddleware</code>:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">http</span><span class="p">.</span><span class="nx">Handle</span><span class="p">(</span><span class="s">&#34;/&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">LoggerServer</span><span class="p">{</span>
    <span class="nx">LogWriter</span><span class="p">:</span><span class="nx">os</span><span class="p">.</span><span class="nx">Stdout</span><span class="p">,</span>
    <span class="nx">Handler</span><span class="p">:</span><span class="o">&amp;</span><span class="nx">MyServer</span><span class="p">{},</span>
  <span class="p">})</span>

  <span class="nx">log</span><span class="p">.</span><span class="nx">Fatal</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">ListenAndServe</span><span class="p">(</span><span class="s">&#34;:8080&#34;</span><span class="p">,</span> <span class="kc">nil</span><span class="p">))</span>
<span class="p">}</span>
</code></pre>
<p>Now run the <code class="command" >curl</code> command:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>curl http://localhost:8080
</span><span class="out" >Hello Decorator!
</span></code></pre>
<p>Our <code class="command" >curl</code> command returns the same message, but if you look at the Terminal where you have run the Go application, you can see the logging:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go run server_decorator.go
</span><span class="out" >Request URI: /
Host: localhost:8080
Content Length: 0
Method: GET
</span></code></pre>
<p>We have decorated <code>MyServer</code> with logging capabilities without actually modifying it. Can we do the same with authentication? Of course! After logging the request, we will authenticate it by using <b>HTTP Basic Authentication</b> as follows:</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">BasicAuthMiddleware</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">Handler</span>  <span class="nx">http</span><span class="p">.</span><span class="nx">Handler</span>
  <span class="nx">User</span>     <span class="kt">string</span>
  <span class="nx">Password</span> <span class="kt">string</span>
<span class="p">}</span>
</code></pre>
<p>The <code>BasicAuthMiddleware</code> middleware stores three fields--a handler to decorate like in the previous middlewares, a user, and a password, which will be the only authorization to access the contents on the server. The implementation of the (decorating) method will proceed as follows:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">BasicAuthMiddleware</span><span class="p">)</span> <span class="nx">ServeHTTP</span><span class="p">(</span><span class="nx">w</span> <span class="nx">http</span><span class="p">.</span><span class="nx">ResponseWriter</span><span class="p">,</span> <span class="nx">r</span> <span class="o">*</span><span class="nx">http</span><span class="p">.</span><span class="nx">Request</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">user</span><span class="p">,</span> <span class="nx">pass</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">r</span><span class="p">.</span><span class="nx">BasicAuth</span><span class="p">()</span>

  <span class="k">if</span> <span class="nx">ok</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">user</span> <span class="o">==</span> <span class="nx">s</span><span class="p">.</span><span class="nx">User</span> <span class="o">&amp;&amp;</span> <span class="nx">pass</span> <span class="o">==</span> <span class="nx">s</span><span class="p">.</span><span class="nx">Password</span> <span class="p">{</span>
      <span class="nx">s</span><span class="p">.</span><span class="nx">Handler</span><span class="p">.</span><span class="nx">ServeHTTP</span><span class="p">(</span><span class="nx">w</span><span class="p">,</span> <span class="nx">r</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
      <span class="nx">fmt</span><span class="p">.</span><span class="nx">Fprintf</span><span class="p">(</span><span class="nx">w</span><span class="p">,</span> <span class="s">&#34;User or password incorrect\n&#34;</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">else</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Fprintln</span><span class="p">(</span><span class="nx">w</span><span class="p">,</span> <span class="s">&#34;Error trying to retrieve data from Basic auth&#34;</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>In the preceding implementation, we use the <code>BasicAuth</code> method from <code>http.Request</code> to automatically retrieve the user and password from the request, plus an <code>ok/ko</code> from the parsing action. Then we check whether the parsing is correct (returning a message to the requester if incorrect, and finishing the request). If no problems have been detected during parsing, we check whether the username and the password match with the ones stored in <code>BasicAuthMiddleware</code>. If the credentials are valid, we shall call the decorated type (our server), but if the credentials aren&#39;t valid, we receive the <code>User or password incorrect</code> message in return, and the request is finished.</p>
<p>Now, we need to provide the user with a way to choose among different types of servers. We will retrieve user input data in the main function. We&#39;ll have three options to choose from:</p>
<ul>
<li>
<p>Simple server</p>
</li>
<li>
<p>Server with logging</p>
</li>
<li>
<p>Server with logging and authentication</p>
</li>
</ul>
<p>We have to use the <code>Fscanf</code> function to retrieve input from the user:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&#34;Enter the type number of server you want to launch from the  following:&#34;</span><span class="p">)</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&#34;1.- Plain server&#34;</span><span class="p">)</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&#34;2.- Server with logging&#34;</span><span class="p">)</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&#34;3.- Server with logging and authentication&#34;</span><span class="p">)</span>

  <span class="kd">var</span> <span class="nx">selection</span> <span class="kt">int</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Fscanf</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Stdin</span><span class="p">,</span> <span class="s">&#34;%d&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">selection</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
<p>The <code>Fscanf</code> function needs an <code>io.Reader</code> implementor as the first argument (which is going to be the input in the console), and it takes the server selected by the user from it. We&#39;ll pass <code>os.Stdin</code> as the <code>io.Reader</code> interface to retrieve user input. Then, we&#39;ll write the type of data it is going to parse. The <code>%d</code> specifier refers to an integer number. Finally, we&#39;ll write memory direction to store the parsed input, in this case, the memory position of the <code>selection</code> variable.</p>
<p>Once the user selects an option, we can take the basic server and decorate it at runtime, switching over to the selected option:</p>
<pre class="code" ><code class="chroma" ><span class="k">switch</span> <span class="nx">selection</span> <span class="p">{</span>
<span class="k">case</span> <span class="mi">1</span><span class="p">:</span>
  <span class="nx">mySuperServer</span> <span class="p">=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">MyServer</span><span class="p">)</span>
<span class="k">case</span> <span class="mi">2</span><span class="p">:</span>
  <span class="nx">mySuperServer</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">LoggerMiddleware</span><span class="p">{</span>
    <span class="nx">Handler</span><span class="p">:</span>   <span class="nb">new</span><span class="p">(</span><span class="nx">MyServer</span><span class="p">),</span>
    <span class="nx">LogWriter</span><span class="p">:</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Stdout</span><span class="p">,</span>
  <span class="p">}</span>
<span class="k">case</span> <span class="mi">3</span><span class="p">:</span>
  <span class="kd">var</span> <span class="nx">user</span><span class="p">,</span> <span class="nx">password</span> <span class="kt">string</span>

  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&#34;Enter user and password separated by a space&#34;</span><span class="p">)</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Fscanf</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Stdin</span><span class="p">,</span> <span class="s">&#34;%s %s&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">user</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">password</span><span class="p">)</span>

  <span class="nx">mySuperServer</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">LoggerMiddleware</span><span class="p">{</span>
    <span class="nx">Handler</span><span class="p">:</span> <span class="o">&amp;</span><span class="nx">SimpleAuthMiddleware</span><span class="p">{</span>
      <span class="nx">Handler</span><span class="p">:</span>  <span class="nb">new</span><span class="p">(</span><span class="nx">MyServer</span><span class="p">),</span>
      <span class="nx">User</span><span class="p">:</span>     <span class="nx">user</span><span class="p">,</span>
      <span class="nx">Password</span><span class="p">:</span> <span class="nx">password</span><span class="p">,</span>
    <span class="p">},</span>
    <span class="nx">LogWriter</span><span class="p">:</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Stdout</span><span class="p">,</span>
  <span class="p">}</span>
<span class="k">default</span><span class="p">:</span>
  <span class="nx">mySuperServer</span> <span class="p">=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">MyServer</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
<p>The first option will be handled by the default <code>switch</code> option--a plain <code>MyServer</code>. In the case of the second option, we decorate a plain server with logging. The third Option is a bit more developed--we ask the user for a username and a password using <code>Fscanf</code> again. Note that you can scan more than one input, as we are doing to retrieve the user and the password. Then, we take the basic server, decorate it with authentication, and finally, with logging.</p>
<p>If you follow the indentation of the nested types of option three, the request passes through the logger, then the authentication middleware, and finally, the <code>MyServer</code> argument if everything is okay. The requests will follow the same route.</p>
<p>The end of the main function takes the decorated handler, and launches the server on the <code>8080</code> port:</p>
<pre class="code" ><code class="chroma" ><span class="nx">http</span><span class="p">.</span><span class="nx">Handle</span><span class="p">(</span><span class="s">&#34;/&#34;</span><span class="p">,</span> <span class="nx">mySuperServer</span><span class="p">)</span>
<span class="nx">log</span><span class="p">.</span><span class="nx">Fatal</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">ListenAndServe</span><span class="p">(</span><span class="s">&#34;:8080&#34;</span><span class="p">,</span> <span class="kc">nil</span><span class="p">))</span>
</code></pre>
<p>So, let&#39;s launch the server with the third option:</p>
<pre class="srci" ><code class="sh" ><span class="out" >&gt;go run server_decorator.go
Enter the server type number you want to launch from the
following:
1.- Plain server
2.- Server with logging
3.- Server with logging and authentication

Enter user and password separated by a space
mario castro
</span></code></pre>
<p>We will first test the plain server by choosing the first option. Run the server with the command <code class="command" >go run server_decorator.go</code>, and select the first option. Then, in a different Terminal, run the basic request with <code class="command" >curl</code>, as follows:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>curl http://localhost:8080
</span><span class="out" >Error trying to retrieve data from Basic auth
</span></code></pre>
<p>Uh, oh! It doesn&#39;t give us access. We haven&#39;t passed any user and password, so it tells us that we cannot continue. Let&#39;s try with some random user and password:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>curl -u no:correct http://localhost:8080
</span><span class="out" >User or password incorrect
</span></code></pre>
<p>No access! We can also check in the Terminal where we launched the server and where every request is being logged:</p>
<pre class="srci" ><code class="sh" ><span class="out" >Request URI: /
Host: localhost:8080
Content Length: 0
Method: GET
</span></code></pre>
<p>Finally, enter the correct username and password:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>curl -u packt:publishing http://localhost:8080
</span><span class="out" >Hello Decorator!
</span></code></pre>
<p>Here we are! Our request has also been logged, and the server has granted access to us. Now we can improve our server as much as we want by writing more middlewares to decorate the server&#39;s functionality.</p>
</div>
<h4 id="a-few-words-about-go&#39;s-structural-typing" >A few words about Go&#39;s structural typing</h4>
<div class="hBody-4" >
<p>Go has a feature that most people dislike at the beginning--structural typing. This is when your structure defines your type without explicitly writing it. For example, when you implement an interface, you don&#39;t have to write explicitly that you are actually implementing it, contrary to languages such as Java where you have to write the keyword <code>implements</code>. If your method follows the signature of the interface, you are actually implementing the interface. This can also lead to accidental implementations of interface, something that could provoke an impossible-to-track mistake, but that is very unlikely.</p>
<p>However, structural typing also allows you to define an interface after defining their implementers. Imagine a MyPrinter struct as follows:</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">MyPrinter</span> <span class="kd">struct</span><span class="p">{}</span>
<span class="kd">func</span><span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">MyPrinter</span><span class="p">)</span><span class="nx">Print</span><span class="p">(){</span>
  <span class="nb">println</span><span class="p">(</span><span class="s">&#34;Hello&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
<p>Imagine we have been working with the <code>MyPrinter</code> type for few months now, but it didn&#39;t implement any interface, so it can&#39;t be a possible candidate for a Decorator pattern, or maybe it can? What if we wrote an interface that matches its <code>Print</code> method after a few months? Consider the following code snippet:</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">Printer</span> <span class="kd">interface</span> <span class="p">{</span>
  <span class="nx">Print</span><span class="p">()</span>
<span class="p">}</span>
</code></pre>
<p>It actually implements the <code>Printer</code> interface, and we can use it to create a Decorator solution.</p>
<p>Structural typing allows a lot of flexibility when writing programs. If you don&#39;t know whether a type should be a part of an interface or not, you can leave it and add the interface later, when you are completely sure about it. This way, you can decorate types very easily and with little modification in your source code.</p>
</div>
<h4 id="summarizing-the-decorator-design-pattern---proxy-versus-decorator" >Summarizing the Decorator design pattern - Proxy versus Decorator</h4>
<div class="hBody-4" >
<p>You might be wondering, what&#39;s the difference between the Decorator pattern and the Proxy pattern? In the Decorator pattern, we decorate a type dynamically. This means that the decoration may or may not be there, or it may be composed of one or many types. If you remember, the Proxy pattern wraps a type in a similar fashion, but it does so at compile time and it&#39;s more like a way to access some type.</p>
<p>At the same time, a decorator might implement the entire interface that the type it decorates also implements <b>or not</b>. So you can have an interface with 10 methods and a decorator that just implements one of them and it will still be valid. A call on a method not implemented by the decorator will be passed to the decorated type. This is a very powerful feature but also very prone to undesired behaviors at runtime if you forget to implement any interface method.</p>
<p>In this aspect, you may think that the Proxy pattern is less flexible, and it is. But the Decorator pattern is weaker, as you could have errors at runtime, which you can avoid at compile time by using the Proxy pattern. Just keep in mind that the Decorator is commonly used when you want to add functionality to an object at runtime, like in our web server. It&#39;s a compromise between what you need and what you want to sacrifice to achieve it.</p>
</div>
<h3 id="facade-design-pattern" >Facade design pattern</h3>
<div class="hBody-3" >
<p>The next pattern we&#39;ll see in this chapter is the Facade pattern. When we discussed the Proxy pattern, you got to know that it was a way to wrap an type to hide some of its features of complexity from the user. Imagine that we group many proxies in a single point such as a file or a library. This could be a Facade pattern.</p>
</div>
<h4 id="description" >Description</h4>
<div class="hBody-4" >
<p>A facade, in architectural terms, is the front wall that hides the rooms and corridors of a building. It protects its inhabitants from cold and rain, and provides them privacy. It orders and divides the dwellings.</p>
<p>The Facade design pattern does the same, but in our code. It shields the code from unwanted access, orders some calls, and hides the complexity scope from the user.</p>
</div>
<h4 id="objectives" >Objectives</h4>
<div class="hBody-4" >
<p>You use Facade when you want to hide the complexity of some tasks, especially when most of them share utilities (such as authentication in an API). A library is a form of facade, where someone has to provide some methods for a developer to do certain things in a friendly way. This way, if a developer needs to use your library, he doesn&#39;t need to know all the inner tasks to retrieve the result he/she wants.</p>
<p>So, you use the Facade design pattern in the following scenarios:</p>
<ul>
<li>
<p>When you want to decrease the complexity of some parts of our code. You hide that complexity behind the facade by providing a more easy-to-use method.</p>
</li>
<li>
<p>When you want to group actions that are cross-related in a single place.</p>
</li>
<li>
<p>When you want to build a library so that others can use your products without worrying about how it all works.</p>
</li>
</ul>
</div>
<h4 id="example" >Example</h4>
<div class="hBody-4" >
<p>As an example, we are going to take the first steps toward writing our own library that accesses <code>OpenWeatherMaps</code> service. In case you are not familiar with <code>OpenWeatherMap</code> service, it is an HTTP service that provides you with live information about weather, as well as historical data on it. The <b>HTTP REST</b> API is very easy to use, and will be a good example on how to create a Facade pattern for hiding the complexity of the network connections behind the REST service.</p>
</div>
<h4 id="acceptance-criteria" >Acceptance criteria</h4>
<div class="hBody-4" >
<p>The <code>OpenWeatherMap</code> API gives lots of information, so we are going to focus on getting live weather data in one city in some geo-located place by using its latitude and longitude values. The following are the requirements and acceptance criteria for this design pattern:</p>
<ol class="num" >
<li>
<p>Provide a single type to access the data. All information retrieved from <code>OpenWeatherMap</code> service will pass through it.</p>
</li>
<li>
<p>Create a way to get the weather data for some city of some country.</p>
</li>
<li>
<p>Create a way to get the weather data for some latitude and longitude position.</p>
</li>
<li>
<p>Only second and thrird point must be visible outside of the package; everything else must be hidden (including all connection-related data).</p>
</li>
</ol>
</div>
<h4 id="unit-test" >Unit test</h4>
<div class="hBody-4" >
<p>To start with our API Facade, we will need an interface with the methods asked in <i>acceptance criteria 2</i> and <i>acceptance criteria 3</i>:</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">CurrentWeatherDataRetriever</span> <span class="kd">interface</span> <span class="p">{</span>
  <span class="nx">GetByCityAndCountryCode</span><span class="p">(</span><span class="nx">city</span><span class="p">,</span> <span class="nx">countryCode</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">Weather</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
  <span class="nx">GetByGeoCoordinates</span><span class="p">(</span><span class="nx">lat</span><span class="p">,</span> <span class="nx">lon</span> <span class="kt">float32</span><span class="p">)</span> <span class="p">(</span><span class="nx">Weather</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
<p>We will call <i>acceptance criteria 2</i> GetByCityAndCountryCode; we will also need a city name and a country code in the string format. A country code is a two-character code, which represents the <b>International Organization for Standardization</b> (<span class="acronym" >ISO</span>) name of world countries. It returns a <code>Weather</code> value, which we will define later, and an error if something goes wrong.</p>
<p><i>Acceptance criteria 3</i> will be called <code>GetByGeoCoordinates</code>, and will need latitude and longitude values in the <code>float32</code> format. It will also return a <code>Weather</code> value and an error. The <code>Weather</code> value is going to be defined according to the returned JSON that the <code>OpenWeatherMap</code> API works with. You can find the description of this JSON at the webpage <a href="http://openweathermap.org/current#current_JSON" >http://openweathermap.org/current#current_JSON</a>.</p>
<p>If you look at the JSON definition, it has the following type:</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">Weather</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">ID</span>   <span class="kt">int</span>    <span class="s">`json:&#34;id&#34;`</span>
  <span class="nx">Name</span> <span class="kt">string</span> <span class="s">`json:&#34;name&#34;`</span>
  <span class="nx">Cod</span>  <span class="kt">int</span>    <span class="s">`json:&#34;cod&#34;`</span>
  <span class="nx">Coord</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Lon</span> <span class="kt">float32</span> <span class="s">`json:&#34;lon&#34;`</span>
    <span class="nx">Lat</span> <span class="kt">float32</span> <span class="s">`json:&#34;lat&#34;`</span>
  <span class="p">}</span> <span class="s">`json:&#34;coord&#34;`</span>

  <span class="nx">Weather</span> <span class="p">[]</span><span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Id</span>          <span class="kt">int</span>    <span class="s">`json:&#34;id&#34;`</span>
    <span class="nx">Main</span>        <span class="kt">string</span> <span class="s">`json:&#34;main&#34;`</span>
    <span class="nx">Description</span> <span class="kt">string</span> <span class="s">`json:&#34;description&#34;`</span>
    <span class="nx">Icon</span>        <span class="kt">string</span> <span class="s">`json:&#34;icon&#34;`</span>
  <span class="p">}</span> <span class="s">`json:&#34;weather&#34;`</span>
  <span class="nx">Base</span> <span class="kt">string</span> <span class="s">`json:&#34;base&#34;`</span>
  <span class="nx">Main</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Temp</span>     <span class="kt">float32</span> <span class="s">`json:&#34;temp&#34;`</span>
    <span class="nx">Pressure</span> <span class="kt">float32</span> <span class="s">`json:&#34;pressure&#34;`</span>
    <span class="nx">Humidity</span> <span class="kt">float32</span> <span class="s">`json:&#34;humidity&#34;`</span>
    <span class="nx">TempMin</span>  <span class="kt">float32</span> <span class="s">`json:&#34;temp_min&#34;`</span>
    <span class="nx">TempMax</span>  <span class="kt">float32</span> <span class="s">`json:&#34;temp_max&#34;`</span>
  <span class="p">}</span> <span class="s">`json:&#34;main&#34;`</span>
  <span class="nx">Wind</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Speed</span> <span class="kt">float32</span> <span class="s">`json:&#34;speed&#34;`</span>
    <span class="nx">Deg</span>   <span class="kt">float32</span> <span class="s">`json:&#34;deg&#34;`</span>
  <span class="p">}</span> <span class="s">`json:&#34;wind&#34;`</span>
  <span class="nx">Clouds</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">All</span> <span class="kt">int</span> <span class="s">`json:&#34;all&#34;`</span>
  <span class="p">}</span> <span class="s">`json:&#34;clouds&#34;`</span>

  <span class="nx">Rain</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">ThreeHours</span> <span class="kt">float32</span> <span class="s">`json:&#34;3h&#34;`</span>
  <span class="p">}</span> <span class="s">`json:&#34;rain&#34;`</span>

  <span class="nx">Dt</span>  <span class="kt">uint32</span> <span class="s">`json:&#34;dt&#34;`</span>
  <span class="nx">Sys</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Type</span>    <span class="kt">int</span>     <span class="s">`json:&#34;type&#34;`</span>
    <span class="nx">ID</span>      <span class="kt">int</span>     <span class="s">`json:&#34;id&#34;`</span>
    <span class="nx">Message</span> <span class="kt">float32</span> <span class="s">`json:&#34;message&#34;`</span>
    <span class="nx">Country</span> <span class="kt">string</span>  <span class="s">`json:&#34;country&#34;`</span>
    <span class="nx">Sunrise</span> <span class="kt">int</span>     <span class="s">`json:&#34;sunrise&#34;`</span>
    <span class="nx">Sunset</span>  <span class="kt">int</span>     <span class="s">`json:&#34;sunset&#34;`</span>
  <span class="p">}</span><span class="s">`json:&#34;sys&#34;`</span>
<span class="p">}</span>
</code></pre>
<p>It&#39;s quite a long struct, but we have everything that a response could include. The struct is called <code>Weather</code>, as it is composed of an ID, a name and a Code (Cod), and a few anonymous structs, which are: Coord, <code>Weather</code>, <code>Base</code>, <code>Main</code>, <code>Wind</code>, <code>Clouds</code>, <code>Rain</code>, <code>Dt</code>, and <code>Sys</code>. We could write these anonymous structs outside of the <code>Weather</code> struct by giving them a name, but it would only be useful if we have to work with them separately.</p>
<p>After every member and struct within our <code>Weather</code> struct, you can find a <code>`json:&#34;something&#34;`</code> line. This comes in handy when differentiating between the JSON key name and your member name. If the JSON key is <code>something</code>, we aren&#39;t forced to call our member <code>something</code>. For example, our ID member will be called <code>id</code> in the JSON response.</p>
<p>Why don&#39;t we give the name of the JSON keys to our types? Well, if your fields in your type are lowercase, the <code>encoding/json</code> package won&#39;t parse them correctly. Also, that last annotation provides us a certain flexibility, not only in terms of changing the members&#39; names, but also of omitting some key if we don&#39;t need it, with the following signature:</p>
<pre class="code" ><code class="chroma" ><span class="err">`</span><span class="nx">json</span><span class="p">:</span><span class="s">&#34;something,omitempty&#34;</span>
</code></pre>
<p>With <code>omitempty</code> at the end, the parse won&#39;t fail if this key is not present in the bytes representation of the JSON key.</p>
<p>Okay, our acceptance criteria 1 ask for a single point of access to the API. This is going to be called <code>CurrentWeatherData</code>:</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">CurrentWeatherData</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">APIkey</span> <span class="kt">string</span>
<span class="p">}</span>
</code></pre>
<p>The <code>CurrentWeatherData</code> type has an API key as public member to work. This is because you have to be a registered user in <code>OpenWeatherMap</code> to enjoy their services. Refer to the <code>OpenWeatherMap</code> API&#39;s webpage for documentation on how to get an API key. We won&#39;t need it in our example, because we aren&#39;t going to do integration tests.</p>
<p>We need mock data so that we can write a <code>mock</code> function to retrieve the data. When sending an HTTP request, the response is contained in a member called body in the form of an <code>io.Reader</code>. We have already worked with types that implement the <code>io.Reader</code> interface, so this should look familiar to you. Our <code>mock</code> function appears like this:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">getMockData</span><span class="p">()</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Reader</span> <span class="p">{</span>
  <span class="nx">response</span> <span class="o">:=</span> <span class="s">`{
</span><span class="s">      &#34;coord&#34;:{&#34;lon&#34;:-3.7,&#34;lat&#34;:40.42},&#34;weather :
</span><span class="s">  [{&#34;id&#34;:803,&#34;main&#34;:&#34;Clouds&#34;,&#34;description&#34;:&#34;broken clouds&#34;,&#34;icon&#34;:&#34;04n&#34;}],&#34;base&#34;:&#34;stations&#34;,&#34;main&#34;:
</span><span class="s">  {&#34;temp&#34;:303.56,&#34;pressure&#34;:1016.46,&#34;humidity&#34;:26.8,&#34;temp_min&#34;:300.95,&#34;temp_max&#34;:305.93},&#34;wind&#34;:
</span><span class="s">  {&#34;speed&#34;:3.17,&#34;deg&#34;:151.001},&#34;rain&#34;:{&#34;3h&#34;:0.0075},&#34;clouds&#34;:
</span><span class="s">  {&#34;all&#34;:68},&#34;dt&#34;:1471295823,&#34;sys&#34;:
</span><span class="s">  {&#34;type&#34;:3,&#34;id&#34;:1442829648,&#34;message&#34;:0.0278,&#34;country&#34;:&#34;ES&#34;,&#34;sunrise&#34;:1471238808,&#34;sunset&#34;:1471288232},&#34;id&#34;:3117735,&#34;name&#34;:&#34;Madrid&#34;,&#34;cod&#34;:200}`</span>

  <span class="nx">r</span> <span class="o">:=</span> <span class="nx">bytes</span><span class="p">.</span><span class="nx">NewReader</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="nx">response</span><span class="p">))</span>
  <span class="k">return</span> <span class="nx">r</span>
<span class="p">}</span>
</code></pre>
<p>This preceding mocked data was produced by making a request to <code>OpenWeatherMap</code> using an API key. The <code>response</code> variable is a string containing a JSON response. Take a close look at the grave accent (`) used to open and close the string. This way, you can use as many quotes as you want without any problem.</p>
<p>Further on, we use a special function in the bytes package called <code>NewReader</code>, which accepts an slice of bytes (which we create by converting the type from string), and returns an <code>io.Reader</code> implementor with the contents of the slice. This is perfect to mimic the <code>Body</code> member of an HTTP response.</p>
<p>We will write a test to try <code>response parser</code>. Both methods return the same type, so we can use the same <code>JSON parser</code> for both:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">TestOpenWeatherMap_responseParser</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">r</span> <span class="o">:=</span> <span class="nx">getMockData</span><span class="p">()</span>
  <span class="nx">openWeatherMap</span> <span class="o">:=</span> <span class="nx">CurrentWeatherData</span><span class="p">{</span><span class="nx">APIkey</span><span class="p">:</span> <span class="s">&#34;&#34;</span><span class="p">}</span>

  <span class="nx">weather</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">openWeatherMap</span><span class="p">.</span><span class="nx">responseParser</span><span class="p">(</span><span class="nx">r</span><span class="p">)</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">t</span><span class="p">.</span><span class="nx">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="k">if</span> <span class="nx">weather</span><span class="p">.</span><span class="nx">ID</span> <span class="o">!=</span> <span class="mi">3117735</span> <span class="p">{</span>
    <span class="nx">t</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&#34;Madrid id is 3117735, not %d\n&#34;</span><span class="p">,</span> <span class="nx">weather</span><span class="p">.</span><span class="nx">ID</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>In the preceding test, we first asked for some mock data, which we store in the variable <code>r</code>. Later, we created a type of <code>CurrentWeatherData</code>, which we called <code>openWeatherMap</code>. Finally, we asked for a weather value for the provided <code>io.Reader</code> interface that we store in the variable <code>weather</code>. After checking for errors, we make sure that the ID is the same as the one stored in the mock data that we got from the <code>getMockData</code> method.</p>
<p>We have to declare the <code>responseParser</code> method before running tests, or the code won&#39;t compile:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">CurrentWeatherData</span><span class="p">)</span> <span class="nx">responseParser</span><span class="p">(</span><span class="nx">body</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Reader</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">Weather</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&#34;Not implemented yet&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
<p>With all the aforementioned, we can run this test:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go <span class="nb">test</span> -v -run<span class="o">=</span>responseParser .
</span><span class="out" >=== RUN   TestOpenWeatherMap_responseParser
--- FAIL: TestOpenWeatherMap_responseParser (0.00s)
        facade_test.go:72: Not implemented yet
FAIL
exit status 1
FAIL
</span></code></pre>
<p>Okay. We won&#39;t write more tests, because the rest would be merely integration tests, which are outside of the scope of explanation of a structural pattern, and will force us to have an API key as well as an Internet connection. If you want to see what the integration tests look like for this example, refer to the code that comes bundled with the book.</p>
</div>
<h4 id="implementation" >Implementation</h4>
<div class="hBody-4" >
<p>First of all, we are going to implement the parser that our methods will use to parse the JSON response from the <code>OpenWeatherMap</code> REST API:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">CurrentWeatherData</span><span class="p">)</span> <span class="nx">responseParser</span><span class="p">(</span><span class="nx">body</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Reader</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">Weather</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">w</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">Weather</span><span class="p">)</span>
  <span class="nx">err</span> <span class="o">:=</span> <span class="nx">json</span><span class="p">.</span><span class="nx">NewDecoder</span><span class="p">(</span><span class="nx">body</span><span class="p">).</span><span class="nx">Decode</span><span class="p">(</span><span class="nx">w</span><span class="p">)</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="nx">w</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre>
<p>And this should be enough to pass the test by now:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go <span class="nb">test</span> -v -run<span class="o">=</span>responseParser .
</span><span class="out" >=== RUN   TestOpenWeatherMap_responseParser
--- PASS: TestOpenWeatherMap_responseParser (0.00s)
PASS
ok
</span></code></pre>
<p>At least we have our parser well tested. Let&#39;s structure our code to look like a library. First, we will create the methods to retrieve the weather of a city by its name and its country code, and the method that uses its latitude and longitude:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">CurrentWeatherData</span><span class="p">)</span> <span class="nx">GetByGeoCoordinates</span><span class="p">(</span><span class="nx">lat</span><span class="p">,</span> <span class="nx">lon</span>
  <span class="kt">float32</span><span class="p">)</span> <span class="p">(</span><span class="nx">weather</span> <span class="o">*</span><span class="nx">Weather</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">c</span><span class="p">.</span><span class="nx">doRequest</span><span class="p">(</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintf</span><span class="p">(</span><span class="s">&#34;http://api.openweathermap.org/data/2.5/weather q=%s,%s&amp;APPID=%s&#34;</span><span class="p">,</span>
      <span class="nx">lat</span><span class="p">,</span> <span class="nx">lon</span><span class="p">,</span> <span class="nx">c</span><span class="p">.</span><span class="nx">APIkey</span><span class="p">))</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">CurrentWeatherData</span><span class="p">)</span> <span class="nx">GetByCityAndCountryCode</span><span class="p">(</span><span class="nx">city</span><span class="p">,</span>
  <span class="nx">countryCode</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">weather</span> <span class="o">*</span><span class="nx">Weather</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">c</span><span class="p">.</span><span class="nx">doRequest</span><span class="p">(</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintf</span><span class="p">(</span><span class="s">&#34;http://api.openweathermap.org/data/2.5/weather? lat=%f&amp;lon=%f&amp;APPID=%s&#34;</span><span class="p">,</span>
      <span class="nx">city</span><span class="p">,</span> <span class="nx">countryCode</span><span class="p">,</span> <span class="nx">c</span><span class="p">.</span><span class="nx">APIkey</span><span class="p">)</span> <span class="p">)</span>
<span class="p">}</span>
</code></pre>
<p>A piece of cake? Of course! Everything must be as easy as possible, and it is a sign of a good job. The complexity in this facade is to create connections to the <code>OpenWeatherMap</code> API, and control the possible errors. This problem is shared between all the Facade methods in our example, so we don&#39;t need to write more than one API call right now.</p>
<p>What we do is pass the URL that the REST API needs in order to return the information we desire. This is achieved by the <code>fmt.Sprintf</code> function, which formats the strings in each case. For example, to gather the data using a city name and a country code, we use the following string:</p>
<pre class="code" ><code class="chroma" >  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintf</span><span class="p">(</span><span class="s">&#34;http://api.openweathermap.org/data/2.5/weather?lat=%f&amp;lon=%f&amp;APPID=%s&#34;</span><span class="p">,</span> <span class="nx">city</span><span class="p">,</span> <span class="nx">countryCode</span><span class="p">,</span> <span class="nx">c</span><span class="p">.</span><span class="nx">APIkey</span><span class="p">)</span>
</code></pre>
<p>This takes the pre-formatted string <a href="https://openweathermap.org/api" >https://openweathermap.org/api</a> and formats it by replacing each <code>%s</code> specifier with the city, the <code>countryCode</code> that we introduced in the arguments, and the API key member of the <code>CurrentWeatherData</code> type.</p>
<p>But, we haven&#39;t set any API key! Yes, because this is a library, and the users of the library will have to use their own API keys. We are hiding the complexity of creating the URIs, and handling the errors.</p>
<p>Finally, the <code>doRequest</code> function is a big fish, so we will see it in detail, step by step:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="p">(</span><span class="nx">o</span> <span class="o">*</span><span class="nx">CurrentWeatherData</span><span class="p">)</span> <span class="nx">doRequest</span><span class="p">(</span><span class="nx">uri</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">weather</span> <span class="o">*</span><span class="nx">Weather</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">client</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">http</span><span class="p">.</span><span class="nx">Client</span><span class="p">{}</span>
  <span class="nx">req</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">http</span><span class="p">.</span><span class="nx">NewRequest</span><span class="p">(</span><span class="s">&#34;GET&#34;</span><span class="p">,</span> <span class="nx">uri</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="k">return</span>
  <span class="p">}</span>
  <span class="nx">req</span><span class="p">.</span><span class="nx">Header</span><span class="p">.</span><span class="nx">Set</span><span class="p">(</span><span class="s">&#34;Content-Type&#34;</span><span class="p">,</span> <span class="s">&#34;application/json&#34;</span><span class="p">)</span>
</code></pre>
<p>First, the signature tells us that the <code>doRequest</code> method accepts a URI string, and returns a pointer to the <code>Weather</code> variable and an error. We start by creating an <code>http.Client</code> class, which will make the requests. Then, we create a request object, which will use the <code>GET</code> method, as described in the <code>OpenWeatherMap</code> webpage, and the URI we passed. If we were to use a different method, or more than one, they would have to be brought about by arguments in the signature. Nevertheless, we will use just the <code>GET</code> method, so we could hardcode it there.</p>
<p>Then, we check whether the request object has been created successfully, and set a header that says that the content type is a JSON:</p>
<pre class="code" ><code class="chroma" ><span class="nx">resp</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">client</span><span class="p">.</span><span class="nx">Do</span><span class="p">(</span><span class="nx">req</span><span class="p">)</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
  <span class="k">return</span>
<span class="p">}</span>

<span class="k">if</span> <span class="nx">resp</span><span class="p">.</span><span class="nx">StatusCode</span> <span class="o">!=</span> <span class="mi">200</span> <span class="p">{</span>
  <span class="nx">byt</span><span class="p">,</span> <span class="nx">errMsg</span> <span class="o">:=</span> <span class="nx">ioutil</span><span class="p">.</span><span class="nx">ReadAll</span><span class="p">(</span><span class="nx">resp</span><span class="p">.</span><span class="nx">Body</span><span class="p">)</span>
  <span class="k">if</span> <span class="nx">errMsg</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">errMsg</span> <span class="p">=</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&#34;%s&#34;</span><span class="p">,</span> <span class="nb">string</span><span class="p">(</span><span class="nx">byt</span><span class="p">))</span>
  <span class="p">}</span>
  <span class="nx">err</span> <span class="p">=</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&#34;Status code was %d, aborting. Error message was:\n%s\n&#34;</span><span class="p">,</span>
    <span class="nx">resp</span><span class="p">.</span><span class="nx">StatusCode</span><span class="p">,</span> <span class="nx">errMsg</span><span class="p">)</span>

  <span class="k">return</span>
<span class="p">}</span>
</code></pre>
<p>Then we make the request, and check for errors. Because we have given names to our return types, if any error occurs, we just have to return the function, and Go will return the variable <code>err</code> and the variable <code>weather</code> in the state they were in at that precise moment.</p>
<p>We check the status code of the response, as we only accept 200 as a good response. If 200 isn&#39;t returned, we will create an error message with the contents of the body and the status code returned:</p>
<pre class="code" ><code class="chroma" >  <span class="nx">weather</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">o</span><span class="p">.</span><span class="nx">responseParser</span><span class="p">(</span><span class="nx">resp</span><span class="p">.</span><span class="nx">Body</span><span class="p">)</span>
  <span class="nx">resp</span><span class="p">.</span><span class="nx">Body</span><span class="p">.</span><span class="nx">Close</span><span class="p">()</span>

  <span class="k">return</span>
<span class="p">}</span>
</code></pre>
<p>Finally, if everything goes well, we use the <code>responseParser</code> function we wrote earlier to parse the contents of Body, which is an <code>io.Reader</code> interface. Maybe you are wondering why we aren&#39;t controlling <code>err</code> from the <code>response parser</code> method. It&#39;s funny, because we are actually controlling it. <code>responseParser</code> and <code>doRequest</code> have the same return signature. Both return a <code>Weather</code> pointer and an error (if any), so we can return directly whatever the result was.</p>
</div>
<h4 id="library-created-with-the-facade-pattern" >Library created with the Facade pattern</h4>
<div class="hBody-4" >
<p>We have the first milestone for a library for the <code>OpenWeatherMap</code> API using the facade pattern. We have hidden the complexity of accessing the <code>OpenWeatherMap</code> REST API in the <code>doRequest</code> and <code>responseParser</code> functions, and the users of our library have an easy-to-use syntax to query the API. For example, to retrieve the weather for Madrid, Spain, a user will only have to introduce arguments and an API key at the beginning:</p>
<pre class="code" ><code class="chroma" ><span class="nx">weatherMap</span> <span class="o">:=</span> <span class="nx">CurrentWeatherData</span><span class="p">{</span><span class="o">*</span><span class="nx">apiKey</span><span class="p">}</span>

<span class="nx">weather</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">weatherMap</span><span class="p">.</span><span class="nx">GetByCityAndCountryCode</span><span class="p">(</span><span class="s">&#34;Madrid&#34;</span><span class="p">,</span> <span class="s">&#34;ES&#34;</span><span class="p">)</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
  <span class="nx">t</span><span class="p">.</span><span class="nx">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
<span class="p">}</span>

<span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&#34;Temperature in Madrid is %f celsius\n&#34;</span><span class="p">,</span> <span class="nx">weather</span><span class="p">.</span><span class="nx">Main</span><span class="p">.</span><span class="nx">Temp</span><span class="o">-</span><span class="mf">273.15</span><span class="p">)</span>
</code></pre>
<p>The console output for the weather in Madrid at the moment of writing this chapter is the following:</p>
<pre class="srci" ><code class="sh" ><span class="out" >Temperature in Madrid is 30.600006 celsius
</span></code></pre>
<p>A typical summer day!</p>
</div>
<h3 id="flyweight-design-pattern" >Flyweight design pattern</h3>
<div class="hBody-3" >
<p>Our next pattern is the <b>Flyweight</b> design pattern. It&#39;s very commonly used in computer graphics and the video game industry, but not so much in enterprise applications.</p>
</div>
<h4 id="description" >Description</h4>
<div class="hBody-4" >
<p>Flyweight is a pattern which allows sharing the state of a heavy object between many instances of some type. Imagine that you have to create and store too many objects of some heavy type that are fundamentally equal. You&#39;ll run out of memory pretty quickly. This problem can be easily solved with the Flyweight pattern, with additional help of the Factory pattern. The factory is usually in charge of encapsulating object creation, as we saw previously.</p>
</div>
<h4 id="objectives" >Objectives</h4>
<div class="hBody-4" >
<p>Thanks to the Flyweight pattern, we can share all possible states of objects in a single common object, and thus minimize object creation by using pointers to already created objects.</p>
</div>
<h4 id="example" >Example</h4>
<div class="hBody-4" >
<p>To give an example, we are going to simulate something that you find on betting webpages. Imagine the final match of the European championship, which is viewed by millions of people across the continent. Now imagine that we own a betting webpage, where we provide historical information about every team in Europe. This is plenty of information, which is usually stored in some distributed database, and each team has, literally, megabytes of information about their players, matches, championships, and so on.</p>
<p>If a million users access information about a team and a new instance of the information is created for each user querying for historical data, we will run out of memory in the blink of an eye. With our Proxy solution, we could make a cache of the <i>n</i> most recent searches to speed up queries, but if we return a clone for every team, we will still get short on memory (but faster thanks to our cache). Funny, right?</p>
<p>Instead, we will store each team&#39;s information just once, and we will deliver references to them to the users. So, if we face a million users trying to access information about a match, we will actually just have two teams in memory with a million pointers to the same memory direction.</p>
</div>
<h4 id="acceptance-criteria" >Acceptance criteria</h4>
<div class="hBody-4" >
<p>The acceptance criteria for a Flyweight pattern must always reduce the amount of memory that is used, and must be focused primarily on this objective:</p>
<ol class="num" >
<li>
<p>We will create a Team struct with some basic information such as the team&#39;s name, players, historical results, and an image depicting their shield.</p>
</li>
<li>
<p>We must ensure correct team creation (note the word <i>creation</i> here, candidate for a creational pattern), and not having duplicates.</p>
</li>
<li>
<p>When creating the same team twice, we must have two pointers pointing to the same memory address.</p>
</li>
</ol>
</div>
<h4 id="basic-structs-and-tests" >Basic structs and tests</h4>
<div class="hBody-4" >
<p>Our <code>Team</code> struct will contain other structs inside, so a total of four structs will be created. The <code>Team</code> struct has the following signature:</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">Team</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">ID</span>             <span class="kt">uint64</span>
  <span class="nx">Name</span>           <span class="kt">string</span>
  <span class="nx">Shield</span>         <span class="p">[]</span><span class="kt">byte</span>
  <span class="nx">Players</span>        <span class="p">[]</span><span class="nx">Player</span>
  <span class="nx">HistoricalData</span> <span class="p">[]</span><span class="nx">HistoricalData</span>
<span class="p">}</span>
</code></pre>
<p>Each team has an ID, a name, some image in an slice of bytes representing the team&#39;s shield, a slice of players, and a slice of historical data. This way, we will have two teams&#39; ID:</p>
<pre class="code" ><code class="chroma" ><span class="kd">const</span> <span class="p">(</span>
  <span class="nx">TEAM_A</span> <span class="p">=</span> <span class="kc">iota</span>
  <span class="nx">TEAM_B</span>
<span class="p">)</span>
</code></pre>
<p>We declare two constants by using the <code>const</code> and <code>iota</code> keywords. The <code>const</code> keyword simply declares that the following declarations are constants. <code>iota</code> is a untyped integer that automatically increments its value for each new constant between the parentheses. The <code>iota</code> value starts to reset to 0 when we declare <code>TEAM_A</code>, so <code>TEAM_A</code> is equal to 0. On the <code>TEAM_B</code> variable, <code>iota</code> is incremented by one so <code>TEAM_B</code> is equal to 1. The <code>iota</code> assignment is an elegant way to save typing when declaring constant values that doesn&#39;t need specific value (like the <i>Pi</i> constant on the <code>math</code> package).</p>
<p>Our <code>Player</code> and <code>HistoricalData</code> are the following:</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">Player</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">Name</span>    <span class="kt">string</span>
  <span class="nx">Surname</span> <span class="kt">string</span>
  <span class="nx">PreviousTeam</span> <span class="kt">uint64</span>
  <span class="nx">Photo</span>   <span class="p">[]</span><span class="kt">byte</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">HistoricalData</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">Year</span>          <span class="kt">uint8</span>
  <span class="nx">LeagueResults</span> <span class="p">[]</span><span class="nx">Match</span>
<span class="p">}</span>
</code></pre>
<p>As you can see, we also need a <code>Match</code> struct, which is stored within <code>HistoricalData</code> struct. A <code>Match</code> struct, in this context, represents the historical result of a match:</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">Match</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">Date</span>          <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span>
  <span class="nx">VisitorID</span>     <span class="kt">uint64</span>
  <span class="nx">LocalID</span>       <span class="kt">uint64</span>
  <span class="nx">LocalScore</span>    <span class="kt">byte</span>
  <span class="nx">VisitorScore</span>  <span class="kt">byte</span>
  <span class="nx">LocalShoots</span>   <span class="kt">uint16</span>
  <span class="nx">VisitorShoots</span> <span class="kt">uint16</span>
<span class="p">}</span>
</code></pre>
<p>This is enough to represent a team, and to fulfill <i>Acceptance Criteria 1</i>. You have probably guessed that there is a lot of information on each team, as some of the European teams have existed for more than 100 years.</p>
<p>For <i>Acceptance Criteria 2,</i> the word <i>creation</i> should give us some clue about how to approach this problem. We will build a factory to create and store our teams. Our Factory will consist of a map of years, including pointers to <code>Teams</code> as values, and a <code>GetTeam</code> function. Using a map will boost the team search if we know their names in advance. We will also dispose of a method to return the number of created objects, which will be called the <code>GetNumberOfObjects</code> method:</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">teamFlyweightFactory</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">createdTeams</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="o">*</span><span class="nx">Team</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">teamFlyweightFactory</span><span class="p">)</span> <span class="nx">GetTeam</span><span class="p">(</span><span class="nx">name</span> <span class="kt">string</span><span class="p">)</span> <span class="o">*</span><span class="nx">Team</span> <span class="p">{</span>
  <span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">teamFlyweightFactory</span><span class="p">)</span> <span class="nx">GetNumberOfObjects</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
  <span class="k">return</span> <span class="mi">0</span>
<span class="p">}</span>
</code></pre>
<p>This is enough to write our first unit test:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">TestTeamFlyweightFactory_GetTeam</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">factory</span> <span class="o">:=</span> <span class="nx">teamFlyweightFactory</span><span class="p">{}</span>

  <span class="nx">teamA1</span> <span class="o">:=</span> <span class="nx">factory</span><span class="p">.</span><span class="nx">GetTeam</span><span class="p">(</span><span class="nx">TEAM_A</span><span class="p">)</span>
  <span class="k">if</span> <span class="nx">teamA1</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">t</span><span class="p">.</span><span class="nx">Error</span><span class="p">(</span><span class="s">&#34;The pointer to the TEAM_A was nil&#34;</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="nx">teamA2</span> <span class="o">:=</span> <span class="nx">factory</span><span class="p">.</span><span class="nx">GetTeam</span><span class="p">(</span><span class="nx">TEAM_A</span><span class="p">)</span>
  <span class="k">if</span> <span class="nx">teamA2</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">t</span><span class="p">.</span><span class="nx">Error</span><span class="p">(</span><span class="s">&#34;The pointer to the TEAM_A was nil&#34;</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="k">if</span> <span class="nx">teamA1</span> <span class="o">!=</span> <span class="nx">teamA2</span> <span class="p">{</span>
    <span class="nx">t</span><span class="p">.</span><span class="nx">Error</span><span class="p">(</span><span class="s">&#34;TEAM_A pointers weren&#39;t the same&#34;</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="k">if</span> <span class="nx">factory</span><span class="p">.</span><span class="nx">GetNumberOfObjects</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">1</span> <span class="p">{</span>
    <span class="nx">t</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&#34;The number of objects created was not 1: %d\n&#34;</span><span class="p">,</span>
      <span class="nx">factory</span><span class="p">.</span><span class="nx">GetNumberOfObjects</span><span class="p">())</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>In our test, we verify all the acceptance criteria. First we create a factory, and then ask for a pointer of <code>TEAM_A</code>. This pointer cannot be <code>nil</code>, or the test will fail.</p>
<p>Then we call for a second pointer to the same team. This pointer can&#39;t be nil either, and it should point to the same memory address as the previous one so we know that it has not allocated a new memory.</p>
<p>Finally, we should check whether the number of created teams is only one, because we have asked for the same team twice. We have two pointers but just one instance of the team. Let&#39;s run the tests:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go <span class="nb">test</span> -v -run<span class="o">=</span>GetTeam .
</span><span class="out" >=== RUN   TestTeamFlyweightFactory_GetTeam
--- FAIL: TestTeamFlyweightFactory_GetTeam (0.00s)
flyweight_test.go:11: The pointer to the TEAM_A was nil
flyweight_test.go:21: The pointer to the TEAM_A was nil
flyweight_test.go:31: The number of objects created was not 1: 0
FAIL
exit status 1
FAIL
</span></code></pre>
<p>Well, it failed. Both pointers were nil and it has not created any object. Interestingly, the function that compares the two pointers doesn&#39;t fail; all in all, nil equals nil.</p>
</div>
<h4 id="implementation" >Implementation</h4>
<div class="hBody-4" >
<p>Our <code>GetTeam</code> method will need to scan the <code>map</code> field called <code>createdTeams</code> to make sure the queried team is already created, and return it if so. If the team wasn&#39;t created, it will have to create it and store it in the map before returning:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">teamFlyweightFactory</span><span class="p">)</span> <span class="nx">GetTeam</span><span class="p">(</span><span class="nx">teamID</span> <span class="kt">int</span><span class="p">)</span> <span class="o">*</span><span class="nx">Team</span> <span class="p">{</span>
  <span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nx">createdTeams</span><span class="p">[</span><span class="nx">teamID</span><span class="p">]</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">t</span><span class="p">.</span><span class="nx">createdTeams</span><span class="p">[</span><span class="nx">teamID</span><span class="p">]</span>
  <span class="p">}</span>

  <span class="nx">team</span> <span class="o">:=</span> <span class="nx">getTeamFactory</span><span class="p">(</span><span class="nx">teamID</span><span class="p">)</span>
  <span class="nx">t</span><span class="p">.</span><span class="nx">createdTeams</span><span class="p">[</span><span class="nx">teamID</span><span class="p">]</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">team</span>

  <span class="k">return</span> <span class="nx">t</span><span class="p">.</span><span class="nx">createdTeams</span><span class="p">[</span><span class="nx">teamID</span><span class="p">]</span>
<span class="p">}</span>
</code></pre>
<p>The preceding code is very simple. If the parameter name exists in the <code>createdTeams</code> map, return the pointer. Otherwise, call a factory for team creation. This is interesting enough to stop for a second and analyze. When you use the Flyweight pattern, it is very common to have a Flyweight factory, which uses other types of creational patterns to retrieve the objects it needs.</p>
<p>So, the <code>getTeamFactory</code> method will give us the team we are looking for, we will store it in the map, and return it. The team factory will be able to create the two teams: <code>TEAM_A</code> and <code>TEAM_B</code>:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">getTeamFactory</span><span class="p">(</span><span class="nx">team</span> <span class="kt">int</span><span class="p">)</span> <span class="nx">Team</span> <span class="p">{</span>
  <span class="k">switch</span> <span class="nx">team</span> <span class="p">{</span>
  <span class="k">case</span> <span class="nx">TEAM_B</span><span class="p">:</span>
    <span class="k">return</span> <span class="nx">Team</span><span class="p">{</span>
      <span class="nx">ID</span><span class="p">:</span>   <span class="mi">2</span><span class="p">,</span>
      <span class="nx">Name</span><span class="p">:</span> <span class="nx">TEAM_B</span><span class="p">,</span>
    <span class="p">}</span>
  <span class="k">default</span><span class="p">:</span>
    <span class="k">return</span> <span class="nx">Team</span><span class="p">{</span>
      <span class="nx">ID</span><span class="p">:</span>   <span class="mi">1</span><span class="p">,</span>
      <span class="nx">Name</span><span class="p">:</span> <span class="nx">TEAM_A</span><span class="p">,</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>We are simplifying the objects&#39; content so that we can focus on the Flyweight pattern&#39;s implementation. Okay, so we just have to define the function to retrieve the number of objects created, which is done as follows:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">teamFlyweightFactory</span><span class="p">)</span> <span class="nx">GetNumberOfObjects</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">createdTeams</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
<p>This was pretty easy. The <code>len</code> function returns the number of elements in an array or slice, the number of characters in a <code>string</code>, and so on. It seems that everything is done, and we can launch our tests again:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go <span class="nb">test</span> -v -run<span class="o">=</span>GetTeam .
</span><span class="out" >=== RUN   TestTeamFlyweightFactory_GetTeam
--- FAIL: TestTeamFlyweightFactory_GetTeam (0.00s)
panic: assignment to entry in nil map [recovered]
        panic: assignment to entry in nil map

goroutine 5 [running]:
panic(0x530900, 0xc0820025c0)
        /home/mcastro/Go/src/runtime/panic.go:481 +0x3f4
testing.tRunner.func1(0xc082068120)
        /home/mcastro/Go/src/testing/testing.go:467 +0x199
panic(0x530900, 0xc0820025c0)
        /home/mcastro/Go/src/runtime/panic.go:443 +0x4f7
/home/mcastro/go-design-patterns/structural/flyweight.
(*teamFlyweightFactory).GetTeam(0xc08202fec0, 0x0, 0x0)
        /home/mcastro/Desktop/go-design-patterns/structural/flyweight/flyweight.go:71 +0x159
/home/mcastro/go-design-patterns/structural/flyweight.TestTeamFlyweightFactory_GetTeam(0xc082068120)
        /home/mcastro/Desktop/go-design-patterns/structural/flyweight/flyweight_test.go:9 +0x61
testing.tRunner(0xc082068120, 0x666580)
        /home/mcastro/Go/src/testing/testing.go:473 +0x9f
created by testing.RunTests
        /home/mcastro/Go/src/testing/testing.go:582 +0x899
exit status 2
FAIL
</span></code></pre>
<p>Panic! Have we forgotten something? By reading the stack trace on the panic message, we can see some addresses, some files, and it seems that the <code>GetTeam</code> method is trying to assign an entry to a nil map on <i>line 71</i> of the <code>flyweight.go</code> file. Let&#39;s look at <i>line 71</i> closely (remember, if you are writing code while following this tutorial, that the error will probably be in a different line so look closely at your own stark trace):</p>
<pre class="code" ><code class="chroma" ><span class="nx">t</span><span class="p">.</span><span class="nx">createdTeams</span><span class="p">[</span><span class="nx">teamName</span><span class="p">]</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">team</span>
</code></pre>
<p>Okay, this line is on the <code>GetTeam</code> method, and, when the method passes through here, it means that it had not found the team on the map-it has created it (the variable team), and is trying to assign it to the map. But the map is nil, because we haven&#39;t initialized it when creating the factory. This has a quick solution. In our test, initialize the map where we have created the factory:</p>
<pre class="code" ><code class="chroma" ><span class="nx">factory</span> <span class="o">:=</span> <span class="nx">teamFlyweightFactory</span><span class="p">{</span>
  <span class="nx">createdTeams</span><span class="p">:</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="o">*</span><span class="nx">Team</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span>
<span class="p">}</span>
</code></pre>
<p>I&#39;m sure you have seen the problem here already. If we don&#39;t have access to the package, we can initialize the variable. Well, we can make the variable public, and that&#39;s all. But this would involve every implementer necessarily knowing that they have to initialize the map, and its signature is neither convenient, or elegant. Instead, we are going to create a simple factory builder to do it for us. This is a very common approach in Go:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">NewTeamFactory</span><span class="p">()</span> <span class="nx">teamFlyweightFactory</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">teamFlyweightFactory</span><span class="p">{</span>
    <span class="nx">createdTeams</span><span class="p">:</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="o">*</span><span class="nx">Team</span><span class="p">),</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>So now, in the test, we replace the factory creation with a call to this function:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">TestTeamFlyweightFactory_GetTeam</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">factory</span> <span class="o">:=</span> <span class="nx">NewTeamFactory</span><span class="p">()</span>
  <span class="o">...</span>
<span class="p">}</span>
</code></pre>
<p>And we run the test again:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go <span class="nb">test</span> -v -run<span class="o">=</span>GetTeam .
</span><span class="out" >=== RUN   TestTeamFlyweightFactory_GetTeam
--- PASS: TestTeamFlyweightFactory_GetTeam (0.00s)
PASS
ok
</span></code></pre>
<p>Perfect! Let&#39;s improve the test by adding a second test, just to ensure that everything will be running as expected with more volume. We are going to create a million calls to the team creation, representing a million calls from users. Then, we will simply check that the number of teams created is only two:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">Test_HighVolume</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">factory</span> <span class="o">:=</span> <span class="nx">NewTeamFactory</span><span class="p">()</span>

  <span class="nx">teams</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="o">*</span><span class="nx">Team</span><span class="p">,</span> <span class="mi">500000</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span>
  <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">500000</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
    <span class="nx">teams</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">factory</span><span class="p">.</span><span class="nx">GetTeam</span><span class="p">(</span><span class="nx">TEAM_A</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">500000</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">2</span><span class="o">*</span><span class="mi">500000</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
    <span class="nx">teams</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">factory</span><span class="p">.</span><span class="nx">GetTeam</span><span class="p">(</span><span class="nx">TEAM_B</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="k">if</span> <span class="nx">factory</span><span class="p">.</span><span class="nx">GetNumberOfObjects</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">2</span> <span class="p">{</span>
    <span class="nx">t</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&#34;The number of objects created was not 2: %d\n&#34;</span><span class="p">,</span>
      <span class="nx">factory</span><span class="p">.</span><span class="nx">GetNumberOfObjects</span><span class="p">())</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>In this test, we retrieve <code>TEAM_A</code> and <code>TEAM_B</code> 500,000 times each to reach a million users. Then, we make sure that just two objects were created:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go <span class="nb">test</span> -v -run<span class="o">=</span>Volume .
</span><span class="out" >=== RUN   Test_HighVolume
--- PASS: Test_HighVolume (0.04s)
PASS
ok
</span></code></pre>
<p>Perfect! We can even check where the pointers are pointing to, and where they are located. We will check with the first three as an example. Add these lines at the end of the last test, and run it again:</p>
<pre class="code" ><code class="chroma" ><span class="k">for</span> <span class="nx">i</span><span class="o">:=</span><span class="mi">0</span><span class="p">;</span> <span class="nx">i</span><span class="p">&lt;</span><span class="mi">3</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&#34;Pointer %d points to %p and is located in %p\n&#34;</span><span class="p">,</span>
    <span class="nx">i</span><span class="p">,</span> <span class="nx">teams</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="o">&amp;</span><span class="nx">teams</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span>
<span class="p">}</span>
</code></pre>
<p>In the preceding test, we use the <code>Printf</code> method to print information about pointers. The <code>%p</code> flag gives you the memory location of the object that the pointer is pointing to. If you reference the pointer by passing the &amp; symbol, it will give you the direction of the pointer itself.</p>
<p>Run the test again with the same command; you will see three new lines in the output with information similar to the following:</p>
<pre class="srci" ><code class="sh" ><span class="out" >Pointer 0 points to 0xc082846000 and is located in 0xc082076000
Pointer 1 points to 0xc082846000 and is located in 0xc082076008
Pointer 2 points to 0xc082846000 and is located in 0xc082076010
</span></code></pre>
<p>What it tells us is that the first three positions in the map point to the same location, but that we actually have three different pointers, which are, effectively, much lighter than our team object.</p>
</div>
<h4 id="what&#39;s-the-difference-between-singleton-and-flyweight-then?" >What&#39;s the difference between Singleton and Flyweight then?</h4>
<div class="hBody-4" >
<p>Well, the difference is subtle but it&#39;s just there. With the Singleton pattern, we ensure that the same type is created only once. Also, the Singleton pattern is a Creational pattern. With Flyweight, which is a Structural pattern, we aren&#39;t worried about how the objects are created, but about how to structure a type to contain heavy information in a light way. The structure we are talking about is the <code>map[int]*Team</code> structure in our example. Here, we really didn&#39;t care about how we created the object; we have simply written an uncomplicated the <code>getTeamFactory</code> method for it. We gave major importance to having a light structure to hold a shareable object (or objects), in this case, the map.</p>
</div>
<h3 id="summary" >Summary</h3>
<div class="hBody-3" >
<p>We have seen several patterns to organize code structures. Structural patterns are concerned about how to create objects, or how they do their business (we&#39;ll see this in the behavioral patterns).</p>
<p>Don&#39;t feel confused about mixing several patterns. You could end up mixing six or seven quite easily if you strictly follow the objectives of each one. Just keep in mind that over-engineering is as bad as no engineering at all. I remember prototyping a load balancer one evening, and after two hours of crazy over-engineered code, I had such a mess in my head that I preferred to start all over again.</p>
<p>In the next chapter, we&#39;ll see behavioral patterns. They are a bit more complex, and they often use Structural and Creational patterns for their objectives, but I&#39;m sure that the reader will find them quite challenging and interesting.</p>
</div>
<h2 id="chapter-5" >Behavioral Patterns - Strategy, Chain of Responsibility, and Command Design Patterns</h2>
<div class="hBody-2" >
<p>The last group of common patterns we are going to see are the behavioral patterns. Now, we aren&#39;t going to define structures or encapsulate object creation but we are going to deal with behaviors.</p>
<p>What&#39;s to deal with in behavior patterns? Well, now we will encapsulate behaviors, for example, algorithms in the Strategy pattern or executions in the command pattern.</p>
<p>Correct Behavior design is the last step after knowing how to deal with object creation and structures. Defining the behavior correctly is the last step of good software design because, all in all, good software design lets us improve algorithms and fix errors easily while the best algorithm implementation will not save us from bad software design.</p>
</div>
<h3 id="strategy-design-pattern" >Strategy design pattern</h3>
<div class="hBody-3" >
<p>The Strategy pattern is probably the easiest to understand of the Behavioral patterns. We have used it a few times while developing the previous patterns but without stopping to talk about it. Now we will.</p>
</div>
<h4 id="description" >Description</h4>
<div class="hBody-4" >
<p>The Strategy pattern uses different algorithms to achieve some specific functionality. These algorithms are hidden behind an interface and, of course, they must be interchangeable. All algorithms achieve the same functionality in a different way. For example, we could have a Sort interface and few sorting algorithms. The result is the same, some list is sorted, but we could have used quick sort, merge sort, and so on.</p>
<p>Can you guess when we used a Strategy pattern in the previous chapters? Three, two, one... Well, we heavily used the strategy pattern when we used the <code>io.Writer</code> interface. The <code>io.Writer</code> interface defines a strategy to write, and the functionality is always the same--to write something. We could write it to the standard out, to some file or to a user-defined type, but we do the same thing at the end--to write. We just change the strategy to write (in this case, we change the place where we write).</p>
</div>
<h4 id="objectives" >Objectives</h4>
<div class="hBody-4" >
<p>The objectives of the Strategy pattern are really clear. The pattern should do the following:</p>
<ul>
<li>
<p>Provide a few algorithms to achieve some specific functionality</p>
</li>
<li>
<p>All types achieve the same functionality in a different way but the client of the strategy isn&#39;t affected</p>
</li>
</ul>
<p>The problem is that this definition covers a huge spectrum of possibilities. This is because Strategy pattern is actually used for a variety of scenarios and many software engineering solutions come with some kind of strategy within. Therefore it&#39;s better to see it in action with a real example.</p>
</div>
<h4 id="rendering-images-or-text" >Rendering images or text</h4>
<div class="hBody-4" >
<p>We are going to do something different for this example. Instead of printing text on the console only, we are also going to paint objects on a file.</p>
<p>In this case, we will have two strategies: console and file. But the user of the library won&#39;t have to deal with the complexity behind them.</p>
<p>The key feature is that the &#34;caller&#34; doesn´t know how the underlying library is working and he just knows the information available on the defined strategy. This is nicely seen on the following diagram:</p>
<figure>
<img src="img/229_1.jpg" />
</figure>
<p>In this diagram, we have chosen to print to console but we won´t deal with the <code>ConsoleStrategy</code> type directly, we´ll always use an interface that represents it. The <code>ConsoleStrategy</code> type will hide the implementation details of printing to console to caller in <code>main</code> function. <code>FileStrategy</code> hides its implementation details as well as any future strategy.</p>
</div>
<h4 id="acceptance-criteria" >Acceptance criteria</h4>
<div class="hBody-4" >
<p>A strategy must have a very clear objective and we will have two ways to achieve it. Our objectives will be as follows:</p>
<ul>
<li>
<p>Provide a way to show to the user an object (a square) in text or image</p>
</li>
<li>
<p>The user must choose between image or text when launching the app</p>
</li>
<li>
<p>The app must be able to add more visualization strategies (audio, for example)</p>
</li>
<li>
<p>If the user selects text, the word <i>Square</i> must be printed in the console</p>
</li>
<li>
<p>If the user selects image, an image of a white square on a black background will be printed on a file</p>
</li>
</ul>
</div>
<h4 id="implementation" >Implementation</h4>
<div class="hBody-4" >
<p>We aren&#39;t going to write tests for this example as it will be quite complicated to check that an image has appeared on the screen (although not impossible by using <b>OpenCV</b>, an impressive library for computer vision). We will start directly by defining our strategy interface that each printing strategy must implement (in our case, the file and console types):</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">PrintStrategy</span> <span class="kd">interface</span> <span class="p">{</span>
  <span class="nx">Print</span><span class="p">()</span> <span class="kt">error</span>
<span class="p">}</span>
</code></pre>
<p>That&#39;s all. Our strategy defines a simple <code>Print()</code> method that returns an <code>error</code> (the error-returning type is mandatory when dealing with files, for example). The types that needs to implement <code>PrintStrategy</code> will be called <code>ConsoleSquare</code> and a <code>ImageSquare</code> type:</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">ConsoleSquare</span> <span class="kd">struct</span> <span class="p">{}</span>

<span class="kd">type</span> <span class="nx">ImageSquare</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">DestinationFilePath</span> <span class="kt">string</span>
<span class="p">}</span>
</code></pre>
<p>The <code>ConsoleSquare</code> struct doesn&#39;t need any inner field because it will always print the word <code>Square</code> to the console. The <code>ImageSquare</code> struct will store a field for the destination of the image file where we will print the square. We will start with the implementation of the <code>ConsoleSquare</code> type as it is the simplest:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">ConsoleSquare</span><span class="p">)</span> <span class="nx">Print</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span>
  <span class="nb">println</span><span class="p">(</span><span class="s">&#34;Square&#34;</span><span class="p">)</span>
  <span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre>
<p>Very easy, but the image is more complex. We won&#39;t spend too much time in explaining in detail how the <code>image</code> package works because the code is easily understandable:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">ImageSquare</span><span class="p">)</span> <span class="nx">Print</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span>
  <span class="nx">width</span> <span class="o">:=</span> <span class="mi">800</span>
  <span class="nx">height</span> <span class="o">:=</span> <span class="mi">600</span>

  <span class="nx">origin</span> <span class="o">:=</span> <span class="nx">image</span><span class="p">.</span><span class="nx">Point</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">}</span>

  <span class="nx">bgImage</span> <span class="o">:=</span> <span class="nx">image</span><span class="p">.</span><span class="nx">NewRGBA</span><span class="p">(</span><span class="nx">image</span><span class="p">.</span><span class="nx">Rectangle</span><span class="p">{</span>
    <span class="nx">Min</span><span class="p">:</span> <span class="nx">origin</span><span class="p">,</span>
    <span class="nx">Max</span><span class="p">:</span> <span class="nx">image</span><span class="p">.</span><span class="nx">Point</span><span class="p">{</span><span class="nx">X</span><span class="p">:</span> <span class="nx">width</span><span class="p">,</span> <span class="nx">Y</span><span class="p">:</span> <span class="nx">height</span><span class="p">},</span>
  <span class="p">})</span>

  <span class="nx">bgColor</span> <span class="o">:=</span> <span class="nx">image</span><span class="p">.</span><span class="nx">Uniform</span><span class="p">{</span><span class="nx">color</span><span class="p">.</span><span class="nx">RGBA</span><span class="p">{</span><span class="nx">R</span><span class="p">:</span> <span class="mi">70</span><span class="p">,</span> <span class="nx">G</span><span class="p">:</span> <span class="mi">70</span><span class="p">,</span> <span class="nx">B</span><span class="p">:</span> <span class="mi">70</span><span class="p">,</span> <span class="nx">A</span><span class="p">:</span><span class="mi">0</span><span class="p">}}</span>
  <span class="nx">quality</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">jpeg</span><span class="p">.</span><span class="nx">Options</span><span class="p">{</span><span class="nx">Quality</span><span class="p">:</span> <span class="mi">75</span><span class="p">}</span>

  <span class="nx">draw</span><span class="p">.</span><span class="nx">Print</span><span class="p">(</span><span class="nx">bgImage</span><span class="p">,</span> <span class="nx">bgImage</span><span class="p">.</span><span class="nx">Bounds</span><span class="p">(),</span> <span class="o">&amp;</span><span class="nx">bgColor</span><span class="p">,</span> <span class="nx">origin</span><span class="p">,</span> <span class="nx">draw</span><span class="p">.</span><span class="nx">Src</span><span class="p">)</span>
</code></pre>
<p>However, here is a short explanation:</p>
<ul>
<li>
<p>We define a size for the image (<code>width</code> and <code>height</code> variables) of 800 pixels of width and 600 pixels of height. Those are going to be the size limits of our image and anything that we write outside of that size won&#39;t be visible.</p>
</li>
<li>
<p>The <code>origin</code> variable stores an <code>image.Point</code>, a type to represent a position in any two-dimensional space. We set the position of this point at (<i>0, 0</i>), the upper-left corner of the image.</p>
</li>
<li>
<p>We need a bitmap that will represent our background, here we called it <code>bgImage</code>. We have a very handy function in the image package to create the <code>image.RGBA</code> types called <code>image.NewRGBA</code>. We need to pass a rectangle to this function so that it knows the bounds of the image. A rectangle is represented by two <code>image.Point</code> types--its upper left corner point (the <code>Min</code> field) and its lower right corner point (the Max field). We use <code>origin</code> as the upper-left and a new point with the values of <code>width</code> and <code>height</code> as the lower-right point.</p>
</li>
<li>
<p>The image will have a gray background color (<code>bgColor</code>). This is done by instancing a type of <code>image.Uniform</code>, which represents a uniform color (hence the name). The <code>image.Uniform</code> type needs an instance of a <code>color.Color</code> interface. A <code>color.Color</code> type is any type that implements the <code>RGBA()</code> (<code>r</code>, <code>g</code>, <code>b</code>, a <code>uint32</code>)  method to return a <code>uint32</code> value for red, green, blue, and alpha colors (RGBA). Alpha is a value for the transparency of a pixel. The <code>color</code> package conveniently provides a type called <code>color.RGBA</code> for this purpose (in case we don&#39;t need to implement our own, which is our case).</p>
</li>
<li>
<p>When storing an image in certain formats, we have to specify the quality of the image. It will affect not only the quality but the size of the file, of course. Here, it is defined as 75; 100 is the maximum quality possible that we can set. As you can see, we are using the <code>jpeg</code> package here to set the value of a type called <code>Options</code> that simply stores the value of the quality, it doesn&#39;t have more values to apply.</p>
</li>
<li>
<p>Finally, the <code>draw.Print</code> function writes the pixels on the supplied image (<code>bgImage</code>) with the characteristics that we have defined on the bounds defined by the same image. The first argument of the <code>draw.Print</code> method takes the destination image, where we used <code>bgImage</code>. The second argument is the bounds of the object to draw in the destination image, we used the same bounds of the image but we could use any other if we wanted a smaller rectangle. The third argument is the color to use to colorize the bounds.</p>
</li>
<li>
<p>The <code>Origin</code> variable is used to tell where the upper-left corner of the bound must be placed. In this case, the bounds are the same size as the image so we need to set it to the origin. The last argument specified is the operation type; just leave it in the <code>draw.Src</code> argument.</p>
</li>
</ul>
<p>Now we have to draw the square. The operation is essentially the same as to draw the background but, in this case, we are drawing a square over the previously drawn <code>bgImage</code>:</p>
<pre class="code" ><code class="chroma" ><span class="nx">squareWidth</span> <span class="o">:=</span> <span class="mi">200</span>
<span class="nx">squareHeight</span> <span class="o">:=</span> <span class="mi">200</span>
<span class="nx">squareColor</span> <span class="o">:=</span> <span class="nx">image</span><span class="p">.</span><span class="nx">Uniform</span><span class="p">{</span><span class="nx">color</span><span class="p">.</span><span class="nx">RGBA</span><span class="p">{</span><span class="nx">R</span><span class="p">:</span> <span class="mi">255</span><span class="p">,</span> <span class="nx">G</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">B</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">A</span><span class="p">:</span> <span class="mi">1</span><span class="p">}}</span>
<span class="nx">square</span> <span class="o">:=</span> <span class="nx">image</span><span class="p">.</span><span class="nx">Rect</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">squareWidth</span><span class="p">,</span> <span class="nx">squareHeight</span><span class="p">)</span>
<span class="nx">square</span> <span class="p">=</span> <span class="nx">square</span><span class="p">.</span><span class="nx">Add</span><span class="p">(</span><span class="nx">image</span><span class="p">.</span><span class="nx">Point</span><span class="p">{</span>
  <span class="nx">X</span><span class="p">:</span> <span class="p">(</span><span class="nx">width</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="nx">squareWidth</span> <span class="o">/</span> <span class="mi">2</span><span class="p">),</span>
  <span class="nx">Y</span><span class="p">:</span> <span class="p">(</span><span class="nx">height</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="nx">squareHeight</span> <span class="o">/</span> <span class="mi">2</span><span class="p">),</span>
<span class="p">})</span>
<span class="nx">squareImg</span> <span class="o">:=</span> <span class="nx">image</span><span class="p">.</span><span class="nx">NewRGBA</span><span class="p">(</span><span class="nx">square</span><span class="p">)</span>

<span class="nx">draw</span><span class="p">.</span><span class="nx">Print</span><span class="p">(</span><span class="nx">bgImage</span><span class="p">,</span> <span class="nx">squareImg</span><span class="p">.</span><span class="nx">Bounds</span><span class="p">(),</span> <span class="o">&amp;</span><span class="nx">squareColor</span><span class="p">,</span> <span class="nx">origin</span><span class="p">,</span> <span class="nx">draw</span><span class="p">.</span><span class="nx">Src</span><span class="p">)</span>
</code></pre>
<p>The square will be of 200*200 pixels of red color. When using the method <code>Add</code>, the <code>Rect</code> type origin is translated to the supplied point; this is to center the square on the image. We create an image with the square <code>Rect</code> and call the <code>Print</code> function on the <code>bgImage</code> image again to draw the red square over it:</p>
<pre class="code" ><code class="chroma" >  <span class="nx">w</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Create</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">DestinationFilePath</span><span class="p">)</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&#34;Error opening image&#34;</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="k">defer</span> <span class="nx">w</span><span class="p">.</span><span class="nx">Close</span><span class="p">()</span>

  <span class="k">if</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">jpeg</span><span class="p">.</span><span class="nx">Encode</span><span class="p">(</span><span class="nx">w</span><span class="p">,</span> <span class="nx">bgImage</span><span class="p">,</span> <span class="nx">quality</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&#34;Error writing image to disk&#34;</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre>
<p>Finally, we will create a file to store the contents of the image. The file will be stored in the path supplied in the <code>DestinationFilePath</code> field of the <code>ImageSquare</code> struct. To create a file, we use <code>os.Create</code> that returns the <code>*os.File</code>. As with every file, it must be closed after using it so don&#39;t forget to use the <code>defer</code> keyword to ensure that you close it when the method finishes.</p>
<div class="about" >
<div class="about-dt" >Tip</div>
<div class="about-dd" >
<p>To defer, or not to defer?</p>
<p>Some people ask why the use of <code>defer</code> at all? Wouldn&#39;t it be the same to simply write it without <code>defer</code> at the end of the function? Well, actually not. If any error occurs during the method execution and you return this error, the <code>Close</code> method won&#39;t be executed if it&#39;s at the end of the function. You can close the file before returning but you&#39;ll have to do it in every error check. With <code>defer</code>, you don&#39;t have to worry about this because the deferred function is executed always (with or without error). This way, we ensure that the file is closed.</p>
</div>
</div>
<p>To parse the arguments, we&#39;ll use the <code>flag</code> package. We have used it before but let&#39;s recall its usage. A flag is a command that the user can pass when executing our app. We can define a flag by using the <code>flag</code>. [type] methods defined in the <code>flag</code> package. We want to read the output that the user wants to use from the console. This flag will be called <code>output</code>. A flag can have a default value; in this case, it will have the value <code>console</code> that will be used when printing to console. So, if the user executes the program without arguments, it prints to console:</p>
<pre class="srci" ><code class="sh" ><span class="out" >var output = flag.String(&#34;output&#34;, &#34;console&#34;, &#34;The output to use between &#39;console&#39; and &#39;image&#39; file&#34;)
</span></code></pre>
<p>Our final step is to write the main function:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">main</span><span class="p">(){</span>
    <span class="nx">flag</span><span class="p">.</span><span class="nx">Parse</span><span class="p">()</span>
</code></pre>
<p>Remember that the first thing to do in the main when using flags is to parse them using the <code>flag.Parse()</code> method! It&#39;s very common to forget this step:</p>
<pre class="code" ><code class="chroma" ><span class="kd">var</span> <span class="nx">activeStrategy</span> <span class="nx">PrintStrategy</span>

<span class="k">switch</span> <span class="o">*</span><span class="nx">output</span> <span class="p">{</span>
<span class="k">case</span> <span class="s">&#34;console&#34;</span><span class="p">:</span>
  <span class="nx">activeStrategy</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">TextSquare</span><span class="p">{}</span>
<span class="k">case</span> <span class="s">&#34;image&#34;</span><span class="p">:</span>
  <span class="nx">activeStrategy</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">ImageSquare</span><span class="p">{</span><span class="s">&#34;/tmp/image.jpg&#34;</span><span class="p">}</span>
<span class="k">default</span><span class="p">:</span>
  <span class="nx">activeStrategy</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">TextSquare</span><span class="p">{}</span>
<span class="p">}</span>
</code></pre>
<p>We define a variable for the strategy that the user has chosen, called <code>activeStrategy</code>. But check that the <code>activeStrategy</code> variable has the <code>PrintStrategy</code> type so it can be populated with any implementation of the <code>PrintStrategy</code> variable. We will set <code>activeStrategy</code> to a new instance of <code>TextSquare</code> when the user writes the  <code>--output=console</code> command and an ImageSquare when we write the  <code>--output=image</code> command. Finally, here is the design pattern execution:</p>
<pre class="code" ><code class="chroma" >  <span class="nx">err</span> <span class="o">:=</span> <span class="nx">activeStrategy</span><span class="p">.</span><span class="nx">Print</span><span class="p">()</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">log</span><span class="p">.</span><span class="nx">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>Our <code>activeStrategy</code> variable is a type implementing <code>PrintStrategy</code> and either the <code>TextSquare</code> or <code>ImageSquare</code> classes. The user will choose at runtime which strategy he wants to use for each particular case. Also, we could have written a factory method pattern to create strategies, so that the strategy creation will also be uncoupled from the main function and abstracted in a different independent package. Think about it: if we have the strategy creation in a different package, it will also allow us to use this project as a library and not only as a standalone app.</p>
<p>Now we will execute both strategies; the <code>TextSquare</code> instance will give us a square by printing the word <code>Square</code> on the console:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go run main.go --output<span class="o">=</span>console
</span><span class="out" >Square
</span></code></pre>
<p>It has worked as expected. Recalling how flags work, we have to use the <code>--</code> (double dash) and the defined flag, <code>output</code> in our case. Then you have two options--using <code>=</code> (equals) and immediately writing the value for the flag or writing <code>&lt;space&gt;</code> and the value for the flag. In this case, we have defined the default value of output to the console so the following three executions are equivalent:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go run main.go --output<span class="o">=</span>console
</span><span class="out" >Square
</span><span class="in" ><span class="prompt" >&gt; </span>go run main.go --output console
</span><span class="out" >Square
</span><span class="in" ><span class="prompt" >&gt; </span>go run main.go
</span><span class="out" >Square
</span></code></pre>
<p>Now we have to try the file strategy. As defined before, the file strategy will print a red square to a file as an image with dark gray background:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go run main.go --output image
</span></code></pre>
<p>Nothing happened? But everything worked correctly. This is actually bad practice. Users must always have some sort of feedback when using your app or your library. Also, if they are using your code as a library, maybe they have a specific format for output so it won&#39;t be nice to directly print to the console. We will solve this issue later. Right now, open the folder <span class="file" >/tmp</span> with your favourite file explorer and you will see a file called <span class="file" >image.jpg</span> with our red square in a dark grey background.</p>
</div>
<h4 id="solving-small-issues-in-our-library" >Solving small issues in our library</h4>
<div class="hBody-4" >
<p>We have a few issues in our code:</p>
<ul>
<li>
<p>It cannot be used as a library. We have critical code written in the <code>main</code> package (strategy creation).</p>
<p><b>Solution</b>: Abstract to two different packages the strategy creation from the command-line application.</p>
</li>
<li>
<p>None of the strategies are doing any logging to file or console. We must provide a way to read some logs that an external user can integrate in their logging strategies or formats.</p>
<p><b>Solution</b>: Inject an <code>io.Writer</code> interface as dependency to act as a logging sink.</p>
</li>
<li>
<p>Our <code>TextSquare</code> class is always writing to the console (an implementer of the <code>io.Writer</code> interface) and the <code>ImageSquare</code> is always writing to file (another implementer of the <code>io.Writer</code> interface). This is too coupled.</p>
<p><b>Solution</b>: Inject an <code>io.Writer</code> interface so that the <code>TextSquare</code> and <code>ImageSquare</code> can write to any of the <code>io.Writer</code> implementations that are available (file and console, but also bytes buffer, binary encoders, <code>JSON</code> handlers... dozens of packages).</p>
</li>
</ul>
<p>So, to use it as a library and solve the first issue, we will follow a common approach in Go file structures for apps and libraries. First, we will place our main package and function outside of the root package; in this case, in a folder called <code>cli</code>. It is also common to call this folder cmd or even <code>app</code>. Then, we will place our <code>PrintStrategy</code> interface in the root package, which now will be called the <code>strategy</code> package. Finally, we will create a <code>shapes</code> package in a folder with the same name where we will put both text and image strategies. So, our file structure will be like this:</p>
<ul>
<li>
<p><b>Root package</b>: strategy</p>
<p><b>File</b>: <span class="file" >print_strategy.go</span></p>
</li>
<li>
<p><b>SubPackage</b>: shapes</p>
<p><b>Files</b>: <span class="file" >image.go</span>, <span class="file" >text.go</span>, <span class="file" >factory.go</span></p>
</li>
<li>
<p><b>SubPackage</b>: cli</p>
<p><b>File</b>: <span class="file" >main.go</span></p>
</li>
</ul>
<p>We are going to modify our interface a bit to fit the needs we have written previously:</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">PrintStrategy</span> <span class="kd">interface</span> <span class="p">{</span>
  <span class="nx">Print</span><span class="p">()</span> <span class="kt">error</span>
  <span class="nx">SetLog</span><span class="p">(</span><span class="nx">io</span><span class="p">.</span><span class="nx">Writer</span><span class="p">)</span>
  <span class="nx">SetWriter</span><span class="p">(</span><span class="nx">io</span><span class="p">.</span><span class="nx">Writer</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
<p>We have added the <code>SetLog(io.Writer)</code> method to add a logger strategy to our types; this is to provide feedback to users. Also, it has a <code>SetWriter</code> method to set the <code>io.Writer</code> strategy. This interface is going to be located on the root package in the <span class="file" >print_strategy.go</span> file. So the final schema looks like this:</p>
<figure>
<img src="img/237_1.jpg" />
</figure>
<p>Both the <code>TextSquare</code> and <code>ImageSquare</code> strategies have to satisfy the <code>SetLog</code> and <code>SetWriter</code> methods which simply store some object on their fields so, instead of implementing the same twice, we can create a struct that implements them and embed this struct in the strategies. By the way, this would be the composite pattern we have seen previously:</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">PrintOutput</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">Writer</span>    <span class="nx">io</span><span class="p">.</span><span class="nx">Writer</span>
  <span class="nx">LogWriter</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Writer</span>
<span class="p">}</span>

<span class="kd">func</span><span class="p">(</span><span class="nx">d</span> <span class="o">*</span><span class="nx">PrintOutput</span><span class="p">)</span> <span class="nx">SetLog</span><span class="p">(</span><span class="nx">w</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Writer</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">d</span><span class="p">.</span><span class="nx">LogWriter</span> <span class="p">=</span> <span class="nx">w</span>
<span class="p">}</span>

<span class="kd">func</span><span class="p">(</span><span class="nx">d</span> <span class="o">*</span><span class="nx">PrintOutput</span><span class="p">)</span> <span class="nx">SetWriter</span><span class="p">(</span><span class="nx">w</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Writer</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">d</span><span class="p">.</span><span class="nx">Writer</span> <span class="p">=</span> <span class="nx">w</span>
<span class="p">}</span>
</code></pre>
<p>So now each strategy must have the <code>PrintOutput</code> struct embedded if we want to modify their <code>Writer</code> and <code>logger</code> fields.</p>
<p>We also need to modify our strategy implementation.</p>
<p>The <code>TextSquare</code> struct now needs a field to store the output <code>io.Writer</code> (the place where it is going to write instead of writing always to the console) and the <code>log</code> writer. These two fields can be provided by embedding the <code>PrintOutput</code> struct. The <code>TextSquare</code> struct is also stored in the file <span class="file" >text.go</span> within the shapes package. So, the struct is now like this:</p>
<pre class="code" ><code class="chroma" ><span class="kn">package</span> <span class="nx">shapes</span>

<span class="kd">type</span> <span class="nx">TextSquare</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">strategy</span><span class="p">.</span><span class="nx">PrintOutput</span>
<span class="p">}</span>
</code></pre>
<p>So now the <code>Print()</code> method is slightly different because, instead of writing directly to the console by using the <code>println</code> function, we have to write whichever <code>io.Writer</code> is stored in the <code>Writer</code> field:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">TextSquare</span><span class="p">)</span> <span class="nx">Print</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span>
  <span class="nx">r</span> <span class="o">:=</span> <span class="nx">bytes</span><span class="p">.</span><span class="nx">NewReader</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="s">&#34;Circle&#34;</span><span class="p">))</span>
  <span class="nx">io</span><span class="p">.</span><span class="nx">Copy</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">Writer</span><span class="p">,</span> <span class="nx">r</span><span class="p">)</span>
  <span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre>
<p>The <code>bytes.NewReader</code> is a very useful function that takes an array of bytes and converts them to an <code>io.Reader</code> interface. We need an <code>io.Reader</code> interface to use the <code>io.Copy</code> function. The <code>io.Copy</code> function is also incredibly useful as it takes an <code>io.Reader</code> (as the second parameter) and pipes it to an <code>io.Writer</code> (its first parameter). So, we won&#39;t return an error in any case. However, it&#39;s easier to do so using directly the <code>Write</code> method of <code>t.Writer</code>:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">TextSquare</span><span class="p">)</span> <span class="nx">Print</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span>
  <span class="nx">t</span><span class="p">.</span><span class="nx">Writer</span><span class="p">.</span><span class="nx">Write</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="s">&#34;Circle&#34;</span><span class="p">))</span>
  <span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre>
<p>You can use whichever method you like more. Usually, you will use the Write method but it&#39;s nice to know the <code>bytes.NewReader</code> function too.</p>
<p>Did you realize that when we use <code>t.Writer</code>, we are actually accessing <code>PrintOutput.Writer</code>? The <code>TextSquare</code> type has a <code>Writer</code> field because the <code>PrintOutput</code> struct has it and it&#39;s embedded on the <code>TextSquare</code> struct.</p>
<div class="about" >
<div class="about-dt" >Tip</div>
<div class="about-dd" >
<p>Embedding is not inheritance. We have embedded the <code>PrintOutput</code> struct on the <code>TextSquare</code> struct. Now we can access <code>PrintOutput</code> fields as if they were in <code>TextSquare</code> fields. This feels a bit like inheritance but there is a very important difference here:</p>
<p><code>TextSquare</code> is not a <code>PrintOutput</code> value but it has a <code>PrintOutput</code> in its composition. What does it mean? That if you have a function that expects a <code>PrintOutput</code>, you cannot a pass <code>TextSquare</code> just because it has a <code>PrintOutput</code> embedded.</p>
<p>But, if you have a function that accepts an interface that <code>PrintOutput</code> implements, you can pass <code>TextSquare</code> if it has a <code>PrintOutput</code> embedded. This is what we are doing in our example.</p>
</div>
</div>
<p>The <code>ImageSquare</code> struct is now like the <code>TextSquare</code>, with a <code>PrintOutput</code> embedded:</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">ImageSquare</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">strategy</span><span class="p">.</span><span class="nx">PrintOutput</span>
<span class="p">}</span>
</code></pre>
<p>The <code>Print</code> method also needs to be modified. Now, we aren&#39;t creating a file from the <code>Print</code> method, as it was breaking the single responsibility principle. A file implements an <code>io.Writer</code> so we will open the file outside of the <code>ImageSquare</code> struct and inject it on the <code>Writer</code> field. So, we just need to modify the end of the <code>Print()</code> method where we wrote to the file:</p>
<pre class="code" ><code class="chroma" ><span class="nx">draw</span><span class="p">.</span><span class="nx">Print</span><span class="p">(</span><span class="nx">bgImage</span><span class="p">,</span> <span class="nx">squareImg</span><span class="p">.</span><span class="nx">Bounds</span><span class="p">(),</span> <span class="o">&amp;</span><span class="nx">squareColor</span><span class="p">,</span> <span class="nx">origin</span><span class="p">,</span> <span class="nx">draw</span><span class="p">.</span><span class="nx">Src</span><span class="p">)</span>

<span class="k">if</span> <span class="nx">i</span><span class="p">.</span><span class="nx">Writer</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&#34;No writer stored on ImageSquare&#34;</span><span class="p">)</span>
<span class="p">}</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">jpeg</span><span class="p">.</span><span class="nx">Encode</span><span class="p">(</span><span class="nx">i</span><span class="p">.</span><span class="nx">Writer</span><span class="p">,</span> <span class="nx">bgImage</span><span class="p">,</span> <span class="nx">quality</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&#34;Error writing image to disk&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">if</span> <span class="nx">i</span><span class="p">.</span><span class="nx">LogWriter</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
  <span class="nx">io</span><span class="p">.</span><span class="nx">Copy</span><span class="p">(</span><span class="nx">i</span><span class="p">.</span><span class="nx">LogWriter</span><span class="p">,</span> <span class="s">&#34;Image written in provided writer\n&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">return</span> <span class="kc">nil</span>
</code></pre>
<p>If you check our previous implementation, after using <code>draw</code>, you can see that we used the <code>Print</code> method, we created a file with <code>os.Create</code> and passed it to the <code>jpeg.Encode</code> function. We have deleted this part about creating the file and we have replaced it with a check looking for a <code>Writer</code> in the fields (<code>if i.Writer != nil</code>). Then, on <code>jpeg.Encode</code> we can replace the file value we were using previously with the content of the <code>i.Writer</code> field. Finally, we are using <code>io.Copy</code> again to log some message to the <code>LogWriter</code> if a logging strategy is provided.</p>
<p>We also have to abstract the knowledge needed from the user to create instances of implementors of the <code>PrintStrategy</code> for which we are going to use a Factory method:</p>
<pre class="code" ><code class="chroma" ><span class="kd">const</span> <span class="p">(</span>
  <span class="nx">TEXT_STRATEGY</span>  <span class="p">=</span> <span class="s">&#34;text&#34;</span>
  <span class="nx">IMAGE_STRATEGY</span> <span class="p">=</span> <span class="s">&#34;image&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nx">NewPrinter</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">strategy</span><span class="p">.</span><span class="nx">Output</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">switch</span> <span class="nx">s</span> <span class="p">{</span>
  <span class="k">case</span> <span class="nx">TEXT_STRATEGY</span><span class="p">:</span>
    <span class="k">return</span> <span class="o">&amp;</span><span class="nx">TextSquare</span><span class="p">{</span>
      <span class="nx">PrintOutput</span><span class="p">:</span> <span class="nx">strategy</span><span class="p">.</span><span class="nx">PrintOutput</span><span class="p">{</span>
        <span class="nx">LogWriter</span><span class="p">:</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Stdout</span><span class="p">,</span>
      <span class="p">},</span>
    <span class="p">},</span> <span class="kc">nil</span>
  <span class="k">case</span> <span class="nx">IMAGE_STRATEGY</span><span class="p">:</span>
    <span class="k">return</span> <span class="o">&amp;</span><span class="nx">ImageSquare</span><span class="p">{</span>
      <span class="nx">PrintOutput</span><span class="p">:</span> <span class="nx">strategy</span><span class="p">.</span><span class="nx">PrintOutput</span><span class="p">{</span>
        <span class="nx">LogWriter</span><span class="p">:</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Stdout</span><span class="p">,</span>
      <span class="p">},</span>
    <span class="p">},</span> <span class="kc">nil</span>
  <span class="k">default</span><span class="p">:</span>
    <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&#34;Strategy &#39;%s&#39; not found\n&#34;</span><span class="p">,</span> <span class="nx">s</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>We have two constants, one of each of our strategies: <code>TEXT_STRATEGY</code> and <code>IMAGE_STRATEGY</code>. Those are the constants that must be provided to the factory to retrieve each square drawer strategy. Our factory method receives an argument <code>s</code>, which is a string with one of the previous constants.</p>
<p>Each strategy has a <code>PrintOutput</code> type embedded with a default logger to <code>stdout</code> but you can override it later by using the <code>SetLog(io.Writer)</code> methods. This approach could be considered a Factory of prototypes. If it is not a recognized strategy, a proper message error will be returned.</p>
<p>What we have now is a library. We have all the functionality we need between the <code>strategy</code> and <code>shapes</code> packages. Now we will write the main package and function in a new folder called <code>cli</code>:</p>
<pre class="code" ><code class="chroma" ><span class="kd">var</span> <span class="nx">output</span> <span class="p">=</span> <span class="nx">flag</span><span class="p">.</span><span class="nx">String</span><span class="p">(</span><span class="s">&#34;output&#34;</span><span class="p">,</span> <span class="s">&#34;text&#34;</span><span class="p">,</span> <span class="s">&#34;The output to use between &#34;</span><span class="o">+</span>
  <span class="s">&#34;&#39;console&#39; and &#39;image&#39; file&#34;</span><span class="p">)</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">flag</span><span class="p">.</span><span class="nx">Parse</span><span class="p">()</span>
</code></pre>
<p>Again, like before, the <code>main</code> function starts by parsing the input arguments on the console to gather the chosen strategy. We can use the variable output now to create a strategy without Factory:</p>
<pre class="code" ><code class="chroma" ><span class="nx">activeStrategy</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">shapes</span><span class="p">.</span><span class="nx">NewPrinter</span><span class="p">(</span><span class="o">*</span><span class="nx">output</span><span class="p">)</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
  <span class="nx">log</span><span class="p">.</span><span class="nx">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
<p>With this snippet, we have our strategy or we stop program execution in the <code>log.Fatal</code> method if any error is found (such as an unrecognized strategy).</p>
<p>Now we will implement the business needs by using our library. For the purpose of the <code>TextStrategy</code>, we want to write, for example, to stdout. For the purpose of the image, we will write to <span class="file" >/tmp/image.jpg</span>. Just like before. So, following the previous statements, we can write:</p>
<pre class="code" ><code class="chroma" ><span class="k">switch</span> <span class="o">*</span><span class="nx">output</span> <span class="p">{</span>
<span class="k">case</span> <span class="nx">shapes</span><span class="p">.</span><span class="nx">TEXT_STRATEGY</span><span class="p">:</span>
  <span class="nx">activeStrategy</span><span class="p">.</span><span class="nx">SetWriter</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Stdout</span><span class="p">)</span>
<span class="k">case</span> <span class="nx">shapes</span><span class="p">.</span><span class="nx">IMAGE_STRATEGY</span><span class="p">:</span>
  <span class="nx">w</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Create</span><span class="p">(</span><span class="s">&#34;/tmp/image.jpg&#34;</span><span class="p">)</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">log</span><span class="p">.</span><span class="nx">Fatal</span><span class="p">(</span><span class="s">&#34;Error opening image&#34;</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="k">defer</span> <span class="nx">w</span><span class="p">.</span><span class="nx">Close</span><span class="p">()</span>

  <span class="nx">activeStrategy</span><span class="p">.</span><span class="nx">SetWriter</span><span class="p">(</span><span class="nx">w</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
<p>In the case of <code>TEXT_STRATEGY</code>, we use <code>SetWriter</code> to set the <code>io.Writer</code> to <code>os.Stdout</code>. In the case of <code>IMAGE_STRATEGY</code>, we create an image in any of our folders and pass the file variable to the <code>SetWriter</code> method. Remember that <code>os.File</code> implements the <code>io.Reader</code> and <code>io.Writer</code> interfaces, so it&#39;s perfectly legal to pass it as an <code>io.Writer</code> to the <code>SetWriter</code> method:</p>
<pre class="code" ><code class="chroma" ><span class="nx">err</span> <span class="p">=</span> <span class="nx">activeStrategy</span><span class="p">.</span><span class="nx">Print</span><span class="p">()</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
  <span class="nx">log</span><span class="p">.</span><span class="nx">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
<p>Finally, we call the <code>Print</code> method of whichever strategy was chosen by the user and check for possible errors. Let&#39;s try the program now:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go run main.go --output text
</span><span class="out" >Circle
</span></code></pre>
<p>It has worked as expected. What about the image strategy?</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go run main.go --output image
</span><span class="out" >Image written in provided writer
</span></code></pre>
<p>If we check in <span class="file" >/tmp/image.jpg</span>, we can find our red square on the dark background.</p>
</div>
<h4 id="final-words-on-the-strategy-pattern" >Final words on the Strategy pattern</h4>
<div class="hBody-4" >
<p>We have learned a powerful way to encapsulate algorithms in different structs. We have also used embedding instead of inheritance to provide cross-functionality between types, which will come in handy very often in our apps. You&#39;ll find yourself combining strategies here and there as we have seen in the second example, where we have strategies for logging and writing by using the <code>io.Writer</code> interface, a strategy for byte-streaming operations.</p>
</div>
<h3 id="chain-of-responsibility-design-pattern" >Chain of responsibility design pattern</h3>
<div class="hBody-3" >
<p>Our next pattern is called <b>chain of responsibility</b>. As its name implies, it consists of a chain and, in our case, each link of the chain follows the single responsibility principle.</p>
</div>
<h4 id="description" >Description</h4>
<div class="hBody-4" >
<p>The single responsibility principle implies that a type, function, method, or any similar abstraction must have one single responsibility only and it must do it quite well. This way, we can apply many functions that achieve one specific thing each to some struct, slice, map, and so on.</p>
<p>When we apply many of these abstractions in a logical way very often, we can chain them to execute in order such as, for example, a logging chain.</p>
<p>A logging chain is a set of types that logs the output of some program to more than one <code>io.Writer</code> interface. We could have a type that logs to the console, a type that logs to a file, and a type that logs to a remote server. You can make three calls every time you want to do some logging, but it&#39;s more elegant to make only one and provoke a chain reaction.</p>
<p>But also, we could have a chain of checks and, in case one of them fails, break the chain and return something. This is the authentication and authorization middleware works.</p>
</div>
<h4 id="objectives" >Objectives</h4>
<div class="hBody-4" >
<p>The objective of the chain of responsibility is to provide to the developer a way to chain actions at runtime. The actions are chained to each other and each link will execute some action and pass the request to the next link (or not). The following are the objectives followed by this pattern:</p>
<ul>
<li>
<p>Dynamically chain the actions at runtime based on some input</p>
</li>
<li>
<p>Pass a request through a chain of processors until one of them can process it, in which case the chain could be stopped</p>
</li>
</ul>
</div>
<h4 id="a-multi-logger-chain" >A multi-logger chain</h4>
<div class="hBody-4" >
<p>We are going to develop a multi-logger solution that we can chain in the way we want. We will use two different console loggers and one general-purpose logger:</p>
<ol class="num" >
<li>
<p>We need a simple logger that logs the text of a request with a prefix <i>First logger</i> and passes it to the next link in the chain.</p>
</li>
<li>
<p>A second logger will write on the console if the incoming text has the word <code>hello</code> and pass the request to a third logger. But, if not, the chain will be broken and it will return immediately.</p>
</li>
<li>
<p>A third logger type is a general purpose logger called <code>WriterLogger</code> that uses an <code>io.Writer</code> interface to log.</p>
</li>
<li>
<p>A concrete implementation of the <code>WriterLogger</code> writes to a file and represents the third link in the chain.</p>
</li>
</ol>
<p>The implementation of these steps is described in the following figure:</p>
<figure>
<img src="img/245_1.jpg" />
</figure>
</div>
<h4 id="unit-test" >Unit test</h4>
<div class="hBody-4" >
<p>The very first thing to do for the chain is, as usual, to define the interface. A chain of responsibility interface will usually have, at least, a <code>Next()</code> method. The <code>Next()</code> method is the one that executes the next link in the chain, of course:</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">ChainLogger</span> <span class="kd">interface</span> <span class="p">{</span>
  <span class="nx">Next</span><span class="p">(</span><span class="kt">string</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
<p>The <code>Next</code> method on our example&#39;s interface takes the message we want to log and passes it to the following link in the chain. As written in the acceptance criteria, we need three loggers:</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">FirstLogger</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">NextChain</span> <span class="nx">ChainLogger</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">f</span> <span class="o">*</span><span class="nx">FirstLogger</span><span class="p">)</span> <span class="nx">Next</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{}</span>

<span class="kd">type</span> <span class="nx">SecondLogger</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">NextChain</span> <span class="nx">ChainLogger</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">f</span> <span class="o">*</span><span class="nx">SecondLogger</span><span class="p">)</span> <span class="nx">Next</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{}</span>

<span class="kd">type</span> <span class="nx">WriterLogger</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">NextChain</span> <span class="nx">ChainLogger</span>
  <span class="nx">Writer</span>    <span class="nx">io</span><span class="p">.</span><span class="nx">Writer</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">w</span> <span class="o">*</span><span class="nx">WriterLogger</span><span class="p">)</span> <span class="nx">Next</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{}</span>
</code></pre>
<p>The <code>FirstLogger</code> and <code>SecondLogger</code> types have exactly the same structure--both implement <code>ChainLogger</code> and have a <code>NextChain</code> field that points to the next <code>ChainLogger</code>. The <code>WriterLogger</code> type is equal to the <code>FirstLogger</code> and <code>SecondLogger</code> types but also has a field to write its data to, so you can pass any <code>io.Writer</code> interface to it.</p>
<p>As we have done before, we&#39;ll implement an <code>io.Writer</code> struct to use in our testing. In our test file, we define the following struct:</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">myTestWriter</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">receivedMessage</span> <span class="kt">string</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">myTestWriter</span><span class="p">)</span> <span class="nx">Write</span><span class="p">(</span><span class="nx">p</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">m</span><span class="p">.</span><span class="nx">receivedMessage</span> <span class="o">+=</span> <span class="nb">string</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span>
  <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="nx">p</span><span class="p">),</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="kd">func</span><span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">myTestWriter</span><span class="p">)</span> <span class="nx">Next</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">){</span>
  <span class="nx">m</span><span class="p">.</span><span class="nx">Write</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="nx">s</span><span class="p">))</span>
<span class="p">}</span>
</code></pre>
<p>We will pass an instance of the <code>myTestWriter</code> struct to <code>WriterLogger</code> so we can track what&#39;s being logged on testing. The <code>myTestWriter</code> class implements the common <code>Write([]byte) (int, error)</code> method from the <code>io.Writer</code> interface. Remember, if it has the <code>Write</code> method, it can be used as <code>io.Writer</code>. The <code>Write</code> method simply stored the string argument to the <code>receivedMessage</code> field so we can check later its value on tests.</p>
<p>This is the beginning of the first test function:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">TestCreateDefaultChain</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Our test ChainLogger
</span><span class="c1"></span>  <span class="nx">myWriter</span> <span class="o">:=</span> <span class="nx">myTestWriter</span><span class="p">{}</span>

  <span class="nx">writerLogger</span> <span class="o">:=</span> <span class="nx">WriterLogger</span><span class="p">{</span><span class="nx">Writer</span><span class="p">:</span> <span class="o">&amp;</span><span class="nx">myWriter</span><span class="p">}</span>
  <span class="nx">second</span> <span class="o">:=</span> <span class="nx">SecondLogger</span><span class="p">{</span><span class="nx">NextChain</span><span class="p">:</span> <span class="o">&amp;</span><span class="nx">writerLogger</span><span class="p">}</span>
  <span class="nx">chain</span> <span class="o">:=</span> <span class="nx">FirstLogger</span><span class="p">{</span><span class="nx">NextChain</span><span class="p">:</span> <span class="o">&amp;</span><span class="nx">second</span><span class="p">}</span>
</code></pre>
<p>Let&#39;s describe these few lines a bit as they are quite important. We create a variable with a default <code>myTestWriter</code> type that we&#39;ll use as an <code>io.Writer</code> interface in the last link of our chain. Then we create the last piece of the link chain, the <code>writerLogger</code> interface. When implementing the chain, you usually start with the last piece on the link and, in our case, it is a <code>WriterLogger</code>. The <code>WriterLogger</code> writes to an <code>io.Writer</code> so we pass <code>myWriter</code> as <code>io.Writer</code> interface.</p>
<p>Then we have created a <code>SecondLogger</code>, the middle link in our chain, with a pointer to the <code>writerLogger</code>. As we mentioned before, <code>SecondLogger</code> just logs and passes the message in case it contains the word <code>hello</code>. In a production app, it could be an error-only logger.</p>
<p>Finally, the first link in the chain has the variable name chain. It points to the second logger. So, to resume, our chain looks like this: <code>FirstLogger | SecondLogger | WriterLogger</code>.</p>
<p>This is going to be our default setup for our tests:</p>
<pre class="code" ><code class="chroma" ><span class="nx">t</span><span class="p">.</span><span class="nx">Run</span><span class="p">(</span><span class="s">&#34;3 loggers, 2 of them writes to console, second only if it founds &#34;</span> <span class="o">+</span>
  <span class="s">&#34;the word &#39;hello&#39;, third writes to some variable if second found &#39;hello&#39;&#34;</span><span class="p">,</span>
  <span class="kd">func</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">){</span>
    <span class="nx">chain</span><span class="p">.</span><span class="nx">Next</span><span class="p">(</span><span class="s">&#34;message that breaks the chain\n&#34;</span><span class="p">)</span>

    <span class="k">if</span> <span class="nx">myWriter</span><span class="p">.</span><span class="nx">receivedMessage</span> <span class="o">!=</span> <span class="s">&#34;&#34;</span> <span class="p">{</span>
      <span class="nx">t</span><span class="p">.</span><span class="nx">Fatal</span><span class="p">(</span><span class="s">&#34;Last link should not receive any message&#34;</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="nx">chain</span><span class="p">.</span><span class="nx">Next</span><span class="p">(</span><span class="s">&#34;Hello\n&#34;</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">!</span><span class="nx">strings</span><span class="p">.</span><span class="nx">Contains</span><span class="p">(</span><span class="nx">myWriter</span><span class="p">.</span><span class="nx">receivedMessage</span><span class="p">,</span> <span class="s">&#34;Hello&#34;</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">t</span><span class="p">.</span><span class="nx">Fatal</span><span class="p">(</span><span class="s">&#34;Last link didn&#39;t received expected message&#34;</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">})</span>
</code></pre>
<p>Continuing with Go 1.7 or later testing signatures, we define an inner test with the following description: <i>three loggers, two of them write to console, the second only if it finds the word &#39;hello&#39;, the third writes to some variable if the second found &#39;hello&#39;</i>. It&#39;s quite descriptive and very easy to understand if someone else has to maintain this code.</p>
<p>First, we use a message on the <code>Next</code> method that will not reach the third link in the chain as it doesn&#39;t contain the word <code>hello</code>. We check the contents of the <code>receivedMessage</code> variable, that by default is empty, to see if it has changed because it shouldn&#39;t.</p>
<p>Next, we use the chain variable again, our first link in the chain, and pass the message <code>&#34;Hello\n&#34;</code>. According to the description of the test, it should log using <code>FirstLogger</code>, then in <code>SecondLogger</code> and finally in WriterLogger because it contains the word <code>hello</code> and the <code>SecondLogger</code> will let it pass.</p>
<p>The test checks that <code>myWriter</code>, the last link in the chain that stored the past message in a variable called <code>receivedMessage</code>, has the word that we passed first in the chain: hello. Let&#39;s run it so it fails:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go <span class="nb">test</span> -v .
</span><span class="out" >=== RUN   TestCreateDefaultChain
=== RUN   TestCreateDefaultChain/3_loggers,_2_of_them_writes_to_console,_second_only_if_it_founds_the_word_&#39;hello&#39;,_third_writes_to_some_variable_if_second_found_&#39;hello&#39;
--- FAIL: TestCreateDefaultChain (0.00s)
--- FAIL: TestCreateDefaultChain/3_loggers,_2_of_them_writes_to_console,_second_only_if_it_founds_the_word_&#39;hello&#39;,_third_writes_to_some_variable_if_second_found_&#39;hello&#39; (0.00s)
        chain_test.go:33: Last message didn&#39;t received expected message
FAIL
exit status 1
FAIL
</span></code></pre>
<p>The test passed for the first check of the test and didn&#39;t for the second check. Well... ideally no check should pass before any implementation is done. Remember that in test-driven development, tests must fail on the first launch because the code they are testing isn&#39;t implemented yet. Go zero-initialization misleads us with this passed check on the test. We can solve this in two ways:</p>
<ul>
<li>
<p>Making the signature of the <code>ChainLogger</code> to return an error: <code>Next(string)</code> error. This way, we would break the chain returning an error. This is a much more convenient way in general, but it will introduce quite a lot of boilerplate right now.</p>
</li>
<li>
<p>Changing the <code>receivedMessage</code> field to a pointer. A default value of a pointer is nil, instead of an empty string.</p>
</li>
</ul>
<p>We will use the second option now, as it&#39;s much simpler and quite effective too. So let&#39;s change the signature of the <code>myTestWriter</code> struct to the following:</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">myTestWriter</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">receivedMessage</span> <span class="o">*</span><span class="kt">string</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">myTestWriter</span><span class="p">)</span> <span class="nx">Write</span><span class="p">(</span><span class="nx">p</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="nx">m</span><span class="p">.</span><span class="nx">receivedMessage</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
         <span class="nx">m</span><span class="p">.</span><span class="nx">receivedMessage</span> <span class="p">=</span> <span class="nb">new</span><span class="p">(</span><span class="kt">string</span><span class="p">)</span>
<span class="p">}</span>
  <span class="nx">tempMessage</span> <span class="o">:=</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintf</span><span class="p">(</span><span class="s">&#34;%s%s&#34;</span><span class="p">,</span> <span class="nx">m</span><span class="p">.</span><span class="nx">receivedMessage</span><span class="p">,</span> <span class="nx">p</span><span class="p">)</span>
  <span class="nx">m</span><span class="p">.</span><span class="nx">receivedMessage</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">tempMessage</span>
  <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="nx">p</span><span class="p">),</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">myTestWriter</span><span class="p">)</span> <span class="nx">Next</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">m</span><span class="p">.</span><span class="nx">Write</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="nx">s</span><span class="p">))</span>
<span class="p">}</span>
</code></pre>
<p>Check that the type of <code>receivedMessage</code> has the asterisk (<code>*</code>) now to indicate that it&#39;s a pointer to a string. The <code>Write</code> function needed to change too. Now we have to check the contents of the <code>receivedMessage</code> field because, as every pointer, it&#39;s initialized to nil. Then we have to store the message in a variable first, so we can take the address in the next line on the assignment (<code>m.receivedMessage = &amp;tempMessage</code>).</p>
<p>So now our test code should change a bit too:</p>
<pre class="code" ><code class="chroma" ><span class="nx">t</span><span class="p">.</span><span class="nx">Run</span><span class="p">(</span><span class="s">&#34;3 loggers, 2 of them writes to console, second only if it founds &#34;</span><span class="o">+</span>
  <span class="s">&#34;the word &#39;hello&#39;, third writes to some variable if second found &#39;hello&#39;&#34;</span><span class="p">,</span>
  <span class="kd">func</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">chain</span><span class="p">.</span><span class="nx">Next</span><span class="p">(</span><span class="s">&#34;message that breaks the chain\n&#34;</span><span class="p">)</span>

    <span class="k">if</span> <span class="nx">myWriter</span><span class="p">.</span><span class="nx">receivedMessage</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
      <span class="nx">t</span><span class="p">.</span><span class="nx">Error</span><span class="p">(</span><span class="s">&#34;Last link should not receive any message&#34;</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="nx">chain</span><span class="p">.</span><span class="nx">Next</span><span class="p">(</span><span class="s">&#34;Hello\n&#34;</span><span class="p">)</span>

    <span class="k">if</span> <span class="nx">myWriter</span><span class="p">.</span><span class="nx">receivedMessage</span> <span class="o">==</span> <span class="s">&#34;&#34;</span> <span class="o">||</span>
      <span class="p">!</span><span class="nx">strings</span><span class="p">.</span><span class="nx">Contains</span><span class="p">(</span><span class="o">*</span><span class="nx">myWriter</span><span class="p">.</span><span class="nx">receivedMessage</span><span class="p">,</span> <span class="s">&#34;Hello&#34;</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">t</span><span class="p">.</span><span class="nx">Fatal</span><span class="p">(</span><span class="s">&#34;Last link didn&#39;t received expected message&#34;</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">})</span>
</code></pre>
<p>Now we are checking that <code>myWriter.receivedMessage</code> is actually <code>nil</code>, so no content has been written for sure on the variable. Also, we have to change the second if to check first that the member isn&#39;t nil before checking its contents or it can throw a panic on test. Let&#39;s test it again:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go <span class="nb">test</span> -v .
</span><span class="out" >=== RUN   TestCreateDefaultChain
=== RUN   TestCreateDefaultChain/3_loggers,_2_of_them_writes_to_console,_second_only_if_it_founds_the_word_&#39;hello&#39;,_third_writes_to_some_variable_if_second_found_&#39;hello&#39;
--- FAIL: TestCreateDefaultChain (0.00s)
--- FAIL: TestCreateDefaultChain/3_loggers,_2_of_them_writes_to_console,_second_only_if_it_founds_the_word_&#39;hello&#39;,_third_writes_to_some_variable_if_second_found_&#39;hello&#39; (0.00s)
        chain_test.go:40: Last link didn&#39;t received expected message
FAIL
exit status 1
FAIL
</span></code></pre>
<p>It fails again and, again, the first half of the test passes correctly without implemented code. So what should we do now? We have change the signature of the <code>myWriter</code> type to make the test fail in both checks and, again, just fail in the second. Well, in this case we can pass this small issue. When writing tests, we must be very careful to not get too crazy about them; unit tests are tools to help us write and maintain code, but our target is to write functionality, not tests. This is important to keep in mind as you can get really crazy engineering unit tests.</p>
</div>
<h4 id="implementation" >Implementation</h4>
<div class="hBody-4" >
<p>Now we have to implement the first, second, and third loggers called <code>FirstLogger</code>, <code>SecondLogger</code>, and <code>WriterLogger</code> respectively. The <code>FirstLogger</code> logger is the easiest one as described in the first acceptance criterion: <i>We need a simple logger that logs the text of a request with a prefix First logger: and passes it to the next link in the chain</i>. So let&#39;s do it:</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">FirstLogger</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">NextChain</span> <span class="nx">ChainLogger</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">f</span> <span class="o">*</span><span class="nx">FirstLogger</span><span class="p">)</span> <span class="nx">Next</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&#34;First logger: %s\n&#34;</span><span class="p">,</span> <span class="nx">s</span><span class="p">)</span>

  <span class="k">if</span> <span class="nx">f</span><span class="p">.</span><span class="nx">NextChain</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">f</span><span class="p">.</span><span class="nx">NextChain</span><span class="p">.</span><span class="nx">Next</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>The implementation is quite easy. Using the <code>fmt.Printf</code> method to format and print the incoming string, we appended the text <code>FirstLogger</code>: text. Then, we check that the <code>NextChain</code> type has actually some content and pass the control to it by calling its <code>Next(string)</code> method.  The test shouldn&#39;t pass yet so we&#39;ll continue with the <code>SecondLogger</code> logger:</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">SecondLogger</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">NextChain</span> <span class="nx">ChainLogger</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">se</span> <span class="o">*</span><span class="nx">SecondLogger</span><span class="p">)</span> <span class="nx">Next</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="nx">strings</span><span class="p">.</span><span class="nx">Contains</span><span class="p">(</span><span class="nx">strings</span><span class="p">.</span><span class="nx">ToLower</span><span class="p">(</span><span class="nx">s</span><span class="p">),</span> <span class="s">&#34;hello&#34;</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&#34;Second logger: %s\n&#34;</span><span class="p">,</span> <span class="nx">s</span><span class="p">)</span>

    <span class="k">if</span> <span class="nx">se</span><span class="p">.</span><span class="nx">NextChain</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
      <span class="nx">se</span><span class="p">.</span><span class="nx">NextChain</span><span class="p">.</span><span class="nx">Next</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">return</span>
  <span class="p">}</span>

  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&#34;Finishing in second logging\n\n&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
<p>As mentioned in the second acceptance criterion, the <code>SecondLogger</code> description is: <i>A second logger will write on the console if the incoming text has the word &#34;hello&#34; and pass the request to a third logger</i>. First of all, it checks whether the incoming text contains the text <code>hello</code>. If it&#39;s true, it prints the message to the console, appending the text <code>SecondLogger</code>: and passes the message to the next link in the chain (check previous instance that a third link exists).</p>
<p>But if it doesn&#39;t contain the text <code>hello</code>, the chain is broken and it prints the message <code>Finishing in second logging</code>.</p>
<p>We&#39;ll finalize with the <code>WriterLogger</code> type:</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">WriterLogger</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">NextChain</span> <span class="nx">ChainLogger</span>
  <span class="nx">Writer</span>    <span class="nx">io</span><span class="p">.</span><span class="nx">Writer</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">w</span> <span class="o">*</span><span class="nx">WriterLogger</span><span class="p">)</span> <span class="nx">Next</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="nx">w</span><span class="p">.</span><span class="nx">Writer</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">w</span><span class="p">.</span><span class="nx">Writer</span><span class="p">.</span><span class="nx">Write</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="s">&#34;WriterLogger: &#34;</span> <span class="o">+</span> <span class="nx">s</span><span class="p">))</span>
  <span class="p">}</span>

  <span class="k">if</span> <span class="nx">w</span><span class="p">.</span><span class="nx">NextChain</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">w</span><span class="p">.</span><span class="nx">NextChain</span><span class="p">.</span><span class="nx">Next</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>The <code>WriterLogger</code> struct&#39;s <code>Next</code> method checks that there is an existing <code>io.Writer</code> interface stored in the <code>Writer</code> member and writes there the incoming message appending the text <code>WriterLogger</code>: to it. Then, like the previous links, check that there are more links to pass the message.</p>
<p>Now the tests will pass successfully:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go <span class="nb">test</span> -v .
</span><span class="out" >=== RUN   TestCreateDefaultChain
=== RUN
TestCreateDefaultChain/3_loggers,_2_of_them_writes_to_console,_second_only_if_it_founds_the_word_&#39;hello&#39;,_third_writes_to_some_variable_if_second_found_&#39;hello&#39;
First logger: message that breaks the chain
Finishing in second logging
First logger: Hello
Second logger: Hello
--- PASS: TestCreateDefaultChain (0.00s)
    --- PASS: TestCreateDefaultChain/3_loggers,_2_of_them_writes_to_console,_second_only_if_it_founds_the_word_&#39;hello&#39;,_third_writes_to_some_variable_if_second_found_&#39;hello&#39; (0.00s)
PASS
ok
</span></code></pre>
<p>The first half of the test prints two messages--the <code>First logger</code>: message that breaks the chain, which is the expected message for the <code>FirstLogger</code>. But it halts in the <code>SecondLogger</code> because no hello word has been found on the incoming message; that&#39;s why it prints the <code>Finishing in second logging</code> string.</p>
<p>The second half of the test receives the message <code>Hello</code>. So the <code>FirstLogger</code> prints and the <code>SecondLogger</code> prints too. The third logger doesn&#39;t print to console at all but to our <code>myWriter.receivedMessage</code> line defined in the test.</p>
</div>
<h4 id="what-about-a-closure?" >What about a closure?</h4>
<div class="hBody-4" >
<p>Sometimes it can be useful to define an even more flexible link in the chain for quick debugging. We can use closures for this so that the link functionality is defined by the caller. What does a closure link look like? Similar to the <code>WriterLogger</code> logger:</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">ClosureChain</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">NextChain</span> <span class="nx">ChainLogger</span>
  <span class="nx">Closure</span>   <span class="kd">func</span><span class="p">(</span><span class="kt">string</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">ClosureChain</span><span class="p">)</span> <span class="nx">Next</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">Closure</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">c</span><span class="p">.</span><span class="nx">Closure</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">NextChain</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">c</span><span class="p">.</span><span class="nx">Next</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>The <code>ClosureChain</code> type has a <code>NextChain</code>, as usual, and a Closure member. Look at the signature of the <code>Closure</code>: <code>func(string)</code>. This means it is a function that takes a <code>string</code> and returns nothing.</p>
<p>The <code>Next(string)</code> method for <code>ClosureChain</code> checks that the <code>Closure</code> member is stored and executes it with the incoming string. As usual, the link checks for more links to pass the message as every link in the chain.</p>
<p>So, how do we use it now? We&#39;ll define a new test to show its functionality:</p>
<pre class="code" ><code class="chroma" ><span class="nx">t</span><span class="p">.</span><span class="nx">Run</span><span class="p">(</span><span class="s">&#34;2 loggers, second uses the closure implementation&#34;</span><span class="p">,</span>
  <span class="kd">func</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">myWriter</span> <span class="p">=</span> <span class="nx">myTestWriter</span><span class="p">{}</span>
    <span class="nx">closureLogger</span> <span class="o">:=</span> <span class="nx">ClosureChain</span><span class="p">{</span>
      <span class="nx">Closure</span><span class="p">:</span> <span class="kd">func</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&#34;My closure logger! Message: %s\n&#34;</span><span class="p">,</span> <span class="nx">s</span><span class="p">)</span>
        <span class="nx">myWriter</span><span class="p">.</span><span class="nx">receivedMessage</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">s</span>
      <span class="p">},</span>
    <span class="p">}</span>

    <span class="nx">writerLogger</span><span class="p">.</span><span class="nx">NextChain</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">closureLogger</span>

    <span class="nx">chain</span><span class="p">.</span><span class="nx">Next</span><span class="p">(</span><span class="s">&#34;Hello closure logger&#34;</span><span class="p">)</span>

    <span class="k">if</span> <span class="o">*</span><span class="nx">myWriter</span><span class="p">.</span><span class="nx">receivedMessage</span> <span class="o">!=</span> <span class="s">&#34;Hello closure logger&#34;</span> <span class="p">{</span>
      <span class="nx">t</span><span class="p">.</span><span class="nx">Fatal</span><span class="p">(</span><span class="s">&#34;Expected message wasn&#39;t received in myWriter&#34;</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">})</span>
</code></pre>
<p>The description of this test makes it clear: <code>&#34;2 loggers, second uses the closure implementation&#34;</code>. We simply use two <code>ChainLogger</code> implementations and we use the <code>closureLogger</code> in the second link. We have created a new <code>myTestWriter</code> to store the contents of the message. When defining the <code>ClosureChain</code>, we defined an anonymous function directly on the <code>Closure</code> member when creating <code>closureLogger</code>. It prints <code>&#34;My closure logger! Message: %s\n&#34;</code> with the incoming message replacing <code>&#34;%s&#34;</code>. Then, we store the incoming message on <code>myWriter</code>, to check later.</p>
<p>After defining this new link, we use the third link from the previous test, add the closure as the fourth link, and passed the message <code>Hello closure logger</code>. We use the word <code>Hello</code> at the beginning so that we ensure that the message will pass the <code>SecondLogger</code>.</p>
<p>Finally, the contents of <code>myWriter.receivedMessage</code> must contain the pased text: <code>Hello closure logger</code>. This is quite a flexible approach with one drawback: when defining a closure like this, we cannot test its contents in a very elegant way. Let&#39;s run the tests again:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go <span class="nb">test</span> -v .
</span><span class="out" >=== RUN   TestCreateDefaultChain
=== RUN   TestCreateDefaultChain/3_loggers,_2_of_them_writes_to_console,_second_only_if_it_founds_the_word_&#39;hello&#39;,_third_writes_to_some_variable_if_second_found_&#39;hello&#39;
First logger: message that breaks the chain
Finishing in second logging

First logger: Hello
Second logger: Hello
=== RUN TestCreateDefaultChain/2_loggers,_second_uses_the_closure_implementation
First logger: Hello closure logger
Second logger: Hello closure logger
My closure logger! Message: Hello closure logger
--- PASS: TestCreateDefaultChain (0.00s)
    --- PASS: TestCreateDefaultChain/3_loggers,_2_of_them_writes_to_console,_second_only_if_it_founds_the_word_&#39;hello&#39;,_third_writes_to_some_variable_if_second_found_&#39;hello&#39; (0.00s)
    --- PASS: TestCreateDefaultChain/2_loggers,_second_uses_the_closure_implementation (0.00s)
PASS
ok
</span></code></pre>
<p>Look at the third RUN: the message passes correctly through the first, second, and third links to arrive at the closure that prints the expected <code>My closure logger! Message: Hello closure logger</code> message.</p>
<p>It&#39;s very useful to add a closure method implementation to some interfaces as it provides quite a lot of flexibility when using the library. You can find this approach very often in Go code, being the most known the one of package <code>net/http</code>. The <code>HandleFunc</code> function which we used previously in the structural patterns to define a handler for an HTTP request.</p>
</div>
<h4 id="putting-it-together" >Putting it together</h4>
<div class="hBody-4" >
<p>We learned a powerful tool to achieve dynamic processing of actions and state handling. The Chain of responsibility pattern is widely used, also to create <b>Finite State Machines</b> (<span class="acronym" >FSM</span>). It is also used interchangeably with the Decorator pattern with the difference that when you decorate, you change the structure of an object while with the chain you define a behavior for each link in the chain that can break it too.</p>
</div>
<h3 id="command-design-pattern" >Command design pattern</h3>
<div class="hBody-3" >
<p>To finish with this chapter, we will see also the <b>Command</b> pattern--a tiny design pattern but still frequently used. You need a way to connect types that are really unrelated? So design a Command for them.</p>
</div>
<h4 id="description" >Description</h4>
<div class="hBody-4" >
<p>The Command design pattern is quite similar to the Strategy design pattern but with key differences. While in the strategy pattern we focus on changing algorithms, in the Command pattern, we focus on the invocation of something or on the abstraction of some type.</p>
<p>A Command pattern is commonly seen as a container. You put something like the info for user interaction on a UI that could be <code>click on login</code> and pass it as a command. You don&#39;t need to have the complexity related to the <code>click on login</code> action in the command but simply the action itself.</p>
<p>An example for the organic world would be a box for a delivery company. We can put anything on it but, as a delivery company, we are interested in managing the box instead of its contents directly.</p>
<p>The command pattern will be used heavily when dealing with channels. With channels you can send any message through it but, if we need a response from the receiving side of the channel, a common approach is to create a command that has a second, response channel attached where we are listening.</p>
<p>Similarly, a good example would be a multi-player video game, where every stroke of each user can be sent as commands to the rest of the users through the network.</p>
</div>
<h4 id="objectives" >Objectives</h4>
<div class="hBody-4" >
<p>When using the Command design pattern, we are trying to encapsulate</p>
<p>some sort of action or information in a light package that must be processed somewhere else. It&#39;s similar to the Strategy pattern but, in fact, a Command could trigger a preconfigured Strategy somewhere else, so they are not the same. The following are the objectives for this design pattern:</p>
<ul>
<li>
<p>Put some information into a box. Just the receiver will open the box and know its contents.</p>
</li>
<li>
<p>Delegate some action somewhere else.</p>
</li>
</ul>
<p>The behavior is also explained in the following diagram:</p>
<figure>
<img src="img/259_1.jpg" />
</figure>
<p>There we have a <b>Command</b> interface with a <b>Get() interface{}</b> method. We have a type <b>A</b> and a type <b>B</b>. The idea is that <b>A</b> and <b>B</b> implement the <b>Command</b> interface to return themselves as an <code>interface{}</code>. As now they implement <b>Command</b>, they can be used in a <b>Command handler</b> which doesn&#39;t care very much about the underlying type. Now <b>A</b> and <b>B</b> can travel through functions that handles commands or store Commands freely. But <b>B</b> handler can take an object from any <b>Command</b> handler to &#34;unwrap&#34; it and take its <b>B</b> content as well as <b>A</b> command handler with its A content.</p>
<p>We put the information in a box (the <b>Command</b>) and delegate what to do with it to the handlers of Commands.</p>
</div>
<h4 id="a-simple-queue" >A simple queue</h4>
<div class="hBody-4" >
<p>Our first example is going to be pretty small. We will put some information into a Command implementer and we will have a queue. We will create many instances of a type implementing a Command pattern and we will pass them to a queue that will store the commands until three of them are in the queue, at which time it will process them.</p>
</div>
<h4 id="acceptance-criteria" >Acceptance criteria</h4>
<div class="hBody-4" >
<p>So the ideal acceptance criteria to understand well the implications of the Command should reflect somehow the creation of a box that can accept unrelated types and the execution of the Command itself:</p>
<ul>
<li>
<p>We need a constructor of console printing commands. When using this constructor with a <code>string</code>, it will return a command that will print it. In this case, the handler is inside the command that acts as a box and as a handler.</p>
</li>
<li>
<p>We need a data structure that stores incoming commands in a queue and prints them once the queue reaches the length of three.</p>
</li>
</ul>
</div>
<h4 id="implementation" >Implementation</h4>
<div class="hBody-4" >
<p>This pattern is quite simple and we will write a few different examples so we&#39;ll implement the library directly to keep things light and short. The classical Command design pattern usually has a common type structure with an <code>Execute</code> method. We are also going to use this structure as it&#39;s quite flexible and simple:</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">Command</span> <span class="kd">interface</span> <span class="p">{</span>
  <span class="nx">Execute</span><span class="p">()</span>
<span class="p">}</span>
</code></pre>
<p>This is generic enough to fill a lot of unrelated types! Think about it--we are going to create a type that prints to console when using the <code>Execute()</code> method but it could print a number or launch a rocket as well! The key here is to focus on invocations because the handlers are also in Command. So we need some type implementing this interface and printing to the console some sort of message:</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">ConsoleOutput</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">message</span> <span class="kt">string</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">ConsoleOutput</span><span class="p">)</span> <span class="nx">Execute</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">message</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
<p>The <code>ConsoleOutput</code> type implements the <code>Command</code> interface and prints to the console the member called <code>message</code>.</p>
<p>As defined in the first acceptance criterion, we need a <code>Command</code> constructor that accepts a message string and returns the <code>Command</code> interface. It will have the signature <code>func CreateCommand(s string) Command</code>:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">CreateCommand</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">)</span> <span class="nx">Command</span> <span class="p">{</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&#34;Creating command&#34;</span><span class="p">)</span>

  <span class="k">return</span> <span class="o">&amp;</span><span class="nx">ConsoleOutput</span><span class="p">{</span>
    <span class="nx">message</span><span class="p">:</span> <span class="nx">s</span><span class="p">,</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>For the command <code>queue</code>, we&#39;ll define a very simple type called <code>CommandQueue</code> to store in a queue any type implementing the <code>Command</code> interface:</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">CommandQueue</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">queue</span> <span class="p">[]</span><span class="nx">Command</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">CommandQueue</span><span class="p">)</span> <span class="nx">AddCommand</span><span class="p">(</span><span class="nx">c</span> <span class="nx">Command</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">p</span><span class="p">.</span><span class="nx">queue</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">p</span><span class="p">.</span><span class="nx">queue</span><span class="p">,</span> <span class="nx">c</span><span class="p">)</span>

  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">p</span><span class="p">.</span><span class="nx">queue</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span> <span class="p">{</span>
    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">command</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">p</span><span class="p">.</span><span class="nx">queue</span> <span class="p">{</span>
      <span class="nx">command</span><span class="p">.</span><span class="nx">Execute</span><span class="p">()</span>
    <span class="p">}</span>

    <span class="nx">p</span><span class="p">.</span><span class="nx">queue</span> <span class="p">=</span> <span class="nb">make</span><span class="p">([]</span><span class="nx">Command</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>The <code>CommandQueue</code> type stores an array of the <code>Commands</code> interface. When the queue array reaches three items, it executes all the commands stored in the queue field. If it hasn&#39;t reached the required length yet, it just stores the command.</p>
<p>We will create five commands, enough to trigger the command queue mechanism, and add them to the queue. Each time a command is created, the message <code>Creating command</code> will be printed to the console. When we create the third command, the automatic command executor will be launched, printing the first three messages. We create and add two commands more, but because we haven&#39;t reached the third command again, they won&#39;t be printed and just the <code>Creating command</code> messages will be printed:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">queue</span> <span class="o">:=</span> <span class="nx">CommandQueue</span><span class="p">{}</span>

  <span class="nx">queue</span><span class="p">.</span><span class="nx">AddCommand</span><span class="p">(</span><span class="nx">CreateCommand</span><span class="p">(</span><span class="s">&#34;First message&#34;</span><span class="p">))</span>
  <span class="nx">queue</span><span class="p">.</span><span class="nx">AddCommand</span><span class="p">(</span><span class="nx">CreateCommand</span><span class="p">(</span><span class="s">&#34;Second message&#34;</span><span class="p">))</span>
  <span class="nx">queue</span><span class="p">.</span><span class="nx">AddCommand</span><span class="p">(</span><span class="nx">CreateCommand</span><span class="p">(</span><span class="s">&#34;Third message&#34;</span><span class="p">))</span>

  <span class="nx">queue</span><span class="p">.</span><span class="nx">AddCommand</span><span class="p">(</span><span class="nx">CreateCommand</span><span class="p">(</span><span class="s">&#34;Fourth message&#34;</span><span class="p">))</span>
  <span class="nx">queue</span><span class="p">.</span><span class="nx">AddCommand</span><span class="p">(</span><span class="nx">CreateCommand</span><span class="p">(</span><span class="s">&#34;Fifth message&#34;</span><span class="p">))</span>
<span class="p">}</span>
</code></pre>
<p>Let&#39;s run the <code>main</code> program. Our definition said that the commands are processed once every three messages and we will create a total of five messages. The first three messages must be printed but not the fourth and fifth because we didn&#39;t reach a sixth message to trigger the command processing:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go run command.go
</span><span class="out" >Creating command
Creating command
Creating command
First message
Second message
Third message
Creating command
Creating command
</span></code></pre>
<p>As you can see, the fourth and fifth messages aren&#39;t printed, as expected, but we know that the commands were created and stored on the array. They just weren&#39;t processed because the queue was waiting for one command more to trigger the processor.</p>
</div>
<h4 id="more-examples" >More examples</h4>
<div class="hBody-4" >
<p>The previous example shows how to use a Command handler that executes the content of the command. But a common way to use a Command pattern is to delegate the information, instead of the execution, to a different object.</p>
<p>For example, instead of printing to the console, we will create a command that extracts information:</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">Command</span> <span class="kd">interface</span> <span class="p">{</span>
  <span class="nx">Info</span><span class="p">()</span> <span class="kt">string</span>
<span class="p">}</span>
</code></pre>
<p>In this case, our <code>Command</code> interface will have a method named <code>Info</code> that will retrieve some information from its implementor. We will create two implementations; one will return the time passed since the creation of the command to its execution:</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">TimePassed</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">start</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">TimePassed</span><span class="p">)</span> <span class="nx">Info</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Since</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">start</span><span class="p">).</span><span class="nx">String</span><span class="p">()</span>
<span class="p">}</span>
</code></pre>
<p>The <code>time.Since</code> function returns the time elapsed since the time stored in the provided parameter. We returned the string representation of the passed time by calling the <code>String()</code> method on the <code>time.Time</code> type. The second implementation of our new <code>Command</code> will return the message <code>Hello World!</code>:</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">HelloMessage</span> <span class="kd">struct</span><span class="p">{}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">h</span> <span class="nx">HelloMessage</span><span class="p">)</span> <span class="nx">Info</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
  <span class="k">return</span> <span class="s">&#34;Hello world!&#34;</span>
<span class="p">}</span>
</code></pre>
<p>And our <code>main</code> function will simply create an instance of each type, then waits for a second and print the info returned from each <code>Command</code>:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">timeCommand</span> <span class="nx">Command</span>
  <span class="nx">timeCommand</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">TimePassed</span><span class="p">{</span><span class="nx">time</span><span class="p">.</span><span class="nx">Now</span><span class="p">()}</span>

  <span class="kd">var</span> <span class="nx">helloCommand</span> <span class="nx">Command</span>
  <span class="nx">helloCommand</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">HelloMessage</span><span class="p">{}</span>

  <span class="nx">time</span><span class="p">.</span><span class="nx">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>

  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">timeCommand</span><span class="p">.</span><span class="nx">Info</span><span class="p">())</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">helloCommand</span><span class="p">.</span><span class="nx">Info</span><span class="p">())</span>
<span class="p">}</span>
</code></pre>
<p>The <code>time.Sleep</code> function stops the execution of the current goroutine for the specified period (a second). So, to recall--the <code>timeCommand</code> variable stores the time when the program was started and its <code>Info()</code> method returns a string representation of the time that passed since we give a value to the type to the moment were we called the <code>Info()</code> method on it. The <code>helloCommand</code> variable returns the message <code>Hello World!</code> when we call its <code>Info()</code> method. Here we haven&#39;t implemented a <code>Command</code> handler again to keep things simple but we can consider the console as the handler because we can only print ASCII characters on it like the ones retrieved by the <code>Info()</code> method.</p>
<p>Let&#39;s run the <code>main</code> function:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go run command.go
</span><span class="out" >1.000216755s
Hello world!
</span></code></pre>
<p>Here we are. In this case, we retrieve some information by using the Command pattern. One type stores time information while the other stores nothing and it simply returns the same simple string. Each time we run the <code>main</code> function will return a different elapsed time, so don&#39;t worry if the time doesn&#39;t match with the one in the example.</p>
</div>
<h4 id="chain-of-responsibility-of-commands" >Chain of responsibility of commands</h4>
<div class="hBody-4" >
<p>Do you remember the chain of responsibility design pattern? We were passing a <code>string</code> message between links to print its contents. But we could be using the previous Command to retrieve information for logging to the console. We&#39;ll mainly reuse the code that we have written already.</p>
<p>The <code>Command</code> interface will be from the type interface that returns a <code>string</code> from the previous example:</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">Command</span> <span class="kd">interface</span> <span class="p">{</span>
  <span class="nx">Info</span><span class="p">()</span> <span class="kt">string</span>
<span class="p">}</span>
</code></pre>
<p>We will use the <code>Command</code> implementation of the <code>TimePassed</code> type too:</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">TimePassed</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">start</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">TimePassed</span><span class="p">)</span> <span class="nx">Info</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Since</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">start</span><span class="p">).</span><span class="nx">String</span><span class="p">()</span>
<span class="p">}</span>
</code></pre>
<p>Remember that this type returns the elapsed time from the object creation on its <code>Info() string</code> method. We also need the <code>ChainLogger</code> interface from the <i>Chain of responsibility design pattern</i> section of this chapter but, this time, it will pass Commands on its <code>Next</code> method instead of <code>string</code>:</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">ChainLogger</span> <span class="kd">interface</span> <span class="p">{</span>
  <span class="nx">Next</span><span class="p">(</span><span class="nx">Command</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
<p>We&#39;ll use just the same type for two links in the chain for simplicity. This link is very similar to the <code>FirstLogger</code> type from the chain of responsibility example, but this time it will append the message <code>Elapsed time from creation</code>: and it will wait 1 second before printing. We&#39;ll call it <code>Logger</code> instead of <code>FirstLogger</code>:</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">Logger</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">NextChain</span> <span class="nx">ChainLogger</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">f</span> <span class="o">*</span><span class="nx">Logger</span><span class="p">)</span> <span class="nx">Next</span><span class="p">(</span><span class="nx">c</span> <span class="nx">Command</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">time</span><span class="p">.</span><span class="nx">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>

  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&#34;Elapsed time from creation: %s\n&#34;</span><span class="p">,</span> <span class="nx">c</span><span class="p">.</span><span class="nx">Info</span><span class="p">())</span>

  <span class="k">if</span> <span class="nx">f</span><span class="p">.</span><span class="nx">NextChain</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">f</span><span class="p">.</span><span class="nx">NextChain</span><span class="p">.</span><span class="nx">Next</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>Finally, we need a <code>main</code> function to execute the chain that takes <code>Command</code> pointers:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">second</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">Logger</span><span class="p">)</span>
  <span class="nx">first</span> <span class="o">:=</span> <span class="nx">Logger</span><span class="p">{</span><span class="nx">NextChain</span><span class="p">:</span> <span class="nx">second</span><span class="p">}</span>

  <span class="nx">command</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">TimePassed</span><span class="p">{</span><span class="nx">start</span><span class="p">:</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Now</span><span class="p">()}</span>

  <span class="nx">first</span><span class="p">.</span><span class="nx">Next</span><span class="p">(</span><span class="nx">command</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
<p>Line by line, we create a variable called <code>second</code> with a pointer to a <code>Logger</code>; this is going to be the second link in our chain. Then we create a variable called <code>first</code>, that will be the first link in the chain. The first link points to the <code>second</code> variable, the second link in the chain.</p>
<p>Then, we create an instance of <code>TimePassed</code> to use it as the <code>Command</code> type. The start time of this command is the execution time (the <code>time.Now()</code> method returns the time in the moment of the execution).</p>
<p>Finally, we pass the <code>Command</code> interface to the chain on the <code>first.Next(command)</code> statement. The output of this program is the following:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go run chain_command.go
</span><span class="out" >Elapsed time from creation: 1.0003419s
Elapsed time from creation: 2.000682s
</span></code></pre>
<p>The resulting output is reflected in the following diagram: The command with the time field is pushed to the first link that knows how to execute Commands of any type. Then it passes the Command to the second link that also knows how to execute Commands:</p>
<p>This approach hides the complexity behind each <code>Command</code> execution from the Command handlers on each link. The functionality hidden behind a Command can be simple or incredibly complex but the idea here is to reuse the handler to manage many types of unrelated implementations.</p>
</div>
<h4 id="rounding-up-the-command-pattern-up" >Rounding-up the Command pattern up</h4>
<div class="hBody-4" >
<p>Command is a very tiny design pattern; its functionality is quite easy to understand but it&#39;s widely used for its simplicity. It looks very similar to the Strategy pattern but remember that Strategy is about having many algorithms to achieve some specific task, but all of them achieve the same task. In the Command pattern, you have many tasks to execute, and not all of them need to be equal.</p>
<p>So, in short, the Command pattern is about execution encapsulation and delegation so that just the receiver or receivers trigger that execution.</p>
</div>
<h3 id="summary" >Summary</h3>
<div class="hBody-3" >
<p>We have taken our first steps in the Behavioral patterns. The objective of this chapter was to introduce the reader to the concept of algorithm and execution encapsulation using proper interfaces and structures. With the strategy, we have encapsulated algorithms, with the chain of responsibility handlers and with the Command design pattern executions.</p>
<p>Now, with the knowledge we have acquired about the strategy pattern, we can uncouple heavily our applications from their algorithms, just for testing, this is a very useful feature to inject mocks in different types that would be almost impossible to test. But also for anything that could need different approaches based on some context (such as shorting a list; some algorithms perform better depending on the distribution of the list).</p>
<p>The Chain of Responsibility pattern opens the door of middleware of any type and plugin-like libraries to improve the functionality of some part. Many open source projects uses a Chain of Responsibility to handler HTTP requests and responses to extract information to the end user (such as cookies info) or check authentication details (I&#39;ll let you pass to the next link only if I have you on my database).</p>
<p>Finally, the Command pattern is the most common pattern for UI handling but also very useful in many other scenarios where we need some type of handling between many unrelated types that are travelling through the code (such as a message passed through a channel).</p>
</div>
<h2 id="chapter-6" >Behavioral Patterns - Template, Memento, and Interpreter Design Patterns</h2>
<div class="hBody-2" >
<p>In this chapter, we will see the next three Behavioral design patterns. The difficulty is being raised as now we will use combinations of Structural and Creational patterns to better solve the objective of some of the Behavioral patterns.</p>
<p>We will start with Template design pattern, a pattern that looks very similar to the Strategy pattern but that provides greater flexibility. Memento design pattern is used in 99% of applications we use every day to achieve undo functions and transactional operations. Finally, we will write a reverse polish notation interpreter to perform simple mathematical operations.</p>
<p>Let&#39;s start with the Template design pattern.</p>
</div>
<h3 id="template-design-pattern" >Template design pattern</h3>
<div class="hBody-3" >
<p>The <b>Template</b> pattern is one of those widely used patterns that are incredibly useful, especially when writing libraries and frameworks. The idea is to provide a user some way to execute code within an algorithm. In this section, we will see how to write idiomatic Go Template patterns and see some Go source code where it&#39;s wisely used. We will write an algorithm of three steps where the second step is delegated to the user while the first and third aren&#39;t. The first and third steps on the algorithm represent the template.</p>
</div>
<h4 id="description" >Description</h4>
<div class="hBody-4" >
<p>While with the Strategy pattern we were encapsulating algorithm implementation in different strategies, with the Template pattern we will try to achieve something similar but with just part of the algorithm.</p>
<p>The Template design pattern lets the user write a part of an algorithm while the rest is executed by the abstraction. This is common when creating libraries to ease in some complex task or when reusability of some algorithm is compromised by only a part of it.</p>
<p>Imagine, for example, that we have a long transaction of HTTP requests. We have to perform the following steps:</p>
<ol class="num" >
<li>
<p>Authenticate user.</p>
</li>
<li>
<p>Authorize him.</p>
</li>
<li>
<p>Retrieve some details from a database.</p>
</li>
<li>
<p>Make some modification.</p>
</li>
<li>
<p>Send the details back in a new request.</p>
</li>
</ol>
<p>It wouldn&#39;t make sense to repeat steps 1 to 5 in the user&#39;s code every time he needs to modify something on the database. Instead, steps 1, 2, 3, and 5 will be abstracted in the same algorithm that receives an interface with whatever the fifth step needs to finish the transaction. It doesn&#39;t need to be a interface either, it could be a callback.</p>
</div>
<h4 id="objectives" >Objectives</h4>
<div class="hBody-4" >
<p>The Template design pattern is all about reusability and giving responsibilities to the user. So the objectives for this pattern are following:</p>
<ul>
<li>
<p>Defer a part of an algorithm of the library to a the user</p>
</li>
<li>
<p>Improve reusability by abstracting the parts of the code that are not common between executions</p>
</li>
</ul>
</div>
<h4 id="example---a-simple-algorithm-with-a-deferred-step" >Example - a simple algorithm with a deferred step</h4>
<div class="hBody-4" >
<p>In our first example, we are going to write an algorithm that is composed of three steps and each of them returns a message. The first and third steps are controlled by the Template and just the second step is deferred to the user.</p>
</div>
<h4 id="requirements-and-acceptance-criteria" >Requirements and acceptance criteria</h4>
<div class="hBody-4" >
<p>A brief description of what the Template pattern has to do is to define a template for an algorithm of three steps that defers the implementation of the second step to the user:</p>
<ol class="num" >
<li>
<p>Each step in the algorithm must return a string.</p>
</li>
<li>
<p>The first step is a method called <code>first()</code> and returns the string <code>hello</code>.</p>
</li>
<li>
<p>The third step is a method called <code>third()</code> and returns the string <code>template</code>.</p>
</li>
<li>
<p>The second step is whatever string the user wants to return but it&#39;s defined by the <code>MessageRetriever</code> interface that has a <code>Message() string</code> method.</p>
</li>
<li>
<p>The algorithm is executed sequentially by a method called <code>ExecuteAlgorithm</code> and returns the strings returned by each step joined in a single string by a space.</p>
</li>
</ol>
</div>
<h4 id="unit-tests-for-the-simple-algorithm" >Unit tests for the simple algorithm</h4>
<div class="hBody-4" >
<p>We will focus on testing the public methods only. This is a very common approach. All in all, if your private methods aren&#39;t called from some level of the public ones, they aren&#39;t called at all. We need two interfaces here, one for the Template implementors and one for the abstract step of the algorithm:</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">MessageRetriever</span> <span class="kd">interface</span> <span class="p">{</span>
  <span class="nx">Message</span><span class="p">()</span><span class="kt">string</span>
<span class="p">}</span>
<span class="kd">type</span> <span class="nx">Template</span> <span class="kd">interface</span> <span class="p">{</span>
   <span class="nx">first</span><span class="p">()</span> <span class="kt">string</span>
   <span class="nx">third</span><span class="p">()</span> <span class="kt">string</span>
   <span class="nx">ExecuteAlgorithm</span><span class="p">(</span><span class="nx">MessageRetriever</span><span class="p">)</span> <span class="kt">string</span>
<span class="p">}</span>
</code></pre>
<p>A Template implementor will accept a <code>MessageRetriever</code> interface to execute as part of its execution algorithm. We need a type that implements this interface called Template, we will call it <code>TemplateImpl</code>:</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">TemplateImpl</span> <span class="kd">struct</span><span class="p">{}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">TemplateImpl</span><span class="p">)</span> <span class="nx">first</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
  <span class="k">return</span> <span class="s">&#34;&#34;</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">TemplateImpl</span><span class="p">)</span> <span class="nx">third</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
  <span class="k">return</span> <span class="s">&#34;&#34;</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">TemplateImpl</span><span class="p">)</span> <span class="nx">ExecuteAlgorithm</span><span class="p">(</span><span class="nx">m</span> <span class="nx">MessageRetriever</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
  <span class="k">return</span> <span class="s">&#34;&#34;</span>
<span class="p">}</span>
</code></pre>
<p>So our first test checks the fourth and fifth acceptance criteria. We will create the <code>TestStruct</code> type that implements the <code>MessageRetriever</code> interface returning the string <code>world</code> and has embedded the Template so that it can call the <code>ExecuteAlgorithm</code> method. It will act as the Template and the abstraction:</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">TestStruct</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">Template</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">TestStruct</span><span class="p">)</span> <span class="nx">Message</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
  <span class="k">return</span> <span class="s">&#34;world&#34;</span>
<span class="p">}</span>
</code></pre>
<p>First, we will define the <code>TestStruct</code> type. In this case, the part of the algorithm deferred to us is going to return the <code>world</code> text. This is the string we will look for later in the test doing a check of type &#34;is the word <code>world</code> present on this string?&#34;.</p>
<p>Take a close look, the <code>TestStruct</code> embeds a type called <code>Template</code> which represents the Template pattern of our algorithm.</p>
<p>When we implement the <code>Message()</code> method, we are implicitly implementing the <code>MessageRetriever</code> interface. So now we can use <code>TestStruct</code> type as a pointer to a <code>MessageRetriever</code> interface:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">TestTemplate_ExecuteAlgorithm</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">t</span><span class="p">.</span><span class="nx">Run</span><span class="p">(</span><span class="s">&#34;Using interfaces&#34;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">){</span>
    <span class="nx">s</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">TestStruct</span><span class="p">{}</span>
    <span class="nx">res</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">ExecuteAlgorithm</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
    <span class="nx">expected</span> <span class="o">:=</span> <span class="s">&#34;world&#34;</span>

    <span class="k">if</span> <span class="p">!</span><span class="nx">strings</span><span class="p">.</span><span class="nx">Contains</span><span class="p">(</span><span class="nx">res</span><span class="p">,</span> <span class="nx">expected</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">t</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&#34;Expected string &#39;%s&#39; wasn&#39;t found on returned string\n&#34;</span><span class="p">,</span> <span class="nx">expected</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">})</span>
<span class="p">}</span>
</code></pre>
<p>In the test, we will use the type we have just created. When we call the <code>ExecuteAlgorithm</code> method, we need to pass the <code>MessageRetriever</code> interface. As the <code>TestStruct</code> type also implements the <code>MessageRetriever</code> interface, we can pass it as an argument, but this is not mandatory, of course.</p>
<p>The result of the <code>ExecuteAlgorithm</code> method, as defined in the fifth acceptance criterion, must return a string that contains the returned value of the <code>first()</code> method, the returned value of <code>TestStruct</code> (the <code>world</code> string) and the returned value of the <code>third()</code> method separated by a space. Our implementation is on the second place; that&#39;s why we checked that a space is prefixed and suffixed on the string <code>world</code>.</p>
<p>So, if the returned string, when calling the <code>ExecuteAlgorithm</code> method, doesn&#39;t contain the string <code>world</code>, the test fails.</p>
<p>This is enough to make the project compile and run the tests that should fail:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go <span class="nb">test</span> -v .
</span><span class="out" >=== RUN   TestTemplate_ExecuteAlgorithm
=== RUN   TestTemplate_ExecuteAlgorithm/Using_interfaces
--- FAIL: TestTemplate_ExecuteAlgorithm (0.00s)
    --- FAIL: TestTemplate_ExecuteAlgorithm/Using_interfaces (0.00s)
      template_test.go:47: Expected string &#39; world &#39; was not found on returned string
FAIL
exit status 1
FAIL
</span></code></pre>
<p>Time to pass to the implementation of this pattern.</p>
</div>
<h4 id="implementing-the-template-pattern" >Implementing the Template pattern</h4>
<div class="hBody-4" >
<p>As defined in the acceptance criteria, we have to return the string hello in the <code>first()</code> method and the string <code>template</code> in the <code>third()</code> method. That&#39;s pretty easy to implement:</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">Template</span> <span class="kd">struct</span><span class="p">{}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">Template</span><span class="p">)</span> <span class="nx">first</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
  <span class="k">return</span> <span class="s">&#34;hello&#34;</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">Template</span><span class="p">)</span> <span class="nx">third</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
  <span class="k">return</span> <span class="s">&#34;template&#34;</span>
<span class="p">}</span>
</code></pre>
<p>With this implementation, we should be covering the <i>second</i> and <i>third</i> acceptance criteria and partially covering the <i>first</i> criterion (each step in the algorithm must return a string).</p>
<p>To cover the <i>fifth</i> acceptance criterion, we define an <code>ExecuteAlgorithm</code> method that accepts the <code>MessageRetriever</code> interface as argument and returns the full algorithm: a single string done by joining the strings returned by the <code>first()</code>, <code>Message()</code> string and <code>third()</code> methods:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">Template</span><span class="p">)</span> <span class="nx">ExecuteAlgorithm</span><span class="p">(</span><span class="nx">m</span> <span class="nx">MessageRetriever</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">strings</span><span class="p">.</span><span class="nx">Join</span><span class="p">([]</span><span class="kt">string</span><span class="p">{</span><span class="nx">t</span><span class="p">.</span><span class="nx">first</span><span class="p">(),</span> <span class="nx">m</span><span class="p">.</span><span class="nx">Message</span><span class="p">(),</span> <span class="nx">t</span><span class="p">.</span><span class="nx">third</span><span class="p">()},</span>  <span class="s">&#34; &#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
<p>The <code>strings.Join</code> function has the following signature:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">Join</span><span class="p">([]</span><span class="kt">string</span><span class="p">,</span><span class="kt">string</span><span class="p">)</span> <span class="kt">string</span>
</code></pre>
<p>It takes an array of strings and joins them, placing the second argument between each item in the array. In our case, we create a string array on the fly to pass it as the first argument. Then we pass a whitespace as the second argument.</p>
<p>With this implementation, the tests must be passing already:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go <span class="nb">test</span> -v .
</span><span class="out" >=== RUN   TestTemplate_ExecuteAlgorithm
=== RUN   TestTemplate_ExecuteAlgorithm/Using_interfaces
--- PASS: TestTemplate_ExecuteAlgorithm (0.00s)
    --- PASS: TestTemplate_ExecuteAlgorithm/Using_interfaces (0.00s)
PASS
ok
</span></code></pre>
<p>The tests passed. The test has checked that the string <code>world</code> is present in the returned result, which is the <code>hello world template</code> message. The <code>hello</code> text was the string returned by the <code>first()</code> method, the <code>world</code> string was returned by our <code>MessageRetriever</code> implementation, and <code>template</code> was the string returned by the <code>third()</code> method. The whitespaces are inserted by Go&#39;s <code>strings.Join</code> function. But any use of the <code>TemplateImpl.ExecuteAlgorithm</code> type will always return <q>hello [something] template</q> in its result.</p>
</div>
<h4 id="anonymous-functions" >Anonymous functions</h4>
<div class="hBody-4" >
<p>This is not the only way to achieve the Template design pattern. We can also use an anonymous function to give our implementation to the <code>ExecuteAlgorithm</code> method.</p>
<p>Let&#39;s write a test in the same method that was used previously just after the test:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">TestTemplate_ExecuteAlgorithm</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">t</span><span class="p">.</span><span class="nx">Run</span><span class="p">(</span><span class="s">&#34;Using interfaces&#34;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">){</span>
    <span class="nx">s</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">TestStruct</span><span class="p">{}</span>
    <span class="nx">res</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">ExecuteAlgorithm</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>

    <span class="nx">expectedOrError</span><span class="p">(</span><span class="nx">res</span><span class="p">,</span> <span class="s">&#34; world &#34;</span><span class="p">,</span> <span class="nx">t</span><span class="p">)</span>
  <span class="p">})</span>

  <span class="nx">t</span><span class="p">.</span><span class="nx">Run</span><span class="p">(</span><span class="s">&#34;Using anonymous functions&#34;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>

    <span class="nx">m</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">AnonymousTemplate</span><span class="p">)</span>

    <span class="nx">res</span> <span class="o">:=</span> <span class="nx">m</span><span class="p">.</span><span class="nx">ExecuteAlgorithm</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
      <span class="k">return</span> <span class="s">&#34;world&#34;</span>
    <span class="p">})</span>

    <span class="nx">expectedOrError</span><span class="p">(</span><span class="nx">res</span><span class="p">,</span> <span class="s">&#34; world &#34;</span><span class="p">,</span> <span class="nx">t</span><span class="p">)</span>
  <span class="p">})</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">expectedOrError</span><span class="p">(</span><span class="nx">res</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">expected</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">!</span><span class="nx">strings</span><span class="p">.</span><span class="nx">Contains</span><span class="p">(</span><span class="nx">res</span><span class="p">,</span> <span class="nx">expected</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">t</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&#34;Expected string &#39;%s&#39; was not found on returned string\n&#34;</span><span class="p">,</span> <span class="nx">expected</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>Our new test is called <i>Using anonymous functions</i>. We have also extracted the checking on the test to an external function to reuse it in this test. We have called this function <code>expectedOrError</code> because it will fail with an error if the expected value isn&#39;t received.</p>
<p>In our test, we will create a type called <code>AnonymousTemplate</code> that replaces the previous <code>Template</code> type. The <code>ExecuteAlgorithm</code> method of this new type accepts the <code>func()</code> method <code>string</code> type that we can implement directly in the test to return the string <code>world</code>.</p>
<p>The <code>AnonymousTemplate</code> type will have the following structure:</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">AnonymousTemplate</span> <span class="kd">struct</span><span class="p">{}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">AnonymousTemplate</span><span class="p">)</span> <span class="nx">first</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
  <span class="k">return</span> <span class="s">&#34;&#34;</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">AnonymousTemplate</span><span class="p">)</span> <span class="nx">third</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
  <span class="k">return</span> <span class="s">&#34;&#34;</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">AnonymousTemplate</span><span class="p">)</span> <span class="nx">ExecuteAlgorithm</span><span class="p">(</span><span class="nx">f</span> <span class="kd">func</span><span class="p">()</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
  <span class="k">return</span> <span class="s">&#34;&#34;</span>
<span class="p">}</span>
</code></pre>
<p>The only difference with the <code>Template</code> type is that the <code>ExecuteAlgorithm</code> method accepts a function that returns a string instead of a <code>MessageRetriever</code> interface. Let&#39;s run the new test:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go <span class="nb">test</span> -v .
</span><span class="out" >=== RUN   TestTemplate_ExecuteAlgorithm
=== RUN   TestTemplate_ExecuteAlgorithm/Using_interfaces
=== RUN   TestTemplate_ExecuteAlgorithm/Using_anonymous_functions
--- FAIL: TestTemplate_ExecuteAlgorithm (0.00s)
    --- PASS: TestTemplate_ExecuteAlgorithm/Using_interfaces (0.00s)
    --- FAIL: TestTemplate_ExecuteAlgorithm/Using_anonymous_functions (0.00s)
      template_test.go:47: Expected string &#39; world &#39; was not found on returned string
FAIL
exit status 1
FAIL
</span></code></pre>
<p>As you can read in the output of the test execution, the error is thrown on the <i>Using anonymous functions</i> test, which is what we were expecting. Now we will write the implementation as follows:</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">AnonymousTemplate</span> <span class="kd">struct</span><span class="p">{}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">AnonymousTemplate</span><span class="p">)</span> <span class="nx">first</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
  <span class="k">return</span> <span class="s">&#34;hello&#34;</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">AnonymousTemplate</span><span class="p">)</span> <span class="nx">third</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
  <span class="k">return</span> <span class="s">&#34;template&#34;</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">AnonymousTemplate</span><span class="p">)</span> <span class="nx">ExecuteAlgorithm</span><span class="p">(</span><span class="nx">f</span> <span class="kd">func</span><span class="p">()</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">strings</span><span class="p">.</span><span class="nx">Join</span><span class="p">([]</span><span class="kt">string</span><span class="p">{</span><span class="nx">a</span><span class="p">.</span><span class="nx">first</span><span class="p">(),</span> <span class="nx">f</span><span class="p">(),</span> <span class="nx">a</span><span class="p">.</span><span class="nx">third</span><span class="p">()},</span> <span class="s">&#34; &#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
<p>The implementation is quite similar to the one in the <code>Template</code> type. However, now we have passed a function called <code>f</code> that we will use as the second item in the string array we used on <code>Join</code> function. As <code>f</code> is simply a function that returns a string, the only thing we need to do with it is to execute it in the proper place (the second position in the array). Run the tests again:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go <span class="nb">test</span> -v .
</span><span class="out" >=== RUN   TestTemplate_ExecuteAlgorithm
=== RUN   TestTemplate_ExecuteAlgorithm/Using_interfaces
=== RUN   TestTemplate_ExecuteAlgorithm/Using_anonymous_functions
--- PASS: TestTemplate_ExecuteAlgorithm (0.00s)
    --- PASS: TestTemplate_ExecuteAlgorithm/Using_interfaces (0.00s)
    --- PASS: TestTemplate_ExecuteAlgorithm/Using_anonymous_functions (0.00s)
PASS
ok
</span></code></pre>
<p>Awesome! Now we know two ways to implement the Template design pattern.</p>
</div>
<h4 id="how-to-avoid-modifications-on-the-interface" >How to avoid modifications on the interface</h4>
<div class="hBody-4" >
<p>The problem of the previous approach is that now we have two templates to maintain and we could end duplicating code. What can we do in the situation that we cannot change the interface are we using? Our interface was <code>MessageRetriever</code> but we want to use an anonymous function now.</p>
<p>Well, do you remember the Adapter design pattern? We just have to create an <code>Adapter</code> type that, accepting a <code>func() string</code> type, returns an implementation of the <code>MessageRetriever</code> interface. We will call this type <code>TemplateAdapter</code>:</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">TemplateAdapter</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">myFunc</span> <span class="kd">func</span><span class="p">()</span> <span class="kt">string</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">TemplateAdapter</span><span class="p">)</span> <span class="nx">Message</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
  <span class="k">return</span> <span class="s">&#34;&#34;</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">MessageRetrieverAdapter</span><span class="p">(</span><span class="nx">f</span> <span class="kd">func</span><span class="p">()</span> <span class="kt">string</span><span class="p">)</span> <span class="nx">MessageRetriever</span> <span class="p">{</span>
  <span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre>
<p>As you can see, the <code>TemplateAdapter</code> type has a field called <code>myFunc</code> which is of type <code>func() string</code>. We have also defined adapter as private because it shouldn&#39;t be used without a function defined in the <code>myFunc</code> field. We have created a public function called the <code>MessageRetrieverAdapter</code> to achieve this. Our test should look more or less like this:</p>
<pre class="code" ><code class="chroma" ><span class="nx">t</span><span class="p">.</span><span class="nx">Run</span><span class="p">(</span><span class="s">&#34;Using anonymous functions adapted to an interface&#34;</span><span class="p">,</span>
  <span class="kd">func</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">){</span>
    <span class="nx">messageRetriever</span> <span class="o">:=</span> <span class="nx">MessageRetrieverAdapter</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
      <span class="k">return</span> <span class="s">&#34;world&#34;</span>
    <span class="p">})</span>

    <span class="k">if</span> <span class="nx">messageRetriever</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
      <span class="nx">t</span><span class="p">.</span><span class="nx">Fatal</span><span class="p">(</span><span class="s">&#34;Can not continue with a nil MessageRetriever&#34;</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="nx">template</span> <span class="o">:=</span> <span class="nx">Template</span><span class="p">{}</span>
    <span class="nx">res</span> <span class="o">:=</span> <span class="nx">template</span><span class="p">.</span><span class="nx">ExecuteAlgorithm</span><span class="p">(</span><span class="nx">messageRetriever</span><span class="p">)</span>

    <span class="nx">expectedOrError</span><span class="p">(</span><span class="nx">res</span><span class="p">,</span> <span class="s">&#34; world &#34;</span><span class="p">,</span> <span class="nx">t</span><span class="p">)</span>
  <span class="p">})</span>
</code></pre>
<p>Look at the statement where we called the <code>MessageRetrieverAdapter</code> method. We passed an anonymous function as an argument defined as <code>func()</code> string. Then, we reuse the previously defined <code>Template</code> type from our first test to pass the <code>messageRetriever</code> variable. Finally, we checked again with the <code>expectedOrError</code> method. Take a look at the <code>MessageRetrieverAdapter</code> method, it will return a function that has nil value. If strictly following the test-driven development rules, we must do tests first and they must not pass before implementation is done. That&#39;s why we returned nil on the <code>MessageRetrieverAdapter</code> function.</p>
<p>So, let&#39;s run the tests:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go <span class="nb">test</span> -v .
</span><span class="out" >=== RUN   TestTemplate_ExecuteAlgorithm
=== RUN   TestTemplate_ExecuteAlgorithm/Using_interfaces
=== RUN   TestTemplate_ExecuteAlgorithm/Using_anonymous_functions
=== RUN   TestTemplate_ExecuteAlgorithm/Using_anonymous_functions_adapted_to_an_interface
--- FAIL: TestTemplate_ExecuteAlgorithm (0.00s)
    --- PASS: TestTemplate_ExecuteAlgorithm/Using_interfaces (0.00s)
    --- PASS: TestTemplate_ExecuteAlgorithm/Using_anonymous_functions (0.00s)
    --- FAIL: TestTemplate_ExecuteAlgorithm/Using_anonymous_functions_adapted_to_an_interface (0.00s)
      template_test.go:39: Can not continue with a nil
MessageRetriever
FAIL
exit status 1
FAIL
</span></code></pre>
<p>The test fails on <i>line 39</i> of the code and it doesn&#39;t continue (again, depending on how you wrote your code, the line representing your error could be somewhere else). We stop test execution because we will need a valid <code>MessageRetriever</code> interface when we call the <code>ExecuteAlgorithm</code> method.</p>
<p>For the implementation of the adapter for our Template pattern, we will start with <code>MessageRetrieverAdapter</code> method:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">MessageRetrieverAdapter</span><span class="p">(</span><span class="nx">f</span> <span class="kd">func</span><span class="p">()</span> <span class="kt">string</span><span class="p">)</span> <span class="nx">MessageRetriever</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="o">&amp;</span><span class="nx">adapter</span><span class="p">{</span><span class="nx">myFunc</span><span class="p">:</span> <span class="nx">f</span><span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>It&#39;s very easy, right? You could be wondering what happens if we pass <code>nil</code> value for the <code>f</code> argument. Well, we will cover this issue by calling the <code>myFunc</code> function.</p>
<p>The <code>adapter</code> type is finished with this implementation:</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">adapter</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">myFunc</span> <span class="kd">func</span><span class="p">()</span> <span class="kt">string</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">adapter</span><span class="p">)</span> <span class="nx">Message</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
  <span class="k">if</span> <span class="nx">a</span><span class="p">.</span><span class="nx">myFunc</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">a</span><span class="p">.</span><span class="nx">myFunc</span><span class="p">()</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="s">&#34;&#34;</span>
<span class="p">}</span>
</code></pre>
<p>When calling the <code>Message()</code> function, we check that we actually have something stored in the <code>myFunc</code> function before calling. If nothing was stored, we return an empty string.</p>
<p>Now, our third implementation of the <code>Template</code> type, using the Adapter pattern, is done:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go <span class="nb">test</span> -v .
</span><span class="out" >=== RUN   TestTemplate_ExecuteAlgorithm
=== RUN   TestTemplate_ExecuteAlgorithm/Using_interfaces
=== RUN   TestTemplate_ExecuteAlgorithm/Using_anonymous_functions
=== RUN   TestTemplate_ExecuteAlgorithm/Using_anonymous_functions_adapted_to_an_interface
--- PASS: TestTemplate_ExecuteAlgorithm (0.00s)
    --- PASS: TestTemplate_ExecuteAlgorithm/Using_interfaces (0.00s)
    --- PASS: TestTemplate_ExecuteAlgorithm/Using_anonymous_functions (0.00s)
    --- PASS: TestTemplate_ExecuteAlgorithm/Using_anonymous_functions_adapted_to_an_interface (0.00s)
PASS
ok
</span></code></pre>
</div>
<h4 id="looking-for-the-template-pattern-in-go&#39;s-source-code" >Looking for the Template pattern in Go&#39;s source code</h4>
<div class="hBody-4" >
<p>The <code>sort</code> package in Go&#39;s source code can be considered a Template implementation of a sort algorithm. As defined in the package itself, the <code>sort</code> package provides primitives for sorting slices and user-defined collections.</p>
<p>Here, we can also find a good example of why Go authors aren&#39;t worried about implementing generics. Sorting the lists is maybe the best example of generic usage in other languages. The way that Go deals with this is very elegant too-it deals with this issue with an interface:</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">Interface</span> <span class="kd">interface</span> <span class="p">{</span>
  <span class="nx">Len</span><span class="p">()</span> <span class="kt">int</span>
  <span class="nx">Less</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span>
  <span class="nx">Swap</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="kt">int</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
<p>This is the interface for lists that need to be sorted by using the sort package. In the words of Go&#39;s authors:</p>
<blockquote>
<p><i>&#34;A type, typically, is a collection that satisfies sort. Interface can be sorted by the routines in this package. The methods require that the elements of the collection be enumerated by an integer index.&#34;</i></p>
</blockquote>
<p>In other words, write a type that implements this <code>Interface</code> so that the <code>sort</code> package can be used to sort any slice. The sorting algorithm is the template and we must define how to retrieve values in our slice.</p>
<p>If we peek in the <code>sort</code> package, we can also find an example of how to use the sorting template but we will create our own example:</p>
<pre class="code" ><code class="chroma" ><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
  <span class="s">&#34;sort&#34;</span>
  <span class="s">&#34;fmt&#34;</span>
<span class="p">)</span>

<span class="kd">type</span> <span class="nx">MyList</span> <span class="p">[]</span><span class="kt">int</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="nx">MyList</span><span class="p">)</span> <span class="nx">Len</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="nx">m</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="nx">MyList</span><span class="p">)</span> <span class="nx">Swap</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">m</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="nx">m</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="nx">m</span><span class="p">[</span><span class="nx">j</span><span class="p">],</span> <span class="nx">m</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="nx">MyList</span><span class="p">)</span> <span class="nx">Less</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">m</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">&lt;</span> <span class="nx">m</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span>
<span class="p">}</span>
</code></pre>
<p>First, we have done a very simple type that stores an int list. This could be any kind of list, usually a list of some kind of struct. Then we have implemented the <code>sort.Interface</code> interface by defining the <code>Len</code>, <code>Swap</code>, and <code>Less</code> methods.</p>
<p>Finally, the <code>main</code> function creates an unordered list of numbers of the <code>MyList</code> type:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">myList</span> <span class="nx">MyList</span> <span class="p">=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">6</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">1</span><span class="p">}</span>

  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">myList</span><span class="p">)</span>
  <span class="nx">sort</span><span class="p">.</span><span class="nx">Sort</span><span class="p">(</span><span class="nx">myList</span><span class="p">)</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">myList</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
<p>We print the list that we created (unordered) and then we sort it (the <code>sort.Sort</code> method actually modifies our variable instead of returning a new list so beware!). Finally, we print again the resulting list. The console output of this <code>main</code> method is the following:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go run sort_example.go
</span><span class="out" >[6 4 2 8 1]
[1 2 4 6 8]
</span></code></pre>
<p>The <code>sort.Sort</code> function has sorted our list in a transparent way. It has a lot of code written and delegates <code>Len</code>, <code>Swap</code> and <code>Less</code> methods to an interface, like we did in our template delegating to the <code>MessageRetriever</code> interface.</p>
</div>
<h4 id="summarizing-the-template-design-pattern" >Summarizing the Template design pattern</h4>
<div class="hBody-4" >
<p>We wanted to put a lot of focus on this pattern because it is very important when developing libraries and frameworks and allows a lot of flexibility and control to users of our library.</p>
<p>We have also seen again that it&#39;s very common to mix patterns to provide flexibility to the users, not only in a behavioral way but also structural. This will come very handy when working with concurrent apps where we need to restrict access to parts of our code to avoid races.</p>
</div>
<h3 id="memento-design-pattern" >Memento design pattern</h3>
<div class="hBody-3" >
<p>Let&#39;s now look at a pattern with a fancy name. If we check a dictionary to see the meaning of <i>memento</i>, we will find the following description:</p>
<blockquote>
<p><i>&#34;An object kept as a reminder of a person or event.&#34;</i></p>
</blockquote>
<p>Here, the key word is <b>reminder</b> as we will remember actions with this design pattern.</p>
</div>
<h4 id="description" >Description</h4>
<div class="hBody-4" >
<p>The meaning of memento is very similar to the functionality it provides in design patterns. Basically, we&#39;ll have a type with some state and we want to be able to save milestones of its state. Having a finite amount of states saved, we can recover them if necessary for a variety of tasks-undo operations, historic, and so on.</p>
<p>The Memento design pattern usually has three players (usually called <b>actors</b>):</p>
<ul>
<li>
<p><b>Memento</b>: A type that stores the type we want to save. Usually, we won&#39;t store the business type directly and we provide an extra layer of abstraction through this type.</p>
</li>
<li>
<p><b>Originator</b>: A type that is in charge of creating mementos and storing the current active state. We said that the Memento type wraps states of the business type and we use originator as the creator of mementos.</p>
</li>
<li>
<p><b>Care Taker</b>: A type that stores the list of mementos that can have the logic to store them in a database or to not store more than a specified number of them.</p>
</li>
</ul>
</div>
<h4 id="objectives" >Objectives</h4>
<div class="hBody-4" >
<p>Memento is all about a sequence of actions over time, say to undo one or two operations or to provide some kind of transactionality to some application.</p>
<p>Memento provides the foundations for many tasks, but its main objectives could be defined as follows:</p>
<ul>
<li>
<p>Capture an object state without modifying the object itself</p>
</li>
<li>
<p>Save a limited amount of states so we can retrieve them later</p>
</li>
</ul>
</div>
<h4 id="a-simple-example-with-strings" >A simple example with strings</h4>
<div class="hBody-4" >
<p>We will develop a simple example using a string as the state we want to save. This way, we will focus on the common Memento pattern implementations before making it a bit more complex with a new example.</p>
<p>The string, stored in a field of a <code>State</code> instance, will be modified and we will be able to undo the operations done in this state.</p>
</div>
<h4 id="requirements-and-acceptance-criteria" >Requirements and acceptance criteria</h4>
<div class="hBody-4" >
<p>We are constantly talking about state; all in all, the Memento pattern is about storing and retrieving states. Our acceptance criteria must be all about states:</p>
<ol class="num" >
<li>
<p>We need to store a finite amount of states of type string.</p>
</li>
<li>
<p>We need a way to restore the current stored state to one of the state list.</p>
</li>
</ol>
<p>With these two simple requirements, we can already start writing some tests for this example.</p>
</div>
<h4 id="unit-test" >Unit test</h4>
<div class="hBody-4" >
<p>As mentioned previously, the Memento design pattern is usually composed of three actors: state, memento, and originator. So we will need three types to represent these actors:</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">State</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">Description</span> <span class="kt">string</span>
<span class="p">}</span>
</code></pre>
<p>The <code>State</code> type is the core business object we will be using during this example. It&#39;s any kind of object that we want to track:</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">memento</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">state</span> <span class="nx">State</span>
<span class="p">}</span>
</code></pre>
<p>The <code>memento</code> type has a field called <code>state</code> representing a single value of a <code>State</code> type. Our <code>states</code> will be containerized within this type before storing them into the <code>care taker</code> type. You could be wondering why we don&#39;t store directly <code>State</code> instances. Basically, because it will couple the <code>originator</code> and the <code>careTaker</code> to the business object and we want to have as little coupling as possible. It will also be less flexible, as we will see in the second example:</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">originator</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">state</span> <span class="nx">State</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">o</span> <span class="o">*</span><span class="nx">originator</span><span class="p">)</span> <span class="nx">NewMemento</span><span class="p">()</span> <span class="nx">memento</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">memento</span><span class="p">{}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">o</span> <span class="o">*</span><span class="nx">originator</span><span class="p">)</span> <span class="nx">ExtractAndStoreState</span><span class="p">(</span><span class="nx">m</span> <span class="nx">memento</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Does nothing
</span><span class="c1"></span><span class="p">}</span>
</code></pre>
<p>The <code>originator</code> type also stores a state. The <code>originator</code> struct&#39;s objects will take states from mementos and create new mementos with their stored state.</p>
<div class="about" >
<div class="about-dt" >Tip</div>
<div class="about-dd" >
<p>What&#39;s the difference between the originator object and the Memento pattern? Why don&#39;t we use Originator pattern&#39;s object directly? Well, if the Memento contains a specific state, the <code>originator</code> type contains the state that is currently loaded. Also, to save the state of something could be as simple as to take some value or as complex as to maintain the state of some distributed application.</p>
</div>
</div>
<p>The Originator will have two public methods--the <code>NewMemento</code>() method and the <code>ExtractAndStoreState(m memento)</code> method. The <code>NewMemento</code> method will return a new Memento built with <code>originator</code> current <code>State</code> value. The <code>ExtractAndStoreState</code> method will take the state of a Memento and store it in the Originator&#39;s state field:</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">careTaker</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">mementoList</span> <span class="p">[]</span><span class="nx">memento</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">careTaker</span><span class="p">)</span> <span class="nx">Add</span><span class="p">(</span><span class="nx">m</span> <span class="nx">memento</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Does nothing
</span><span class="c1"></span><span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">careTaker</span><span class="p">)</span> <span class="nx">Memento</span><span class="p">(</span><span class="nx">i</span> <span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="nx">memento</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">memento</span><span class="p">{},</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&#34;Not implemented yet&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
<p>The <code>careTaker</code> type stores the Memento list with all the states we need to save. It also stores an <code>Add</code> method to insert a new Memento on the list and a Memento retriever that takes an index on the Memento list.</p>
<p>So let&#39;s start with the <code>Add</code> method of the <code>careTaker</code> type. The Add method must take a <code>memento</code> object and add it to the <code>careTaker</code> object&#39;s list of Mementos:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">TestCareTaker_Add</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">originator</span> <span class="o">:=</span> <span class="nx">originator</span><span class="p">{}</span>
  <span class="nx">originator</span><span class="p">.</span><span class="nx">state</span> <span class="p">=</span> <span class="nx">State</span><span class="p">{</span><span class="nx">Description</span><span class="p">:</span><span class="s">&#34;Idle&#34;</span><span class="p">}</span>

  <span class="nx">careTaker</span> <span class="o">:=</span> <span class="nx">careTaker</span><span class="p">{}</span>
  <span class="nx">mem</span> <span class="o">:=</span> <span class="nx">originator</span><span class="p">.</span><span class="nx">NewMemento</span><span class="p">()</span>
  <span class="k">if</span> <span class="nx">mem</span><span class="p">.</span><span class="nx">state</span><span class="p">.</span><span class="nx">Description</span> <span class="o">!=</span> <span class="s">&#34;Idle&#34;</span> <span class="p">{</span>
    <span class="nx">t</span><span class="p">.</span><span class="nx">Error</span><span class="p">(</span><span class="s">&#34;Expected state was not found&#34;</span><span class="p">)</span>
  <span class="p">}</span>
</code></pre>
<p>At the beginning of our test, we created two basic actors for memento--the <code>originator</code> and the <code>careTaker</code>. We set a first state on the originator with the description <code>Idle</code>.</p>
<p>Then, we create the first Memento calling the <code>NewMemento</code> method. This should wrap the current originator&#39;s state in a <code>memento</code> type. Our first check is very simple--the state description of the returned Memento must be like the state description we pass to the originator, that is, the <code>Idle</code> description.</p>
<p>The last step to check whether our Memento&#39;s <code>Add</code> method works correctly is to see whether the Memento list has grown after adding one item:</p>
<pre class="code" ><code class="chroma" ><span class="nx">currentLen</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">careTaker</span><span class="p">.</span><span class="nx">mementoList</span><span class="p">)</span>
<span class="nx">careTaker</span><span class="p">.</span><span class="nx">Add</span><span class="p">(</span><span class="nx">mem</span><span class="p">)</span>

<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">careTaker</span><span class="p">.</span><span class="nx">mementoList</span><span class="p">)</span> <span class="o">!=</span> <span class="nx">currentLen</span><span class="o">+</span><span class="mi">1</span> <span class="p">{</span>
  <span class="nx">t</span><span class="p">.</span><span class="nx">Error</span><span class="p">(</span><span class="s">&#34;No new elements were added on the list&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
<p>We also have to test the <code>Memento(int) memento</code> method. This should take a <code>memento</code> value from the <code>careTaker</code> list. It takes the index you want to retrieve from the list so, as usual with lists, we must check that it behaves correctly against negative numbers and out of index values:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">TestCareTaker_Memento</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">originator</span> <span class="o">:=</span> <span class="nx">originator</span><span class="p">{}</span>
  <span class="nx">careTaker</span> <span class="o">:=</span> <span class="nx">careTaker</span><span class="p">{}</span>

  <span class="nx">originator</span><span class="p">.</span><span class="nx">state</span> <span class="p">=</span> <span class="nx">State</span><span class="p">{</span><span class="s">&#34;Idle&#34;</span><span class="p">}</span>
  <span class="nx">careTaker</span><span class="p">.</span><span class="nx">Add</span><span class="p">(</span><span class="nx">originator</span><span class="p">.</span><span class="nx">NewMemento</span><span class="p">())</span>
</code></pre>
<p>We have to start like we did in our previous test--creating an <code>originator</code> and <code>careTaker</code> objects and adding the first Memento to the <code>caretaker</code>:</p>
<pre class="code" ><code class="chroma" ><span class="nx">mem</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">careTaker</span><span class="p">.</span><span class="nx">Memento</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
  <span class="nx">t</span><span class="p">.</span><span class="nx">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">if</span> <span class="nx">mem</span><span class="p">.</span><span class="nx">state</span><span class="p">.</span><span class="nx">Description</span> <span class="o">!=</span> <span class="s">&#34;Idle&#34;</span> <span class="p">{</span>
  <span class="nx">t</span><span class="p">.</span><span class="nx">Error</span><span class="p">(</span><span class="s">&#34;Unexpected state&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
<p>Once we have the first object on the <code>careTaker</code> object, we can ask for it using <code>careTaker.Memento(0)</code>. Index <code>0</code> on the <code>Memento(int)</code> method retrieves the first item on the slice (remember that slices start with <code>0</code>). No error should be returned because we have already added a value to the <code>caretaker</code> object.</p>
<p>Then, after retrieving the first memento, we checked that the description matches the one that we passed at the beginning of the test:</p>
<pre class="code" ><code class="chroma" >  <span class="nx">mem</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">careTaker</span><span class="p">.</span><span class="nx">Memento</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">t</span><span class="p">.</span><span class="nx">Fatal</span><span class="p">(</span><span class="s">&#34;An error is expected when asking for a negative number but no error was found&#34;</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>The last step on this test involves using a negative number to retrieve some value. In this case, an error must be returned that shows that no negative numbers can be used. It is also possible to return the first index when you pass negative numbers but here we will return an error.</p>
<p>The last function to check is the <code>ExtractAndStoreState</code> method. This function must take a Memento and extract all its state information to set it in the <code>Originator</code> object:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">TestOriginator_ExtractAndStoreState</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">originator</span> <span class="o">:=</span> <span class="nx">originator</span><span class="p">{</span><span class="nx">state</span><span class="p">:</span><span class="nx">State</span><span class="p">{</span><span class="s">&#34;Idle&#34;</span><span class="p">}}</span>
  <span class="nx">idleMemento</span> <span class="o">:=</span> <span class="nx">originator</span><span class="p">.</span><span class="nx">NewMemento</span><span class="p">()</span>

  <span class="nx">originator</span><span class="p">.</span><span class="nx">ExtractAndStoreState</span><span class="p">(</span><span class="nx">idleMemento</span><span class="p">)</span>
  <span class="k">if</span> <span class="nx">originator</span><span class="p">.</span><span class="nx">state</span><span class="p">.</span><span class="nx">Description</span> <span class="o">!=</span> <span class="s">&#34;Idle&#34;</span> <span class="p">{</span>
    <span class="nx">t</span><span class="p">.</span><span class="nx">Error</span><span class="p">(</span><span class="s">&#34;Unexpected state found&#34;</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>This test is simple. We create a default <code>originator</code> variable with an Idle state. Then, we retrieve a new Memento object to use it later. We change the state of the <code>originator</code> variable to the <code>Working</code> state to ensure that the new state will be written.</p>
<p>Finally, we have to call the <code>ExtractAndStoreState</code> method with the <code>idleMemento</code> variable. This should restore the state of the originator to the <code>idleMemento</code> state&#39;s value, something that we checked in the last if statement.</p>
<p>Now it&#39;s time to run the tests:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go <span class="nb">test</span> -v .
</span><span class="out" >=== RUN   TestCareTaker_Add
--- FAIL: TestCareTaker_Add (0.00s)
  memento_test.go:13: Expected state was not found
  memento_test.go:20: No new elements were added on the list
=== RUN   TestCareTaker_Memento
--- FAIL: TestCareTaker_Memento (0.00s)
  memento_test.go:33: Not implemented yet
=== RUN   TestOriginator_ExtractAndStoreState
--- FAIL: TestOriginator_ExtractAndStoreState (0.00s)
  memento_test.go:54: Unexpected state found
FAIL
exit status 1
FAIL
</span></code></pre>
<p>Because the three tests fail, we can continue with the implementation.</p>
</div>
<h4 id="implementing-the-memento-pattern" >Implementing the Memento pattern</h4>
<div class="hBody-4" >
<p>The Memento pattern&#39;s implementation is usually very simple if you don&#39;t get too crazy. The three actors (<code>memento</code>, <code>originator</code>, and <code>care taker</code>) have a very defined role in the pattern and their implementation is very straightforward:</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">originator</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">state</span> <span class="nx">State</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">o</span> <span class="o">*</span><span class="nx">originator</span><span class="p">)</span> <span class="nx">NewMemento</span><span class="p">()</span> <span class="nx">memento</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">memento</span><span class="p">{</span><span class="nx">state</span><span class="p">:</span> <span class="nx">o</span><span class="p">.</span><span class="nx">state</span><span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">o</span> <span class="o">*</span><span class="nx">originator</span><span class="p">)</span> <span class="nx">ExtractAndStoreState</span><span class="p">(</span><span class="nx">m</span> <span class="nx">memento</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">o</span><span class="p">.</span><span class="nx">state</span> <span class="p">=</span> <span class="nx">m</span><span class="p">.</span><span class="nx">state</span>
<span class="p">}</span>
</code></pre>
<p>The <code>Originator</code> object needs to return a new values of Memento types when calling the <code>NewMemento</code> method. It also needs to store the value of a <code>memento</code> object in the state field of the struct as needed for the <code>ExtractAndStoreState</code> method:</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">careTaker</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">mementoList</span> <span class="p">[]</span><span class="nx">memento</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">careTaker</span><span class="p">)</span> <span class="nx">Push</span><span class="p">(</span><span class="nx">m</span> <span class="nx">memento</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">c</span><span class="p">.</span><span class="nx">mementoList</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">mementoList</span><span class="p">,</span> <span class="nx">m</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">careTaker</span><span class="p">)</span> <span class="nx">Memento</span><span class="p">(</span><span class="nx">i</span> <span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="nx">memento</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">mementoList</span><span class="p">)</span> <span class="p">&lt;</span> <span class="nx">i</span> <span class="o">||</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">memento</span><span class="p">{},</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&#34;Index not found\n&#34;</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">c</span><span class="p">.</span><span class="nx">mementoList</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre>
<p>The <code>careTaker</code> type is also straightforward. When we call the <code>Add</code> method, we overwrite the <code>mementoList</code> field by calling the <code>append</code> method with the value passed in the argument. This creates a new list with the new value included.</p>
<p>When calling the <code>Memento</code> method, we have to do a couple of checks beforehand. In this case, we check that the index is not outside of the range of the slice and that the index is not a negative number in the if statement, in which case we return an error. If everything goes fine, it just returns the specified <code>memento</code> object and no errors.</p>
<div class="about" >
<div class="about-dt" >Tip</div>
<div class="about-dd" >
<p>A note about method and function naming conventions. You could find some people that like to give slightly more descriptive names to methods such as <code>Memento</code>. An example would be to use a name such as <code>MementoOrError</code> method, clearly showing that you return two objects when calling this function or even <code>GetMementoOrError</code> method. This could be a very explicit approach for naming and it&#39;s not necessarily bad, but you won&#39;t find it very common in Go&#39;s source code.</p>
</div>
</div>
<p>Time to check the test results:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go <span class="nb">test</span> -v .
</span><span class="out" >=== RUN   TestCareTaker_Add
--- PASS: TestCareTaker_Add (0.00s)
=== RUN   TestCareTaker_Memento
--- PASS: TestCareTaker_Memento (0.00s)
=== RUN   TestOriginator_ExtractAndStoreState
--- PASS: TestOriginator_ExtractAndStoreState (0.00s)
PASS
ok
</span></code></pre>
<p>That was enough to reach 100% of coverage. While this is far from being a perfect metric, at least we know that we are reaching every corner of our source code and that we haven&#39;t cheated in our tests to achieve it.</p>
</div>
<h4 id="another-example-using-the-command-and-facade-patterns" >Another example using the Command and Facade patterns</h4>
<div class="hBody-4" >
<p>The previous example is good and simple enough to understand the functionality of the Memento pattern. However, it is more commonly used in conjunction with the Command pattern and a simple Facade pattern.</p>
<p>The idea is to use a Command pattern to encapsulate a set of different types of states (those that implement a <code>Command</code> interface) and provide a small facade to automate the insertion in the <code>caretaker</code> object.</p>
<p>We are going to develop a small example of a hypothetical audio mixer. We are going to use the same Memento pattern to save two types of states: <code>Volume</code> and <code>Mute</code>. The <code>Volume</code> state is going to be a byte type and the <code>Mute</code> state a Boolean type. We will use two completely different types to show the flexibility of this approach (and its drawbacks).</p>
<p>As a side note, we can also ship each <code>Command</code> interface with their own serialization methods on the interface. This way, we can give the ability to the caretaker to store states in some kind of storage without really knowing what&#39;s storing.</p>
<p>Our <code>Command</code> interface is going to have one method to return the value of its implementer. It&#39;s very simple, every command in our audio mixer that we want to undo will have to implement this interface:</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">Command</span> <span class="kd">interface</span> <span class="p">{</span>
  <span class="nx">GetValue</span><span class="p">()</span> <span class="kd">interface</span><span class="p">{}</span>
<span class="p">}</span>
</code></pre>
<p>There is something interesting in this interface. The <code>GetValue</code> method returns an interface to a value. This also means that the return type of this method is... well... untyped? Not really, but it returns an interface that can be a representation of any type and we will need to typecast it later if we want to use its specific type. Now we have to define the <code>Volume</code> and <code>Mute</code> types and implement the <code>Command</code> interface:</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">Volume</span> <span class="kt">byte</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">v</span> <span class="nx">Volume</span><span class="p">)</span> <span class="nx">GetValue</span><span class="p">()</span> <span class="kd">interface</span><span class="p">{}</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">v</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">Mute</span> <span class="kt">bool</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="nx">Mute</span><span class="p">)</span> <span class="nx">GetValue</span><span class="p">()</span> <span class="kd">interface</span><span class="p">{}</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">m</span>
<span class="p">}</span>
</code></pre>
<p>They are both quite easy implementations. However, the <code>Mute</code> type will return a <code>bool</code> type on the <code>GetValue</code>() method and <code>Volume</code> will return a <code>byte</code> type.</p>
<p>As in the previous example, we&#39;ll need a <code>Memento</code> type that will hold a <code>Command</code>. In other words, it will store a pointer to a Mute or a Volume type:</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">Memento</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">memento</span> <span class="nx">Command</span>
<span class="p">}</span>
</code></pre>
<p>The <code>originator</code> type works as in the previous example but uses the <code>Command</code> keyword instead of the <code>state</code> keyword:</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">originator</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">Command</span> <span class="nx">Command</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">o</span> <span class="o">*</span><span class="nx">originator</span><span class="p">)</span> <span class="nx">NewMemento</span><span class="p">()</span> <span class="nx">Memento</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">Memento</span><span class="p">{</span><span class="nx">memento</span><span class="p">:</span> <span class="nx">o</span><span class="p">.</span><span class="nx">Command</span><span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">o</span> <span class="o">*</span><span class="nx">originator</span><span class="p">)</span> <span class="nx">ExtractAndStoreCommand</span><span class="p">(</span><span class="nx">m</span> <span class="nx">Memento</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">o</span><span class="p">.</span><span class="nx">Command</span> <span class="p">=</span> <span class="nx">m</span><span class="p">.</span><span class="nx">memento</span>
<span class="p">}</span>
</code></pre>
<p>And the <code>caretaker</code> object is almost the same, but this time we&#39;ll use a stack instead of a simple list and we will store a command instead of a state:</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">careTaker</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">mementoList</span> <span class="p">[]</span><span class="nx">Memento</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">careTaker</span><span class="p">)</span> <span class="nx">Add</span><span class="p">(</span><span class="nx">m</span> <span class="nx">Memento</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">c</span><span class="p">.</span><span class="nx">mementoList</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">mementoList</span><span class="p">,</span> <span class="nx">m</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">careTaker</span><span class="p">)</span> <span class="nx">Pop</span><span class="p">()</span> <span class="nx">Memento</span> <span class="p">{</span>
  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">mementoStack</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
    <span class="nx">tempMemento</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">mementoStack</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">mementoStack</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="nx">c</span><span class="p">.</span><span class="nx">mementoStack</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">mementoStack</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="nb">len</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">mementoStack</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">return</span> <span class="nx">tempMemento</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="nx">Memento</span><span class="p">{}</span>
<span class="p">}</span>
</code></pre>
<p>However, our <code>Memento</code> list is replaced with a <code>Pop</code> method. It also returns a <code>memento</code> object but it will return them acting as a stack (last to enter, first to go out). So, we take the last element on the stack and store it in the <code>tempMemento</code> variable. Then we replace the stack with a new version that doesn&#39;t contain the last element on the next line. Finally, we return the <code>tempMemento</code> variable.</p>
<p>Until now, everything looks almost like in the previous example. We also talked about automating some tasks by using the Facade pattern, so let&#39;s do it. This is going to be called the <code>MementoFacade</code> type and will have the <code>SaveSettings</code> and <code>RestoreSettings</code> methods. The <code>SaveSettings</code> method takes a <code>Command</code>, stores it in an inner originator, and saves it in an inner <code>careTaker</code> field. The <code>RestoreSettings</code> method makes the opposite flow-restores an index of the <code>careTaker</code> and returns the <code>Command</code> inside the <code>Memento</code> object:</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">MementoFacade</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">originator</span> <span class="nx">originator</span>
  <span class="nx">careTaker</span>  <span class="nx">careTaker</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">MementoFacade</span><span class="p">)</span> <span class="nx">SaveSettings</span><span class="p">(</span><span class="nx">s</span> <span class="nx">Command</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">m</span><span class="p">.</span><span class="nx">originator</span><span class="p">.</span><span class="nx">Command</span> <span class="p">=</span> <span class="nx">s</span>
  <span class="nx">m</span><span class="p">.</span><span class="nx">careTaker</span><span class="p">.</span><span class="nx">Add</span><span class="p">(</span><span class="nx">m</span><span class="p">.</span><span class="nx">originator</span><span class="p">.</span><span class="nx">NewMemento</span><span class="p">())</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">MementoFacade</span><span class="p">)</span> <span class="nx">RestoreSettings</span><span class="p">(</span><span class="nx">i</span> <span class="kt">int</span><span class="p">)</span> <span class="nx">Command</span> <span class="p">{</span>
  <span class="nx">m</span><span class="p">.</span><span class="nx">originator</span><span class="p">.</span><span class="nx">ExtractAndStoreCommand</span><span class="p">(</span><span class="nx">m</span><span class="p">.</span><span class="nx">careTaker</span><span class="p">.</span><span class="nx">Memento</span><span class="p">(</span><span class="nx">i</span><span class="p">))</span>
  <span class="k">return</span> <span class="nx">m</span><span class="p">.</span><span class="nx">originator</span><span class="p">.</span><span class="nx">Command</span>
<span class="p">}</span>
</code></pre>
<p>Our Facade pattern will hold the contents of the originator and the care taker and will provide those two easy-to-use methods to save and restore settings.</p>
<p>So, how do we use this?</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">main</span><span class="p">(){</span>
  <span class="nx">m</span> <span class="o">:=</span> <span class="nx">MementoFacade</span><span class="p">{}</span>

  <span class="nx">m</span><span class="p">.</span><span class="nx">SaveSettings</span><span class="p">(</span><span class="nx">Volume</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>
  <span class="nx">m</span><span class="p">.</span><span class="nx">SaveSettings</span><span class="p">(</span><span class="nx">Mute</span><span class="p">(</span><span class="kc">false</span><span class="p">))</span>
</code></pre>
<p>First, we get a variable with a Facade pattern. Zero-value initialization will give us zero-valued <code>originator</code> and <code>caretaker</code> objects. They don&#39;t have any unexpected field so everything will initialize correctly (if any of them had a pointer, for example, it would be initialized to <code>nil</code> as mentioned in the <a href="#zero-initialization" >Zero-initialization</a> section of <a href="#chapter-1" >Chapter 1</a>, <i>Ready... Steady... Go!</i>).</p>
<p>We create a <code>Volume</code> value with <code>Volume(4)</code> and, yes, we have used parentheses. The <code>Volume</code> type does not have any inner field like structs so we cannot use curly braces to set its value. The way to set it is to use parentheses (or create a pointer to the type <code>Volume</code> and then set the value of the pointed space). We also save a value of the type <code>Mute</code> using the Facade pattern.</p>
<p>We don&#39;t know what <code>Command</code> type is returned here, so we need to make a type assertion. We will make a small function to help us with this that checks the type and prints an appropriate value:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">assertAndPrint</span><span class="p">(</span><span class="nx">c</span> <span class="nx">Command</span><span class="p">){</span>
  <span class="k">switch</span> <span class="nx">cast</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.(</span><span class="kd">type</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">case</span> <span class="nx">Volume</span><span class="p">:</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&#34;Volume:\t%d\n&#34;</span><span class="p">,</span> <span class="nx">cast</span><span class="p">)</span>
  <span class="k">case</span> <span class="nx">Mute</span><span class="p">:</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&#34;Mute:\t%t\n&#34;</span><span class="p">,</span> <span class="nx">cast</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>The <code>assertAndPrint</code> method takes a <code>Command</code> type and casts it to the two possible types-<code>Volume</code> or <code>Mute</code>. In each case, it prints a message to the console with a personalized message. Now we can continue and finish the <code>main</code> function, which will look like this:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">m</span> <span class="o">:=</span> <span class="nx">MementoFacade</span><span class="p">{}</span>

  <span class="nx">m</span><span class="p">.</span><span class="nx">SaveSettings</span><span class="p">(</span><span class="nx">Volume</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>
  <span class="nx">m</span><span class="p">.</span><span class="nx">SaveSettings</span><span class="p">(</span><span class="nx">Mute</span><span class="p">(</span><span class="kc">false</span><span class="p">))</span>

  <span class="nx">assertAndPrint</span><span class="p">(</span><span class="nx">m</span><span class="p">.</span><span class="nx">RestoreSettings</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>

  <span class="nx">assertAndPrint</span><span class="p">(</span><span class="nx">m</span><span class="p">.</span><span class="nx">RestoreSettings</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
<span class="p">}</span>
</code></pre>
<p>The part highlighted in bold shows the new changes within the main function. We took the index 0 from the <code>careTaker</code> object and passed it to the new function and the same with the index <code>1</code>. Running this small program, we should get the <code>Volume</code> and <code>Mute</code> values on the console:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go run memento_command.go
</span><span class="out" >Mute:   false
Volume: 4
</span></code></pre>
<p>Great! In this small example, we have combined three different design patterns to keep getting comfortable using various patterns. Keep in mind that we could have abstracted the creation of <code>Volume</code> and <code>Mute</code> states to a Factory pattern too so this is not where would stop.</p>
</div>
<h4 id="last-words-on-the-memento-pattern" >Last words on the Memento pattern</h4>
<div class="hBody-4" >
<p>With the Memento pattern, we have learned a powerful way to create undoable operations that are very useful when writing UI applications but also when you have to develop transactional operations. In any case, the situation is the same: you need a <code>Memento</code>, an <code>Originator</code>, and a <code>caretaker</code> actor.</p>
<div class="about" >
<div class="about-dt" >Tip</div>
<div class="about-dd" >
<p>A <b>transaction operation</b> is a set of atomic operations that must all be done or fail. In other words, if you have a transaction composed of five operations and just one of them fails, the transaction cannot be completed and every modification done by the other four must be undone.</p>
</div>
</div>
</div>
<h3 id="interpreter-design-pattern" >Interpreter design pattern</h3>
<div class="hBody-3" >
<p>Now we are going to dig into a quite complex pattern. The <b>Interpreter</b> pattern is, in fact, widely used to solve business cases where it&#39;s useful to have a language to perform common operations. Let&#39;s see what we mean by language.</p>
</div>
<h4 id="description" >Description</h4>
<div class="hBody-4" >
<p>The most famous interpreter we can talk about is probably SQL. It&#39;s defined as a special-purpose programming language for managing data held in relational databases. SQL is quite complex and big but, all in all, is a set of words and operators that allow us to perform operations such as insert, select, or delete.</p>
<p>Another typical example is musical notation. It&#39;s a language itself and the interpreter is the musician who knows the connection between a note and its representation on the instrument they are playing.</p>
<p>In computer science, it can be useful to design a small language for a variety of reasons: repetitive tasks, higher-level languages for non-developers, or <b>Interface Definition Languages</b> (<span class="acronym" >IDL</span>) such as <b>Protocol buffers</b> or <b>Apache Thrift</b>.</p>
</div>
<h4 id="objectives" >Objectives</h4>
<div class="hBody-4" >
<p>Designing a new language, big or small, can be a time consuming task so it&#39;s very important to have the objectives clear before investing time and resources on writing an interpreter of it:</p>
<ul>
<li>
<p>Provide syntax for very common operations in some scope (such as playing notes).</p>
</li>
<li>
<p>Have a intermediate language to translate actions between two systems. For example, the apps that generate the <b>Gcode</b> needed to print with 3D printers.</p>
</li>
<li>
<p>Ease the use of some operations in an easier-to-use syntax.</p>
</li>
</ul>
<p>SQL allows the use of relational databases in a very easy-to-use syntax (that can become incredibly complex too) but the idea is to not need to write your own functions to make insertions and searches.</p>
</div>
<h4 id="example---a-polish-notation-calculator" >Example - a polish notation calculator</h4>
<div class="hBody-4" >
<p>A very typical example of an interpreter is to create a reverse polish notation calculator. For those who don&#39;t know what polish notation is, it&#39;s a mathematical notation to make operations where you write your operation first (sum) and then the values (3 4), so <span class="math" >+ 3 4</span> is equivalent to the more common <span class="math" >3 + 4</span> and its result would be <span class="math" >7</span>. So, for a reverse polish notation, you put first the values and then the operation, so <i>3 4 + </i>would also be <span class="math" >7</span>.</p>
</div>
<h4 id="acceptance-criteria-for-the-calculator" >Acceptance criteria for the calculator</h4>
<div class="hBody-4" >
<p>For our calculator, the acceptance criteria we should pass to consider it done are as follows:</p>
<ol class="num" >
<li>
<p>Create a language that allows making common arithmetic operations (sums, subtractions, multiplications, and divisions). The syntax is <code>sum</code> for sums, <code>mul</code> for multiplications, <code>sub</code> for subtractions, and <code>div</code> for divisions.</p>
</li>
<li>
<p>It must be done using reverse polish notation.</p>
</li>
<li>
<p>The user must be able to write as many operations in a row as they want.</p>
</li>
<li>
<p>The operations must be performed from left to right.</p>
</li>
</ol>
<p>So the <code>3 4 sum 2 sub</code> notation is the same than <span class="math" >(3 + 4) - 2</span> and result would be <i>5</i>.</p>
</div>
<h4 id="unit-test-of-some-operations" >Unit test of some operations</h4>
<div class="hBody-4" >
<p>In this case, we will only have a public method called <code>Calculate</code> that takes an operation with its values defined as a string and will return a value or an error:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">Calculate</span><span class="p">(</span><span class="nx">o</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&#34;Not implemented yet&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
<p>So, we will send a string like <q><code>3 4 +</code></q> to the <code>Calculate</code> method and it should return <i>7, nil</i>. Two tests more will check the correct implementation:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">TestCalculate</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">tempOperation</span> <span class="p">=</span> <span class="s">&#34;3 4 sum 2 sub&#34;</span>
  <span class="nx">res</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">Calculate</span><span class="p">(</span><span class="nx">tempOperation</span><span class="p">)</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">t</span><span class="p">.</span><span class="nx">Error</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="k">if</span> <span class="nx">res</span> <span class="o">!=</span> <span class="mi">5</span> <span class="p">{</span>
    <span class="nx">t</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&#34;Expected result not found: %d != %d\n&#34;</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="nx">res</span><span class="p">)</span>
  <span class="p">}</span>
</code></pre>
<p>First, we are going to make the operation we have used as an example. The <code>3 4 sum 2 sub</code> notation is part of our language and we use it in the <code>Calculate</code> function. If an error is returned, the test fails. Finally, the result must be equal to <code>5</code> and we check it on the last lines. The next test checks the rest of the operators on slightly more complex operations:</p>
<pre class="code" ><code class="chroma" >  <span class="nx">tempOperation</span> <span class="o">:=</span> <span class="s">&#34;5 3 sub 8 mul 4 sum 5 div&#34;</span>
  <span class="nx">res</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">Calculate</span><span class="p">(</span><span class="nx">tempOperation</span><span class="p">)</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">t</span><span class="p">.</span><span class="nx">Error</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="k">if</span> <span class="nx">res</span> <span class="o">!=</span> <span class="mi">4</span> <span class="p">{</span>
    <span class="nx">t</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&#34;Expected result not found: %d != %d\n&#34;</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="nx">res</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>Here, we repeated the preceding process with a longer operation, the <i>(((5 - 3) * 8) + 4) / 5</i> notation which is equal to <i>4</i>. From left to right, it would be as follows:</p>
<div class="example-block" >
<pre class="example" >(((5 - 3) * 8) + 4) / 5
  ((2 * 8) + 4) / 5
    (16 + 4) / 5
      20 / 5
        4
</pre>
</div>
<p>The test must fail, of course!</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go <span class="nb">test</span> -v .
</span><span class="out" >  interpreter_test.go:9: Not implemented yet
  interpreter_test.go:13: Expected result not found: 4 != 0
  interpreter_test.go:19: Not implemented yet
  interpreter_test.go:23: Expected result not found: 5 != 0
exit status 1
FAIL
</span></code></pre>
</div>
<h4 id="implementation" >Implementation</h4>
<div class="hBody-4" >
<p>Implementation is going to be longer than testing this time. To start, we will define our possible operators in constants:</p>
<pre class="code" ><code class="chroma" ><span class="kd">const</span> <span class="p">(</span>
  <span class="nx">SUM</span> <span class="p">=</span> <span class="s">&#34;sum&#34;</span>
  <span class="nx">SUB</span> <span class="p">=</span> <span class="s">&#34;sub&#34;</span>
  <span class="nx">MUL</span> <span class="p">=</span> <span class="s">&#34;mul&#34;</span>
  <span class="nx">DIV</span> <span class="p">=</span> <span class="s">&#34;div&#34;</span>
<span class="p">)</span>
</code></pre>
<p>Interpreter patterns are usually implemented using an abstract syntax tree, something that is commonly achieved using a stack. We have created stacks before during the book so this should be already familiar to readers:</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">polishNotationStack</span> <span class="p">[]</span><span class="kt">int</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">polishNotationStack</span><span class="p">)</span> <span class="nx">Push</span><span class="p">(</span><span class="nx">s</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
  <span class="o">*</span><span class="nx">p</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="o">*</span><span class="nx">p</span><span class="p">,</span> <span class="nx">s</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">polishNotationStack</span><span class="p">)</span> <span class="nx">Pop</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
  <span class="nx">length</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="o">*</span><span class="nx">p</span><span class="p">)</span>

  <span class="k">if</span> <span class="nx">length</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
    <span class="nx">temp</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="nx">p</span><span class="p">)[</span><span class="nx">length</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="o">*</span><span class="nx">p</span> <span class="p">=</span> <span class="p">(</span><span class="o">*</span><span class="nx">p</span><span class="p">)[:</span><span class="nx">length</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">return</span> <span class="nx">temp</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="mi">0</span>
<span class="p">}</span>
</code></pre>
<p>We have two methods--the <code>Push</code> method to add elements to the top of the stack and the <code>Pop</code> method to remove elements and return them. In case you are thinking that the line <code>*p = (*p)[:length-1]</code> is a bit cryptic, we&#39;ll explain it.</p>
<p>The value stored in the direction of <code>p</code> will be overridden with the actual value in the direction of <code>p (*p)</code> but taking only the elements from the beginning to the penultimate element of the array <code>(:length-1)</code>.</p>
<p>So, now we will go step by step with the <code>Calculate</code> function, creating more functions as far as we need them:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">Calculate</span><span class="p">(</span><span class="nx">o</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">stack</span> <span class="o">:=</span> <span class="nx">polishNotationStack</span><span class="p">{}</span>
  <span class="nx">operators</span> <span class="o">:=</span> <span class="nx">strings</span><span class="p">.</span><span class="nx">Split</span><span class="p">(</span><span class="nx">o</span><span class="p">,</span> <span class="s">&#34; &#34;</span><span class="p">)</span>
</code></pre>
<p>The first two things we need to do are to create the stack and to get all different symbols from the incoming operation (in this case, we aren&#39;t checking that it isn&#39;t empty). We split the incoming string operations by the space to get a nice slice of symbols (values and operators).</p>
<p>Next, we will iterate over every symbol by using range but we need a function to know whether the incoming symbol is a value or an operator:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">isOperator</span><span class="p">(</span><span class="nx">o</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
  <span class="k">if</span> <span class="nx">o</span> <span class="o">==</span> <span class="nx">SUM</span> <span class="o">||</span> <span class="nx">o</span> <span class="o">==</span> <span class="nx">SUB</span> <span class="o">||</span> <span class="nx">o</span> <span class="o">==</span> <span class="nx">MUL</span> <span class="o">||</span> <span class="nx">o</span> <span class="o">==</span> <span class="nx">DIV</span> <span class="p">{</span>
    <span class="k">return</span> <span class="kc">true</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="kc">false</span>
<span class="p">}</span>
</code></pre>
<p>If the incoming symbol is any of the ones defined in our constants, the incoming symbol is an operator:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">Calculate</span><span class="p">(</span><span class="nx">o</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">stack</span> <span class="o">:=</span> <span class="nx">polishNotationStack</span><span class="p">{}</span>
  <span class="nx">operators</span> <span class="o">:=</span> <span class="nx">strings</span><span class="p">.</span><span class="nx">Split</span><span class="p">(</span><span class="nx">o</span><span class="p">,</span> <span class="s">&#34; &#34;</span><span class="p">)</span>

  <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">operatorString</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">operators</span> <span class="p">{</span>

    <span class="k">if</span> <span class="nx">isOperator</span><span class="p">(</span><span class="nx">operatorString</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">right</span> <span class="o">:=</span> <span class="nx">stack</span><span class="p">.</span><span class="nx">Pop</span><span class="p">()</span>
      <span class="nx">left</span>  <span class="o">:=</span> <span class="nx">stack</span><span class="p">.</span><span class="nx">Pop</span><span class="p">()</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="c1">// Is a value
</span><span class="c1"></span>    <span class="p">}</span>
  <span class="p">}</span>
</code></pre>
<p>If it is an operator, we consider that we have already passed two values so what we have to do is to take those two values from the stack. The first value taken would be the rightmost and the second the leftmost (remember that in subtractions and divisions, the order of the operands is important). Then, we need some function to get the operation we want to perform:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">getOperationFunc</span><span class="p">(</span><span class="nx">o</span> <span class="kt">string</span><span class="p">)</span> <span class="kd">func</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
  <span class="k">switch</span> <span class="nx">o</span> <span class="p">{</span>
  <span class="k">case</span> <span class="nx">SUM</span><span class="p">:</span>
    <span class="k">return</span> <span class="kd">func</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">a</span> <span class="o">+</span> <span class="nx">b</span>
    <span class="p">}</span>
  <span class="k">case</span> <span class="nx">SUB</span><span class="p">:</span>
    <span class="k">return</span> <span class="kd">func</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">a</span> <span class="o">-</span> <span class="nx">b</span>
    <span class="p">}</span>
  <span class="k">case</span> <span class="nx">MUL</span><span class="p">:</span>
    <span class="k">return</span> <span class="kd">func</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">a</span> <span class="o">*</span> <span class="nx">b</span>
    <span class="p">}</span>
  <span class="k">case</span> <span class="nx">DIV</span><span class="p">:</span>
    <span class="k">return</span> <span class="kd">func</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">a</span> <span class="o">/</span> <span class="nx">b</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre>
<p>The <code>getOperationFunc</code> functions returns a two-argument function that returns an integer. We check the incoming operator and we return an anonymous function that performs the specified operation. So, now our <code>for range</code> continues like this:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">Calculate</span><span class="p">(</span><span class="nx">o</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">stack</span> <span class="o">:=</span> <span class="nx">polishNotationStack</span><span class="p">{}</span>
  <span class="nx">operators</span> <span class="o">:=</span> <span class="nx">strings</span><span class="p">.</span><span class="nx">Split</span><span class="p">(</span><span class="nx">o</span><span class="p">,</span> <span class="s">&#34; &#34;</span><span class="p">)</span>

  <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">operatorString</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">operators</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">isOperator</span><span class="p">(</span><span class="nx">operatorString</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">right</span> <span class="o">:=</span> <span class="nx">stack</span><span class="p">.</span><span class="nx">Pop</span><span class="p">()</span>
      <span class="nx">left</span> <span class="o">:=</span> <span class="nx">stack</span><span class="p">.</span><span class="nx">Pop</span><span class="p">()</span>
      <span class="nx">mathFunc</span> <span class="o">:=</span> <span class="nx">getOperationFunc</span><span class="p">(</span><span class="nx">operatorString</span><span class="p">)</span>
      <span class="nx">res</span> <span class="o">:=</span> <span class="nx">mathFunc</span><span class="p">(</span><span class="nx">left</span><span class="p">,</span> <span class="nx">right</span><span class="p">)</span>
      <span class="nx">stack</span><span class="p">.</span><span class="nx">Push</span><span class="p">(</span><span class="nx">res</span><span class="p">)</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="c1">// Is a value
</span><span class="c1"></span>    <span class="p">}</span>
  <span class="p">}</span>
</code></pre>
<p>The <code>mathFunc</code> variable is returned by the function. We use it immediately to perform the operation on the left and right values taken from the stack and we store its result in a new variable called <code>res</code>. Finally, we need to push this new value to the stack to keep operating with it later.</p>
<p>Now, here is the implementation when the incoming symbol is a value:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">Calculate</span><span class="p">(</span><span class="nx">o</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">stack</span> <span class="o">:=</span> <span class="nx">polishNotationStack</span><span class="p">{}</span>
  <span class="nx">operators</span> <span class="o">:=</span> <span class="nx">strings</span><span class="p">.</span><span class="nx">Split</span><span class="p">(</span><span class="nx">o</span><span class="p">,</span> <span class="s">&#34; &#34;</span><span class="p">)</span>

  <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">operatorString</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">operators</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">isOperator</span><span class="p">(</span><span class="nx">operatorString</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">right</span> <span class="o">:=</span> <span class="nx">stack</span><span class="p">.</span><span class="nx">Pop</span><span class="p">()</span>
      <span class="nx">left</span> <span class="o">:=</span> <span class="nx">stack</span><span class="p">.</span><span class="nx">Pop</span><span class="p">()</span>
      <span class="nx">mathFunc</span> <span class="o">:=</span> <span class="nx">getOperationFunc</span><span class="p">(</span><span class="nx">operatorString</span><span class="p">)</span>
      <span class="nx">res</span> <span class="o">:=</span> <span class="nx">mathFunc</span><span class="p">(</span><span class="nx">left</span><span class="p">,</span> <span class="nx">right</span><span class="p">)</span>
      <span class="nx">stack</span><span class="p">.</span><span class="nx">Push</span><span class="p">(</span><span class="nx">res</span><span class="p">)</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="nx">val</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">strconv</span><span class="p">.</span><span class="nx">Atoi</span><span class="p">(</span><span class="nx">operatorString</span><span class="p">)</span>

      <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">err</span>
      <span class="p">}</span>

      <span class="nx">stack</span><span class="p">.</span><span class="nx">Push</span><span class="p">(</span><span class="nx">val</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">}</span>
</code></pre>
<p>What we need to do every time we get a symbol is to push it to the stack. We have to parse the string symbol to a usable <code>int</code> type. This is commonly done with the <code>strconv</code> package by using its <code>Atoi</code> function. The <code>Atoi</code> function takes a string and returns an integer from it or an error. If everything goes well, the value is pushed into the stack.</p>
<p>At the end of the <code>range</code> statement, just one value must be stored on it, so we just need to return it and the function is done:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">Calculate</span><span class="p">(</span><span class="nx">o</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">stack</span> <span class="o">:=</span> <span class="nx">polishNotationStack</span><span class="p">{}</span>
  <span class="nx">operators</span> <span class="o">:=</span> <span class="nx">strings</span><span class="p">.</span><span class="nx">Split</span><span class="p">(</span><span class="nx">o</span><span class="p">,</span> <span class="s">&#34; &#34;</span><span class="p">)</span>

  <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">operatorString</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">operators</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">isOperator</span><span class="p">(</span><span class="nx">operatorString</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">right</span> <span class="o">:=</span> <span class="nx">stack</span><span class="p">.</span><span class="nx">Pop</span><span class="p">()</span>
      <span class="nx">left</span> <span class="o">:=</span> <span class="nx">stack</span><span class="p">.</span><span class="nx">Pop</span><span class="p">()</span>
      <span class="nx">mathFunc</span> <span class="o">:=</span> <span class="nx">getOperationFunc</span><span class="p">(</span><span class="nx">operatorString</span><span class="p">)</span>
      <span class="nx">res</span> <span class="o">:=</span> <span class="nx">mathFunc</span><span class="p">(</span><span class="nx">left</span><span class="p">,</span> <span class="nx">right</span><span class="p">)</span>
      <span class="nx">stack</span><span class="p">.</span><span class="nx">Push</span><span class="p">(</span><span class="nx">res</span><span class="p">)</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="nx">val</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">strconv</span><span class="p">.</span><span class="nx">Atoi</span><span class="p">(</span><span class="nx">operatorString</span><span class="p">)</span>
      <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">err</span>
      <span class="p">}</span>

      <span class="nx">stack</span><span class="p">.</span><span class="nx">Push</span><span class="p">(</span><span class="nx">val</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="nx">stack</span><span class="p">.</span><span class="nx">Pop</span><span class="p">()),</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre>
<p>Time to run the tests again:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go <span class="nb">test</span> -v .
</span><span class="out" >ok
</span></code></pre>
<p>Great! We have just created a reverse polish notation interpreter in a very simple and easy way (we still lack the parser, but that&#39;s another story).</p>
</div>
<h4 id="complexity-with-the-interpreter-design-pattern" >Complexity with the Interpreter design pattern</h4>
<div class="hBody-4" >
<p>In this example, we haven&#39;t used any interfaces. This is not exactly how the Interpreter design pattern is defined in more object-oriented languages. However, this example is the simplest example possible to understand the objectives of the language and the next level is inevitably much more complex and not intended for beginner users.</p>
<p>With a more complex example, we will have to define a type containing more types of itself, a value, or nothing. With a parser, you create this abstract syntax tree to interpret it later.</p>
<p>The same example, done by using interfaces, would be as in the following description section.</p>
</div>
<h4 id="interpreter-pattern-again---now-using-interfaces" >Interpreter pattern again - now using interfaces</h4>
<div class="hBody-4" >
<p>The main interface we are going to use is called the <code>Interpreter</code> interface. This interface has a <code>Read()</code> method that every symbol (value or operator) must implement:</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">Interpreter</span> <span class="kd">interface</span> <span class="p">{</span>
  <span class="nx">Read</span><span class="p">()</span> <span class="kt">int</span>
<span class="p">}</span>
</code></pre>
<p>We will implement only the sum and the subtraction from the operators and a type called <code>Value</code> for the numbers:</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">value</span> <span class="kt">int</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">v</span> <span class="o">*</span><span class="nx">value</span><span class="p">)</span> <span class="nx">Read</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="o">*</span><span class="nx">v</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
<p>The <code>Value</code> is a type <code>int</code> that, when implementing the <code>Read</code> method, just returns its value:</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">operationSum</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">Left</span>  <span class="nx">Interpreter</span>
  <span class="nx">Right</span> <span class="nx">Interpreter</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">operationSum</span><span class="p">)</span> <span class="nx">Read</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">a</span><span class="p">.</span><span class="nx">Left</span><span class="p">.</span><span class="nx">Read</span><span class="p">()</span> <span class="o">+</span> <span class="nx">a</span><span class="p">.</span><span class="nx">Right</span><span class="p">.</span><span class="nx">Read</span><span class="p">()</span>
<span class="p">}</span>
</code></pre>
<p>The <code>operationSum</code> struct has the <code>Left</code> and <code>Right</code> fields and its <code>Read</code> method returns the sum of each of their <code>Read</code> methods. The <code>operationSubtract</code> struct is the same but subtracting:</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">operationSubtract</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">Left</span>  <span class="nx">Interpreter</span>
  <span class="nx">Right</span> <span class="nx">Interpreter</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">operationSubtract</span><span class="p">)</span> <span class="nx">Read</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">s</span><span class="p">.</span><span class="nx">Left</span><span class="p">.</span><span class="nx">Read</span><span class="p">()</span> <span class="o">-</span> <span class="nx">s</span><span class="p">.</span><span class="nx">Right</span><span class="p">.</span><span class="nx">Read</span><span class="p">()</span>
<span class="p">}</span>
</code></pre>
<p>We also need a Factory pattern to create operators; we will call it the <code>operatorFactory</code> method. The difference now is that it not only accepts the symbol but also the <code>Left</code> and <code>Right</code> values taken from the stack:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">operatorFactory</span><span class="p">(</span><span class="nx">o</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">left</span><span class="p">,</span> <span class="nx">right</span> <span class="nx">Interpreter</span><span class="p">)</span> <span class="nx">Interpreter</span> <span class="p">{</span>
  <span class="k">switch</span> <span class="nx">o</span> <span class="p">{</span>
  <span class="k">case</span> <span class="nx">SUM</span><span class="p">:</span>
    <span class="k">return</span> <span class="o">&amp;</span><span class="nx">operationSum</span><span class="p">{</span>
      <span class="nx">Left</span><span class="p">:</span> <span class="nx">left</span><span class="p">,</span>
      <span class="nx">Right</span><span class="p">:</span> <span class="nx">right</span><span class="p">,</span>
    <span class="p">}</span>
  <span class="k">case</span> <span class="nx">SUB</span><span class="p">:</span>
    <span class="k">return</span> <span class="o">&amp;</span><span class="nx">operationSubtract</span><span class="p">{</span>
      <span class="nx">Left</span><span class="p">:</span> <span class="nx">left</span><span class="p">,</span>
      <span class="nx">Right</span><span class="p">:</span> <span class="nx">right</span><span class="p">,</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre>
<p>As we have just mentioned, we also need a stack. We can reuse the one from the previous example by changing its type:</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">polishNotationStack</span> <span class="p">[]</span><span class="nx">Interpreter</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">polishNotationStack</span><span class="p">)</span> <span class="nx">Push</span><span class="p">(</span><span class="nx">s</span> <span class="nx">Interpreter</span><span class="p">)</span> <span class="p">{</span>
  <span class="o">*</span><span class="nx">p</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="o">*</span><span class="nx">p</span><span class="p">,</span> <span class="nx">s</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">polishNotationStack</span><span class="p">)</span> <span class="nx">Pop</span><span class="p">()</span> <span class="nx">Interpreter</span> <span class="p">{</span>
  <span class="nx">length</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="o">*</span><span class="nx">p</span><span class="p">)</span>

  <span class="k">if</span> <span class="nx">length</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
    <span class="nx">temp</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="nx">p</span><span class="p">)[</span><span class="nx">length</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="o">*</span><span class="nx">p</span> <span class="p">=</span> <span class="p">(</span><span class="o">*</span><span class="nx">p</span><span class="p">)[:</span><span class="nx">length</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">return</span> <span class="nx">temp</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre>
<p>Now the stack works with Interpreter pointers instead of <code>int</code> but its functionality is the same. Finally, our <code>main</code> method also looks similar to our previous example:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">stack</span> <span class="o">:=</span> <span class="nx">polishNotationStack</span><span class="p">{}</span>
  <span class="nx">operators</span> <span class="o">:=</span> <span class="nx">strings</span><span class="p">.</span><span class="nx">Split</span><span class="p">(</span><span class="s">&#34;3 4 sum 2 sub&#34;</span><span class="p">,</span> <span class="s">&#34; &#34;</span><span class="p">)</span>

  <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">operatorString</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">operators</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">operatorString</span> <span class="o">==</span> <span class="nx">SUM</span> <span class="o">||</span> <span class="nx">operatorString</span> <span class="o">==</span> <span class="nx">SUB</span> <span class="p">{</span>
      <span class="nx">right</span> <span class="o">:=</span> <span class="nx">stack</span><span class="p">.</span><span class="nx">Pop</span><span class="p">()</span>
      <span class="nx">left</span> <span class="o">:=</span> <span class="nx">stack</span><span class="p">.</span><span class="nx">Pop</span><span class="p">()</span>
      <span class="nx">mathFunc</span> <span class="o">:=</span> <span class="nx">operatorFactory</span><span class="p">(</span><span class="nx">operatorString</span><span class="p">,</span> <span class="nx">left</span><span class="p">,</span> <span class="nx">right</span><span class="p">)</span>
      <span class="nx">res</span> <span class="o">:=</span> <span class="nx">value</span><span class="p">(</span><span class="nx">mathFunc</span><span class="p">.</span><span class="nx">Read</span><span class="p">())</span>
      <span class="nx">stack</span><span class="p">.</span><span class="nx">Push</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">res</span><span class="p">)</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="nx">val</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">strconv</span><span class="p">.</span><span class="nx">Atoi</span><span class="p">(</span><span class="nx">operatorString</span><span class="p">)</span>
      <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
      <span class="p">}</span>

      <span class="nx">temp</span> <span class="o">:=</span> <span class="nx">value</span><span class="p">(</span><span class="nx">val</span><span class="p">)</span>
      <span class="nx">stack</span><span class="p">.</span><span class="nx">Push</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">temp</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="nb">println</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="nx">stack</span><span class="p">.</span><span class="nx">Pop</span><span class="p">().</span><span class="nx">Read</span><span class="p">()))</span>
<span class="p">}</span>
</code></pre>
<p>Like before, we check whether the symbol is operator or value first. When it&#39;s a value, it pushes it into the stack.</p>
<p>When the symbol is an operator, we also take the right and left values from the stack, we call the Factory pattern using the current operator and the left and right values that we just took from the stack. Once we have the operator type, we just need to call its <code>Read</code> method to push the returned value to the stack too.</p>
<p>Finally, just one example must be left on the stack, so we print it:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go run interpreter.go
</span><span class="out" >5
</span></code></pre>
</div>
<h4 id="the-power-of-the-interpreter-pattern" >The power of the Interpreter pattern</h4>
<div class="hBody-4" >
<p>This pattern is extremely powerful but it must also be used carefully. To create a language, it generates a strong coupling between its users and the functionality it provides. One can fall into the error of trying to create a too flexible language that is incredibly complex to use and maintain. Also, one can create a fairly small and useful language that doesn&#39;t interpret correctly sometimes and it could be a pain for its users.</p>
<p>In our example, we have omitted quite a lot of error-checking to focus on the implementation of the Interpreter. However, you&#39;ll need quite a lot of error checking and verbose output on errors to help the user correct its syntax errors. So, have fun writing your language but be nice to your users.</p>
</div>
<h3 id="summary" >Summary</h3>
<div class="hBody-3" >
<p>This chapter has dealt with three extremely powerful patterns that require a lot of practice before using them in production code. It&#39;s a very good idea to make some exercises with them by simulating typical production problems:</p>
<ul>
<li>
<p>Create a simple REST server that reuses most of the error-checking and connection functionality to provide an easy-to-use interface to practice the Template pattern</p>
</li>
<li>
<p>Make a small library that can write to different databases but only in the case that all writes were OK, or delete the newly created writes to practice Memento for example</p>
</li>
<li>
<p>Write your own language, to make simple things such as answering simple questions like bots usually do so you can practice a bit of the Interpreter pattern</p>
</li>
</ul>
<p>The idea is to practice coding and reread any section until you get comfortable with each pattern.</p>
</div>
<h2 id="chapter-7" >Behavioral Patterns - Visitor, State, Mediator, and Observer Design Patterns</h2>
<div class="hBody-2" >
<p>This is the last chapter about Behavioral patterns and it also closes this book&#39;s section about common, well known design patterns in Go language.</p>
<p>In this chapter, we are going to look at three more design patterns. Visitor pattern is very useful when you want to abstract away some functionality from a set of objects.</p>
<p>State is used commonly to build <b>Finite State Machines</b> (<span class="acronym" >FSM</span>) and, in this section, we will develop a small <i>guess the number</i> game.</p>
<p>Finally, the Observer pattern is commonly used in event-driven architectures and is gaining a lot of traction again, especially in the microservices world.</p>
<p>After this chapter, we&#39;ll need to feel very comfortable with common design patterns before digging in concurrency and the advantages (and complexity), it brings to design patterns.</p>
</div>
<h3 id="visitor-design-pattern" >Visitor design pattern</h3>
<div class="hBody-3" >
<p>In the next design pattern, we are going to delegate some logic of an object&#39;s type to an external type called the visitor that will visit our object to perform operations on it.</p>
</div>
<h4 id="description" >Description</h4>
<div class="hBody-4" >
<p>In the Visitor design pattern, we are trying to separate the logic needed to work with a specific object outside of the object itself. So we could have many different visitors that do some things to specific types.</p>
<p>For example, imagine that we have a log writer that writes to console. We could make the logger &#34;visitable&#34; so that you can prepend any text to each log. We could write a Visitor pattern that prepends the date, the time, and the hostname to a field stored in the object.</p>
</div>
<h4 id="objectives" >Objectives</h4>
<div class="hBody-4" >
<p>With Behavioral design patterns we are mainly dealing with algorithms. Visitor patterns are not an exception. The objectives that we are trying to achieve are as follows:</p>
<ul>
<li>
<p>To separate the algorithm of some type from its implementation within some other type</p>
</li>
<li>
<p>To improve the flexibility of some types by using them with little or no logic at all so all new functionality can be added without altering the object structure</p>
</li>
<li>
<p>To fix a structure or behavior that would break the open/closed principle in a type</p>
</li>
</ul>
<p>You might be thinking what the open/closed principle is. In computer science, the open/closed principle states that: <i>entities should be open for </i> <i>extension but closed for modification</i>. This simple state has lots of implications that allows building more maintainable software and less prone to errors. And the Visitor pattern helps us to delegate some commonly changing algorithm from a type that we need it to be &#34;stable&#34; to an external type that can change often without affecting our original one.</p>
</div>
<h4 id="a-log-appender" >A log appender</h4>
<div class="hBody-4" >
<p>We are going to develop a simple log appender as an example of the Visitor pattern. Following the approach we have had in previous chapters, we will start with an extremely simple example to clearly understand how the Visitor design pattern works before jumping to a more complex one. We have already developed similar examples modifying texts too, but in slightly different ways.</p>
<p>For this particular example, we will create a Visitor that appends different information to the types it &#34;visits&#34;.</p>
</div>
<h4 id="acceptance-criteria" >Acceptance criteria</h4>
<div class="hBody-4" >
<p>To effectively use the Visitor design pattern, we must have two roles--a visitor and a visitable. The <code>Visitor</code> is the type that will act within a <code>Visitable</code> type. So a <code>Visitable</code> interface implementation has an algorithm detached to the <code>Visitor</code> type:</p>
<ol class="num" >
<li>
<p>We need two message loggers: <code>MessageA</code> and <code>MessageB</code> that will print a message with an <code>A</code>: or a <code>B</code>: respectively before the message.</p>
</li>
<li>
<p>We need a Visitor able to modify the message to be printed. It will append the text &#34;Visited A&#34; or &#34;Visited B&#34; to them, respectively.</p>
</li>
</ol>
</div>
<h4 id="unit-tests" >Unit tests</h4>
<div class="hBody-4" >
<p>As we mentioned before, we will need a role for the <code>Visitor</code> and the <code>Visitable</code> interfaces. They will be interfaces. We also need the <code>MessageA</code> and <code>MessageB</code> structs:</p>
<pre class="code" ><code class="chroma" ><span class="kn">package</span> <span class="nx">visitor</span>

<span class="kn">import</span> <span class="p">(</span>
  <span class="s">&#34;io&#34;</span>
  <span class="s">&#34;os&#34;</span>
  <span class="s">&#34;fmt&#34;</span>
<span class="p">)</span>

<span class="kd">type</span> <span class="nx">MessageA</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">Msg</span> <span class="kt">string</span>
  <span class="nx">Output</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Writer</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">MessageB</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">Msg</span> <span class="kt">string</span>
  <span class="nx">Output</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Writer</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">Visitor</span> <span class="kd">interface</span> <span class="p">{</span>
  <span class="nx">VisitA</span><span class="p">(</span><span class="o">*</span><span class="nx">MessageA</span><span class="p">)</span>
  <span class="nx">VisitB</span><span class="p">(</span><span class="o">*</span><span class="nx">MessageB</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">Visitable</span> <span class="kd">interface</span> <span class="p">{</span>
  <span class="nx">Accept</span><span class="p">(</span><span class="nx">Visitor</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="err">@</span><span class="nx">c</span><span class="p">(</span><span class="nx">MessageVisitor</span><span class="p">)</span> <span class="kd">struct</span> <span class="p">{}</span>
</code></pre>
<p>The types <code>MessageA</code> and <code>MessageB</code> structs both have an <code>Msg</code> field to store the text that they will print. The output <code>io.Writer</code> will implement the <code>os.Stdout</code> interface by default or a new <code>io.Writer</code> interface, like the one we will use to check that the contents are correct.</p>
<p>The <code>Visitor</code> interface has a <code>Visit</code> method, one for each of <code>Visitable</code> interface&#39;s <code>MessageA</code> and <code>MessageB</code> type. The <code>Visitable</code> interface has a method called <code>Accept(Visitor)</code> that will execute the decoupled algorithm.</p>
<p>Like in previous examples, we will create a type that implements the <code>io.Writer</code> package so that we can use it in tests:</p>
<pre class="code" ><code class="chroma" ><span class="kn">package</span> <span class="nx">visitor</span>

<span class="kn">import</span> <span class="s">&#34;testing&#34;</span>

<span class="kd">type</span> <span class="nx">TestHelper</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">Received</span> <span class="kt">string</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">TestHelper</span><span class="p">)</span> <span class="nx">Write</span><span class="p">(</span><span class="nx">p</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">t</span><span class="p">.</span><span class="nx">Received</span> <span class="p">=</span> <span class="nb">string</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span>
  <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="nx">p</span><span class="p">),</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre>
<p>The <code>TestHelper</code> struct implements the <code>io.Writer</code> interface. Its functionality is quite simple; it stores the written bytes on the Received field. Later we can check the contents of <code>Received</code> to test against our expected value.</p>
<p>We will write just one test that will check the overall correctness of the code. Within this test, we will write two sub tests: one for <code>MessageA</code> and one for <code>MessageB</code> types:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">Test_Overall</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">testHelper</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">TestHelper</span><span class="p">{}</span>
  <span class="nx">visitor</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">MessageVisitor</span><span class="p">{}</span>
  <span class="o">...</span>
<span class="p">}</span>
</code></pre>
<p>We will use a <code>TestHelper</code> struct and a <code>MessageVisitor</code> struct on each test for each message type. First, we will test the <code>MessageA</code> type:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">Test_Overall</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">testHelper</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">TestHelper</span><span class="p">{}</span>
  <span class="nx">visitor</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">MessageVisitor</span><span class="p">{}</span>

  <span class="nx">t</span><span class="p">.</span><span class="nx">Run</span><span class="p">(</span><span class="s">&#34;MessageA test&#34;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">){</span>
    <span class="nx">msg</span> <span class="o">:=</span> <span class="nx">MessageA</span><span class="p">{</span>
      <span class="nx">Msg</span><span class="p">:</span> <span class="s">&#34;Hello World&#34;</span><span class="p">,</span>
      <span class="nx">Output</span><span class="p">:</span> <span class="nx">testHelper</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="nx">msg</span><span class="p">.</span><span class="nx">Accept</span><span class="p">(</span><span class="nx">visitor</span><span class="p">)</span>
    <span class="nx">msg</span><span class="p">.</span><span class="nx">Print</span><span class="p">()</span>

    <span class="nx">expected</span> <span class="o">:=</span> <span class="s">&#34;A: Hello World (Visited A)&#34;</span>
    <span class="k">if</span> <span class="nx">testHelper</span><span class="p">.</span><span class="nx">Received</span> <span class="o">!=</span>  <span class="nx">expected</span> <span class="p">{</span>
      <span class="nx">t</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&#34;Expected result was incorrect. %s != %s&#34;</span><span class="p">,</span>
        <span class="nx">testHelper</span><span class="p">.</span><span class="nx">Received</span><span class="p">,</span> <span class="nx">expected</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">})</span>
  <span class="o">...</span>
<span class="p">}</span>
</code></pre>
<p>This is the full first test. We created <code>MessageA</code> struct, giving it a value <code>Hello World</code> for the <code>Msg</code> field and the pointer to <code>TestHelper</code>, which we created at the beginning of the test. Then, we execute its Accept method. Inside the <code>Accept(Visitor)</code> method on the <code>MessageA</code> struct, the <code>VisitA(*MessageA)</code> method is executed to alter the contents of the Msg field (that&#39;s why we passed the pointer to <code>VisitA</code> method, without a pointer the contents won&#39;t be persisted).</p>
<p>To test if the <code>Visitor</code> type has done its job within the <code>Accept</code> method, we must call the <code>Print()</code> method on the <code>MessageA</code> type later. This way, the <code>MessageA</code> struct must write the contents of <code>Msg</code> to the provided <code>io.Writer</code> interface (our <code>TestHelper</code>).</p>
<p>The last part of the test is the check. According to the description of <i>acceptance criteria 2</i>, the output text of <code>MessageA</code> type must be prefixed with the text A:, the stored message and the text <q><code>(Visited)</code></q> just at the end. So, for the <code>MessageA</code> type, the expected text must be <q><code>A: Hello World (Visited)</code></q>, this is the check that we did in the <code>if</code> section.</p>
<p>The <code>MessageB</code> type has a very similar implementation:</p>
<pre class="code" ><code class="chroma" >  <span class="nx">t</span><span class="p">.</span><span class="nx">Run</span><span class="p">(</span><span class="s">&#34;MessageB test&#34;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">){</span>
    <span class="nx">msg</span> <span class="o">:=</span> <span class="nx">MessageB</span> <span class="p">{</span>
      <span class="nx">Msg</span><span class="p">:</span> <span class="s">&#34;Hello World&#34;</span><span class="p">,</span>
      <span class="nx">Output</span><span class="p">:</span> <span class="nx">testHelper</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="nx">msg</span><span class="p">.</span><span class="nx">Accept</span><span class="p">(</span><span class="nx">visitor</span><span class="p">)</span>
    <span class="nx">msg</span><span class="p">.</span><span class="nx">Print</span><span class="p">()</span>

    <span class="nx">expected</span> <span class="o">:=</span> <span class="s">&#34;B: Hello World (Visited B)&#34;</span>
    <span class="k">if</span> <span class="nx">testHelper</span><span class="p">.</span><span class="nx">Received</span> <span class="o">!=</span>  <span class="nx">expected</span> <span class="p">{</span>
      <span class="nx">t</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&#34;Expected result was incorrect. %s != %s&#34;</span><span class="p">,</span>
        <span class="nx">testHelper</span><span class="p">.</span><span class="nx">Received</span><span class="p">,</span> <span class="nx">expected</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">})</span>
<span class="p">}</span>
</code></pre>
<p>In fact, we have just changed the type from <code>MessageA</code> to <code>MessageB</code> and the expected text now is <q><code>B: Hello World (Visited B)</code></q>. The <code>Msg</code> field is also <q><code>Hello World</code></q> and we also used the <code>TestHelper</code> type.</p>
<p>We still lack the correct implementations of the interfaces to compile the code and run the tests. The <code>MessageA</code> and <code>MessageB</code> structs have to implement the <code>Accept(Visitor)</code> method:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">MessageA</span><span class="p">)</span> <span class="nx">Accept</span><span class="p">(</span><span class="nx">v</span> <span class="nx">Visitor</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Do nothing
</span><span class="c1"></span><span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">MessageB</span><span class="p">)</span> <span class="nx">Accept</span><span class="p">(</span><span class="nx">v</span> <span class="nx">Visitor</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Do nothing
</span><span class="c1"></span><span class="p">}</span>
</code></pre>
<p>We need the implementations of the <code>VisitA(*MessageA)</code> and <code>VisitB(*MessageB)</code> methods that are declared on the <code>Visitor</code> interface. The <code>MessageVisitor</code> interface is the type that must implement them:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="p">(</span><span class="nx">mf</span> <span class="o">*</span><span class="nx">MessageVisitor</span><span class="p">)</span> <span class="nx">VisitA</span><span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">MessageA</span><span class="p">){</span>
  <span class="c1">// Do nothing
</span><span class="c1"></span><span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">mf</span> <span class="o">*</span><span class="nx">MessageVisitor</span><span class="p">)</span> <span class="nx">VisitB</span><span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">MessageB</span><span class="p">){</span>
  <span class="c1">// Do nothing
</span><span class="c1"></span><span class="p">}</span>
</code></pre>
<p>Finally, we will create a <code>Print()</code> method for each message type. This is the method that we will use to test the contents of the <code>Msg</code> field on each type:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">MessageA</span><span class="p">)</span> <span class="nx">Print</span><span class="p">(){</span>
  <span class="c1">// Do nothing
</span><span class="c1"></span><span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">MessageB</span><span class="p">)</span> <span class="nx">Print</span><span class="p">(){</span>
  <span class="c1">// Do nothing
</span><span class="c1"></span><span class="p">}</span>
</code></pre>
<p>Now we can run the tests to really check if they are failing yet:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go <span class="nb">test</span> -v .
</span><span class="out" >=== RUN   Test_Overall
=== RUN   Test_Overall/MessageA_test
=== RUN   Test_Overall/MessageB_test
--- FAIL: Test_Overall (0.00s)
  --- FAIL: Test_Overall/MessageA_test (0.00s)
      visitor_test.go:30: Expected result was incorrect.  != A:
Hello World (Visited A)
  --- FAIL: Test_Overall/MessageB_test (0.00s)
      visitor_test.go:46: Expected result was incorrect.  != B:
Hello World (Visited B)
FAIL
exit status 1
FAIL
</span></code></pre>
<p>The outputs of the tests are clear. The expected messages were incorrect because the contents were empty. It&#39;s time to create the implementations.</p>
</div>
<h4 id="implementation-of-visitor-pattern" >Implementation of Visitor pattern</h4>
<div class="hBody-4" >
<p>We will start completing the implementation of the <code>VisitA(*MessageA)</code> and <code>VisitB(*MessageB)</code> methods:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="p">(</span><span class="nx">mf</span> <span class="o">*</span><span class="nx">MessageVisitor</span><span class="p">)</span> <span class="nx">VisitA</span><span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">MessageA</span><span class="p">){</span>
  <span class="nx">m</span><span class="p">.</span><span class="nx">Msg</span> <span class="p">=</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintf</span><span class="p">(</span><span class="s">&#34;%s %s&#34;</span><span class="p">,</span> <span class="nx">m</span><span class="p">.</span><span class="nx">Msg</span><span class="p">,</span> <span class="s">&#34;(Visited A)&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">mf</span> <span class="o">*</span><span class="nx">MessageVisitor</span><span class="p">)</span> <span class="nx">VisitB</span><span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">MessageB</span><span class="p">){</span>
  <span class="nx">m</span><span class="p">.</span><span class="nx">Msg</span> <span class="p">=</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintf</span><span class="p">(</span><span class="s">&#34;%s %s&#34;</span><span class="p">,</span> <span class="nx">m</span><span class="p">.</span><span class="nx">Msg</span><span class="p">,</span> <span class="s">&#34;(Visited B)&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
<p>Its functionality is quite straightforward--the <code>fmt.Sprintf</code> method returns a formatted string with the actual contents of <code>m.Msg</code>, a white space, and the message, <code>Visited</code>. This string will be stored on the <code>Msg</code> field, overriding the previous contents.</p>
<p>Now we will develop the <code>Accept</code> method for each message type that must execute the corresponding Visitor:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">MessageA</span><span class="p">)</span> <span class="nx">Accept</span><span class="p">(</span><span class="nx">v</span> <span class="nx">Visitor</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">v</span><span class="p">.</span><span class="nx">VisitA</span><span class="p">(</span><span class="nx">m</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">MessageB</span><span class="p">)</span> <span class="nx">Accept</span><span class="p">(</span><span class="nx">v</span> <span class="nx">Visitor</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">v</span><span class="p">.</span><span class="nx">VisitB</span><span class="p">(</span><span class="nx">m</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
<p>This small code has some implications on it. In both cases, we are using a <code>Visitor</code>, which in our example is exactly the same as the <code>MessageVisitor</code> interface, but they could be completely different. The key is to understand that the Visitor pattern executes an algorithm in its <code>Visit</code> method that deals with the <code>Visitable</code> object. What could the <code>Visitor</code> be doing? In this example, it alters the <code>Visitable</code> object, but it could be simply fetching information from it. For example, we could have a <code>Person</code> type with lots of fields: name, surname, age, address, city, postal code, and so on. We could write a Visitor to fetch just the name and surname from a person as a unique string, a visitor to fetch the address info for a different section of an app, and so on.</p>
<p>Finally, there is the <code>Print()</code> method, which will help us to test the types. We mentioned before that it must print to the <code>Stdout</code> call by default:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">MessageA</span><span class="p">)</span> <span class="nx">Print</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">if</span> <span class="nx">m</span><span class="p">.</span><span class="nx">Output</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">m</span><span class="p">.</span><span class="nx">Output</span> <span class="p">=</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Stdout</span>
  <span class="p">}</span>

  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Fprintf</span><span class="p">(</span><span class="nx">m</span><span class="p">.</span><span class="nx">Output</span><span class="p">,</span> <span class="s">&#34;A: %s&#34;</span><span class="p">,</span> <span class="nx">m</span><span class="p">.</span><span class="nx">Msg</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">MessageB</span><span class="p">)</span> <span class="nx">Print</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">if</span> <span class="nx">m</span><span class="p">.</span><span class="nx">Output</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">m</span><span class="p">.</span><span class="nx">Output</span> <span class="p">=</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Stdout</span>
  <span class="p">}</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Fprintf</span><span class="p">(</span><span class="nx">m</span><span class="p">.</span><span class="nx">Output</span><span class="p">,</span> <span class="s">&#34;B: %s&#34;</span><span class="p">,</span> <span class="nx">m</span><span class="p">.</span><span class="nx">Msg</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
<p>It first checks the content of the <code>Output</code> field to assign the output of the <code>os.Stdout</code> call in case it is null. In our tests, we are storing a pointer there to our <code>TestHelper</code> type so this line is never executed in our test. Finally, each message type prints to the <code>Output</code> field, the full message stored in the <code>Msg</code> field. This is done by using the <code>Fprintf</code> method, which takes an <code>io.Writer</code> package as the first argument and the text to format as the next arguments.</p>
<p>Our implementation is now complete and we can run the tests again to see if they all pass now:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go <span class="nb">test</span> -v .
</span><span class="out" >=== RUN   Test_Overall
=== RUN   Test_Overall/MessageA_test
=== RUN   Test_Overall/MessageB_test
--- PASS: Test_Overall (0.00s)
  --- PASS: Test_Overall/MessageA_test (0.00s)
  --- PASS: Test_Overall/MessageB_test (0.00s)
PASS
ok
</span></code></pre>
<p>Everything is OK! The Visitor pattern has done its job flawlessly and the message contents were altered after calling their <code>Visit</code> methods. The very important thing here is that we can add more functionality to both the structs, <code>MessageA</code> and <code>MessageB</code>, without altering their types. We can just create a new Visitor type that does everything on the <code>Visitable</code>, for example, we can create a <code>Visitor</code> to add a method that prints the contents of the <code>Msg</code> field:</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">MsgFieldVisitorPrinter</span> <span class="kd">struct</span> <span class="p">{}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">mf</span> <span class="o">*</span><span class="nx">MsgFieldVisitorPrinter</span><span class="p">)</span> <span class="nx">VisitA</span><span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">MessageA</span><span class="p">){</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="nx">m</span><span class="p">.</span><span class="nx">Msg</span><span class="p">)</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">mf</span> <span class="o">*</span><span class="nx">MsgFieldVisitorPrinter</span><span class="p">)</span> <span class="nx">VisitB</span><span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">MessageB</span><span class="p">){</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="nx">m</span><span class="p">.</span><span class="nx">Msg</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
<p>We have just added some functionality to both types without altering their contents! That&#39;s the power of the Visitor design pattern.</p>
</div>
<h4 id="another-example" >Another example</h4>
<div class="hBody-4" >
<p>We will develop a second example, this one a bit more complex. In this case, we will emulate an online shop with a few products. The products will have plain types, with just fields and we will make a couple of visitors to deal with them in the group.</p>
<p>First of all, we will develop the interfaces. The <code>ProductInfoRetriever</code> type has a method to get the price and the name of the product. The <code>Visitor</code> interface, like before, has a <code>Visit</code> method that accepts the <code>ProductInfoRetriever</code> type. Finally, <code>Visitable</code> interface is exactly the same; it has an <code>Accept</code> method that takes a <code>Visitor</code> type as an argument:</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">ProductInfoRetriever</span> <span class="kd">interface</span> <span class="p">{</span>
  <span class="nx">GetPrice</span><span class="p">()</span> <span class="kt">float32</span>
  <span class="nx">GetName</span><span class="p">()</span> <span class="kt">string</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">Visitor</span> <span class="kd">interface</span> <span class="p">{</span>
  <span class="nx">Visit</span><span class="p">(</span><span class="nx">ProductInfoRetriever</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">Visitable</span> <span class="kd">interface</span> <span class="p">{</span>
  <span class="nx">Accept</span><span class="p">(</span><span class="nx">Visitor</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
<p>All the products of the online shop must implement the <code>ProductInfoRetriever</code> type. Also, most products will have some commons fields, such as name or price (the ones defined in the <code>ProductInfoRetriever</code> interface). We created the <code>Product</code> type, implemented the <code>ProductInfoRetriever</code> and the <code>Visitable</code> interfaces, and embedded it on each product:</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">Product</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">Price</span> <span class="kt">float32</span>
  <span class="nx">Name</span>  <span class="kt">string</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">Product</span><span class="p">)</span> <span class="nx">GetPrice</span><span class="p">()</span> <span class="kt">float32</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">p</span><span class="p">.</span><span class="nx">Price</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">Product</span><span class="p">)</span> <span class="nx">Accept</span><span class="p">(</span><span class="nx">v</span> <span class="nx">Visitor</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">v</span><span class="p">.</span><span class="nx">Visit</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">Product</span><span class="p">)</span> <span class="nx">GetName</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">p</span><span class="p">.</span><span class="nx">Name</span>
<span class="p">}</span>
</code></pre>
<p>Now we have a very generic <code>Product</code> type that can store the information about almost any product of the shop. For example, we could have a <code>Rice</code> and a <code>Pasta</code> product:</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">Rice</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">Product</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">Pasta</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">Product</span>
<span class="p">}</span>
</code></pre>
<p>Each has the <code>Product</code> type embedded. Now we need to create a couple of <code>Visitors</code> interfaces, one that sums the price of all products and one that prints the name of each product:</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">PriceVisitor</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">Sum</span> <span class="kt">float32</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">pv</span> <span class="o">*</span><span class="nx">PriceVisitor</span><span class="p">)</span> <span class="nx">Visit</span><span class="p">(</span><span class="nx">p</span> <span class="nx">ProductInfoRetriever</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">pv</span><span class="p">.</span><span class="nx">Sum</span> <span class="o">+=</span> <span class="nx">p</span><span class="p">.</span><span class="nx">GetPrice</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">NamePrinter</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">ProductList</span> <span class="kt">string</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">n</span> <span class="o">*</span><span class="nx">NamePrinter</span><span class="p">)</span> <span class="nx">Visit</span><span class="p">(</span><span class="nx">p</span> <span class="nx">ProductInfoRetriever</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">n</span><span class="p">.</span><span class="nx">Names</span> <span class="p">=</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintf</span><span class="p">(</span><span class="s">&#34;%s\n%s&#34;</span><span class="p">,</span> <span class="nx">p</span><span class="p">.</span><span class="nx">GetName</span><span class="p">(),</span> <span class="nx">n</span><span class="p">.</span><span class="nx">ProductList</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
<p>The <code>PriceVisitor</code> struct takes the value of the <code>Price</code> variable of the <code>ProductInfoRetriever</code> type, passed as an argument, and adds it to the <code>Sum</code> field. The <code>NamePrinter</code> struct stores the name of the <code>ProductInfoRetriever</code> type, passed as an argument, and appends it to a new line on the <code>ProductList</code> field.</p>
<p>Time for the <code>main</code> function:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">products</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="nx">Visitable</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
  <span class="nx">products</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">Rice</span><span class="p">{</span>
    <span class="nx">Product</span><span class="p">:</span> <span class="nx">Product</span><span class="p">{</span>
      <span class="nx">Price</span><span class="p">:</span> <span class="mf">32.0</span><span class="p">,</span>
      <span class="nx">Name</span><span class="p">:</span>  <span class="s">&#34;Some rice&#34;</span><span class="p">,</span>
    <span class="p">},</span>
  <span class="p">}</span>
  <span class="nx">products</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">Pasta</span><span class="p">{</span>
    <span class="nx">Product</span><span class="p">:</span> <span class="nx">Product</span><span class="p">{</span>
      <span class="nx">Price</span><span class="p">:</span> <span class="mf">40.0</span><span class="p">,</span>
      <span class="nx">Name</span><span class="p">:</span>  <span class="s">&#34;Some pasta&#34;</span><span class="p">,</span>
    <span class="p">},</span>
  <span class="p">}</span>

  <span class="c1">// Print the sum of prices
</span><span class="c1"></span>  <span class="nx">priceVisitor</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">PriceVisitor</span><span class="p">{}</span>

  <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">p</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">products</span> <span class="p">{</span>
    <span class="nx">p</span><span class="p">.</span><span class="nx">Accept</span><span class="p">(</span><span class="nx">priceVisitor</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&#34;Total: %f\n&#34;</span><span class="p">,</span> <span class="nx">priceVisitor</span><span class="p">.</span><span class="nx">Sum</span><span class="p">)</span>

  <span class="c1">// Print the products list
</span><span class="c1"></span>  <span class="nx">nameVisitor</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">NamePrinter</span><span class="p">{}</span>

  <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">p</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">products</span> <span class="p">{</span>
    <span class="nx">p</span><span class="p">.</span><span class="nx">Accept</span><span class="p">(</span><span class="nx">nameVisitor</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&#34;\nProduct list:\n-------------\n%s&#34;</span><span class="p">,</span> <span class="nx">nameVisitor</span><span class="p">.</span><span class="nx">ProductList</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
<p>We create a slice of two <code>Visitable</code> objects: a <code>Rice</code> and a <code>Pasta</code> type with some arbitrary names. Then we iterate for each of them using a <code>PriceVisitor</code> instance as an argument. We print the total price after the range for. Finally, we repeat this operation with the <code>NamePrinter</code> and print the resulting <code>ProductList</code>. The output of this <code>main</code> function is as follows:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go run visitor.go
</span><span class="out" >Total: 72.000000
Product list:
-------------
Some pasta
Some rice
</span></code></pre>
<p>Ok, this is a nice example of the <code>Visitor</code> pattern but... what if there are special considerations about a product? For example, what if we need to sum 20 to the total price of a fridge type? OK, let&#39;s write the <code>Fridge</code> structure:</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">Fridge</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">Product</span>
<span class="p">}</span>
</code></pre>
<p>The idea here is to just override the <code>GetPrice()</code> method to return the product&#39;s price plus 20:</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">Fridge</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">Product</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">f</span> <span class="o">*</span><span class="nx">Fridge</span><span class="p">)</span> <span class="nx">GetPrice</span><span class="p">()</span> <span class="kt">float32</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">f</span><span class="p">.</span><span class="nx">Product</span><span class="p">.</span><span class="nx">Price</span> <span class="o">+</span> <span class="mi">20</span>
<span class="p">}</span>
</code></pre>
<p>Unfortunately, this isn&#39;t enough for our example. The <code>Fridge</code> structure is not of a  <code>Visitable</code> type. The <code>Product</code> struct is of a <code>Visitable</code> type and the <code>Fridge</code> struct has a <code>Product</code> struct embedded but, as we mentioned in earlier chapters, a type that embeds a second type cannot be considered of that latter type, even when it has all its fields and methods. The solution is to also implement the <code>Accept(Visitor)</code> method so that it can be considered as a Visitable:</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">Fridge</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">Product</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">f</span> <span class="o">*</span><span class="nx">Fridge</span><span class="p">)</span> <span class="nx">GetPrice</span><span class="p">()</span> <span class="kt">float32</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">f</span><span class="p">.</span><span class="nx">Product</span><span class="p">.</span><span class="nx">Price</span> <span class="o">+</span> <span class="mi">20</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">f</span> <span class="o">*</span><span class="nx">Fridge</span><span class="p">)</span> <span class="nx">Accept</span><span class="p">(</span><span class="nx">v</span> <span class="nx">Visitor</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">v</span><span class="p">.</span><span class="nx">Visit</span><span class="p">(</span><span class="nx">f</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
<p>Let&#39;s rewrite the <code>main</code> function  to add this new <code>Fridge</code> product to the slice:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">products</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="nx">Visitable</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
  <span class="nx">products</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">Rice</span><span class="p">{</span>
    <span class="nx">Product</span><span class="p">:</span> <span class="nx">Product</span><span class="p">{</span>
      <span class="nx">Price</span><span class="p">:</span> <span class="mf">32.0</span><span class="p">,</span>
      <span class="nx">Name</span><span class="p">:</span>  <span class="s">&#34;Some rice&#34;</span><span class="p">,</span>
    <span class="p">},</span>
  <span class="p">}</span>
  <span class="nx">products</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">Pasta</span><span class="p">{</span>
    <span class="nx">Product</span><span class="p">:</span> <span class="nx">Product</span><span class="p">{</span>
      <span class="nx">Price</span><span class="p">:</span> <span class="mf">40.0</span><span class="p">,</span>
      <span class="nx">Name</span><span class="p">:</span>  <span class="s">&#34;Some pasta&#34;</span><span class="p">,</span>
    <span class="p">},</span>
  <span class="p">}</span>
  <span class="nx">products</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">Fridge</span><span class="p">{</span>
    <span class="nx">Product</span><span class="p">:</span> <span class="nx">Product</span><span class="p">{</span>
      <span class="nx">Price</span><span class="p">:</span> <span class="mi">50</span><span class="p">,</span>
      <span class="nx">Name</span><span class="p">:</span>  <span class="s">&#34;A fridge&#34;</span><span class="p">,</span>
    <span class="p">},</span>
  <span class="p">}</span>
  <span class="o">...</span>
<span class="p">}</span>
</code></pre>
<p>Everything else continues the same. Running this new main function produces the following output:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go run visitor.go
</span><span class="out" >Total: 142.000000
Product list:
-------------
A fridge
Some pasta
Some rice
</span></code></pre>
<p>As expected, the total price is higher now, outputting the sum of the rice (32), the pasta (40), and the fridge (50 of the product plus 20 of the transport, so 70). We could be adding visitors forever to this products, but the idea is clear--we decoupled some algorithms outside of the types to the visitors.</p>
</div>
<h4 id="visitors-to-the-rescue!" >Visitors to the rescue!</h4>
<div class="hBody-4" >
<p>We have seen a powerful abstraction to add new algorithms to some types. However, because of the lack of overloading in Go, this pattern could be limiting in some aspects (we have seen it in the first example, where we had to create the <code>VisitA</code> and <code>VisitB</code> implementations). In the second example, we haven&#39;t dealt with this limitation because we have used an interface to the <code>Visit</code> method of the <code>Visitor</code> struct, but we just used one type of visitor (<code>ProductInfoRetriever</code>) and we would have the same problem if we implemented a <code>Visit</code> method for a second type, which is one of the objectives of the original <i>Gang of Four</i> design patterns.</p>
</div>
<h3 id="state-design-pattern" >State design pattern</h3>
<div class="hBody-3" >
<p>State patterns are directly related to FSMs. An FSM, in very simple terms, is something that has one or more states and travels between them to execute some behaviors. Let&#39;s see how the State pattern helps us to define FSM.</p>
</div>
<h4 id="description" >Description</h4>
<div class="hBody-4" >
<p>A light switch is a common example of an FSM. It has two states--on and off. One state can transit to the other and vice versa. The way that the State pattern works is similar. We have a <code>State</code> interface and an implementation of each state we want to achieve. There is also usually a context that holds cross-information between the states.</p>
<p>With FSM, we can achieve very complex behaviors by splitting their scope between states. This way we can model pipelines of execution based on any kind of inputs or create event-driven software that responds to particular events in specified ways.</p>
</div>
<h4 id="objectives" >Objectives</h4>
<div class="hBody-4" >
<p>The main objectives of the State pattern is to develop FSM are as follows:</p>
<ul>
<li>
<p>To have a type that alters its own behavior when some internal things have changed</p>
</li>
<li>
<p>Model complex graphs and pipelines can be upgraded easily by adding more states and rerouting their output states</p>
</li>
</ul>
</div>
<h4 id="a-small-guess-the-number-game" >A small guess the number game</h4>
<div class="hBody-4" >
<p>We are going to develop a very simple game that uses FSM. This game is a number guessing game. The idea is simple--we will have to guess some number between 0 and 10 and we have just a few attempts or we&#39;ll lose.</p>
<p>We will leave the player to choose the level of difficulty by asking how many tries the user has before losing. Then, we will ask the player for the correct number and keep asking if they don&#39;t guess it or if the number of tries reaches zero.</p>
</div>
<h4 id="acceptance-criteria" >Acceptance criteria</h4>
<div class="hBody-4" >
<p>For this simple game, we have five acceptance criteria that basically describe the mechanics of the game:</p>
<ol class="num" >
<li>
<p>The game will ask the player how many tries they will have before losing the game.</p>
</li>
<li>
<p>The number to guess must be between 0 and 10.</p>
</li>
<li>
<p>Every time a player enters a number to guess, the number of retries drops by one.</p>
</li>
<li>
<p>If the number of retries reaches zero and the number is still incorrect, the game finishes and the player has lost.</p>
</li>
<li>
<p>If the player guesses the number, the player wins.</p>
</li>
</ol>
</div>
<h4 id="implementation-of-state-pattern" >Implementation of State pattern</h4>
<div class="hBody-4" >
<p>The idea of unit tests is quite straightforward in a State pattern so we will spend more time explaining in detail the mechanism to use it, which is a bit more complex than usual.</p>
<p>First of all, we need the interface to represent the different states and a game context to store the information between states. For this game, the context needs to store the number of retries, if the user has won or not, the secret number to guess, and the current state. The state will have an <code>executeState</code> method that accepts one of these contexts and returns <code>true</code> if the game has finished, or <code>false</code> if not:</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">GameState</span> <span class="kd">interface</span> <span class="p">{</span>
  <span class="nx">executeState</span><span class="p">(</span><span class="o">*</span><span class="nx">GameContext</span><span class="p">)</span> <span class="kt">bool</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">GameContext</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">SecretNumber</span> <span class="kt">int</span>
  <span class="nx">Retries</span> <span class="kt">int</span>
  <span class="nx">Won</span> <span class="kt">bool</span>
  <span class="nx">Next</span> <span class="nx">GameState</span>
<span class="p">}</span>
</code></pre>
<p>As described in <i>acceptance criteria 1</i>, the player must be able to introduce the number of retries they want. This will be achieved by a state called <code>StartState</code>. Also, the <code>StartState</code> struct must prepare the game, setting the context to its initial value before the player:</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">StartState</span> <span class="kd">struct</span><span class="p">{}</span>
<span class="kd">func</span><span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">StartState</span><span class="p">)</span> <span class="nx">executeState</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">GameContext</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
  <span class="nx">c</span><span class="p">.</span><span class="nx">Next</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">AskState</span><span class="p">{}</span>

  <span class="nx">rand</span><span class="p">.</span><span class="nx">Seed</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Now</span><span class="p">().</span><span class="nx">UnixNano</span><span class="p">())</span>
  <span class="nx">c</span><span class="p">.</span><span class="nx">SecretNumber</span> <span class="p">=</span> <span class="nx">rand</span><span class="p">.</span><span class="nx">Intn</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>

  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&#34;Introduce a number a number of retries to set the difficulty:&#34;</span><span class="p">)</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Fscanf</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Stdin</span><span class="p">,</span> <span class="s">&#34;%d\n&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">Retries</span><span class="p">)</span>

  <span class="k">return</span> <span class="kc">true</span>
<span class="p">}</span>
</code></pre>
<p>First of all, the <code>StartState</code> struct implements the <code>GameState</code> structure because it has the <code>executeState(*Context)</code> method of <code>Boolean</code> type on its structure. At the beginning of this state, it sets the only state possible after executing this one--the <code>AskState</code> state. The <code>AskState</code> struct is not declared yet, but it will be the state where we ask the player for a number to guess.</p>
<p>In the next two lines, we use the <code>Rand</code> package of Go to generate a random number. In the first line, we feed the random generator with the <code>int64</code> type number returned by the current moment, so we ensure a random feed in each execution (if you put a constant number here, the randomizer will also generate the same number too). The <code>rand.Intn(int)</code> method returns an integer number between zero and the specified number, so here we cover <i>acceptance criteria 2</i>.</p>
<p>Next, a message asking for a number of retries to set precedes the <code>fmt.Fscanf</code> method, a powerful function where you can pass it an <code>io.Reader</code> (the standard input of the console), a format (number), and an interface to store the contents of the reader, in this case, the <code>Retries</code> field of the context.</p>
<p>Finally, we return <code>true</code> to tell the engine that the game must continue. Let&#39;s see the <code>AskState</code> struct, which we have used at the beginning of the function:</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">AskState</span> <span class="kd">struct</span> <span class="p">{}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">AskState</span><span class="p">)</span> <span class="nx">executeState</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">GameContext</span><span class="p">)</span> <span class="kt">bool</span><span class="p">{</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&#34;Introduce a number between 0 and 10, you have %d tries left\n&#34;</span><span class="p">,</span> <span class="nx">c</span><span class="p">.</span><span class="nx">Retries</span><span class="p">)</span>

  <span class="kd">var</span> <span class="nx">n</span> <span class="kt">int</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Fscanf</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Stdin</span><span class="p">,</span> <span class="s">&#34;%d&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">n</span><span class="p">)</span>
  <span class="nx">c</span><span class="p">.</span><span class="nx">Retries</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">Retries</span> <span class="o">-</span> <span class="mi">1</span>

  <span class="k">if</span> <span class="nx">n</span> <span class="o">==</span> <span class="nx">c</span><span class="p">.</span><span class="nx">SecretNumber</span> <span class="p">{</span>
    <span class="nx">c</span><span class="p">.</span><span class="nx">Won</span> <span class="p">=</span> <span class="kc">true</span>
    <span class="nx">c</span><span class="p">.</span><span class="nx">Next</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">FinishState</span><span class="p">{}</span>
  <span class="p">}</span>

  <span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">Retries</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
    <span class="nx">c</span><span class="p">.</span><span class="nx">Next</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">FinishState</span><span class="p">{}</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="kc">true</span>
<span class="p">}</span>
</code></pre>
<p>The <code>AskState</code> structure also implements the <code>GameState</code> state, as you have probably guessed already. This states starts with a message for the player, asking them to insert a new number. In the next three lines, we create a local variable to store the contents of the number that the player will introduce. We used the <code>fmt.Fscanf</code> method again, as we did in <code>StartState</code> struct to capture the player&#39;s input and store it in the variable n. Then, we have one retry less in our counter, so we have to subtract one to the number of retries represented in the <code>Retries</code> field.</p>
<p>Then, there are two checks: one that checks if the user has entered the correct number, in which case the context field <code>Won</code> is set to <code>true</code> and the next state is set to the <code>FinishState</code> struct (not declared yet).</p>
<p>The second check is controlling that the number of retries has not reached zero, in which case it won&#39;t let the player ask again for a number and it will send the player to the <code>FinishState</code> struct directly. After all, we have to tell the game engine again that the game must continue by returning <code>true</code> in the <code>executeState</code> method.</p>
<p>Finally, we define the <code>FinishState</code> struct. It controls the exit status of the game, checking the contents of the <code>Won</code> field in the context object:</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">FinishState</span> <span class="kd">struct</span><span class="p">{}</span>
<span class="kd">func</span><span class="p">(</span><span class="nx">f</span> <span class="o">*</span><span class="nx">FinishState</span><span class="p">)</span> <span class="nx">executeState</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">GameContext</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
  <span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">Won</span> <span class="p">{</span>
    <span class="nb">println</span><span class="p">(</span><span class="s">&#34;Congrats, you won&#34;</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="k">else</span> <span class="p">{</span>
    <span class="nb">println</span><span class="p">(</span><span class="s">&#34;You lose&#34;</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="kc">false</span>
<span class="p">}</span>
</code></pre>
<p>The <code>TheFinishState</code> struct also implements the <code>GameState</code> state by having <code>executeState</code> method in its structure. The idea here is very simple--if the player has won (this field is set previously in the <code>AskState</code> struct), the <code>FinishState</code> structure will print the message <code>Congrats, you won</code>. If the player has not won (remember that the zero value of the Boolean variable is <code>false</code>), the <code>FinishState</code> prints the message <code>You lose</code>.</p>
<p>In this case, the game can be considered finished, so we return <code>false</code> to say that the game must not continue.</p>
<p>We just need the <code>main</code> method to play our game:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">start</span> <span class="o">:=</span> <span class="nx">StartState</span><span class="p">{}</span>
  <span class="nx">game</span> <span class="o">:=</span> <span class="nx">GameContext</span><span class="p">{</span>
    <span class="nx">Next</span><span class="p">:</span><span class="o">&amp;</span><span class="nx">start</span><span class="p">,</span>
  <span class="p">}</span>
  <span class="k">for</span> <span class="nx">game</span><span class="p">.</span><span class="nx">Next</span><span class="p">.</span><span class="nx">executeState</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">game</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">}</span>
</code></pre>
<p>Well, yes, it can&#39;t be simpler. The game must begin with the <code>start</code> method, although it could be abstracted more outside in case that the game needs more initialization in the future, but in our case it is fine. Then, we create a context where we set the <code>Next</code> state as a pointer to the <code>start</code> variable. So the first state that will be executed in the game will be the <code>StartState</code> state.</p>
<p>The last line of the <code>main</code> function has a lot of things just there. We create a loop, without any statement inside it. As with any loop, it keeps looping after the condition is not satisfied. The condition we are using is the returned value of the <code>GameStates</code> structure, <code>true</code> as soon as the game is not finished.</p>
<p>So, the idea is simple: we execute the state in the context, passing a pointer to the context to it. Each state returns <code>true</code> until the game has finished and the <code>FinishState</code> struct will return <code>false</code>. So our for loop will keep looping, waiting for a <code>false</code> condition sent by the <code>FinishState</code> structure to end the application.</p>
<p>Let&#39;s play once:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go run state.go
</span><span class="out" >Introduce a number a number of retries to set the difficulty:
5
Introduce a number between 0 and 10, you have 5 tries left
8
Introduce a number between 0 and 10, you have 4 tries left
2
Introduce a number between 0 and 10, you have 3 tries left
1
Introduce a number between 0 and 10, you have 2 tries left
3
Introduce a number between 0 and 10, you have 1 tries left
4
You lose
</span></code></pre>
<p>We lost! We set the number of retries to 5. Then we kept inserting numbers, trying to guess the secret number. We entered 8, 2, 1, 3, and 4, but it wasn&#39;t any of them. I don&#39;t even know what the correct number was; let&#39;s fix this!</p>
<p>Go to the definition of the <code>FinishState</code> struct and change the line where it says <code>You lose</code>, and replace it with the following:</p>
<pre class="code" ><code class="chroma" ><span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&#34;You lose. The correct number was: %d\n&#34;</span><span class="p">,</span> <span class="nx">c</span><span class="p">.</span><span class="nx">SecretNumber</span><span class="p">)</span>
</code></pre>
<p>Now it will show the correct number. Let&#39;s play again:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go run state.go
</span><span class="out" >Introduce a number a number of retries to set the difficulty:
3
Introduce a number between 0 and 10, you have 3 tries left
6
Introduce a number between 0 and 10, you have 2 tries left
2
Introduce a number between 0 and 10, you have 1 tries left
1
You lose. The correct number was: 9
</span></code></pre>
<p>This time we make it a little harder by setting only three tries... and we lost again. I entered 6, 2, and 1, but the correct number was 9. Last try:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go run state.go
</span><span class="out" >Introduce a number a number of retries to set the difficulty:
5
Introduce a number between 0 and 10, you have 5 tries left
3
Introduce a number between 0 and 10, you have 4 tries left
4
Introduce a number between 0 and 10, you have 3 tries left
5
Introduce a number between 0 and 10, you have 2 tries left
6
Congrats, you won
</span></code></pre>
<p>Great! This time we lowered the difficulty, allowing up to five tries and we won! we even had one more try left, but we guessed the number in the fourth try after entering 3, 4, 5. The correct number was 6, which was my fourth try.</p>
</div>
<h4 id="a-state-to-win-and-a-state-to-lose" >A state to win and a state to lose</h4>
<div class="hBody-4" >
<p>Have you realized that we could have a winning and a lose state instead of printing the messages directly in the <code>FinishState</code> struct? This way we could, for example, check some hypothetical scoreboard in the win section to see if we have set a record. Let&#39;s refactor our game. First we need a <code>WinState</code> and a <code>LoseState</code> struct:</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">WinState</span> <span class="kd">struct</span><span class="p">{}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">w</span> <span class="o">*</span><span class="nx">WinState</span><span class="p">)</span> <span class="nx">executeState</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">GameContext</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
  <span class="nb">println</span><span class="p">(</span><span class="s">&#34;Congrats, you won&#34;</span><span class="p">)</span>

  <span class="k">return</span> <span class="kc">false</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">LoseState</span> <span class="kd">struct</span><span class="p">{}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">l</span> <span class="o">*</span><span class="nx">LoseState</span><span class="p">)</span> <span class="nx">executeState</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">GameContext</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&#34;You lose. The correct number was: %d\n&#34;</span><span class="p">,</span> <span class="nx">c</span><span class="p">.</span><span class="nx">SecretNumber</span><span class="p">)</span>
  <span class="k">return</span> <span class="kc">false</span>
<span class="p">}</span>
</code></pre>
<p>These two new states have nothing new. They contain the same messages that were previously in the <code>FinishState</code> state that, by the way, must be modified to use these new states:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="p">(</span><span class="nx">f</span> <span class="o">*</span><span class="nx">FinishState</span><span class="p">)</span> <span class="nx">executeState</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">GameContext</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
  <span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">Won</span> <span class="p">{</span>
    <span class="nx">c</span><span class="p">.</span><span class="nx">Next</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">WinState</span><span class="p">{}</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="nx">c</span><span class="p">.</span><span class="nx">Next</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">LoseState</span><span class="p">{}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="kc">true</span>
<span class="p">}</span>
</code></pre>
<p>Now, the finish state doesn&#39;t print anything and, instead, delegates this to the next state in the chain--the <code>WinState</code> structure, if the user has won and the <code>LoseState</code> struct, if not. Remember that the game doesn&#39;t finish on the <code>FinishState</code> struct now, and we must return true instead of <code>false</code> to notify to the engine that it must keep executing states in the chain.</p>
</div>
<h4 id="the-game-built-using-the-state-pattern" >The game built using the State pattern</h4>
<div class="hBody-4" >
<p>You must be thinking now that you can extend this game forever with new states, and it&#39;s true. The power of the State pattern is not only the capacity to create a complex FSM, but also the flexibility to improve it as much as you want by adding new states and modifying some old states to point to the new ones without affecting the rest of the FSM.</p>
</div>
<h3 id="mediator-design-pattern" >Mediator design pattern</h3>
<div class="hBody-3" >
<p>Let&#39;s continue with the Mediator pattern. As its name implies, it&#39;s a pattern that will be in between two types to exchange information. But, why will we want this behavior at all? Let&#39;s look at this in detail.</p>
</div>
<h4 id="description" >Description</h4>
<div class="hBody-4" >
<p>One of the key objectives of any design pattern is to avoid tight coupling between objects. This can be done in many ways, as we have seen already.</p>
<p>But one particularly effective method when the application grows a lot is the Mediator pattern. The Mediator pattern is the perfect example of a pattern that is commonly used by every programmer without thinking very much about it.</p>
<p>Mediator pattern will act as the type in charge of exchanging communication between two objects. This way, the communicating objects don&#39;t need to know each other and can change more freely. The pattern that maintains which objects give what information is the Mediator.</p>
</div>
<h4 id="objectives" >Objectives</h4>
<div class="hBody-4" >
<p>As previously described, the main objectives of the Mediator pattern are about loose coupling and encapsulation. The objectives are:</p>
<ul>
<li>
<p>To provide loose coupling between two objects that must communicate between them</p>
</li>
<li>
<p>To reduce the amount of dependencies of a particular type to the minimum by passing these needs to the Mediator pattern</p>
</li>
</ul>
</div>
<h4 id="a-calculator" >A calculator</h4>
<div class="hBody-4" >
<p>For the Mediator pattern, we are going to develop an extremely simple arithmetic calculator. You&#39;re probably thinking that a calculator is so simple that it does not need any pattern. But we will see that this is not exactly true.</p>
<p>Our calculator will only do two very simple operations: sum and subtract.</p>
</div>
<h4 id="acceptance-criteria" >Acceptance criteria</h4>
<div class="hBody-4" >
<p>It sounds quite funny to talk about acceptance criteria to define a calculator, but let&#39;s do it anyway:</p>
<ol class="num" >
<li>
<p>Define an operation called <code>Sum</code> that takes a number and adds it to another number.</p>
</li>
<li>
<p>Define an operation called <code>Subtract</code> that takes a number and substracts it to another number.</p>
</li>
</ol>
<p>Well, I don&#39;t know about you, but I really need a rest after this <i>complex</i> criteria. So why are we defining this so much? Patience, you will have the answer soon.</p>
</div>
<h4 id="implementation" >Implementation</h4>
<div class="hBody-4" >
<p>We have to jump directly to the implementation because we cannot test that the sum will be correct (well, we can, but we will be testing if Go is correctly written!). We could test that we pass the acceptance criteria, but it&#39;s a bit of an overkill for our example.</p>
<p>So let&#39;s start by implementing the necessary types:</p>
<pre class="code" ><code class="chroma" ><span class="kn">package</span> <span class="nx">main</span>

<span class="kd">type</span> <span class="nx">One</span> <span class="kd">struct</span><span class="p">{}</span>
<span class="kd">type</span> <span class="nx">Two</span> <span class="kd">struct</span><span class="p">{}</span>
<span class="kd">type</span> <span class="nx">Three</span> <span class="kd">struct</span><span class="p">{}</span>
<span class="kd">type</span> <span class="nx">Four</span> <span class="kd">struct</span><span class="p">{}</span>
<span class="kd">type</span> <span class="nx">Five</span> <span class="kd">struct</span><span class="p">{}</span>
<span class="kd">type</span> <span class="nx">Six</span> <span class="kd">struct</span><span class="p">{}</span>
<span class="kd">type</span> <span class="nx">Seven</span> <span class="kd">struct</span><span class="p">{}</span>
<span class="kd">type</span> <span class="nx">Eight</span> <span class="kd">struct</span><span class="p">{}</span>
<span class="kd">type</span> <span class="nx">Nine</span> <span class="kd">struct</span><span class="p">{}</span>
<span class="kd">type</span> <span class="nx">Zero</span> <span class="kd">struct</span><span class="p">{}</span>
</code></pre>
<p>Well... this look quite awkward. We already have numeric types in Go to perform these operations, we don&#39;t need a type for each number!</p>
<p>But let&#39;s continue for a second with this insane approach. Let&#39;s implement the <code>One</code> struct:</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">One</span> <span class="kd">struct</span><span class="p">{}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">o</span> <span class="o">*</span><span class="nx">One</span><span class="p">)</span> <span class="nx">OnePlus</span><span class="p">(</span><span class="nx">n</span> <span class="kd">interface</span><span class="p">{})</span> <span class="kd">interface</span><span class="p">{}</span> <span class="p">{</span>
  <span class="k">switch</span> <span class="nx">n</span><span class="p">.(</span><span class="kd">type</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">case</span> <span class="nx">One</span><span class="p">:</span>
    <span class="k">return</span> <span class="o">&amp;</span><span class="nx">Two</span><span class="p">{}</span>
  <span class="k">case</span> <span class="nx">Two</span><span class="p">:</span>
    <span class="k">return</span> <span class="o">&amp;</span><span class="nx">Three</span><span class="p">{}</span>
  <span class="k">case</span> <span class="nx">Three</span><span class="p">:</span>
    <span class="k">return</span> <span class="o">&amp;</span><span class="nx">Four</span><span class="p">{}</span>
  <span class="k">case</span> <span class="nx">Four</span><span class="p">:</span>
    <span class="k">return</span> <span class="o">&amp;</span><span class="nx">Five</span><span class="p">{}</span>
  <span class="k">case</span> <span class="nx">Five</span><span class="p">:</span>
    <span class="k">return</span> <span class="o">&amp;</span><span class="nx">Six</span><span class="p">{}</span>
  <span class="k">case</span> <span class="nx">Six</span><span class="p">:</span>
    <span class="k">return</span> <span class="o">&amp;</span><span class="nx">Seven</span><span class="p">{}</span>
  <span class="k">case</span> <span class="nx">Seven</span><span class="p">:</span>
    <span class="k">return</span> <span class="o">&amp;</span><span class="nx">Eight</span><span class="p">{}</span>
  <span class="k">case</span> <span class="nx">Eight</span><span class="p">:</span>
    <span class="k">return</span> <span class="o">&amp;</span><span class="nx">Nine</span><span class="p">{}</span>
  <span class="k">case</span> <span class="nx">Nine</span><span class="p">:</span>
    <span class="k">return</span> <span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="kd">interface</span><span class="p">{}{</span><span class="o">&amp;</span><span class="nx">One</span><span class="p">{},</span> <span class="o">&amp;</span><span class="nx">Zero</span><span class="p">{}}</span>
  <span class="k">default</span><span class="p">:</span>
    <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&#34;Number not found&#34;</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>OK , I&#39;ll stop here. What is wrong with this implementation? This is completely crazy! It&#39;s overkill to make every operation possible between numbers to make sums! Especially when we have more than one digit.</p>
<p>Well, believe it or not, this is how a lot of software is commonly designed today. A small app where an object uses two or three objects grows, and it ends up using dozens of them. It becomes an absolute hell to simply add or remove a type from the application because it is hidden in some of this craziness.</p>
<p>So what can we do in this calculator? Use a Mediator type that frees all the cases:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">Sum</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="kd">interface</span><span class="p">{})</span> <span class="kd">interface</span><span class="p">{}{</span>
  <span class="k">switch</span> <span class="nx">a</span> <span class="o">:=</span> <span class="nx">a</span><span class="p">.(</span><span class="kd">type</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">case</span> <span class="nx">One</span><span class="p">:</span>
    <span class="k">switch</span> <span class="nx">b</span><span class="p">.(</span><span class="kd">type</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">case</span> <span class="nx">One</span><span class="p">:</span>
        <span class="k">return</span> <span class="o">&amp;</span><span class="nx">Two</span><span class="p">{}</span>
      <span class="k">case</span> <span class="nx">Two</span><span class="p">:</span>
        <span class="k">return</span> <span class="o">&amp;</span><span class="nx">Three</span><span class="p">{}</span>
      <span class="k">default</span><span class="p">:</span>
        <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&#34;Number not found&#34;</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">case</span> <span class="nx">Two</span><span class="p">:</span>
    <span class="k">switch</span> <span class="nx">b</span><span class="p">.(</span><span class="kd">type</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">case</span> <span class="nx">One</span><span class="p">:</span>
        <span class="k">return</span> <span class="o">&amp;</span><span class="nx">Three</span><span class="p">{}</span>
      <span class="k">case</span> <span class="nx">Two</span><span class="p">:</span>
        <span class="k">return</span> <span class="o">&amp;</span><span class="nx">Four</span><span class="p">{}</span>
      <span class="k">default</span><span class="p">:</span>
      <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&#34;Number not found&#34;</span><span class="p">)</span>

    <span class="p">}</span>
    <span class="k">case</span> <span class="kt">int</span><span class="p">:</span>
    <span class="k">switch</span> <span class="nx">b</span> <span class="o">:=</span> <span class="nx">b</span><span class="p">.(</span><span class="kd">type</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">case</span> <span class="nx">One</span><span class="p">:</span>
        <span class="k">return</span> <span class="o">&amp;</span><span class="nx">Three</span><span class="p">{}</span>
      <span class="k">case</span> <span class="nx">Two</span><span class="p">:</span>
        <span class="k">return</span> <span class="o">&amp;</span><span class="nx">Four</span><span class="p">{}</span>
      <span class="k">case</span> <span class="kt">int</span><span class="p">:</span>
        <span class="k">return</span> <span class="nx">a</span> <span class="o">+</span> <span class="nx">b</span>
      <span class="k">default</span><span class="p">:</span>
      <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&#34;Number not found&#34;</span><span class="p">)</span>

    <span class="p">}</span>
    <span class="k">default</span><span class="p">:</span>
    <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&#34;Number not found&#34;</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>We have just developed a couple of numbers to keep things short. The <code>Sum</code> function acts as a mediator between two numbers. First it checks the type of the first number named <code>a</code>. Then, for each type of the first number, it checks the type of the second number named b and returns the resulting type.</p>
<p>While the solution still looks very crazy now, the only one that knows about all possible numbers in the calculator is the <code>Sum</code> function. But take a closer look and you&#39;ll see that we have added a type case for the int type. We have cases <code>One</code>, <code>Two</code>, and <code>int</code>. Inside the <code>int</code> case, we also have another <code>int</code> case for the b number. What do we do here? If both types are of the <code>int</code> case, we can return the sum of them.</p>
<p>Do you think that this will work? Let&#39;s write a simple <code>main</code> function:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">main</span><span class="p">(){</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&#34;%#v\n&#34;</span><span class="p">,</span> <span class="nx">Sum</span><span class="p">(</span><span class="nx">One</span><span class="p">{},</span> <span class="nx">Two</span><span class="p">{}))</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&#34;%d\n&#34;</span><span class="p">,</span> <span class="nx">Sum</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
<span class="p">}</span>
</code></pre>
<p>We print the sum of type <code>One</code> and type <code>Two</code>. By using the <code>&#34;%#v&#34;</code> format, we ask to print information about the type. The second line in the function uses <code>int</code> types, and we also print the result. This in the console produces the following output:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go run mediator.go
</span><span class="out" >&amp;main.Three{}
7
</span></code></pre>
<p>Not very impressive, right? But let&#39;s think for a second. By using the Mediator pattern, we have been able to refactor the initial calculator, where we have to define every operation on every type to a Mediator pattern, the <code>Sum</code> function.</p>
<p>The nice thing is that, thanks to the Mediator pattern, we have been able to start using integers as values for our calculator. We have just defined the simplest example by adding two integers, but we could have done the same with an integer and the <code>type</code>:</p>
<pre class="code" ><code class="chroma" ><span class="k">case</span> <span class="nx">One</span><span class="p">:</span>
  <span class="k">switch</span> <span class="nx">b</span> <span class="o">:=</span> <span class="nx">b</span><span class="p">.(</span><span class="kd">type</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">case</span> <span class="nx">One</span><span class="p">:</span>
    <span class="k">return</span> <span class="o">&amp;</span><span class="nx">Two</span><span class="p">{}</span>
  <span class="k">case</span> <span class="nx">Two</span><span class="p">:</span>
    <span class="k">return</span> <span class="o">&amp;</span><span class="nx">Three</span><span class="p">{}</span>
  <span class="k">case</span> <span class="kt">int</span><span class="p">:</span>
    <span class="k">return</span> <span class="nx">b</span><span class="o">+</span><span class="mi">1</span>
  <span class="k">default</span><span class="p">:</span>
    <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&#34;Number not found&#34;</span><span class="p">)</span>
  <span class="p">}</span>
</code></pre>
<p>With this small modification, we can now use type <code>One</code> with an <code>int</code> as number <code>b</code>. If we keep working on this Mediator pattern, we could achieve a lot of flexibility between types, without having to implement every possible operation between them, generating a tight coupling.</p>
<p>We&#39;ll add a new <code>Sum</code> method in the main function to see this in action:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">main</span><span class="p">(){</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&#34;%#v\n&#34;</span><span class="p">,</span> <span class="nx">Sum</span><span class="p">(</span><span class="nx">One</span><span class="p">{},</span> <span class="nx">Two</span><span class="p">{}))</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&#34;%d\n&#34;</span><span class="p">,</span> <span class="nx">Sum</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&#34;%d\n&#34;</span><span class="p">,</span> <span class="nx">Sum</span><span class="p">(</span><span class="nx">One</span><span class="p">{},</span><span class="mi">2</span><span class="p">))</span>
<span class="p">}</span>
</code></pre>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go run mediator.go
</span><span class="out" >&amp;main.Three{}
3
3
</span></code></pre>
<p>Nice. The Mediator pattern is in charge of knowing about the possible types and returns the most convenient type for our case, which is an integer. Now we could keep growing this <code>Sum</code> function until we completely get rid of using the numeric types we have defined.</p>
</div>
<h4 id="uncoupling-two-types-with-the-mediator" >Uncoupling two types with the Mediator</h4>
<div class="hBody-4" >
<p>We have carried out a disruptive example to try to think outside the box and reason deeply about the Mediator pattern. Tight coupling between entities in an app can become really complex to deal with in the future and allow more difficult refactoring if needed.</p>
<p>Just remember that the Mediator pattern is there to act as a managing type between two types that don&#39;t know about each other so that you can take one of the types without affecting the other and replace a type in a more easy and convenient way.</p>
</div>
<h3 id="observer-design-pattern" >Observer design pattern</h3>
<div class="hBody-3" >
<p>We will finish the common <i>Gang of Four</i> design patterns with my favorite: the Observer pattern, also known as publish/subscriber or publish/listener. With the State pattern, we defined our first event-driven architecture, but with the Observer pattern we will really reach a new level of abstraction.</p>
</div>
<h4 id="description" >Description</h4>
<div class="hBody-4" >
<p>The idea behind the Observer pattern is simple--to subscribe to some event that will trigger some behavior on many subscribed types. Why is this so interesting? Because we uncouple an event from its possible handlers.</p>
<p>For example, imagine a login button. We could code that when the user clicks the button, the button color changes, an action is executed, and a form check is performed in the background. But with the Observer pattern, the type that changes the color will subscribe to the event of the clicking of the button. The type that checks the form and the type that performs an action will subscribe to this event too.</p>
</div>
<h4 id="objectives" >Objectives</h4>
<div class="hBody-4" >
<p>The Observer pattern is especially useful to achieve many actions that are triggered on one event. It is also especially useful when you don&#39;t know how many actions are performed after an event in advance or there is a possibility that the number of actions is going to grow in the near future. To resume, do the following:</p>
<ul>
<li>
<p>Provide an event-driven architecture where one event can trigger one or more actions</p>
</li>
<li>
<p>Uncouple the actions that are performed from the event that triggers them</p>
</li>
<li>
<p>Provide more than one event that triggers the same action</p>
</li>
</ul>
</div>
<h4 id="the-notifier" >The notifier</h4>
<div class="hBody-4" >
<p>We will develop the simplest possible application to fully understand the roots of the Observer pattern. We are going to make a <code>Publisher</code> struct, which is the one that triggers an event so it must accept new observers and remove them if necessary. When the <code>Publisher</code> struct is triggered, it must notify all its observers of the new event with the data associated.</p>
</div>
<h4 id="acceptance-criteria" >Acceptance criteria</h4>
<div class="hBody-4" >
<p>The requirements must tell us to have some type that triggers some method in one or more actions:</p>
<ol class="num" >
<li>
<p>We must have a publisher with a <code>NotifyObservers</code> method that accepts a message as an argument and triggers a <code>Notify</code> method on every observer subscribed.</p>
</li>
<li>
<p>We must have a method to add new subscribers to the publisher.</p>
</li>
<li>
<p>We must have a method to remove new subscribers from the publisher.</p>
</li>
</ol>
</div>
<h4 id="unit-tests" >Unit tests</h4>
<div class="hBody-4" >
<p>Maybe you have realized that our requirements defined almost exclusively the <code>Publisher</code> type. This is because the action performed by the observer is irrelevant for the Observer pattern. It should simply execute an action, in this case the <code>Notify</code> method, that one or many types will implement. So let&#39;s define this only interface for this pattern:</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">Observer</span> <span class="kd">interface</span> <span class="p">{</span>
  <span class="nx">Notify</span><span class="p">(</span><span class="kt">string</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
<p>The <code>Observer</code> interface has a <code>Notify</code> method that accepts a string type that will contain the message to spread. It does not need to return anything, but we could return an error if we want to check if all observers have been reached when calling the <code>publish</code> method of the <code>Publisher</code> structure.</p>
<p>To test all the acceptance criteria, we just need a structure called <code>Publisher</code> with three methods:</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">Publisher</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">ObserversList</span> <span class="p">[]</span><span class="nx">Observer</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">Publisher</span><span class="p">)</span> <span class="nx">AddObserver</span><span class="p">(</span><span class="nx">o</span> <span class="nx">Observer</span><span class="p">)</span> <span class="p">{}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">Publisher</span><span class="p">)</span> <span class="nx">RemoveObserver</span><span class="p">(</span><span class="nx">o</span> <span class="nx">Observer</span><span class="p">)</span> <span class="p">{}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">Publisher</span><span class="p">)</span> <span class="nx">NotifyObservers</span><span class="p">(</span><span class="nx">m</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{}</span>
</code></pre>
<p>The <code>Publisher</code> structure stores the list of subscribed observers in a slice field called <code>ObserversList</code>. Then it has the three methods mentioned on the acceptance criteria-the <code>AddObserver</code> method to subscribe a new observer to the publisher, the <code>RemoveObserver</code> method to unsubscribe an observer, and the <code>NotifyObservers</code> method with a string that acts as the message we want to spread between all observers.</p>
<p>With these three methods, we have to set up a root test to configure the <code>Publisher</code> and three subtests to test each method. We also need to define a test type structure that implements the <code>Observer</code> interface. This structure is going to be called <code>TestObserver</code>:</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">TestObserver</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">ID</span>      <span class="kt">int</span>
  <span class="nx">Message</span> <span class="kt">string</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">TestObserver</span><span class="p">)</span> <span class="nx">Notify</span><span class="p">(</span><span class="nx">m</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&#34;Observer %d: message &#39;%s&#39; received \n&#34;</span><span class="p">,</span> <span class="nx">p</span><span class="p">.</span><span class="nx">ID</span><span class="p">,</span> <span class="nx">m</span><span class="p">)</span>
  <span class="nx">p</span><span class="p">.</span><span class="nx">Message</span> <span class="p">=</span> <span class="nx">m</span>
<span class="p">}</span>
</code></pre>
<p>The <code>TestObserver</code> structure implements the Observer pattern by defining a <code>Notify(string)</code> method in its structure. In this case, it prints the received message together with its own observer ID. Then, it stores the message in its <code>Message</code> field. This allows us to check later if the content of the <code>Message</code> field is as expected. Remember that it could also be done by passing the <code>testing.T</code> pointer and the expected message and checking within the <code>TestObserver</code> structure.</p>
<p>Now we can set up the <code>Publisher</code> structure to execute the three tests. We will create three instances of the <code>TestObserver</code> structure:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">TestSubject</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">testObserver1</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">TestObserver</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="s">&#34;&#34;</span><span class="p">}</span>
  <span class="nx">testObserver2</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">TestObserver</span><span class="p">{</span><span class="mi">2</span><span class="p">,</span> <span class="s">&#34;&#34;</span><span class="p">}</span>
  <span class="nx">testObserver3</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">TestObserver</span><span class="p">{</span><span class="mi">3</span><span class="p">,</span> <span class="s">&#34;&#34;</span><span class="p">}</span>
  <span class="nx">publisher</span> <span class="o">:=</span> <span class="nx">Publisher</span><span class="p">{}</span>
</code></pre>
<p>We have given a different ID to each observer so that we can see later that each of them has printed the expected message. Then, we have added the observers by calling the <code>AddObserver</code> method on the <code>Publisher</code> structure.</p>
<p>Let&#39;s write an <code>AddObserver</code> test, it must add a new observer to the <code>ObserversList</code> field of the <code>Publisher</code> structure:</p>
<pre class="code" ><code class="chroma" ><span class="nx">t</span><span class="p">.</span><span class="nx">Run</span><span class="p">(</span><span class="s">&#34;AddObserver&#34;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">publisher</span><span class="p">.</span><span class="nx">AddObserver</span><span class="p">(</span><span class="nx">testObserver1</span><span class="p">)</span>
  <span class="nx">publisher</span><span class="p">.</span><span class="nx">AddObserver</span><span class="p">(</span><span class="nx">testObserver2</span><span class="p">)</span>
  <span class="nx">publisher</span><span class="p">.</span><span class="nx">AddObserver</span><span class="p">(</span><span class="nx">testObserver3</span><span class="p">)</span>

  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">publisher</span><span class="p">.</span><span class="nx">ObserversList</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">3</span> <span class="p">{</span>
    <span class="nx">t</span><span class="p">.</span><span class="nx">Fail</span><span class="p">()</span>
  <span class="p">}</span>
<span class="p">})</span>
</code></pre>
<p>We have added three observers to the <code>Publisher</code> structure, so the length of the slice must be 3. If it&#39;s not 3, the test will fail.</p>
<p>The <code>RemoveObserver</code> test will take the observer with ID 2 and remove it from the list:</p>
<pre class="code" ><code class="chroma" ><span class="nx">t</span><span class="p">.</span><span class="nx">Run</span><span class="p">(</span><span class="s">&#34;RemoveObserver&#34;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">publisher</span><span class="p">.</span><span class="nx">RemoveObserver</span><span class="p">(</span><span class="nx">testObserver2</span><span class="p">)</span>

  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">publisher</span><span class="p">.</span><span class="nx">ObserversList</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span> <span class="p">{</span>
    <span class="nx">t</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&#34;The size of the observer list is not the &#34;</span> <span class="o">+</span>
      <span class="s">&#34;expected. 3 != %d\n&#34;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">publisher</span><span class="p">.</span><span class="nx">ObserversList</span><span class="p">))</span>
  <span class="p">}</span>

  <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">observer</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">publisher</span><span class="p">.</span><span class="nx">ObserversList</span> <span class="p">{</span>
    <span class="nx">testObserver</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">observer</span><span class="p">.(</span><span class="nx">TestObserver</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
      <span class="nx">t</span><span class="p">.</span><span class="nx">Fail</span><span class="p">()</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="nx">testObserver</span><span class="p">.</span><span class="nx">ID</span> <span class="o">==</span> <span class="mi">2</span> <span class="p">{</span>
      <span class="nx">t</span><span class="p">.</span><span class="nx">Fail</span><span class="p">()</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">})</span>
</code></pre>
<p>After removing the second observer, the length of the <code>Publisher</code> structure must be 2 now. We also check that none of the observers left have the <code>ID</code> 2 because it must be removed.</p>
<p>The last method to test is the <code>Notify</code> method. When using the Notify method, all instances of <code>TestObserver</code> structure must change their <code>Message</code> field from empty to the passed message (<code>Hello World!</code> in this case). First we will check that all the <code>Message</code> fields are, in fact, empty before calling the <code>NotifyObservers</code> test:</p>
<pre class="code" ><code class="chroma" ><span class="nx">t</span><span class="p">.</span><span class="nx">Run</span><span class="p">(</span><span class="s">&#34;Notify&#34;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">observer</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">publisher</span><span class="p">.</span><span class="nx">ObserversList</span> <span class="p">{</span>
    <span class="nx">printObserver</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">observer</span><span class="p">.(</span><span class="o">*</span><span class="nx">TestObserver</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
      <span class="nx">t</span><span class="p">.</span><span class="nx">Fail</span><span class="p">()</span>
      <span class="k">break</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="nx">printObserver</span><span class="p">.</span><span class="nx">Message</span> <span class="o">!=</span> <span class="s">&#34;&#34;</span> <span class="p">{</span>
      <span class="nx">t</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&#34;The observer&#39;s Message field weren&#39;t &#34;</span> <span class="o">+</span>
        <span class="s">&#34; empty: %s\n&#34;</span><span class="p">,</span> <span class="nx">printObserver</span><span class="p">.</span><span class="nx">Message</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">}</span>
</code></pre>
<p>Using a <code>for</code> statement, we are iterating over the <code>ObserversList</code> field to slice in the <code>publisher</code> instance. We need to make a type casting from a pointer to an observer, to a pointer to the <code>TestObserver</code> structure, and check that the casting has been done correctly. Then, we check that the <code>Message</code> field is actually empty.</p>
<p>The next step is to create a message to send--in this case, it will be <code>&#34;Hello World!&#34;</code> and then pass this message to the <code>NotifyObservers</code> method to notify every observer on the list (currently observers 1 and 3 only):</p>
<pre class="code" ><code class="chroma" >    <span class="nx">message</span> <span class="o">:=</span> <span class="s">&#34;Hello World!&#34;</span>
    <span class="nx">publisher</span><span class="p">.</span><span class="nx">NotifyObservers</span><span class="p">(</span><span class="nx">message</span><span class="p">)</span>

    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">observer</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">publisher</span><span class="p">.</span><span class="nx">ObserversList</span> <span class="p">{</span>
      <span class="nx">printObserver</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">observer</span><span class="p">.(</span><span class="o">*</span><span class="nx">TestObserver</span><span class="p">)</span>
      <span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
        <span class="nx">t</span><span class="p">.</span><span class="nx">Fail</span><span class="p">()</span>
        <span class="k">break</span>
      <span class="p">}</span>

      <span class="k">if</span> <span class="nx">printObserver</span><span class="p">.</span><span class="nx">Message</span> <span class="o">!=</span> <span class="nx">message</span> <span class="p">{</span>
        <span class="nx">t</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&#34;Expected message on observer %d was &#34;</span> <span class="o">+</span>
          <span class="s">&#34;not expected: &#39;%s&#39; != &#39;%s&#39;\n&#34;</span><span class="p">,</span> <span class="nx">printObserver</span><span class="p">.</span><span class="nx">ID</span><span class="p">,</span>
          <span class="nx">printObserver</span><span class="p">.</span><span class="nx">Message</span><span class="p">,</span> <span class="nx">message</span><span class="p">)</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">})</span>
<span class="p">}</span>
</code></pre>
<p>After calling the <code>NotifyObservers</code> method, each <code>TestObserver</code> tests in the <code>ObserversList</code> field must have the message <code>&#34;Hello World!&#34;</code> stored in their <code>Message</code> field. Again, we use a <code>for</code> loop to iterate over every observer of the <code>ObserversList</code> field and we typecast each to a <code>TestObserver</code> test (remember that <code>TestObserver</code> structure doesn&#39;t have any field as it&#39;s an interface). We could avoid type casting by adding a new <code>Message()</code> method to <code>Observer</code> instance and implementing it in the</p>
<p><code>TestObserver</code> structure to return the contents of the <code>Message</code> field. Both methods are equally valid. Once we have type casted to a <code>TestObserver</code> method called <code>printObserver</code> variable as a local variable, we check that each instance in the <code>ObserversList</code> structure has the string <code>&#34;Hello World!&#34;</code> stored in their <code>Message</code> field.</p>
<p>Time to run the tests that must fail all to check their effectiveness in the later implementation:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go <span class="nb">test</span> -v
</span><span class="out" >=== RUN   TestSubject
=== RUN   TestSubject/AddObserver
=== RUN   TestSubject/RemoveObserver
=== RUN   TestSubject/Notify
--- FAIL: TestSubject (0.00s)
    --- FAIL: TestSubject/AddObserver (0.00s)
    --- FAIL: TestSubject/RemoveObserver (0.00s)
        observer_test.go:40: The size of the observer list is not the expected. 3 != 0
    --- PASS: TestSubject/Notify (0.00s)
FAIL
exit status 1
FAIL
</span></code></pre>
<p>Something isn&#39;t working as expected. How is the <code>Notify</code> method passing the tests if we haven&#39;t implemented the function yet? Take a look at the test of the <code>Notify</code> method again. The test iterates over the <code>ObserversList</code> structure and each <code>Fail</code> call is inside this for loop. If the list is empty, it won&#39;t iterate, so it won&#39;t execute any <code>Fail</code> call.</p>
<p>Let&#39;s fix this issue by adding a small non-empty list check at the beginning of the <code>Notify</code> test:</p>
<pre class="code" ><code class="chroma" >  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">publisher</span><span class="p">.</span><span class="nx">ObserversList</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
      <span class="nx">t</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&#34;The list is empty. Nothing to test\n&#34;</span><span class="p">)</span>
  <span class="p">}</span>
</code></pre>
<p>And we will rerun the tests to see if the <code>TestSubject/Notify</code> method is already failing:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go <span class="nb">test</span> -v
</span><span class="out" >=== RUN   TestSubject
=== RUN   TestSubject/AddObserver
=== RUN   TestSubject/RemoveObserver
=== RUN   TestSubject/Notify
--- FAIL: TestSubject (0.00s)
    --- FAIL: TestSubject/AddObserver (0.00s)
    --- FAIL: TestSubject/RemoveObserver (0.00s)
        observer_test.go:40: The size of the observer list is not the expected. 3 != 0
    --- FAIL: TestSubject/Notify (0.00s)
        observer_test.go:58: The list is empty. Nothing to test
FAIL
exit status 1
FAIL
</span></code></pre>
<p>Nice, all of them are failing and now we have some guarantee on our tests. We can proceed to the implementation.</p>
</div>
<h4 id="implementation" >Implementation</h4>
<div class="hBody-4" >
<p>Our implementation is just to define the <code>AddObserver</code>, the <code>RemoveObserver</code>, and the <code>NotifyObservers</code> methods:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">Publisher</span><span class="p">)</span> <span class="nx">AddObserver</span><span class="p">(</span><span class="nx">o</span> <span class="nx">Observer</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">s</span><span class="p">.</span><span class="nx">ObserversList</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">ObserversList</span><span class="p">,</span> <span class="nx">o</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
<p>The <code>AddObserver</code> method adds the <code>Observer</code> instance to the <code>ObserversList</code> structure by appending the pointer to the current list of pointers. This one was very easy. The <code>AddObserver</code> test must be passing now (but not the rest or we could have done something wrong):</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go <span class="nb">test</span> -v
</span><span class="out" >=== RUN   TestSubject
=== RUN   TestSubject/AddObserver
=== RUN   TestSubject/RemoveObserver
=== RUN   TestSubject/Notify
--- FAIL: TestSubject (0.00s)
    --- PASS: TestSubject/AddObserver (0.00s)
    --- FAIL: TestSubject/RemoveObserver (0.00s)
        observer_test.go:40: The size of the observer list is not the expected. 3 != 3
    --- FAIL: TestSubject/Notify (0.00s)
        observer_test.go:87: Expected message on observer 1 was not expected: &#39;default&#39; != &#39;Hello World!&#39;
        observer_test.go:87: Expected message on observer 2 was not expected: &#39;default&#39; != &#39;Hello World!&#39;
        observer_test.go:87: Expected message on observer 3 was not expected: &#39;default&#39; != &#39;Hello World!&#39;
FAIL
exit status 1
FAIL
</span></code></pre>
<p>Excellent. Just the <code>AddObserver</code> method has passed the test, so we can now continue to the <code>RemoveObserver</code> method:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">Publisher</span><span class="p">)</span> <span class="nx">RemoveObserver</span><span class="p">(</span><span class="nx">o</span> <span class="nx">Observer</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">indexToRemove</span> <span class="kt">int</span>

  <span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">observer</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">s</span><span class="p">.</span><span class="nx">ObserversList</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">observer</span> <span class="o">==</span> <span class="nx">o</span> <span class="p">{</span>
      <span class="nx">indexToRemove</span> <span class="p">=</span> <span class="nx">i</span>
      <span class="k">break</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="nx">s</span><span class="p">.</span><span class="nx">ObserversList</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">ObserversList</span><span class="p">[:</span><span class="nx">indexToRemove</span><span class="p">],</span>
    <span class="nx">s</span><span class="p">.</span><span class="nx">ObserversList</span><span class="p">[</span><span class="nx">indexToRemove</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span><span class="o">...</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
<p>The <code>RemoveObserver</code> method will iterate for each element in the <code>ObserversList</code> structure, comparing the <code>Observer</code> object&#39;s o variable with the ones stored in the list. If it finds a match, it saves the index  in the local variable, <code>indexToRemove</code>, and stops the iteration. The way to remove indexes on a slice in Go is a bit tricky:</p>
<ol class="num" >
<li>
<p>First, we need to use slice indexing to return a new slice containing every object from the beginning of the slice to the index we want to remove (not included).</p>
</li>
<li>
<p>Then, we get another slice from the index we want to remove (not included) to the last object in the slice</p>
</li>
<li>
<p>Finally, we join the previous two new slices into a new one (the <code>append</code> function)</p>
</li>
</ol>
<p>For example, in a list from 1 to 10 in which we want to remove the number 5, we have to create a new slice, joining a slice from 1 to 4 and a slice from 6 to 10.</p>
<p>This index removal is done with the <code>append</code> function again because we are actually appending two lists together. Just take a closer look at the three dots at the end of the second argument of the <code>append</code> function. The <code>append</code> function adds an element (the second argument) to a slice (the first), but we want to append an entire list. This can be achieved using the three dots, which translate to something like <i>keep adding elements until you finish the second array</i>.</p>
<p>Ok, let&#39;s run this test now:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go <span class="nb">test</span> -v
</span><span class="out" >=== RUN   TestSubject
=== RUN   TestSubject/AddObserver
=== RUN   TestSubject/RemoveObserver
=== RUN   TestSubject/Notify
--- FAIL: TestSubject (0.00s)
    --- PASS: TestSubject/AddObserver (0.00s)
    --- PASS: TestSubject/RemoveObserver (0.00s)
    --- FAIL: TestSubject/Notify (0.00s)
        observer_test.go:87: Expected message on observer 1 was not expected: &#39;default&#39; != &#39;Hello World!&#39;
        observer_test.go:87: Expected message on observer 3 was not expected: &#39;default&#39; != &#39;Hello World!&#39;
FAIL
exit status 1
FAIL
</span></code></pre>
<p>We continue in the good path. The <code>RemoveObserver</code> test has been fixed without fixing anything else. Now we have to finish our implementation by defining the <code>NotifyObservers</code> method:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">Publisher</span><span class="p">)</span> <span class="nx">NotifyObservers</span><span class="p">(</span><span class="nx">m</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&#34;Publisher received message &#39;%s&#39; to notify observers\n&#34;</span><span class="p">,</span> <span class="nx">m</span><span class="p">)</span>
  <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">observer</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">s</span><span class="p">.</span><span class="nx">ObserversList</span> <span class="p">{</span>
    <span class="nx">observer</span><span class="p">.</span><span class="nx">Notify</span><span class="p">(</span><span class="nx">m</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>The <code>NotifyObservers</code> method is quite simple because it prints a message to the console to announce that a particular message is going to be passed to the <code>Observers</code>. After this, we use a for loop to iterate over <code>ObserversList</code> structure and execute each <code>Notify(string)</code> method by passing the argument <code>m</code>. After executing this, all observers must have the message <code>Hello World!</code> stored in their <code>Message</code> field. Let&#39;s see if this is true by running the tests:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go <span class="nb">test</span> -v
</span><span class="out" >=== RUN   TestSubject
=== RUN   TestSubject/AddObserver
=== RUN   TestSubject/RemoveObserver
=== RUN   TestSubject/Notify
Publisher received message &#39;Hello World!&#39; to notify observers
Observer 1: message &#39;Hello World!&#39; received
Observer 3: message &#39;Hello World!&#39; received
--- PASS: TestSubject (0.00s)
    --- PASS: TestSubject/AddObserver (0.00s)
    --- PASS: TestSubject/RemoveObserver (0.00s)
    --- PASS: TestSubject/Notify (0.00s)
PASS
ok
</span></code></pre>
<p>Excellent! We can also see the outputs of the <code>Publisher</code> and Observer types on the console. The <code>Publisher</code> structure prints the following message:</p>
<pre class="srci" ><code class="sh" ><span class="out" >hey! I have received the message  &#39;Hello World!&#39; and I&#39;m going
to pass the same message to the observers
</span></code></pre>
<p>After this, all observers print their respective messages as follows:</p>
<pre class="srci" ><code class="sh" ><span class="out" >hey, I&#39;m observer 1 and I have received the message &#39;Hello
World!&#39;
</span></code></pre>
<p>And the same for the third observer.</p>
</div>
<h4 id="summary" >Summary</h4>
<div class="hBody-4" >
<p>We have unlocked the power of event-driven architectures with the State pattern and the Observer pattern. Now you can really execute asynchronous algorithms and operations in your application that respond to events in your system.</p>
<p>The Observer pattern is commonly used in UI&#39;s. Android programming is filled with Observer patterns so that the Android SDK can delegate the actions to be performed by the programmers creating an app.</p>
</div>
<h2 id="chapter-8" >Introduction to Gos Concurrency</h2>
<div class="hBody-2" >
<p>We have just finished with the <i>Gang Of Four</i> design patterns that are commonly used in object oriented programming languages. They have been used extensively for the last few decades (even before they were explicitly defined in a book).</p>
<p>In this chapter, we are going to see concurrency in the Go language. We will, learn that with multiple cores and multiple processes, applications can help us to achieve better performance and endless possibilities. We will look at how to use some of the already known patterns in concurrently safe ways.</p>
</div>
<h3 id="a-little-bit-of-history-and-theory" >A little bit of history and theory</h3>
<div class="hBody-3" >
<p>When we talk about Go&#39;s concurrency, it&#39;s impossible not to talk about history. In the last decades, we saw an improvement in the speed of CPUs until we reached the hardware limits imposed by current hardware materials, design, and architectures. When we reached this point, we started to play with the first multicore computers, the first double CPU motherboards, and then single CPUs with more than one core in their heart.</p>
<p>Unfortunately, the languages we are using are still the ones created when we had single core CPUs, such as Java or C++. While being terrific systems languages, they lack a proper concurrency support by design. You can develop concurrent apps in both of the languages used in your project by using third party tools or by developing your own (not a very easy task).</p>
<p>Go&#39;s concurrency was designed with these caveats in mind. The creators wanted garbage collected and procedural language that is familiar for newcomers, but which, at the same time, can be used to write concurrent applications easily and without affecting the core of the language.</p>
<p>We have experienced this in the early chapters. We have developed more than 20 design patterns without a word about concurrency. This clearly shows that the concurrent features of the Go language are completely separated from the core language while being part of it, a perfect example of abstraction and encapsulation.</p>
<p>There are many concurrency models in computer science, the most famous being the actor model present in languages such as <b>Erlang</b> or <b>Scala</b>. Go, on the other side, uses <b>Communicating Sequential Processes</b> (<span class="acronym" >CSP</span>), which has a different approach to concurrency.</p>
</div>
<h4 id="concurrency-versus-parallelism" >Concurrency versus parallelism</h4>
<div class="hBody-4" >
<p>Many people have misunderstood the differences between both, even thinking that they are the same. There is a popular speech by Rob Pike, one of the creators of Go, <i>Concurrency is not parallelism</i>, which I really agree with. As a quick summary of the talk, we can extract the following:</p>
<ul>
<li>
<p>Concurrency is about dealing with many things at once</p>
</li>
<li>
<p>Parallelism is about doing many things at the same time</p>
</li>
</ul>
<p>Concurrency enables parallelism by designing a correct structure of concurrency work.</p>
<p>For example, we can think of the mechanism of a bike. When we pedal, we usually push down the pedal to produce force (and this push, raises our opposite leg on the opposite pedal). We cannot push with both legs at the same time because the cranks don&#39;t allow us to do it. But this design allows the construction of a parallel bike, commonly called a <b>tandem bike</b>. A tandem bike is a bike that two people can ride at the same time; they both pedal and apply force to the bike.</p>
<p>In the bike example, concurrency is the design of a bike that, with two legs (Goroutines), you can produce power to move the bike by yourself.</p>
<p>The design is concurrent and correct. If we use a tandem bike and two people (two cores), the solution is concurrent, correct, and parallel. But the key thing is that with a concurrent design, we don&#39;t have to worry about parallelism; we can think about it as an extra feature if our concurrent design is correct. In fact, we can use the tandem bike with only one person, but the concurrent design of the legs, pedals, chain, wheels of a bike is still correct.</p>
<figure>
<img src="img/356_1.jpg" />
</figure>
<p>With concurrency, on the left side, we have a design and a structure that is executed sequentially by the same CPU core. Once we have this design and structure, parallelism can be achieved by simply repeating this structure on a different thread.</p>
<p>This is how Go eases the reasoning about concurrent and parallel programs by simply not worrying too much about parallel execution and focusing much more on concurrent design and structure. Breaking a big task into smaller tasks that can be run concurrently usually provides much better performance in a single-core computer, but, if this design can also be run in parallel, we could achieve an even higher throughput (or not, depending on the design).</p>
<p>In fact, we can set the number of cores in use in a Go app by setting the environment variable <code>GOMAXPROCS</code> to the number of cores we want. This is not only useful when using schedulers, such as <b>Apache Mesos</b>, but it gives us more control about how a Go app works and performs.</p>
<p>So, to recap, it is very important to keep in mind that concurrency is about structure and parallelism is about execution. We must think about making our programs concurrent in a better way, by breaking them down into smaller pieces of work, and Go&#39;s scheduler will try to make them parallel if it&#39;s possible and allowed.</p>
</div>
<h4 id="csp-versus-actor-based-concurrency" >CSP versus actor-based concurrency</h4>
<div class="hBody-4" >
<p>The most common and, perhaps, intuitive way to think about concurrency is close to the way the actor model works.</p>
<figure>
<img src="img/357_1.jpg" />
</figure>
<p>In the actor model, if <b>Actor 1</b> wants to communicate with <b>Actor 2</b>, then <b>Actor 1</b> must know <b>Actor 2</b> first; for example, it must have its process ID, maybe from the creation step, and put a message on its inbox queue. After placing the message, <b>Actor 1</b> can continue its tasks without getting blocked if <b>Actor 2</b> cannot process the message immediately.</p>
<p>CSP, on the other side, introduces a new entity into the equation-channels. Channels are the way to communicate between processes because they are completely anonymous (unlike actors, where we need to know their process IDs). In the case of CSP, we don&#39;t have a process ID to use to communicate. Instead, we have to create a channel to the processes to allow incoming and outgoing communication. In this case, what we know that the receiver is the channel it uses to receive data:</p>
<figure>
<img src="img/358_1.jpg" />
</figure>
<p>In this diagram, we can see that the processes are anonymous, but we have a channel with ID 1, that is, <b>Channel 1</b>, which connects them together. This abstraction does not tell us how many processes are on each side of the channel; it simply connects them and allows communication between processes by using the channel.</p>
<p>The key here is that channels isolate both extremes so that process A can send data through a channel that will be handled by potentially one or more processes that&#39; are transparent to A. It also works the same in reverse; process B can receive data from many channels one at a time.</p>
</div>
<h3 id="goroutines" >Goroutines</h3>
<div class="hBody-3" >
<p>In Go, we achieve concurrency by working with Goroutines. They are like processes that run applications in a computer concurrently; in fact, the main loop of Go could be considered a Goroutine, too. Goroutines are used in places where we would use actors. They execute some logic and die (or keep looping if necessary).</p>
<p>But Goroutines are not threads. We can launch thousands of concurrent Goroutines, even millions. They are incredibly cheap, with a small growth stack. We will use Goroutines to execute code that we want to work concurrently. For example, three calls to three services to compose a response can be designed concurrently with three Goroutines to do the service calls potentially in parallel and a fourth Goroutine to receive them and compose the response. What&#39;s the point here? That if we have a computer with four cores, we could potentially run this service call in parallel, but if we use a one-core computer, the design will still be correct and the calls will be executed concurrently in only one core. By designing concurrent applications, we don&#39;t need to worry about parallel execution.</p>
<p>Returning to the bike analogy, we were pushing the pedals of the bike with our two legs. That&#39;s two Goroutines concurrently pushing the pedals. When we use the tandem, we had a total of four Goroutines, possibly working in parallel. But we also have two hands to handle the front and rear brakes. That&#39;s a total of eight Goroutines for our two threads bike. Actually, we don&#39;t pedal when we brake and we don&#39;t brake when we pedal; that&#39;s a correct concurrent design. Our nervous system transports the information about when to stop pedaling and when to start braking. In Go, our nervous system is composed of channels; we will see them after playing a bit with Goroutines first.</p>
</div>
<h4 id="our-first-goroutine" >Our first Goroutine</h4>
<div class="hBody-4" >
<p>Enough of the explanations now. Let&#39;s get our hands dirty. For our first Goroutine, we will print the message <code>Hello World!</code> in a Goroutine. Let&#39;s start with what we&#39;ve been doing up until now:</p>
<pre class="code" ><code class="chroma" ><span class="kn">package</span> <span class="nx">main</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">helloWorld</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">helloWorld</span><span class="p">(){</span>
  <span class="nb">println</span><span class="p">(</span><span class="s">&#34;Hello World!&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
<p>Running this small snippet of code will simply output <code>Hello World!</code> in the console:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go run main.go
</span><span class="out" >Hello World!
</span></code></pre>
<p>Not impressive at all. To run it in a new Goroutine, we just need to add the keyword <code>go</code> at the beginning of the call to the function:</p>
<pre class="code" ><code class="chroma" ><span class="kn">package</span> <span class="nx">main</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">go</span> <span class="nx">helloWorld</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">helloWorld</span><span class="p">(){</span>
  <span class="nb">println</span><span class="p">(</span><span class="s">&#34;Hello World!&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
<p>With this simple word, we are telling Go to start a new Goroutine running the contents of the <code>helloWorld</code> function.</p>
<p>So, let&#39;s run it:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go run main.go
</span></code></pre>
<p>What? It printed nothing! Why is that? Things get complicated when you start to deal with concurrent applications. The problem is that the <code>main</code> function finishes before the <code>helloWorld</code> function gets executed. Let&#39;s analyse it step by step. the <code>main</code> function starts and schedules a new Goroutine that will execute the <code>helloWorld</code> function, but the function isn&#39;t executed when the function finishes--it is still in the scheduling process.</p>
<p>So, our <code>main</code> problem is that the <code>main</code> function has to wait for the Goroutine to be executed before finishing. So let&#39;s pause for a second to give some room to the Goroutine:</p>
<pre class="code" ><code class="chroma" ><span class="kn">package</span> <span class="nx">main</span>
<span class="kn">import</span> <span class="s">&#34;time&#34;</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">go</span> <span class="nx">helloWorld</span><span class="p">()</span>

  <span class="nx">time</span><span class="p">.</span><span class="nx">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">helloWorld</span><span class="p">(){</span>
  <span class="nb">println</span><span class="p">(</span><span class="s">&#34;Hello World!&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
<p>The <code>time.Sleep</code> function effectively sleeps the main Goroutine for one second before continuing (and exiting). If we run this now, we must get the message:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go run main.go
</span><span class="out" >Hello World!
</span></code></pre>
<p>I suppose you must have noticed by now the small gap of time where the program is freezing before finishing. This is the function for sleeping. If you are doing a lot of tasks, you might want to raise the waiting time to whatever you want. Just remember that in any application the <code>main</code> function cannot finish before the rest of the Goroutines.</p>
</div>
<h4 id="anonymous-functions-launched-as-new-goroutines" >Anonymous functions launched as new Goroutines</h4>
<div class="hBody-4" >
<p>We have defined the <code>helloWorld</code> function so that it can be launched with a different Goroutine. This is not strictly necessary because you can launch snippets of code directly in the function&#39;s scope:</p>
<pre class="code" ><code class="chroma" ><span class="kn">package</span> <span class="nx">main</span>
<span class="kn">import</span> <span class="s">&#34;time&#34;</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
    <span class="nb">println</span><span class="p">(</span><span class="s">&#34;Hello World&#34;</span><span class="p">)</span>
  <span class="p">}()</span>
  <span class="nx">time</span><span class="p">.</span><span class="nx">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
<p>This is also valid. We have used an anonymous function and we have launched it in a new Goroutine using the <code>go</code> keyword. Take a closer look at the closing braces of the function-they are followed by opening and closing parenthesis, indicating the execution of the function.</p>
<p>We can also pass data to anonymous functions:</p>
<pre class="code" ><code class="chroma" ><span class="kn">package</span> <span class="nx">main</span>
<span class="kn">import</span> <span class="s">&#34;time&#34;</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">go</span> <span class="kd">func</span><span class="p">(</span><span class="nx">msg</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
    <span class="nb">println</span><span class="p">(</span><span class="nx">msg</span><span class="p">)</span>
  <span class="p">}(</span><span class="s">&#34;Hello World&#34;</span><span class="p">)</span>
  <span class="nx">time</span><span class="p">.</span><span class="nx">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
<p>This is also valid. We had defined an anonymous function that received a string, which then printed the received string. When we called the function in a different Goroutine, we passed the message we wanted to print. In this sense, the following example would also be valid:</p>
<pre class="code" ><code class="chroma" ><span class="kn">package</span> <span class="nx">main</span>
<span class="kn">import</span> <span class="s">&#34;time&#34;</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">messagePrinter</span> <span class="o">:=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">msg</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
    <span class="nb">println</span><span class="p">(</span><span class="nx">msg</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="k">go</span> <span class="nx">messagePrinter</span><span class="p">(</span><span class="s">&#34;Hello World&#34;</span><span class="p">)</span>
  <span class="k">go</span> <span class="nx">messagePrinter</span><span class="p">(</span><span class="s">&#34;Hello goroutine&#34;</span><span class="p">)</span>
  <span class="nx">time</span><span class="p">.</span><span class="nx">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
<p>In this case, we have defined a function within the scope of our <code>main</code> function and stored it in a variable called <code>messagePrinter</code>. Now we can concurrently print as many messages as we want by using the <code>messagePrinter(string)</code> signature:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go run main.go
</span><span class="out" >Hello World
Hello goroutine
</span></code></pre>
<p>We have just scratched the surface of concurrent programming in Go, but we can already see that it can be quite powerful. But we definitely have to do something with that sleeping period. WaitGroups can help us with this problem.</p>
</div>
<h4 id="waitgroups" >WaitGroups</h4>
<div class="hBody-4" >
<p><code>WaitGroup</code> comes in the synchronization package (the <code>sync</code> package) to help us synchronize many concurrent Goroutines. It works very easily--every time we have to wait for one Goroutine to finish, we add 1 to the group, and once all of them are added, we ask the group to wait. When the Goroutine finishes, it says <code>Done</code> and the <code>WaitGroup</code> will take one from the group:</p>
<pre class="code" ><code class="chroma" ><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
  <span class="s">&#34;sync&#34;</span>
  <span class="s">&#34;fmt&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">wait</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span>
  <span class="nx">wait</span><span class="p">.</span><span class="nx">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

  <span class="k">go</span> <span class="kd">func</span><span class="p">(){</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&#34;Hello World!&#34;</span><span class="p">)</span>
    <span class="nx">wait</span><span class="p">.</span><span class="nx">Done</span><span class="p">()</span>
  <span class="p">}()</span>
  <span class="nx">wait</span><span class="p">.</span><span class="nx">Wait</span><span class="p">()</span>
<span class="p">}</span>
</code></pre>
<p>This is the simplest possible example of a <code>WaitGroup</code>. First, we created a variable to hold it called the <code>wait</code> variable. Next, before launching the new Goroutine, we say to the WaitGroup <q>hey, you&#39;ll have to wait for one thing to finish</q> by using the <code>wait.Add(1)</code> method. Now we can launch the 1 that the WaitGroup has to wait for, which in this case is the previous Goroutine that prints Hello World and says Done (by using the <code>wait.Done()</code> method) at the end of the Goroutine. Finally, we indicate to the WaitGroup to wait. We have to remember that the function <code>wait.Wait()</code> was probably executed before the Goroutine.</p>
<p>Let&#39;s run the code again:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go run main.go
</span><span class="out" >Hello World!
</span></code></pre>
<p>Now it just waits the necessary time and not one millisecond more before exiting the application. Remember that when we use the <code>Add(value)</code> method, we add entities to the <code>WaitGroup</code>, and when we use the <code>Done()</code> method, we subtract one.</p>
<p>Actually, the <code>Add</code> function takes a delta value, so the following code is equivalent to the previous:</p>
<pre class="code" ><code class="chroma" ><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
  <span class="s">&#34;sync&#34;</span>
  <span class="s">&#34;fmt&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">wait</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span>
  <span class="nx">wait</span><span class="p">.</span><span class="nx">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

  <span class="k">go</span> <span class="kd">func</span><span class="p">(){</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&#34;Hello World!&#34;</span><span class="p">)</span>
    <span class="nx">wait</span><span class="p">.</span><span class="nx">Add</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
  <span class="p">}()</span>
  <span class="nx">wait</span><span class="p">.</span><span class="nx">Wait</span><span class="p">()</span>
<span class="p">}</span>
</code></pre>
<p>In this case, we added 1 before launching the Goroutine and we added <code>-1</code> (subtracted 1) at the end of it. If we know in advance how many Goroutines we are going to launch, we can also call the <code>Add</code> method just once:</p>
<pre class="code" ><code class="chroma" ><span class="kn">package</span> <span class="nx">main</span>
<span class="kn">import</span> <span class="p">(</span>
  <span class="s">&#34;fmt&#34;</span>
  <span class="s">&#34;sync&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">wait</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span>

  <span class="nx">goRoutines</span> <span class="o">:=</span> <span class="mi">5</span>
  <span class="nx">wait</span><span class="p">.</span><span class="nx">Add</span><span class="p">(</span><span class="nx">goRoutines</span><span class="p">)</span>

  <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">goRoutines</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
    <span class="k">go</span> <span class="kd">func</span><span class="p">(</span><span class="nx">goRoutineID</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&#34;ID:%d: Hello goroutines!\n&#34;</span><span class="p">,</span> <span class="nx">goRoutineID</span><span class="p">)</span>
      <span class="nx">wait</span><span class="p">.</span><span class="nx">Done</span><span class="p">()</span>
    <span class="p">}(</span><span class="nx">i</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="nx">wait</span><span class="p">.</span><span class="nx">Wait</span><span class="p">()</span>
<span class="p">}</span>
</code></pre>
<p>In this example, we are going to create five Goroutines (as stated in the <code>goroutines</code> variable). We know it in advance, so we simply add them all to the WaitGroup. We are then going to launch the same amount of <code>goroutine</code> variables by using a <code>for</code> loop. Every time one Goroutine finishes, it calls the <code>Done()</code> method of the WaitGroup that is effectively waiting at the end of the main loop.</p>
<p>Again, in this case, the code reaches the end of the <code>main</code> function before all Goroutines are launched (if any), and the WaitGroup makes the execution of the main flow wait until all <code>Done</code> messages are called. Let&#39;s run this small program:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go run main.go
</span><span class="out" >ID:4: Hello goroutines!
ID:0: Hello goroutines!
ID:1: Hello goroutines!
ID:2: Hello goroutines!
ID:3: Hello goroutines!
</span></code></pre>
<p>We haven&#39;t mentioned it before, but we have passed the iteration index to each Goroutine as the parameter <code>GoroutineID</code> to print it with the message <code>Hello goroutines!</code> You might also have noticed that the Goroutines aren&#39;t executed in order. Of course! We are dealing with a scheduler that doesn&#39;t guarantee the order of execution of the Goroutines. This is something to keep in mind when programming concurrent applications. In fact, if we execute it again, we won&#39;t necessarily get the same order of output:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go run main.go
</span><span class="out" >ID:4: Hello goroutines!
ID:2: Hello goroutines!
ID:1: Hello goroutines!
ID:3: Hello goroutines!
ID:0: Hello goroutines!
</span></code></pre>
</div>
<h3 id="callbacks" >Callbacks</h3>
<div class="hBody-3" >
<p>Now that we know how to use WaitGroups, we can also introduce the concept of callbacks. If you have ever worked with languages like JavaScript that use them extensively, this section will be familiar to you. A callback is an anonymous function that will be executed within the context of a different function.</p>
<p>For example, we want to write a function to convert a string to uppercase, as well as making it asynchronous. How do we write this function so that we can work with callbacks? There&#39;s a little trick-we can have have a function that takes a string and returns a string:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">toUpperSync</span><span class="p">(</span><span class="nx">word</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
  <span class="c1">// Code will go here
</span><span class="c1"></span><span class="p">}</span>
</code></pre>
<p>So take the returning type of this function (a string) and put it as the second parameter in an anonymous function, as shown here:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">toUpperSync</span><span class="p">(</span><span class="nx">word</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">f</span> <span class="kd">func</span><span class="p">(</span><span class="kt">string</span><span class="p">))</span> <span class="p">{</span>
  <span class="c1">// Code will go here
</span><span class="c1"></span><span class="p">}</span>
</code></pre>
<p>Now, the <code>toUpperSync</code> function returns nothing, but also takes a function that, by coincidence, also takes a string. We can execute this function with the result we will usually return.</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">toUpperSync</span><span class="p">(</span><span class="nx">word</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">f</span> <span class="kd">func</span><span class="p">(</span><span class="kt">string</span><span class="p">))</span> <span class="p">{</span>
  <span class="nx">f</span><span class="p">(</span><span class="nx">strings</span><span class="p">.</span><span class="nx">ToUpper</span><span class="p">(</span><span class="nx">word</span><span class="p">))</span>
<span class="p">}</span>
</code></pre>
<p>We execute the f function with the result of calling the <code>strings.ToUpper</code> method with the provided word (which returns the word <code>parameter</code> in uppercase). Let&#39;s write the <code>main</code> function too:</p>
<pre class="code" ><code class="chroma" ><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
  <span class="s">&#34;fmt&#34;</span>
  <span class="s">&#34;strings&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">toUpperSync</span><span class="p">(</span><span class="s">&#34;Hello Callbacks!&#34;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">v</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&#34;Callback: %s\n&#34;</span><span class="p">,</span> <span class="nx">v</span><span class="p">)</span>
  <span class="p">})</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">toUpperSync</span><span class="p">(</span><span class="nx">word</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">f</span> <span class="kd">func</span><span class="p">(</span><span class="kt">string</span><span class="p">))</span> <span class="p">{</span>
  <span class="nx">f</span><span class="p">(</span><span class="nx">strings</span><span class="p">.</span><span class="nx">ToUpper</span><span class="p">(</span><span class="nx">word</span><span class="p">))</span>
<span class="p">}</span>
</code></pre>
<p>In our main code, we have defined our callback. As you can see, we passed the test <code>Hello Callbacks!</code> to convert it to uppercase. Next we pass the callback to be executed with the result of passing our string to uppercase. In this case, we simply print the text in the console with the text <code>Callback</code> in front of it. When we execute this code, we get the following result:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go run main.go
</span><span class="out" >Callback: HELLO CALLBACKS!
</span></code></pre>
<p>Strictly speaking, this is a synchronous callback. To make it asynchronous we have to introduce some concurrent handling:</p>
<pre class="code" ><code class="chroma" ><span class="kn">package</span> <span class="nx">main</span>
<span class="kn">import</span> <span class="p">(</span>
  <span class="s">&#34;fmt&#34;</span>
  <span class="s">&#34;strings&#34;</span>
  <span class="s">&#34;sync&#34;</span>
<span class="p">)</span>

<span class="kd">var</span> <span class="nx">wait</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">wait</span><span class="p">.</span><span class="nx">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

  <span class="nx">toUpperAsync</span><span class="p">(</span><span class="s">&#34;Hello Callbacks!&#34;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">v</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&#34;Callback: %s\n&#34;</span><span class="p">,</span> <span class="nx">v</span><span class="p">)</span>
    <span class="nx">wait</span><span class="p">.</span><span class="nx">Done</span><span class="p">()</span>
  <span class="p">})</span>

  <span class="nb">println</span><span class="p">(</span><span class="s">&#34;Waiting async response...&#34;</span><span class="p">)</span>
  <span class="nx">wait</span><span class="p">.</span><span class="nx">Wait</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">toUpperAsync</span><span class="p">(</span><span class="nx">word</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">f</span> <span class="kd">func</span><span class="p">(</span><span class="kt">string</span><span class="p">))</span> <span class="p">{</span>
  <span class="k">go</span> <span class="kd">func</span><span class="p">(){</span>
    <span class="nx">f</span><span class="p">(</span><span class="nx">strings</span><span class="p">.</span><span class="nx">ToUpper</span><span class="p">(</span><span class="nx">word</span><span class="p">))</span>
  <span class="p">}()</span>
<span class="p">}</span>
</code></pre>
<p>This is the same code executed asynchronously. We use WaitGroups to handle concurrency (we will see later that channels can also be used for this). Now, our function <code>toUpperAsync</code> is, as its name implies, asynchronous. We launched the callback in a different Goroutine by using the keyword <code>go</code> when calling the callback. We write a small message to show the ordering nature of the concurrent execution more precisely. We wait until the callback signals that it&#39;s finished and we can exit the program safely. When we execute this, we get the following result:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go run main.go
</span><span class="out" >Waiting async response...
Callback: HELLO CALLBACKS!
</span></code></pre>
<p>As you can see, the program reaches the end of the <code>main</code> function before executing the callback in the <code>toUpperAsync</code> function. This pattern brings many possibilities, but leaves us open to one big problem called callback hell.</p>
</div>
<h4 id="callback-hell" >Callback hell</h4>
<div class="hBody-4" >
<p>The term <b>callback hell</b> is commonly used to refer to when many callbacks have been stacked within each other. This makes them difficult to reason with and handle when they grow too much. For example, using the same code as before, we could stack another asynchronous call with the contents that we previously printed to the console:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">wait</span><span class="p">.</span><span class="nx">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

  <span class="nx">toUpperAsync</span><span class="p">(</span><span class="s">&#34;Hello Callbacks!&#34;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">v</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">toUpperAsync</span><span class="p">(</span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintf</span><span class="p">(</span><span class="s">&#34;Callback: %s\n&#34;</span><span class="p">,</span> <span class="nx">v</span><span class="p">),</span> <span class="kd">func</span><span class="p">(</span><span class="nx">v</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&#34;Callback within %s&#34;</span><span class="p">,</span> <span class="nx">v</span><span class="p">)</span>
      <span class="nx">wait</span><span class="p">.</span><span class="nx">Done</span><span class="p">()</span>
    <span class="p">})</span>
  <span class="p">})</span>
  <span class="nb">println</span><span class="p">(</span><span class="s">&#34;Waiting async response...&#34;</span><span class="p">)</span>
  <span class="nx">wait</span><span class="p">.</span><span class="nx">Wait</span><span class="p">()</span>
<span class="p">}</span>
</code></pre>
<p>(We have omitted imports, the package name, and the <code>toUpperAsync</code> function as they have not changed.) Now we have the <code>toUpperAsync</code> function within a <code>toUpperAsync</code> function, and we could embed many more if we want. In this case, we again pass the text that we previously printed on the console to use it in the following callback. The inner callback finally prints it on the console, giving the following output:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go run main.go
</span><span class="out" >Waiting async response...
Callback within CALLBACK: HELLO CALLBACKS!
</span></code></pre>
<p>In this case, we can assume that the outer callback will be executed before the inner one. That&#39;s why we don&#39;t need to add one more to the WaitGroup.</p>
<p>The point here is that we must be careful when using callbacks. In very complex systems, too many callbacks are hard to reason with and hard to deal with. But with care and rationality, they are powerful tools.</p>
</div>
<h3 id="mutexes" >Mutexes</h3>
<div class="hBody-3" >
<p>If you are working with concurrent applications, you have to deal with more than one resource potentially accessing some memory location. This is usually called <b>race condition</b>.</p>
<p>In simpler terms, a race condition is similar to that moment where two people try to get the last piece of pizza at exactly the same time--their hands collide. Replace the pizza with a variable and their hands with Goroutines and we&#39;ll have a perfect analogy.</p>
<p>There is one character at the dinner table to solve this issues--a father or mother. They have kept the pizza on a different table and we have to ask for permission to stand up before getting our slice of pizza. It doesn&#39;t matter if all the kids ask at the same time--they will only allow one kid to stand.</p>
<p>Well, a mutex is like our parents. They&#39;ll control who can access the pizza--I mean, a variable--and they won&#39;t allow anyone else to access it.</p>
<p>To use a mutex, we have to actively lock it; if it&#39;s already locked (another Goroutine is using it), we&#39;ll have to wait until it&#39;s unlocked again. Once we get access to the mutex, we can lock it again, do whatever modifications are needed, and unlock it again. We&#39;ll look at this using an example.</p>
</div>
<h4 id="an-example-with-mutexes---concurrent-counter" >An example with mutexes - concurrent counter</h4>
<div class="hBody-4" >
<p>Mutexes are widely used in concurrent programming. Maybe not so much in Go because it has a more idiomatic way of concurrent programming in its use of channels, but it&#39;s worth seeing how they work for the situations where channels simply don&#39;t fit so well.</p>
<p>For our example, we are going to develop a small concurrent counter. This counter will add one to an integer field in a <code>Counter</code> type. This should be done in a concurrent-safe way.</p>
<p>Our <code>Counter</code> structure is defined like this:</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">Counter</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span>
  <span class="nx">value</span> <span class="kt">int</span>
<span class="p">}</span>
</code></pre>
<p>The <code>Counter</code> structure has a field of <code>int</code> type that stores the current value of the count. It also embeds the <code>Mutex</code> type from the <code>sync</code> package. Embedding this field will allow us to lock and unlock the entire structure without actively calling a specific field.</p>
<p>Our <code>main</code> function launches 10 Goroutines that try to add one to the field value of <code>Counter</code> structure. All of this is done concurrently:</p>
<pre class="code" ><code class="chroma" ><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
  <span class="s">&#34;sync&#34;</span>
  <span class="s">&#34;time&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">counter</span> <span class="o">:=</span> <span class="nx">Counter</span><span class="p">{}</span>

  <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
    <span class="k">go</span> <span class="kd">func</span><span class="p">(</span><span class="nx">i</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">counter</span><span class="p">.</span><span class="nx">Lock</span><span class="p">()</span>
      <span class="nx">counter</span><span class="p">.</span><span class="nx">value</span><span class="o">++</span>
      <span class="k">defer</span> <span class="nx">counter</span><span class="p">.</span><span class="nx">Unlock</span><span class="p">()</span>
    <span class="p">}(</span><span class="nx">i</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="nx">time</span><span class="p">.</span><span class="nx">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>

  <span class="nx">counter</span><span class="p">.</span><span class="nx">Lock</span><span class="p">()</span>
  <span class="k">defer</span> <span class="nx">counter</span><span class="p">.</span><span class="nx">Unlock</span><span class="p">()</span>

  <span class="nb">println</span><span class="p">(</span><span class="nx">counter</span><span class="p">.</span><span class="nx">value</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
<p>We have created a type called Counter. Using a for loop, we have launched a total of 10 Goroutines, as we saw in the <i>Anonymous functions launched as new Goroutines</i> section. But inside every Goroutine, we are locking the counter so that no more Goroutines can access it, adding one to the field value, and unlocking it again so others can access it.</p>
<p>Finally, we&#39;ll print the value held by the counter. It must be 10 because we have launched 10 Goroutines. But how can we know that this program is thread safe? Well, Go comes with a very handy built-in feature called the &#34;race detector&#34;.</p>
</div>
<h4 id="presenting-the-race-detector" >Presenting the race detector</h4>
<div class="hBody-4" >
<p>We already know what a race condition is. To recap, it is used when two processes try to access the same resource at the same time with one or more writing operations (both processes writing or one process writing while the other reads) involved at that precise moment.</p>
<p>Go has a very handy tool to help diagnose race conditions, that you can run in your tests or your main application directly. So let&#39;s reuse the example we just wrote for the <i>mutexes</i> section and run it with the race detector. This is as simple as adding the -race command-line flag to the command execution of our program:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go run -race main.go
</span><span class="out" >10
</span></code></pre>
<p>Well, not very impressive is it? But in fact it is telling us that it has not detected a potential race condition in the code of this program. Let&#39;s make the detector of <code>-race</code> flag warn us of a possible race condition by not locking <code>counter</code> before we modify it:</p>
<pre class="code" ><code class="chroma" ><span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
  <span class="k">go</span> <span class="kd">func</span><span class="p">(</span><span class="nx">i</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// counter.Lock()
</span><span class="c1"></span>    <span class="nx">counter</span><span class="p">.</span><span class="nx">value</span><span class="o">++</span>
    <span class="c1">// counter.Unlock()
</span><span class="c1"></span>  <span class="p">}(</span><span class="nx">i</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
<p>Inside the <code>for</code> loop, comment the <code>Lock</code> and <code>Unlock</code> calls before and after adding <code>1</code> to the field value. This will introduce a race condition. Let&#39;s run the same program again with the race flag activated:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go run -race main.go
</span><span class="out" >==================
WARNING: DATA RACE
Read at 0x00c42007a068 by goroutine 6:
  main.main.func1()
      [some_path]/concurrency/locks/main.go:19 +0x44
Previous write at 0x00c42007a068 by goroutine 5:
  main.main.func1()
      [some_path]/concurrency/locks/main.go:19 +0x60
Goroutine 6 (running) created at:
  main.main()
      [some_path]/concurrency/locks/main.go:21 +0xb6
Goroutine 5 (finished) created at:
  main.main()
      [some_path]/concurrency/locks/main.go:21 +0xb6
==================
10
Found 1 data race(s)
exit status 66
</span></code></pre>
<p>I have reduced the output a bit to see things more clearly. We can see a big, uppercase message reading <code>WARNING: DATA RACE</code>. But this output is very easy to reason with. First, it is telling us that some memory position represented by <i>line 19</i> on our <span class="file" >main.go</span> file is reading some variable. But there is also a write operation in <i>line 19</i> of the same file!</p>
<p>This is because a <q><code>++</code></q> operation requires a read of the current value and a write to add one to it. That&#39;s why the race condition is in the same line, because every time it&#39;s executed it reads and writes the field in the <code>Counter</code> structure.</p>
<p>But let&#39;s keep in mind that the race detector works at runtime. It doesn&#39;t analyze our code statically! What does it mean? It means that we can have a potential race condition in our design that the race detector will not detect. For example:</p>
<pre class="code" ><code class="chroma" ><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&#34;sync&#34;</span>

<span class="kd">type</span> <span class="nx">Counter</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span>
  <span class="nx">value</span> <span class="kt">int</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">counter</span> <span class="o">:=</span> <span class="nx">Counter</span><span class="p">{}</span>

  <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
    <span class="k">go</span> <span class="kd">func</span><span class="p">(</span><span class="nx">i</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">counter</span><span class="p">.</span><span class="nx">value</span><span class="o">++</span>
    <span class="p">}(</span><span class="nx">i</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>We will leave the code as shown in the preceding example. We will take all locks and unlocks from the code and launch a single Goroutine to update the <code>value</code> field:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go run -race main.go
</span></code></pre>
<p>No warnings, so the code is correct. Well, we know, by design, it&#39;s not. We can raise the number of Goroutines executed to two and see what happens:</p>
<pre class="code" ><code class="chroma" ><span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">2</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
  <span class="k">go</span> <span class="kd">func</span><span class="p">(</span><span class="nx">i</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">counter</span><span class="p">.</span><span class="nx">value</span><span class="o">++</span>
  <span class="p">}(</span><span class="nx">i</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
<p>Let&#39;s execute the program again:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go run -race main.go
</span><span class="out" >WARNING: DATA RACE
Read at 0x00c42007a008 by goroutine 6:
  main.main.func1()
    [some_path]concurrency/race_detector/main.go:15 +0x44
Previous write at 0x00c42007a008 by goroutine 5:
  main.main.func1()
    [some_path]/concurrency/race_detector/main.go:15 +0x60
Goroutine 6 (running) created at:
  main.main()
    [some_path]/concurrency/race_detector/main.go:16 +0xad
Goroutine 5 (finished) created at:
  main.main()
    [some_path]/concurrency/race_detector/main.go:16 +0xad
==================
Found 1 data race(s)
exit status 66
</span></code></pre>
<p>Now yes, the race condition is detected. But what if we reduce the number of processors in use to just one? Will we have a race condition too?</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span><span class="nv">GOMAXPROCS</span><span class="o">=</span><span class="m">1</span>
</span><span class="in" ><span class="prompt" >&gt; </span>go run -race main.go
</span></code></pre>
<p>It seems that no race condition has been detected. This is because the scheduler executed one Goroutine first and then the other, so, finally, the race condition didn&#39;t occur. But with a higher number of Goroutines it will also warn us about a race condition, even using only one core.</p>
<p>So, the race detector can help us to detect race conditions that are happening in our code, but it won&#39;t protect us from a bad design that is not immediately executing race conditions. A very useful feature that can save us from lots of headaches.</p>
</div>
<h3 id="channels" >Channels</h3>
<div class="hBody-3" >
<p>Channels are the second primitive in the language that allows us to write concurrent applications. We have talked a bit about channels in the <i>Communicating sequential processes</i> section.</p>
<p>Channels are the way we communicate between processes. We could be sharing a memory location and using mutexes to control the processes&#39; access. But channels provide us with a more natural way to handle concurrent applications that also produces better concurrent designs in our programs.</p>
</div>
<h4 id="our-first-channel" >Our first channel</h4>
<div class="hBody-4" >
<p>Working with many Goroutines seems pretty difficult if we can&#39;t create some synchronization between them. The order of execution could be irrelevant as soon as they are synchronized. Channels are the second key feature to write concurrent applications in Go.</p>
<p>A TV channel in real life is something that connects an emission (from a studio) to millions of TVs (the receivers). Channels in Go work in a similar fashion. One or more Goroutines can work as emitters, and one or more Goroutine can act as receivers.</p>
<p>One more thing channels, by default, block the execution of Goroutines until something is received. It is as if our favourite TV show delays the emission until we turn the TV on so we don&#39;t miss anything.</p>
<p>How is this done in Go?</p>
<pre class="code" ><code class="chroma" ><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">channel</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">string</span><span class="p">)</span>
  <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">channel</span> <span class="o">&lt;-</span> <span class="s">&#34;Hello World!&#34;</span>
  <span class="p">}()</span>

  <span class="nx">message</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">channel</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">message</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
<p>To create channels in Go, we use the same syntax that we use to create slices. The <code>make</code> keyword is used to create a channel, and we have to pass the keyword <code>chan</code> and the type that the channel will transport, in this case, strings. With this, we have a blocking channel with the name <code>channel</code>. Next, we launch a Goroutines that sends the message <code>Hello</code> <code>World!</code> to the channel. This is indicated by the intuitive arrow that shows the flow--the <code>Hello World!</code> text going to (<code>&lt;-</code>) a channel. This works like an assignment in a variable, so we can only pass something to a channel by first writing the channel, then the arrow, and finally the value to pass. We cannot write <code>&#34;Hello World!&#34; -&gt; channel</code>.</p>
<p>As we mentioned earlier, this channel is blocking the execution of Gorountines until a message is received. In this case, the execution of the <code>main</code> function is stopped until the message from the launched Goroutines reaches the other end of the channel in the line <code>message := &lt;-channel</code>. In this case, the arrow points in the same direction, but it&#39;s placed before the channel, indicating that the data is being extracted from the channel and assigned to a new variable called message (using the new assignment <q><code>:=</code></q> operator).</p>
<p>In this case, we don&#39;t need to use a WaitGroup to synchronize the <code>main</code> function with the created Goroutines, as the default nature of channels is to block until data is received. But does it work the other way around? If there is no receiver when the Goroutine sends the message, does it continue? Let&#39;s edit this example to see this:</p>
<pre class="code" ><code class="chroma" ><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
  <span class="s">&#34;fmt&#34;</span>
  <span class="s">&#34;time&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">channel</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">string</span><span class="p">)</span>

  <span class="kd">var</span> <span class="nx">waitGroup</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span>

  <span class="nx">waitGroup</span><span class="p">.</span><span class="nx">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
  <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">channel</span> <span class="o">&lt;-</span> <span class="s">&#34;Hello World!&#34;</span>
    <span class="nb">println</span><span class="p">(</span><span class="s">&#34;Finishing goroutine&#34;</span><span class="p">)</span>
    <span class="nx">waitGroup</span><span class="p">.</span><span class="nx">Done</span><span class="p">()</span>
  <span class="p">}()</span>

  <span class="nx">time</span><span class="p">.</span><span class="nx">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
  <span class="nx">message</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">channel</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">message</span><span class="p">)</span>
  <span class="nx">waitGroup</span><span class="p">.</span><span class="nx">Wait</span><span class="p">()</span>
<span class="p">}</span>
</code></pre>
<p>We are going to use the <code>Sleep</code> function again. In this case, we print a message when the Goroutine is finished. The big difference is in the <code>main</code> function. Now we wait one second before we listen to the channel for data:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go run main.go
</span><span class="out" >Finishing goroutine
Hello World!
</span></code></pre>
<p>The output can differ because, again, there are no guarantees in the order of execution, but now we can see that no message is printed until one second has passed. After the initial delay, we start listening to the channel, take the data, and print it. So the emitter also has to wait for a cue from the other side of the channel to continue its execution.</p>
<p>To recap, channels are ways to communicate between Goroutines by sending data through one end and receiving it at the other (like a pipe). In their default state, an emitter Goroutine will block its execution until a receiver Goroutine takes the data. The same goes for a receiver Goroutine, which will block until some emitter sends data through the channel. So you can have passive listeners (waiting for data) or passive emitters (waiting for listeners).</p>
</div>
<h4 id="buffered-channels" >Buffered channels</h4>
<div class="hBody-4" >
<p>A buffered channel works in a similar way to default unbuffered channels. You also pass and take values from them by using the arrows, but, unlike unbuffered channels, senders don&#39;t need to wait until some Goroutine picks the data that they are sending:</p>
<pre class="code" ><code class="chroma" ><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
  <span class="s">&#34;fmt&#34;</span>
  <span class="s">&#34;time&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">channel</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">string</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

  <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">channel</span> <span class="o">&lt;-</span> <span class="s">&#34;Hello World!&#34;</span>
    <span class="nb">println</span><span class="p">(</span><span class="s">&#34;Finishing goroutine&#34;</span><span class="p">)</span>
  <span class="p">}()</span>

  <span class="nx">time</span><span class="p">.</span><span class="nx">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>

  <span class="nx">message</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">channel</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">message</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
<p>This example is like the first example we used for channels, but now we have set the capacity of the channel to one in the <code>make</code> statement. With this, we tell the compiler that this channel has a capacity of one string before getting blocked. So the first string doesn&#39;t block the emitter, but the second would. Let&#39;s run this example:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go run main.go
</span><span class="out" >Finishing goroutine
Hello World!
</span></code></pre>
<p>Now we can run this small program as many times as we want--the output will always be in the same order. This time, we have launched the concurrent function and waited for one second. Previously, the anonymous function wouldn&#39;t continue until the second has passed and someone can pick the sent data. In this case, with a buffered channel, the data is held in the channel and frees the Goroutine to continue its execution. In this case, the Goroutine is always finishing before the wait time passes.</p>
<p>This new channel has a size of one, so a second message would block the Goroutine execution:</p>
<pre class="code" ><code class="chroma" ><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
  <span class="s">&#34;fmt&#34;</span>
  <span class="s">&#34;time&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">channel</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">string</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

  <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">channel</span> <span class="o">&lt;-</span> <span class="s">&#34;Hello World! 1&#34;</span>
    <span class="nx">channel</span> <span class="o">&lt;-</span> <span class="s">&#34;Hello World! 2&#34;</span>
    <span class="nb">println</span><span class="p">(</span><span class="s">&#34;Finishing goroutine&#34;</span><span class="p">)</span>
  <span class="p">}()</span>

  <span class="nx">time</span><span class="p">.</span><span class="nx">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>

  <span class="nx">message</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">channel</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">message</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
<p>Here, we add a second <code>Hello world! 2</code> message, and we provide it with an index. In this case, the output of this program could be like the following:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go run main.go
</span><span class="out" >Hello World! 1
</span></code></pre>
<p>Indicating that we have just taken one message from the channel buffer, we have printed it, and the <code>main</code> function finished before the launched Goroutine could finish. The Goroutine got blocked when sending the second message and couldn&#39;t continue until the other end took the first message. Then it prints it so quickly that it doesn&#39;t have time to print the message to show the ending of the Goroutine. If you keep executing the program on the console, sooner or later the scheduler will finish the Goroutine execution before the main thread.</p>
</div>
<h4 id="directional-channels" >Directional channels</h4>
<div class="hBody-4" >
<p>One cool feature about Go channels is that, when we use them as parameters, we can restrict their directionality so that they can be used only to send or to receive. The compiler will complain if a channel is used in the restricted direction. This feature applies a new level of static typing to Go apps and makes code more understandable and more readable.</p>
<p>We&#39;ll take a simple example with channels:</p>
<pre class="code" ><code class="chroma" ><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
  <span class="s">&#34;fmt&#34;</span>
  <span class="s">&#34;time&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">channel</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">string</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

  <span class="k">go</span> <span class="kd">func</span><span class="p">(</span><span class="nx">ch</span> <span class="kd">chan</span><span class="o">&lt;-</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">ch</span> <span class="o">&lt;-</span> <span class="s">&#34;Hello World!&#34;</span>
    <span class="nb">println</span><span class="p">(</span><span class="s">&#34;Finishing goroutine&#34;</span><span class="p">)</span>
  <span class="p">}(</span><span class="nx">channel</span><span class="p">)</span>

  <span class="nx">time</span><span class="p">.</span><span class="nx">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>

  <span class="nx">message</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">channel</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">message</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
<p>The line where we launch the new Goroutine <code>go func(ch chan&lt;- string)</code> states that the channel passed to this function can only be used as an input channel, and you can&#39;t listen to it.</p>
<p>We can also pass a channel that will be used as a receiver channel only:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">receivingCh</span><span class="p">(</span><span class="nx">ch</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">msg</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">ch</span>
  <span class="nb">println</span><span class="p">(</span><span class="nx">msg</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
<p>As you can see, the arrow is on the opposite side of the keyword <code>chan</code>, indicating an extracting operation from the channel. Keep in mind that the channel arrow always points left, to indicate a receiving channel, it must go on the left, and to indicate an inserting channel, it must go on the right.</p>
<p>If we try to send a value through this <i>receive only</i> channel, the compiler will complain about it:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">receivingCh</span><span class="p">(</span><span class="nx">ch</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">msg</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">ch</span>
  <span class="nb">println</span><span class="p">(</span><span class="nx">msg</span><span class="p">)</span>
  <span class="nx">ch</span> <span class="o">&lt;-</span> <span class="s">&#34;hello&#34;</span>
<span class="p">}</span>
</code></pre>
<p>This function has a receive only channel that we will try to use to send the message <code>hello</code> through. Let&#39;s see what the compiler says:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go run main.go
</span><span class="out" >./main.go:20: invalid operation: ch &lt;- &#34;hello2&#34; (send to receive-only type &lt;-chan string)
</span></code></pre>
<p>It doesn&#39;t like it and asks us to correct it. Now the code is even more readable and safe, and we have just placed an arrow in front or behind the <code>chan</code> argument.</p>
</div>
<h4 id="the-select-statement" >The select statement</h4>
<div class="hBody-4" >
<p>The select statement is also a key feature in Go. It is used to handle more than one channel input within a Goroutine. In fact, it opens lots of possibilities, and we will use it extensively in the following chapters.</p>
<figure>
<img src="img/384_1.jpg" />
</figure>
<p>In the <code>select</code> structure, we ask the program to choose between one or more channels to receive their data. We can save this data in a variable and make something with it before finishing the select. The <code>select</code> structure is just executed once; it doesn&#39;t matter if it is listening to more channels, it will be executed only once and the code will continue executing. If we want it to handle the same channels more than once, we have to put it in a <code>for</code> loop.</p>
<p>We will make a small app that will send the message <code>hello</code> and the message <code>goodbye</code> to the same Goroutine, which will print them and exit if it doesn&#39;t receive anything else in five seconds.</p>
<p>First, we will make a generic function that sends a string over a channel:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">sendString</span><span class="p">(</span><span class="nx">ch</span> <span class="kd">chan</span><span class="o">&lt;-</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">s</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">ch</span> <span class="o">&lt;-</span> <span class="nx">s</span>
<span class="p">}</span>
</code></pre>
<p>Now we can send a string over a channel by simply calling the <code>sendString</code> method. It&#39;s time for the receiver. The receiver will take messages from both channels--the one that sends <code>hello</code> messages and the one that sends <code>goodbye</code> messages. You can also see this in the previous diagram:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">receiver</span><span class="p">(</span><span class="nx">helloCh</span><span class="p">,</span> <span class="nx">goodbyeCh</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">quitCh</span> <span class="kd">chan</span><span class="o">&lt;-</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span> <span class="p">{</span>
    <span class="k">select</span> <span class="p">{</span>
    <span class="k">case</span> <span class="nx">msg</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">helloCh</span><span class="p">:</span>
      <span class="nb">println</span><span class="p">(</span><span class="nx">msg</span><span class="p">)</span>
    <span class="k">case</span> <span class="nx">msg</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">goodbyeCh</span><span class="p">:</span>
      <span class="nb">println</span><span class="p">(</span><span class="nx">msg</span><span class="p">)</span>
    <span class="k">case</span> <span class="o">&lt;-</span><span class="nx">time</span><span class="p">.</span><span class="nx">After</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span> <span class="o">*</span> <span class="mi">2</span><span class="p">):</span>
      <span class="nb">println</span><span class="p">(</span><span class="s">&#34;Nothing received in 2 seconds. Exiting&#34;</span><span class="p">)</span>
      <span class="nx">quitCh</span> <span class="o">&lt;-</span> <span class="kc">true</span>
      <span class="k">break</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>Let&#39;s start with the arguments. This function takes three channels--two receiving channels and one to send something through it. Then, it starts an infinite loop with the <code>for</code> keyword. This way we can keep listening to both channels forever.</p>
<p>Inside the scope of <code>select</code> block, we have to use a case for each channel we want to handle (have you realized how similar it is to the <code>switch</code> statement?). Let&#39;s see the three cases step by step:</p>
<ul>
<li>
<p>The first case takes the incoming data from the <code>helloCh</code> argument and saves it in a variable called <code>msg</code>. Then it prints the contents of this variable.</p>
</li>
<li>
<p>The second case takes the incoming data from the <code>goodbyeCh</code> argument and saves it in a variable called <code>msg</code> too. Then it also prints the content of this variable.</p>
</li>
<li>
<p>The third case is quite interesting. It calls the <code>time</code> function. After that, if we check its signature, it accepts a time and duration value and returns a receiving channel. This receiving channel will receive a time, the value of <code>time</code> after the specified duration has passed. In our example, we use the channel it returns as a timeout. Because the select is restarted after each handle, the timer is restarted too. This is a very simple way to set a timer to a Goroutine waiting for the response of one or many channels.</p>
</li>
</ul>
<p>Everything is ready for the <code>main</code> function:</p>
<pre class="code" ><code class="chroma" ><span class="kn">package</span> <span class="nx">main</span>
<span class="kn">import</span> <span class="s">&#34;time&#34;</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">helloCh</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">string</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
  <span class="nx">goodbyeCh</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">string</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
  <span class="nx">quitCh</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">bool</span><span class="p">)</span>
  <span class="k">go</span> <span class="nx">receiver</span><span class="p">(</span><span class="nx">helloCh</span><span class="p">,</span> <span class="nx">goodbyeCh</span><span class="p">,</span> <span class="nx">quitCh</span><span class="p">)</span>

  <span class="k">go</span> <span class="nx">sendString</span><span class="p">(</span><span class="nx">helloCh</span><span class="p">,</span> <span class="s">&#34;hello!&#34;</span><span class="p">)</span>

  <span class="nx">time</span><span class="p">.</span><span class="nx">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>

  <span class="k">go</span> <span class="nx">sendString</span><span class="p">(</span><span class="nx">goodbyeCh</span><span class="p">,</span> <span class="s">&#34;goodbye!&#34;</span><span class="p">)</span>
  <span class="o">&lt;-</span><span class="nx">quitCh</span>
<span class="p">}</span>
</code></pre>
<p>Again, step by step, we created the three channels that we&#39;ll need in this exercise. Then, we launched our <code>receiver</code> function in a different Goroutine. This Goroutine is handled by Go&#39;s scheduler and our program continues. We launched a new Goroutine to send the message <code>hello</code> to the <code>helloCh</code> arguments. Again, this is going to occur eventually when the Go&#39;s scheduler decides.</p>
<p>Our program continues again and waits for a second. In this break, Go&#39;s scheduler will have time to execute the receiver and the first message (if it hasn&#39;t done so yet), so the <code>hello!</code> message will appear on the console during the break.</p>
<p>A new message is sent over the <code>goodbye</code> channel with the goodbye! text in a new Goroutine, and our program continues again to a line where we wait for an incoming message in the <code>quitCh</code> argument.</p>
<p>We have launched three Goroutines already--the receiver that it is still running, the first message that had finished when the message was handled by the <code>select</code> statement, and the second message was been printed almost immediately and had finished too. So just the receiver is running at this moment, and if it doesn&#39;t receive any other message in the following two seconds, it will handle the incoming message from the <code>time</code> structure. After <code>channel</code> type, print a message to say that it is quitting, send a <code>true</code> to the <code>quitCh</code>, and break the infinite loop where it was looping.</p>
<p>Let&#39;s run this small app:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go run main.go
</span><span class="out" >hello!
goodbye!
Nothing received in 2 seconds. Exiting
</span></code></pre>
<p>The result  may not be very impressive, but the concept is clear. We can handle many incoming channels in the same Goroutine by using the select statement.</p>
</div>
<h4 id="ranging-over-channels-too!" >Ranging over channels too!</h4>
<div class="hBody-4" >
<p>The last feature about channels that we will see is ranging over channels. We are talking about the range keyword. We have used it extensively to range over lists, and we can use it to range over a channel too:</p>
<pre class="code" ><code class="chroma" ><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&#34;time&#34;</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">ch</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span>

  <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">ch</span> <span class="o">&lt;-</span> <span class="mi">1</span>
    <span class="nx">time</span><span class="p">.</span><span class="nx">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>

    <span class="nx">ch</span> <span class="o">&lt;-</span> <span class="mi">2</span>

    <span class="nb">close</span><span class="p">(</span><span class="nx">ch</span><span class="p">)</span>
  <span class="p">}()</span>
  <span class="k">for</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">ch</span> <span class="p">{</span>
    <span class="nb">println</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>In this case, we have created an unbuffered channel, but it would work with a buffered one too. We launched a function in a new Goroutine that sends the number &#34;1&#34; over a channel, waits a second, sends the number &#34;2&#34;, and closes the channel.</p>
<p>The last step is to range over the channel. The syntax is quite similar to a list range. We store the incoming data from the channel in the variable v and we print this variable to the console. The range keeps iterating until the channel is closed, taking data from the channel.</p>
<p>Can you guess the output of this little program?</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go run main.go
</span><span class="out" >1
2
</span></code></pre>
<p>Again, not very impressive. It prints the number &#34;1&#34;, then waits a second, prints the number &#34;2&#34;, and exits the application.</p>
<p>According to the design of this concurrent app, the range was iterates over possible incoming data from the channel until the concurrent Goroutine closes this channel. At that moment, the range finishes and the app can exit.</p>
<p>Range is very useful in taking data from a channel, and it&#39;s commonly used in fan-in patterns where many different Goroutines send data to the same channel.</p>
</div>
<h3 id="using-it-all---concurrent-singleton" >Using it all - concurrent singleton</h3>
<div class="hBody-3" >
<p>Now that we know how to create Goroutines and channels, we&#39;ll put all our knowledge in a single package. Think back to the first few chapter, when we explained the singleton pattern-it was some structure or variable that could only exist once in our code. All access to this structure should be done using the pattern described, but, in fact, it wasn&#39;t concurrent safe.</p>
<p>Now we will write with concurrency in mind. We will write a concurrent counter, like the one we wrote in the <i>mutexes</i> section, but this time we will solve it with channels.</p>
</div>
<h4 id="unit-test" >Unit test</h4>
<div class="hBody-4" >
<p>To restrict concurrent access to the <code>singleton</code> instance, just one Goroutine will be able to access it. We&#39;ll access it using channels--the first one to add one, the second one to get the current count, and the third one to stop the Goroutine.</p>
<p>We will add one 10,000 times using 10,000 different Goroutines launched from two different <code>singleton</code> instances. Then, we&#39;ll introduce a loop to check the count of the <code>singleton</code> until it is 5,000, but we&#39;ll write how much the count is before starting the loop.</p>
<p>Once the count has reached 5,000, the loop will exit and quit the running Goroutine-the test code looks like this:</p>
<pre class="code" ><code class="chroma" ><span class="kn">package</span> <span class="nx">channel_singleton</span>
<span class="kn">import</span> <span class="p">(</span>
  <span class="s">&#34;testing&#34;</span>
  <span class="s">&#34;time&#34;</span>
  <span class="s">&#34;fmt&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nx">TestStartInstance</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">singleton</span> <span class="o">:=</span> <span class="nx">GetInstance</span><span class="p">()</span>
  <span class="nx">singleton2</span> <span class="o">:=</span> <span class="nx">GetInstance</span><span class="p">()</span>

  <span class="nx">n</span> <span class="o">:=</span> <span class="mi">5000</span>

  <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
    <span class="k">go</span> <span class="nx">singleton</span><span class="p">.</span><span class="nx">AddOne</span><span class="p">()</span>
    <span class="k">go</span> <span class="nx">singleton2</span><span class="p">.</span><span class="nx">AddOne</span><span class="p">()</span>
  <span class="p">}</span>

  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&#34;Before loop, current count is %d\n&#34;</span><span class="p">,</span> <span class="nx">singleton</span><span class="p">.</span><span class="nx">GetCount</span><span class="p">())</span>

  <span class="kd">var</span> <span class="nx">val</span> <span class="kt">int</span>
  <span class="k">for</span> <span class="nx">val</span> <span class="o">!=</span> <span class="nx">n</span><span class="o">*</span><span class="mi">2</span> <span class="p">{</span>
    <span class="nx">val</span> <span class="p">=</span> <span class="nx">singleton</span><span class="p">.</span><span class="nx">GetCount</span><span class="p">()</span>
    <span class="nx">time</span><span class="p">.</span><span class="nx">Sleep</span><span class="p">(</span><span class="mi">10</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Millisecond</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="nx">singleton</span><span class="p">.</span><span class="nx">Stop</span><span class="p">()</span>
<span class="p">}</span>
</code></pre>
<p>Here, we can see the full test we&#39;ll use. After creating two instances of the <code>singleton</code>, we have created a <code>for</code> loop that launches the <code>AddOne</code> method 5,000 times from each instance. This is not happening yet; they are being scheduled and will be executed eventually. We are printing the count of the <code>singleton</code> instance to clearly see this eventuality; depending on the computer, it will print some number greater than 0 and lower than 10,000.</p>
<p>The last step before stopping the Goroutine that is holding the count is to enter a loop that checks the value of the count and waits 10 milliseconds if the value is not the expected value (10,000). Once it reaches this value, the loop will exit and we can stop the <code>singleton</code> instance.</p>
<p>We&#39;ll jump directly to the implementation as the requirement is quite simple.</p>
</div>
<h4 id="implementation" >Implementation</h4>
<div class="hBody-4" >
<p>First of all, we&#39;ll create the Goroutine that will hold the count:</p>
<pre class="code" ><code class="chroma" ><span class="kd">var</span> <span class="nx">addCh</span> <span class="kd">chan</span> <span class="kt">bool</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">bool</span><span class="p">)</span>
<span class="kd">var</span> <span class="nx">getCountCh</span> <span class="kd">chan</span> <span class="kd">chan</span> <span class="kt">int</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span>
<span class="kd">var</span> <span class="nx">quitCh</span> <span class="kd">chan</span> <span class="kt">bool</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">bool</span><span class="p">)</span>

<span class="kd">func</span> <span class="nx">init</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">count</span> <span class="kt">int</span>

  <span class="k">go</span> <span class="kd">func</span><span class="p">(</span><span class="nx">addCh</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="kt">bool</span><span class="p">,</span> <span class="nx">getCountCh</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="kd">chan</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">quitCh</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">{</span>
      <span class="k">select</span> <span class="p">{</span>
      <span class="k">case</span> <span class="o">&lt;-</span><span class="nx">addCh</span><span class="p">:</span>
        <span class="nx">count</span><span class="o">++</span>
      <span class="k">case</span> <span class="nx">ch</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">getCountCh</span><span class="p">:</span>
        <span class="nx">ch</span> <span class="o">&lt;-</span> <span class="nx">count</span>
      <span class="k">case</span> <span class="o">&lt;-</span><span class="nx">quitCh</span><span class="p">:</span>
        <span class="k">return</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}(</span><span class="nx">addCh</span><span class="p">,</span> <span class="nx">getCountCh</span><span class="p">,</span> <span class="nx">quitCh</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
<p>We created three channels, as we mentioned earlier:</p>
<ul>
<li>
<p>The <code>addCh</code> channel is used to communicate with the action of adding one to the count, and receives a <code>bool</code> type just to signal &#34;add one&#34; (we don&#39;t need to send the number, although we could).</p>
</li>
<li>
<p>The <code>getCountCh</code> channel will return a channel that will receive the current value of the count. Take a moment to reason about the <code>getCountCh</code> channel-it&#39;s a channel that receives a channel that receives integer types. It sounds a bit complicated, but it will make more sense when we finish the example, don&#39;t worry.</p>
</li>
<li>
<p>The <code>quitCh</code> channel will communicate to the Goroutine that it should end its infinite loop and finish itself too.</p>
</li>
</ul>
<p>Now we have the channels that we need to perform the actions we want. Next, we launch the Goroutine passing the channels as arguments. As you can see, we are restricting the direction of the channels to provide more type safety. Inside this Goroutine, we create an infinite <code>for</code> loop. This loop won&#39;t stop until a break is executed within it.</p>
<p>Finally, the <code>select</code> statement, if you remember, was a way to receive data from different channels at the same time. We have three cases, so we listen to the three incoming channels that entered as arguments:</p>
<ul>
<li>
<p>The <code>addCh</code> case will add one to the count. Remember that only one case can be executed on each iteration so that no Goroutine could be accessing the current count until we finish adding one.</p>
</li>
<li>
<p>The <code>getCountCh</code> channel receives a channel that receives an integer, so we capture this new channel and send the current value through it to the other end.</p>
</li>
<li>
<p>The <code>quitCh</code> channel breaks the <code>for</code> loop, so the Goroutine ends.</p>
</li>
</ul>
<p>One last thing. The <code>init()</code> function in any package will get executed on program execution, so we don&#39;t need to worry about executing this function specifically from our code.</p>
<p>Now, we&#39;ll create the type that the tests are expecting. We will see that all the magic and logic is hidden from the end user in this type (as we have seen in the code of the test):</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">singleton</span> <span class="kd">struct</span> <span class="p">{}</span>

<span class="kd">var</span> <span class="nx">instance</span> <span class="nx">singleton</span>
<span class="kd">func</span> <span class="nx">GetInstance</span><span class="p">()</span> <span class="o">*</span><span class="nx">singleton</span> <span class="p">{</span>
  <span class="k">return</span> <span class="o">&amp;</span><span class="nx">instance</span>
<span class="p">}</span>
</code></pre>
<p>The <code>singleton</code> type works similar to the way it worked in <a href="#chapter-2" >Chapter 2</a>, <i>Creational Patterns - Singleton, Builder, Factory, Prototype, and Abstract Factory</i>, but this time it won&#39;t hold the count value. We created a local value for it called <code>instance</code>, and we return the pointer to this instance when we call the <code>GetInstance</code>() method. It is not strictly necessary to do it this way, but we don&#39;t need to allocate a new instance of the <code>singleton</code> type every time we want to access the count variable.</p>
<p>First, the <code>AddOne()</code> method will have to add one to the current count. How? By sending <code>true</code> to the <code>addCh</code> channel. That&#39;s simple:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">singleton</span><span class="p">)</span> <span class="nx">AddOne</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">addCh</span> <span class="o">&lt;-</span> <span class="kc">true</span>
<span class="p">}</span>
</code></pre>
<p>This small snippet will trigger the <code>addCh</code> case in our Goroutine in turn. The <code>addCh</code> case simply executes <code>count++</code> and finishes, letting <code>select</code> channel control flow that is executed on <code>init</code> function above to execute the next instruction:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">singleton</span><span class="p">)</span> <span class="nx">GetCount</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
  <span class="nx">resCh</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span>
  <span class="k">defer</span> <span class="nb">close</span><span class="p">(</span><span class="nx">resCh</span><span class="p">)</span>
  <span class="nx">getCountCh</span> <span class="o">&lt;-</span> <span class="nx">resCh</span>
  <span class="k">return</span> <span class="o">&lt;-</span><span class="nx">resCh</span>
<span class="p">}</span>
</code></pre>
<p>The <code>GetCount</code> method creates a channel every time it&#39;s called and defers the action of closing it at the end of the function. This channel is unbuffered as we have seen previously in this chapter. An unbuffered channel blocks the execution until it receives some data. So we send this channel to <code>getCountCh</code> which is a channel too and, effectively, expects a <code>chan int</code> type to send the current count value back through it. The <code>GetCount()</code> method will not return until the value of <code>count</code> variable arrives to the <code>resCh</code> channel.</p>
<p>You might be thinking, why aren&#39;t we using the same channel in both directions to receive the value of the count? This way we will avoid an allocation. Well, if we use the same channel inside the <code>GetCount()</code> method, we will have two listeners in this channel--one in <code>select</code> statement, at the beginning of the file on the init function, and one there, so it could resolve to any of them when sending the value back:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">singleton</span><span class="p">)</span> <span class="nx">Stop</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">quitCh</span> <span class="o">&lt;-</span> <span class="kc">true</span>
  <span class="nb">close</span><span class="p">(</span><span class="nx">addCh</span><span class="p">)</span>
  <span class="nb">close</span><span class="p">(</span><span class="nx">getCountCh</span><span class="p">)</span>
  <span class="nb">close</span><span class="p">(</span><span class="nx">quitCh</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
<p>Finally, we have to stop the Goroutine at some moment. The <code>Stop</code> method sends the value to the <code>singleton</code> type Goroutine so that the <code>quitCh</code> case is triggered and the <code>for</code> loop is broken. The next step is to close all channels so that no more data can be sent through them. This is very convenient when you know that you won&#39;t be using some of your channels anymore.</p>
<p>Time to execute the tests and take a look:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go <span class="nb">test</span> -v .
</span><span class="out" >=== RUN   TestStartInstance
Before loop, current count is 4911
--- PASS: TestStartInstance (0.03s)
PASS
ok
</span></code></pre>
<p>Very little code output, but everything has worked as expected. In the test, we printed the value of the count before entering the loop that iterates until it reaches the value 10,000. As we saw previously, the Go scheduler will try to run the content of the Goroutines using as many OS threads as you configured by using the <code>GOMAXPROCS</code> configuration. In my computer, it is set to 4 because my computer has four cores. But the point is that we can see that a lot of things can happen after launching a Goroutine (or 10,000) and the next execution line.</p>
<p>But what about its use of mutexes?</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">singleton</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">count</span> <span class="kt">int</span>
  <span class="nx">sync</span><span class="p">.</span><span class="nx">RWMutex</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">instance</span> <span class="nx">singleton</span>

<span class="kd">func</span> <span class="nx">GetInstance</span><span class="p">()</span> <span class="o">*</span><span class="nx">singleton</span> <span class="p">{</span>
  <span class="k">return</span> <span class="o">&amp;</span><span class="nx">instance</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">singleton</span><span class="p">)</span> <span class="nx">AddOne</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">s</span><span class="p">.</span><span class="nx">Lock</span><span class="p">()</span>
  <span class="k">defer</span> <span class="nx">s</span><span class="p">.</span><span class="nx">Unlock</span><span class="p">()</span>
  <span class="nx">s</span><span class="p">.</span><span class="nx">count</span><span class="o">++</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">singleton</span><span class="p">)</span> <span class="nx">GetCount</span><span class="p">()</span><span class="kt">int</span> <span class="p">{</span>
  <span class="nx">s</span><span class="p">.</span><span class="nx">RLock</span><span class="p">()</span>
  <span class="k">defer</span> <span class="nx">s</span><span class="p">.</span><span class="nx">RUnlock</span><span class="p">()</span>
  <span class="k">return</span> <span class="nx">s</span><span class="p">.</span><span class="nx">count</span>
<span class="p">}</span>
</code></pre>
<p>In this case, the code is much leaner. As we saw previously, we can embed the mutex within the <code>singleton</code> structure. The count is also held in the <code>count</code> field and the <code>AddOne()</code> and <code>GetCount()</code> methods lock and unlock the value to be concurrently safe.</p>
<p>One more thing. In this <code>singleton</code> instance, we are using the <code>RWMutex</code> type instead of the already known <code>sync.Mutex</code> type. The main difference here is that the <code>RWMutex</code> type has two types of locks--a read lock and a write lock. The read lock, executed by calling the <code>RLock</code> method, only waits if a write lock is currently active. At the same time, it only blocks a write lock, so that many read actions can be done in parallel. It makes a lot of sense; we don&#39;t want to block a Goroutine that wants to read a value just because another Goroutine is also reading the value-it won&#39;t change. The <code>sync.RWMutex</code> type helps us to achieve this logic in our code.</p>
</div>
<h3 id="summary" >Summary</h3>
<div class="hBody-3" >
<p>We have seen how to write a concurrent Singleton using mutexes and channels. While the channels example was more complex, it also shows the core power of Go&#39;s concurrency, as you can achieve complex levels of event-driven architectures by simply using channels.</p>
<p>Just keep in mind that, if you haven&#39;t written concurrent code in the past, it can take some time to start thinking concurrently in a comfortable way. But it&#39;s nothing that practice cannot solve.</p>
<p>We have seen the importance of designing concurrent apps to achieve parallelism in our programs. We have dealt with most of Go&#39;s primitives to write concurrent applications, and now we can write common concurrent design patterns.</p>
</div>
<h2 id="chapter-9" >Concurrency Patterns - Barrier, Future, and Pipeline Design Patterns</h2>
<div class="hBody-2" >
<p>Now that we are familiar with the concepts of concurrency and parallelism, and we have understood how to achieve them by using Go&#39;s concurrency primitives, we can see some patterns regarding concurrent work and parallel execution. In this chapter we&#39;ll see the following patterns:</p>
<ul>
<li>
<p>Barrier is a very common pattern, especially when we have to wait for more than one response from different Goroutines before letting the program continue</p>
</li>
<li>
<p>Future pattern allows us to write an algorithm that will be executed eventually in time (or not) by the same Goroutine or a different one</p>
</li>
<li>
<p>Pipeline is a powerful pattern to build complex synchronous flows of Goroutines that are connected with each other according to some logic</p>
</li>
</ul>
<p>Take a quick look at the description of the three patterns. They all describe some sort of logic to synchronize execution in time. It&#39;s very important to keep in mind that we are now developing concurrent structures with all the tools and patterns we have seen in the previous chapters. With Creational patterns we were dealing with creating objects. With the Structural patterns we were learning how to build idiomatic structures and in Behavioral patterns we were managing mostly with algorithms. Now, with Concurrency patterns, we will mostly manage the timing execution and order execution of applications that has more than one <i>flow</i>.</p>
</div>
<h3 id="barrier-concurrency-pattern" >Barrier concurrency pattern</h3>
<div class="hBody-3" >
<p>We are going to start with the Barrier pattern. Its purpose is simple--put up a barrier so that nobody passes until we have all the results we need, something quite common in concurrent applications.</p>
</div>
<h4 id="description" >Description</h4>
<div class="hBody-4" >
<p>Imagine the situation where we have a microservices application where one service needs to compose its response by merging the responses of another three microservices. This is where the Barrier pattern can help us.</p>
<p>Our Barrier pattern could be a service that will block its response until it has been composed with the results returned by one or more different Goroutines (or services). And what kind of primitive do we have that has a blocking nature? Well, we can use a lock, but it&#39;s more idiomatic in Go to use an unbuffered channel.</p>
</div>
<h4 id="objectives" >Objectives</h4>
<div class="hBody-4" >
<p>As its name implies, the Barrier pattern tries to stop an execution so it doesn&#39;t finish before it&#39;s ready to finish. The Barrier pattern&#39;s objectives are as follows:</p>
<ul>
<li>
<p>Compose the value of a type with the data coming from one or more Goroutines.</p>
</li>
<li>
<p>Control the correctness of any of those incoming data pipes so that no inconsistent data is returned. We don&#39;t want a partially filled result because one of the pipes has returned an error.</p>
</li>
</ul>
</div>
<h4 id="an-http-get-aggregator" >An HTTP GET aggregator</h4>
<div class="hBody-4" >
<p>For our example, we are going to write a very typical situation in a microservices application-an app that performs two HTTP <code>GET</code> calls and joins them in a single response that will be printed on the console.</p>
<p>Our small app must perform each request in a different Goroutine and print the result on the console if both responses are correct. If any of them returns an error, then we print just the error.</p>
<p>The design must be concurrent, allowing us to take advantage of our multicore CPUs to make the calls in parallel:</p>
<figure>
<img src="img/399_1.jpg" />
</figure>
<p>In the preceding diagram, the solid lines represent calls and the dashed lines represent channels. The balloons are Goroutines, so we have two Goroutines launched by the <code>main</code> function (which could also be considered a Goroutine). These two functions will communicate back to the <code>main</code> function by using a <b>common channel</b> that they received when they were created on the <code>makeRequest</code> calls.</p>
</div>
<h4 id="acceptance-criteria" >Acceptance criteria</h4>
<div class="hBody-4" >
<p>Our main objective in this app is to get a merged response of two different calls, so we can describe our acceptance criteria like this:</p>
<ul>
<li>
<p>Print on the console the merged result of the two calls to <a href="http://httpbin.org/headers" >http://httpbin.org/headers</a> and <a href="http://httpbin.org/user-agent" >http://httpbin.org/user-agent</a> URLs. These are a couple of public endpoints that respond with data from the incoming connections. They are very popular for testing purposes. You will need an internet connection to do this exercise.</p>
</li>
<li>
<p>If any of the calls fails, it must not print any result-just the error message (or error messages if both calls failed).</p>
</li>
<li>
<p>The output must be printed as a composed result when both calls have finished. It means that we cannot print the result of one call and then the other.</p>
</li>
</ul>
</div>
<h4 id="unit-test---integration" >Unit test - integration</h4>
<div class="hBody-4" >
<p>To write unit or integration tests for concurrent designs can sometimes be tricky, but this won&#39;t stop us from writing our awesome unit tests. We will have a single <code>barrier</code> method that accepts a set of endpoints defined as a <code>string</code> type. The barrier will make a <code>GET</code> request to each endpoint and compose the result before printing it out. In this case, we will write three integration tests to simplify our code so we don&#39;t need to generate mock responses:</p>
<pre class="code" ><code class="chroma" ><span class="kn">package</span> <span class="nx">barrier</span>

<span class="kn">import</span> <span class="p">(</span>
  <span class="s">&#34;bytes&#34;</span>
  <span class="s">&#34;io&#34;</span>
  <span class="s">&#34;os&#34;</span>
  <span class="s">&#34;strings&#34;</span>
  <span class="s">&#34;testing&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nx">TestBarrier</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">t</span><span class="p">.</span><span class="nx">Run</span><span class="p">(</span><span class="s">&#34;Correct endpoints&#34;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">endpoints</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;http://httpbin.org/headers&#34;</span><span class="p">,</span> <span class="s">&#34;http://httpbin.org/user-agent&#34;</span> <span class="p">}</span>
  <span class="p">})</span>

  <span class="nx">t</span><span class="p">.</span><span class="nx">Run</span><span class="p">(</span><span class="s">&#34;One endpoint incorrect&#34;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">endpoints</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;http://malformed-url&#34;</span><span class="p">,</span> <span class="s">&#34;http://httpbin.org/user-agent&#34;</span> <span class="p">}</span>
  <span class="p">})</span>

  <span class="nx">t</span><span class="p">.</span><span class="nx">Run</span><span class="p">(</span><span class="s">&#34;Very short timeout&#34;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">endpoints</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;http://httpbin.org/headers&#34;</span><span class="p">,</span> <span class="s">&#34;http://httpbin.org/user-agent&#34;</span> <span class="p">}</span>
  <span class="p">})</span>
<span class="p">}</span>
</code></pre>
<p>We have a single test that will execute three subtests:</p>
<ul>
<li>
<p>The first test makes two calls to the correct endpoints</p>
</li>
<li>
<p>The second test will have an incorrect endpoint, so it must return an error</p>
</li>
<li>
<p>The last test will return the maximum timeout time so that we can force a timeout error</p>
</li>
</ul>
<p>We will have a function called <code>barrier</code> that will accept an undetermined number of endpoints in the form of strings. Its signature could be like this:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">barrier</span><span class="p">(</span><span class="nx">endpoints</span> <span class="o">...</span><span class="kt">string</span><span class="p">)</span> <span class="p">{}</span>
</code></pre>
<p>As you can see, the <code>barrier</code> function doesn&#39;t return any value because its result will be printed on the console. Previously, we have written an implementation of an <code>io.Writer</code> interface to emulate the writing on the operating system&#39;s <code>stdout</code> library. Just to change things a bit, we will capture the <code>stdout</code> library instead of emulating one. The process to capture the <code>stdout</code> library isn&#39;t difficult once you understand concurrency primitives in Go:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">captureBarrierOutput</span><span class="p">(</span><span class="nx">endpoints</span> <span class="o">...</span><span class="kt">string</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
    <span class="nx">reader</span><span class="p">,</span> <span class="nx">writer</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Pipe</span><span class="p">()</span>

    <span class="nx">os</span><span class="p">.</span><span class="nx">Stdout</span> <span class="p">=</span> <span class="nx">writer</span>
    <span class="nx">out</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">string</span><span class="p">)</span>

    <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">buf</span> <span class="nx">bytes</span><span class="p">.</span><span class="nx">Buffer</span>
      <span class="nx">io</span><span class="p">.</span><span class="nx">Copy</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">buf</span><span class="p">,</span> <span class="nx">reader</span><span class="p">)</span>
      <span class="nx">out</span> <span class="o">&lt;-</span> <span class="nx">buf</span><span class="p">.</span><span class="nx">String</span><span class="p">()</span>
    <span class="p">}()</span>

    <span class="nx">barrier</span><span class="p">(</span><span class="nx">endpoints</span><span class="o">...</span><span class="p">)</span>

    <span class="nx">writer</span><span class="p">.</span><span class="nx">Close</span><span class="p">()</span>
    <span class="nx">temp</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">out</span>

    <span class="k">return</span> <span class="nx">temp</span>
<span class="p">}</span>
</code></pre>
<p>Don&#39;t feel daunted by this code; it&#39;s really simple. First we created a pipe; we have done this before in <a href="#chapter-3" >Chapter 3</a>, <i>Structural Patterns - Adapter, Bridge, and Composite Design Patterns</i>, when we talked about the Adapter design pattern. To recall, a pipe allows us to connect an <code>io.Writer</code> interface to an <code>io.Reader</code> interface so that the reader input is the <code>Writer</code> output. We define the <code>os.Stdout</code> as the writer. Then, to capture stdout output, we will need a different Goroutine that listens while we write to the console. As you know, if we write, we don&#39;t capture, and if we capture, we are not writing. The keyword here is while; it is a good rule of thumb that if you find this word in some definition, you&#39;ll probably need a concurrent structure. So we use the go keyword to launch a different Goroutine that copies reader input to a bytes buffer before sending the contents of the buffer through a channel (that we should have previously created).</p>
<p>At this point, we have a listening Goroutine, but we haven&#39;t printed anything yet, so we call our (not yet written) function <code>barrier</code> with the provided endpoints. Next, we have to close the writer to signal the Goroutine that no more input is going to come to it. Our channel called out blocks execution until some value is received (the one sent by our launched Goroutine). The last step is to return the contents captured from the console.</p>
<p>OK, so we have a function called <code>captureBarrierOutput</code> that will capture the outputs in <code>stdout</code> and return them as a string. We can write our tests now:</p>
<pre class="code" ><code class="chroma" ><span class="nx">t</span><span class="p">.</span><span class="nx">Run</span><span class="p">(</span><span class="s">&#34;Correct endpoints&#34;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">endpoints</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;http://httpbin.org/headers&#34;</span><span class="p">,</span> <span class="s">&#34;http://httpbin.org/user-agent&#34;</span><span class="p">}</span>

  <span class="nx">result</span> <span class="o">:=</span> <span class="nx">captureBarrierOutput</span><span class="p">(</span><span class="nx">endpoints</span><span class="o">...</span><span class="p">)</span>

  <span class="k">if</span> <span class="p">!</span><span class="nx">strings</span><span class="p">.</span><span class="nx">Contains</span><span class="p">(</span><span class="nx">result</span><span class="p">,</span> <span class="s">&#34;Accept-Encoding&#34;</span><span class="p">)</span> <span class="o">||</span> <span class="p">!</span><span class="nx">strings</span><span class="p">.</span><span class="nx">Contains</span> <span class="p">(</span><span class="nx">result</span><span class="p">,</span> <span class="s">&#34;User-Agent&#34;</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">t</span><span class="p">.</span><span class="nx">Fail</span><span class="p">()</span>
  <span class="p">}</span>

  <span class="nx">t</span><span class="p">.</span><span class="nx">Log</span><span class="p">(</span><span class="nx">result</span><span class="p">)</span>
<span class="p">})</span>
</code></pre>
<p>All the tests are very easy to implement. All in all, it is the <code>captureBarrierOutput</code> function that calls the <code>barrier</code> function. So we pass the endpoints and check the returned result. Our composed response directed to <code>http://httpbin.org</code> must contain the text <i>Accept-Encoding</i> and <i>User-Agent</i> in the responses of each endpoint. If we don&#39;t find those texts, the test will fail. For debugging purposes, we log the response in case we want to check it with the <code>-v</code> flag on the go test:</p>
<pre class="code" ><code class="chroma" ><span class="nx">t</span><span class="p">.</span><span class="nx">Run</span><span class="p">(</span><span class="s">&#34;One endpoint incorrect&#34;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">endpoints</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;http://malformed-url&#34;</span><span class="p">,</span> <span class="s">&#34;http://httpbin.org/user-agent&#34;</span><span class="p">}</span>

  <span class="nx">result</span> <span class="o">:=</span> <span class="nx">captureBarrierOutput</span><span class="p">(</span><span class="nx">endpoints</span><span class="o">...</span><span class="p">)</span>

  <span class="k">if</span> <span class="p">!</span><span class="nx">strings</span><span class="p">.</span><span class="nx">Contains</span><span class="p">(</span><span class="nx">result</span><span class="p">,</span> <span class="s">&#34;ERROR&#34;</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">t</span><span class="p">.</span><span class="nx">Fail</span><span class="p">()</span>
  <span class="p">}</span>

  <span class="nx">t</span><span class="p">.</span><span class="nx">Log</span><span class="p">(</span><span class="nx">result</span><span class="p">)</span>
<span class="p">})</span>
</code></pre>
<p>This time we used an incorrect endpoint URL, so the response must return the error prefixed with the word <i>ERROR</i> that we will write ourselves in the <code>barrier</code> function.</p>
<p>The last function will reduce the timeout of the HTTP <code>GET</code> client to a minimum of 1 ms, so we force a timeout:</p>
<pre class="code" ><code class="chroma" ><span class="nx">t</span><span class="p">.</span><span class="nx">Run</span><span class="p">(</span><span class="s">&#34;Very short timeout&#34;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">endpoints</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;http://httpbin.org/headers&#34;</span><span class="p">,</span> <span class="s">&#34;http://httpbin.org/user-agent&#34;</span><span class="p">}</span>
  <span class="nx">timeoutMilliseconds</span> <span class="p">=</span> <span class="mi">1</span>
  <span class="nx">result</span> <span class="o">:=</span> <span class="nx">captureBarrierOutput</span><span class="p">(</span><span class="nx">endpoints</span><span class="o">...</span><span class="p">)</span>

  <span class="k">if</span> <span class="p">!</span><span class="nx">strings</span><span class="p">.</span><span class="nx">Contains</span><span class="p">(</span><span class="nx">result</span><span class="p">,</span> <span class="s">&#34;Timeout&#34;</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">t</span><span class="p">.</span><span class="nx">Fail</span><span class="p">()</span>
  <span class="p">}</span>

  <span class="nx">t</span><span class="p">.</span><span class="nx">Log</span><span class="p">(</span><span class="nx">result</span><span class="p">)</span>
<span class="p">})</span>
</code></pre>
<p>The <code>timeoutMilliseconds</code> variable will be a package variable that we will have to define later during implementation.</p>
</div>
<h4 id="implementation" >Implementation</h4>
<div class="hBody-4" >
<p>We needed to define a package variable called timeoutMilliseconds. Let&#39;s start from there:</p>
<pre class="code" ><code class="chroma" ><span class="kn">package</span> <span class="nx">barrier</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&#34;fmt&#34;</span>
    <span class="s">&#34;io/ioutil&#34;</span>
    <span class="s">&#34;net/http&#34;</span>
    <span class="s">&#34;time&#34;</span>
<span class="p">)</span>

<span class="kd">var</span> <span class="nx">timeoutMilliseconds</span> <span class="kt">int</span> <span class="p">=</span> <span class="mi">5000</span>
</code></pre>
<p>The initial timeout delay is 5 seconds (5,000 milliseconds) and we will need those packages in our code.</p>
<p>OK, so we need a function that launches a Goroutine for each endpoint URL. Do you remember how we achieve the communication between Goroutines? Exactly--channels! So we will need a channel to handle responses and a channel to handle errors.</p>
<p>But we can simplify it a bit more. We will receive two correct responses, two errors, or a response and an error; in any case, there are always two responses, so we can join errors and responses in a merged type:</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">barrierResp</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Err</span>  <span class="kt">error</span>
    <span class="nx">Resp</span> <span class="kt">string</span>
<span class="p">}</span>
</code></pre>
<p>So, each Goroutine will send back a value of the <code>barrierResp</code> type. This value will have a value for <code>Err</code> or a value for the <code>Resp</code> field.</p>
<p>The procedure is simple: we create a channel of size 2, the one that will receive responses of the <code>barrierResp</code> type, we launch both requests and wait for two responses, and then check to see if there is any error:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">barrier</span><span class="p">(</span><span class="nx">endpoints</span> <span class="o">...</span><span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">requestNumber</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">endpoints</span><span class="p">)</span>

  <span class="nx">in</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="nx">barrierResp</span><span class="p">,</span> <span class="nx">requestNumber</span><span class="p">)</span>
  <span class="k">defer</span> <span class="nb">close</span><span class="p">(</span><span class="nx">in</span><span class="p">)</span>

  <span class="nx">responses</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="nx">barrierResp</span><span class="p">,</span> <span class="nx">requestNumber</span><span class="p">)</span>

  <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">endpoint</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">endpoints</span> <span class="p">{</span>
    <span class="k">go</span> <span class="nx">makeRequest</span><span class="p">(</span><span class="nx">in</span><span class="p">,</span> <span class="nx">endpoint</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="kd">var</span> <span class="nx">hasError</span> <span class="kt">bool</span>
  <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">requestNumber</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
    <span class="nx">resp</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">in</span>
    <span class="k">if</span> <span class="nx">resp</span><span class="p">.</span><span class="nx">Err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
      <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&#34;ERROR: &#34;</span><span class="p">,</span> <span class="nx">resp</span><span class="p">.</span><span class="nx">Err</span><span class="p">)</span>
      <span class="nx">hasError</span> <span class="p">=</span> <span class="kc">true</span>
    <span class="p">}</span>
    <span class="nx">responses</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">resp</span>
  <span class="p">}</span>

  <span class="k">if</span> <span class="p">!</span><span class="nx">hasError</span> <span class="p">{</span>
    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">resp</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">responses</span> <span class="p">{</span>
      <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">resp</span><span class="p">.</span><span class="nx">Resp</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>Following the previous description, we created a buffered channel called <code>in</code>, making it the size of the incoming endpoints, and we deferred channel closing. Then, we launched a function called <code>makeRequest</code> with each endpoint and the response channel.</p>
<p>Now we will loop  twice, once for each endpoint. In the loop, we block the execution waiting for data from the <code>in</code> channel. If we find an error, we print it prefixed with the word <i>ERROR</i> as we expect in our tests, and set <code>hasErrorvar</code> to true. After two responses, if we don&#39;t find any error (<code>hasError== false</code>) we print every response and the channel will be closed.</p>
<p>We still lack the <code>makeRequest</code> function:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">makeRequest</span><span class="p">(</span><span class="nx">out</span> <span class="kd">chan</span><span class="o">&lt;-</span> <span class="nx">barrierResp</span><span class="p">,</span> <span class="nx">url</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">res</span> <span class="o">:=</span> <span class="nx">barrierResp</span><span class="p">{}</span>
  <span class="nx">client</span> <span class="o">:=</span> <span class="nx">http</span><span class="p">.</span><span class="nx">Client</span><span class="p">{</span>
    <span class="nx">Timeout</span><span class="p">:</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span><span class="p">(</span><span class="nx">timeoutMilliseconds</span><span class="p">)</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Millisecond</span><span class="p">),</span>
  <span class="p">}</span>

  <span class="nx">resp</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">client</span><span class="p">.</span><span class="nx">Get</span><span class="p">(</span><span class="nx">url</span><span class="p">)</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">res</span><span class="p">.</span><span class="nx">Err</span> <span class="p">=</span> <span class="nx">err</span>
    <span class="nx">out</span> <span class="o">&lt;-</span> <span class="nx">res</span>
    <span class="k">return</span>
  <span class="p">}</span>

  <span class="nx">byt</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">ioutil</span><span class="p">.</span><span class="nx">ReadAll</span><span class="p">(</span><span class="nx">resp</span><span class="p">.</span><span class="nx">Body</span><span class="p">)</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">res</span><span class="p">.</span><span class="nx">Err</span> <span class="p">=</span> <span class="nx">err</span>
    <span class="nx">out</span> <span class="o">&lt;-</span> <span class="nx">res</span>
    <span class="k">return</span>
  <span class="p">}</span>

  <span class="nx">res</span><span class="p">.</span><span class="nx">Resp</span> <span class="p">=</span> <span class="nb">string</span><span class="p">(</span><span class="nx">byt</span><span class="p">)</span>
  <span class="nx">out</span> <span class="o">&lt;-</span> <span class="nx">res</span>
<span class="p">}</span>
</code></pre>
<p>The <code>makeRequest</code> function is a very straightforward functions that accepts a channel to output <code>barrierResp</code> values to and a URL to request. We create an <code>http.Client</code> and set its timeout field to the value of the <code>timeoutMilliseconds</code> package variable. This is how we can change the timeout delay before the <code>in</code> function tests. Then, we simply make the <code>GET</code> call, take the response, parse it to a byte slice, and send it through the <code>out</code> channel.</p>
<p>We do all this by filling a variable called <code>res</code> of the <code>barrierResp</code> type. If we find an error while performing a <code>GET</code> request or parsing the body of the result, we fill the <code>res.Err</code> field, send it to the <code>out</code> channel (which has the opposite side connected to the original Goroutine), and exit the function (so we don&#39;t send two values through the <code>out</code> channel by mistake).</p>
<p>Time to run the tests. Remember that you need an Internet connection, or the first two tests will fail. We will first try the test that has two endpoints that are correct:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go <span class="nb">test</span> -run<span class="o">=</span>TestBarrier/Correct_endpoints -v .
</span><span class="out" >=== RUN   TestBarrier
=== RUN   TestBarrier/Correct_endpoints
--- PASS: TestBarrier (0.54s)
    --- PASS: TestBarrier/Correct_endpoints (0.54s)
    	barrier_test.go:18: {
    		  &#34;headers&#34;: {
    		    &#34;Accept-Encoding&#34;: &#34;gzip&#34;,
    		    &#34;Connection&#34;: &#34;close&#34;,
    		    &#34;Host&#34;: &#34;httpbin.org&#34;,
    		    &#34;User-Agent&#34;: &#34;Go-http-client/1.1&#34;
    		  }
    		}

    		{
    		  &#34;user-agent&#34;: &#34;Go-http-client/1.1&#34;
    		}
ok
</span></code></pre>
<p>Perfect. We have a JSON response with a key, <code>headers</code>, and another JSON response with a key <code>User-Agent</code>. In our integration tests, we were looking for the strings, <code>User-Agent</code> and <code>Accept-Encoding</code>, which are present, so the test has passed successfully.</p>
<p>Now we will run the test that has an incorrect endpoint:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go <span class="nb">test</span> -run<span class="o">=</span>TestBarrier/One_endpoint_incorrect -v .
</span><span class="out" >=== RUN   TestBarrier
=== RUN   TestBarrier/One_endpoint_incorrect
--- PASS: TestBarrier (0.27s)
    --- PASS: TestBarrier/One_endpoint_incorrect (0.27s)
        barrier_test.go:31: ERROR:  Get http://malformed-url: dial tcp: lookup malformed-url: no such host
ok
</span></code></pre>
<p>We can see that we have had an error where <code>http://malformed-url</code> has returned a <i>no such host</i> error. A request to this URL must return a text with the word <code>ERROR</code>: prefixed, as we stated during the acceptance criteria, that&#39;s why this test is correct (we don&#39;t have a false positive).</p>
<div class="about" >
<div class="about-dt" >Note</div>
<div class="about-dd" >
<p>In testing, it&#39;s very important to understand the concepts of &#34;false positive&#34; and &#34;false negative&#34; tests. A false positive test is roughly described as a test that passes a condition when it shouldn&#39;t (result: all passed) while the false negative is just the reverse (result: test failed). For example, we could be testing that a string is returned when doing the requests but, the returned string could be completely empty! This will lead to a false negative, a test that doesn&#39;t fail even when we are checking a behavior that is incorrect on purpose (a request to <code>http://malformed-url</code>).</p>
</div>
</div>
<p>The last test reduced the timeout time to 1 ms:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go <span class="nb">test</span> -run<span class="o">=</span>TestBarrier/Very_short_timeout -v .
</span><span class="out" >=== RUN   TestBarrier
=== RUN   TestBarrier/Very_short_timeout
--- PASS: TestBarrier (0.00s)
    --- PASS: TestBarrier/Very_short_timeout (0.00s)
        barrier_test.go:43: ERROR:  Get http://httpbin.org/user-agent: net/http: request canceled while waiting for connection (Client.Timeout exceeded while awaiting headers)
        ERROR:  Get http://httpbin.org/headers: net/http: request canceled while waiting for connection (Client.Timeout exceeded while awaiting headers)
ok
</span></code></pre>
<p>Again, the test passed successfully and we have got two timeout errors. The URLs were correct, but we didn&#39;t have a response in less than one millisecond, so the client has returned a timeout error.</p>
</div>
<h4 id="waiting-for-responses-with-the-barrier-design-pattern" >Waiting for responses with the Barrier design pattern</h4>
<div class="hBody-4" >
<p>The Barrier pattern opens the door of microservices programming with its composable nature. It could be considered a Structural pattern, as you can imagine.</p>
<p>The Barrier pattern is not only useful to make network requests; we could also use it to split some task into multiple Goroutines. For example, an expensive operation could be split into a few smaller operations distributed in different Goroutines to maximize parallelism and achieve better performance.</p>
</div>
<h3 id="future-design-pattern" >Future design pattern</h3>
<div class="hBody-3" >
<p>The Future design pattern (also called <b>Promise</b>) is a quick and easy way to achieve concurrent structures for asynchronous programming. We will take advantage of first class functions in Go to develop <i>Futures</i>.</p>
</div>
<h4 id="description" >Description</h4>
<div class="hBody-4" >
<p>In short, we will define each possible behavior of an action before executing them in different Goroutines. Node.js uses this approach, providing event-driven programming by default. The idea here is to achieve a <i>fire-and-forget</i> that handles all possible results in an action.</p>
<p>To understand it better, we can talk about a type that has embedded the behavior in case an execution goes well or in case it fails.</p>
<figure>
<img src="img/410_1.jpg" />
</figure>
<p>In the preceding diagram, the <code>main</code> function launches a <b>Future</b> within a new Goroutine. It won&#39;t wait for anything, nor will it receive any progress of the Future. It really fires and forgets it.</p>
<p>The interesting thing here is that we can launch a new Future within a Future and embed as many Futures as we want in the same Goroutine (or new ones). The idea is to take advantage of the result of one Future to launch the next. For example:</p>
<figure>
<img src="img/412_1.jpg" />
</figure>
<p>Here, we have the same Future. In this case, if the <code>Execute</code> function returned a correct result, the <code>Success</code> function is executed, and only in this case we execute a new Goroutine with another <code>Future</code> inside (or even without a Goroutine).</p>
<p>This is a kind of lazy programming, where a <code>Future</code> could be calling to itself indefinitely or just until some rule is satisfied. The idea is to define the behavior in advance and let the future resolve the possible solutions.</p>
</div>
<h4 id="objectives" >Objectives</h4>
<div class="hBody-4" >
<p>With the Future pattern, we can launch many new Goroutines, each with an action and its own handlers. This enables us to do the following:</p>
<ul>
<li>
<p>Delegate the action handler to a different Goroutine</p>
</li>
<li>
<p>Stack many asynchronous calls between them (an asynchronous call that calls another asynchronous call in its results)</p>
</li>
</ul>
</div>
<h4 id="a-simple-asynchronous-requester" >A simple asynchronous requester</h4>
<div class="hBody-4" >
<p>We are going to develop a very simple example to try to understand how a Future works. In this example, we will have a method that returns a string or an error, but we want to execute it concurrently. We have learned ways to do this already. Using a channel, we can launch a new Goroutine and handle the incoming result from the channel.</p>
<p>But in this case, we will have to handle the result (string or error), and we don&#39;t want this. Instead, we will define what to do in case of success and what to do in case of error and fire-and-forget the Goroutine.</p>
</div>
<h4 id="acceptance-criteria" >Acceptance criteria</h4>
<div class="hBody-4" >
<p>We don&#39;t have functional requirements for this task. Instead, we will have technical requirements for it:</p>
<ul>
<li>
<p>Delegate the function execution to a different Goroutine</p>
</li>
<li>
<p>The function will return a string (maybe) or an error</p>
</li>
<li>
<p>The handlers must be already defined before executing the function</p>
</li>
<li>
<p>The design must be reusable</p>
</li>
</ul>
</div>
<h4 id="unit-tests" >Unit tests</h4>
<div class="hBody-4" >
<p>So, as we mentioned, we will use first class functions to achieve this behavior, and we will need three specific types of function:</p>
<ul>
<li>
<p><code>type SuccessFunc func(string)</code>: The <code>SuccessFunc</code> function will be executed if everything went well. Its string argument will be the result of the operation, so this function will be called by our Goroutine.</p>
</li>
<li>
<p><code>type FailFunc func(error)</code>: The <code>FailFunc</code> function handles the opposite result, that is, when something goes wrong, and, as you can see, it will return an error.</p>
</li>
<li>
<p><code>type ExecuteStringFunc func() (string, error)</code>: Finally, the <code>ExecuteStringFunc</code> function is a type that defines the operation we want to perform. Maybe it will return a string or an error. Don&#39;t worry if this all seems confusing; it will be clearer later.</p>
</li>
</ul>
<p>So, we create the <code>future</code> object, we define a success behavior, we define a fail behavior, and we pass an <code>ExecuteStringFunc</code> type to be executed. In the implementation file, we&#39;ll need a new type:</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">MaybeString</span> <span class="kd">struct</span> <span class="p">{}</span>
</code></pre>
<p>We will also create two tests in the <span class="file" >_test.go</span> file:</p>
<pre class="code" ><code class="chroma" ><span class="kn">package</span> <span class="nx">future</span>

<span class="kn">import</span> <span class="p">(</span>
  <span class="s">&#34;errors&#34;</span>
  <span class="s">&#34;testing&#34;</span>
  <span class="s">&#34;sync&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nx">TestStringOrError_Execute</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">future</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">MaybeString</span><span class="p">{}</span>
  <span class="nx">t</span><span class="p">.</span><span class="nx">Run</span><span class="p">(</span><span class="s">&#34;Success result&#34;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
    <span class="o">...</span>
  <span class="p">})</span>
  <span class="nx">t</span><span class="p">.</span><span class="nx">Run</span><span class="p">(</span><span class="s">&#34;Error result&#34;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
  <span class="o">...</span>
  <span class="p">})</span>
<span class="p">}</span>
</code></pre>
<p>We will define functions by chaining them, as you would usually see in Node.js. Code like this is compact and not particularly difficult to follow:</p>
<pre class="code" ><code class="chroma" ><span class="nx">t</span><span class="p">.</span><span class="nx">Run</span><span class="p">(</span><span class="s">&#34;Success result&#34;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">future</span><span class="p">.</span><span class="nx">Success</span><span class="p">(</span><span class="kd">func</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">t</span><span class="p">.</span><span class="nx">Log</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
  <span class="p">}).</span><span class="nx">Fail</span><span class="p">(</span><span class="kd">func</span><span class="p">(</span><span class="nx">e</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">t</span><span class="p">.</span><span class="nx">Fail</span><span class="p">()</span>
  <span class="p">})</span>

  <span class="nx">future</span><span class="p">.</span><span class="nx">Execute</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">(</span><span class="kt">string</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="s">&#34;Hello World!&#34;</span><span class="p">,</span> <span class="kc">nil</span>
  <span class="p">})</span>
<span class="p">})</span>
</code></pre>
<p>The <code>future.Success</code> function must be defined in the <code>MaybeString</code> structure to accept a <code>SuccessFunc</code> function that will be executed if everything goes correctly and return the same pointer to the <code>future</code> object (so we can keep chaining). The <code>Fail</code> function must also be defined in the <code>MaybeString</code> structure and must accept a <code>FailFunc</code> function to later return the pointer. We return the pointer in both cases so we can define the <code>Fail</code> and the <code>Success</code> or vice versa.</p>
<p>Finally, we use the <code>Execute</code> method to pass an <code>ExecuteStringFunc</code> type (a function that accepts nothing and returns a string or an error). In this case, we return a string and nil, so we expect that the <code>SuccessFunc</code> function will be executed and we log the result to the console. In case that fail function is executed, the test has failed because the <code>FailFunc</code> function shouldn&#39;t be executed for a returned nil error.</p>
<p>But we still lack something here. We said that the function must be executed asynchronously in a different Goroutine, so we have to synchronize this test somehow so that it doesn&#39;t finish too soon. Again, we can use a channel or a <code>sync.WaitGroup</code>:</p>
<pre class="code" ><code class="chroma" ><span class="nx">t</span><span class="p">.</span><span class="nx">Run</span><span class="p">(</span><span class="s">&#34;Success result&#34;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">wg</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span>
  <span class="nx">wg</span><span class="p">.</span><span class="nx">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
  <span class="nx">future</span><span class="p">.</span><span class="nx">Success</span><span class="p">(</span><span class="kd">func</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">t</span><span class="p">.</span><span class="nx">Log</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
    <span class="nx">wg</span><span class="p">.</span><span class="nx">Done</span><span class="p">()</span>
  <span class="p">}).</span><span class="nx">Fail</span><span class="p">(</span><span class="kd">func</span><span class="p">(</span><span class="nx">e</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">t</span><span class="p">.</span><span class="nx">Fail</span><span class="p">()</span>
    <span class="nx">wg</span><span class="p">.</span><span class="nx">Done</span><span class="p">()</span>
  <span class="p">})</span>

  <span class="nx">future</span><span class="p">.</span><span class="nx">Execute</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">(</span><span class="kt">string</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="s">&#34;Hello World!&#34;</span><span class="p">,</span> <span class="kc">nil</span>
  <span class="p">})</span>

  <span class="nx">wg</span><span class="p">.</span><span class="nx">Wait</span><span class="p">()</span>
<span class="p">})</span>
</code></pre>
<p>We have seen WaitGroups before in the previous channel. This WaitGroup is configured to wait for one signal (<code>wg.Add(1</code>)). The <code>Success</code> and <code>Fail</code> methods will trigger the <code>Done()</code> method of the <code>WaitGroup</code> to allow execution to continue and finish testing (that is why the <code>Wait()</code> method is at the end). Remember that each <code>Done()</code> method will subtract one from the WaitGroup, and we have added only one, so our Wait() method will only block until one <code>Done()</code> method is executed.</p>
<p>Using what we know of making a <code>Success</code> result unit test, it&#39;s easy to make a <code>Failed</code> result unit test by swapping the <code>t.Fail()</code> method call from the error to success so that the test fails if a call to success is done:</p>
<pre class="code" ><code class="chroma" ><span class="nx">t</span><span class="p">.</span><span class="nx">Run</span><span class="p">(</span><span class="s">&#34;Failed result&#34;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">wg</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span>
  <span class="nx">wg</span><span class="p">.</span><span class="nx">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

  <span class="nx">future</span><span class="p">.</span><span class="nx">Success</span><span class="p">(</span><span class="kd">func</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">t</span><span class="p">.</span><span class="nx">Fail</span><span class="p">()</span>
    <span class="nx">wg</span><span class="p">.</span><span class="nx">Done</span><span class="p">()</span>
  <span class="p">}).</span><span class="nx">Fail</span><span class="p">(</span><span class="kd">func</span><span class="p">(</span><span class="nx">e</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">t</span><span class="p">.</span><span class="nx">Log</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">Error</span><span class="p">())</span>
    <span class="nx">wg</span><span class="p">.</span><span class="nx">Done</span><span class="p">()</span>
  <span class="p">})</span>

  <span class="nx">future</span><span class="p">.</span><span class="nx">Execute</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">(</span><span class="kt">string</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="s">&#34;&#34;</span><span class="p">,</span> <span class="nx">errors</span><span class="p">.</span><span class="nx">New</span><span class="p">(</span><span class="s">&#34;Error ocurred&#34;</span><span class="p">)</span>
  <span class="p">})</span>

  <span class="nx">wg</span><span class="p">.</span><span class="nx">Wait</span><span class="p">()</span>
<span class="p">})</span>
</code></pre>
<p>If you are using an IDE like me, your Success, Fail, and Execute method calls must be in red. This is because we lack our method&#39;s declaration in the implementation file:</p>
<pre class="code" ><code class="chroma" ><span class="kn">package</span> <span class="nx">future</span>

<span class="kd">type</span> <span class="nx">SuccessFunc</span> <span class="kd">func</span><span class="p">(</span><span class="kt">string</span><span class="p">)</span>
<span class="kd">type</span> <span class="nx">FailFunc</span> <span class="kd">func</span><span class="p">(</span><span class="kt">error</span><span class="p">)</span>
<span class="kd">type</span> <span class="nx">ExecuteStringFunc</span> <span class="kd">func</span><span class="p">()</span> <span class="p">(</span><span class="kt">string</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>

<span class="kd">type</span> <span class="nx">MaybeString</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="o">...</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">MaybeString</span><span class="p">)</span> <span class="nx">Success</span><span class="p">(</span><span class="nx">f</span> <span class="nx">SuccessFunc</span><span class="p">)</span> <span class="o">*</span><span class="nx">MaybeString</span> <span class="p">{</span>
  <span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">MaybeString</span><span class="p">)</span> <span class="nx">Fail</span><span class="p">(</span><span class="nx">f</span> <span class="nx">FailFunc</span><span class="p">)</span> <span class="o">*</span><span class="nx">MaybeString</span> <span class="p">{</span>
  <span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">MaybeString</span><span class="p">)</span> <span class="nx">Execute</span><span class="p">(</span><span class="nx">f</span> <span class="nx">ExecuteStringFunc</span><span class="p">)</span> <span class="p">{</span>
  <span class="o">...</span>
<span class="p">}</span>
</code></pre>
<p>Our test seems ready to execute. Let&#39;s try it out:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go <span class="nb">test</span> -v .
</span><span class="out" >=== RUN   TestStringOrError_Execute
=== RUN   TestStringOrError_Execute/Success_result
fatal error: all goroutines are asleep - deadlock!
goroutine 1 [chan receive]:
testing.(*T).Run(0xc4200780c0, 0x5122e9, 0x19, 0x51d750, 0xc420041d30)
        /usr/lib/go/src/testing/testing.go:647 +0x316
testing.RunTests.func1(0xc4200780c0)
        /usr/lib/go/src/testing/testing.go:793 +0x6d
testing.tRunner(0xc4200780c0, 0xc420041e20)
        /usr/lib/go/src/testing/testing.go:610 +0x81
testing.RunTests(0x51d758, 0x5931e0, 0x1, 0x1, 0x50feb4)
        /usr/lib/go/src/testing/testing.go:799 +0x2f5
testing.(*M).Run(0xc420041ee8, 0xc420014550)
        /usr/lib/go/src/testing/testing.go:743 +0x85
main.main()
        go-design-patterns/future/_test/_testmain.go:54 +0xc6
...continue
</span></code></pre>
<p>Well... the tests have failed, yes... but not in a controllable way. Why is this? We don&#39;t have any implementation yet, so no <code>Success</code> or <code>Fail</code> functions are being executed either. Our WaitGroup is waiting forever for a call to the <code>Done()</code> method that will never arrive, so it can&#39;t continue and finish the test. That&#39;s the meaning of <i>All Goroutines are asleep - deadlock!</i>. In our specific example, it would mean <i>Nobody is going to call <code>Done()</code>, so we are dead!</i>.</p>
<div class="about" >
<div class="about-dt" >Note</div>
<div class="about-dd" >
<p>Thanks to the Go compiler and the runtime executor, we can detect deadlocks easily. Imagine if Go runtime couldn&#39;t detect deadlocks--we would be effectively stuck in a blank screen without knowing what was wrong.</p>
<p>So how can we solve this? Well, an easy way would be with a timeout that calls the <code>Done()</code> method after waiting a while for completion. For this code, it&#39;s safe to wait for 1 second because it&#39;s not doing long-running operations.</p>
</div>
</div>
<p>We will declare a <code>timeout</code> function within our <span class="file" >test</span> file that waits for a second, then prints a message, sets the test as failed, and lets the WaitGroup continue by calling its <code>Done()</code> method:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">timeout</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">,</span> <span class="nx">wg</span> <span class="o">*</span><span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">time</span><span class="p">.</span><span class="nx">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
  <span class="nx">t</span><span class="p">.</span><span class="nx">Log</span><span class="p">(</span><span class="s">&#34;Timeout!&#34;</span><span class="p">)</span>

  <span class="nx">t</span><span class="p">.</span><span class="nx">Fail</span><span class="p">()</span>
  <span class="nx">wg</span><span class="p">.</span><span class="nx">Done</span><span class="p">()</span>
<span class="p">}</span>
</code></pre>
<p>The final look of each subtest is similar to our previous example of the <code>&#34;Success result&#34;</code>:</p>
<pre class="code" ><code class="chroma" ><span class="nx">t</span><span class="p">.</span><span class="nx">Run</span><span class="p">(</span><span class="s">&#34;Success result&#34;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">wg</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span>
  <span class="nx">wg</span><span class="p">.</span><span class="nx">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

  <span class="c1">// Timeout!
</span><span class="c1"></span>  <span class="k">go</span> <span class="nx">timeout</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">wg</span><span class="p">)</span>
  <span class="c1">// ...
</span><span class="c1"></span><span class="p">})</span>
</code></pre>
<p>Let&#39;s see what happens when we execute our tests again:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go <span class="nb">test</span> -v .
</span><span class="out" >=== RUN   TestStringOrError_Execute
=== RUN   TestStringOrError_Execute/Success_result
=== RUN   TestStringOrError_Execute/Failed_result
--- FAIL: TestStringOrError_Execute (2.00s)
    --- FAIL: TestStringOrError_Execute/Success_result (1.00s)
        future_test.go:64: Timeout!
    --- FAIL: TestStringOrError_Execute/Failed_result (1.00s)
        future_test.go:64: Timeout!
FAIL
exit status 1
FAIL
</span></code></pre>
<p>Our tests failed, but in a controlled way. Look at the end of the <code>FAIL</code> lines--notice how the elapsed time is 1 second because it has been triggered by the timeout, as we can see in the logging messages.</p>
<p>It&#39;s time to pass to the implementation.</p>
</div>
<h4 id="implementation" >Implementation</h4>
<div class="hBody-4" >
<p>According to our tests, the implementation must take a <code>SuccessFunc</code>, a <code>FailFunc</code>, and an <code>ExecuteStringFunc</code> function in a chained fashion within the <code>MaybeString</code> type and launches the <code>ExecuteStringFunc</code> function asynchronously to call <code>SuccessFunc</code> or <code>FailFunc</code> functions according to the returned result of the <code>ExecuteStringFunc</code> function.</p>
<p>The chain is implemented by storing the functions within the type and returning the pointer to the type. We are talking about our previously declared type methods, of course:</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">MaybeString</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">successFunc</span> <span class="nx">SuccessFunc</span>
  <span class="nx">failFunc</span>    <span class="nx">FailFunc</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">MaybeString</span><span class="p">)</span> <span class="nx">Success</span><span class="p">(</span><span class="nx">f</span> <span class="nx">SuccessFunc</span><span class="p">)</span> <span class="o">*</span><span class="nx">MaybeString</span> <span class="p">{</span>
  <span class="nx">s</span><span class="p">.</span><span class="nx">successFunc</span> <span class="p">=</span> <span class="nx">f</span>
  <span class="k">return</span> <span class="nx">s</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">MaybeString</span><span class="p">)</span> <span class="nx">Fail</span><span class="p">(</span><span class="nx">f</span> <span class="nx">FailFunc</span><span class="p">)</span> <span class="o">*</span><span class="nx">MaybeString</span> <span class="p">{</span>
  <span class="nx">s</span><span class="p">.</span><span class="nx">failFunc</span> <span class="p">=</span> <span class="nx">f</span>
  <span class="k">return</span> <span class="nx">s</span>
<span class="p">}</span>
</code></pre>
<p>We needed two fields to store the <code>SuccessFunc</code> and <code>FailFunc</code> functions, which are named the <code>successFunc</code> and <code>failFunc</code> fields respectively. This way, calls to the <code>Success</code> and <code>Fail</code> methods simply store their incoming functions to our new fields. They are simply setters that also return the pointer to the specific <code>MaybeString</code> value. These type methods take a pointer to the <code>MaybeString</code> structure, so don&#39;t forget to put &#34;*&#34; on <code>MaybeString</code> after the <code>func</code> declaration.</p>
<p>Execute takes the <code>ExecuteStringFunc</code> method and executes it asynchronously. This seems quite simple with a Goroutine, right?</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">MaybeString</span><span class="p">)</span> <span class="nx">Execute</span><span class="p">(</span><span class="nx">f</span> <span class="nx">ExecuteStringFunc</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">go</span> <span class="kd">func</span><span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">MaybeString</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">str</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">f</span><span class="p">()</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
      <span class="nx">s</span><span class="p">.</span><span class="nx">failFunc</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="nx">s</span><span class="p">.</span><span class="nx">successFunc</span><span class="p">(</span><span class="nx">str</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">}(</span><span class="nx">s</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
<p>Looks quite simple because it is simple! We launch the Goroutine that executes the <code>f</code> method (an <code>ExecuteStringFunc</code>) and takes its result--maybe a string and maybe an error. If an error is present, we call the field <code>failFunc</code> in our <code>MaybeString</code> structure. If no error is present, we call the <code>successFunc</code> field. We use a Goroutine to delegate a function execution and error handling so our Goroutine doesn&#39;t have to do it.</p>
<p>Let&#39;s run unit tests now:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go <span class="nb">test</span> -v .
</span><span class="out" >=== RUN   TestStringOrError_Execute
=== RUN   TestStringOrError_Execute/Success_result
=== RUN   TestStringOrError_Execute/Failed_result
--- PASS: TestStringOrError_Execute (0.00s)
    --- PASS: TestStringOrError_Execute/Success_result (0.00s)
        future_test.go:21: Hello World!
    --- PASS: TestStringOrError_Execute/Failed_result (0.00s)
        future_test.go:49: Error ocurred
PASS
ok
</span></code></pre>
<p>Great! Look how the execution time is now nearly zero, so our timeouts have not been executed (actually, they were executed, but the tests already finished and their result was already stated).</p>
<p>What&#39;s more, now we can use our <code>MaybeString</code> type to asynchronously execute any type of function that accepts nothing and returns a string or an error. A function that accepts nothing seems a bit useless, right? But we can use closures to introduce a context into this type of function.</p>
<p>Let&#39;s write a <code>setContext</code> function that takes a string as an argument and returns an <code>ExecuteStringFunc</code> method that returns the previous argument with the suffix <code>Closure!</code>:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">setContext</span><span class="p">(</span><span class="nx">msg</span> <span class="kt">string</span><span class="p">)</span> <span class="nx">ExecuteStringFunc</span> <span class="p">{</span>
  <span class="nx">msg</span> <span class="p">=</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintf</span><span class="p">(</span><span class="s">&#34;%d Closure!\n&#34;</span><span class="p">,</span> <span class="nx">msg</span><span class="p">)</span>

  <span class="k">return</span> <span class="kd">func</span><span class="p">()</span> <span class="p">(</span><span class="kt">string</span><span class="p">,</span> <span class="kt">error</span><span class="p">){</span>
    <span class="k">return</span> <span class="nx">msg</span><span class="p">,</span> <span class="kc">nil</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>So, we can write a new test that uses this closure:</p>
<pre class="code" ><code class="chroma" ><span class="nx">t</span><span class="p">.</span><span class="nx">Run</span><span class="p">(</span><span class="s">&#34;Closure Success result&#34;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">wg</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span>
  <span class="nx">wg</span><span class="p">.</span><span class="nx">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
  <span class="c1">// Timeout!
</span><span class="c1"></span>  <span class="k">go</span> <span class="nx">timeout</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">wg</span><span class="p">)</span>

  <span class="nx">future</span><span class="p">.</span><span class="nx">Success</span><span class="p">(</span><span class="kd">func</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">t</span><span class="p">.</span><span class="nx">Log</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
    <span class="nx">wg</span><span class="p">.</span><span class="nx">Done</span><span class="p">()</span>
  <span class="p">}).</span><span class="nx">Fail</span><span class="p">(</span><span class="kd">func</span><span class="p">(</span><span class="nx">e</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">t</span><span class="p">.</span><span class="nx">Fail</span><span class="p">()</span>
    <span class="nx">wg</span><span class="p">.</span><span class="nx">Done</span><span class="p">()</span>
  <span class="p">})</span>

  <span class="nx">future</span><span class="p">.</span><span class="nx">Execute</span><span class="p">(</span><span class="nx">setContext</span><span class="p">(</span><span class="s">&#34;Hello&#34;</span><span class="p">))</span>
  <span class="nx">wg</span><span class="p">.</span><span class="nx">Wait</span><span class="p">()</span>
<span class="p">})</span>
</code></pre>
<p>The <code>setContext</code> function returns an <code>ExecuteStringFunc</code> method it can pass directly to the <code>Execute</code> function. We call the <code>setContext</code> function with an arbitrary text that we know will be returned.</p>
<p>Let&#39;s execute our tests again. Now everything has to go well!</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go <span class="nb">test</span> -v .
</span><span class="out" >=== RUN   TestStringOrError_Execute
=== RUN   TestStringOrError_Execute/Success_result
=== RUN   TestStringOrError_Execute/Failed_result
=== RUN   TestStringOrError_Execute/Closure_Success_result
--- PASS: TestStringOrError_Execute (0.00s)
    --- PASS: TestStringOrError_Execute/Success_result (0.00s)
        future_test.go:21: Hello World!
    --- PASS: TestStringOrError_Execute/Failed_result (0.00s)
        future_test.go:49: Error ocurred
    --- PASS: TestStringOrError_Execute/Closure_Success_result (0.00s)
        future_test.go:69: Hello Closure!
PASS
ok
</span></code></pre>
<p>It gave us an OK too. Closure test shows the behavior that we explained before. By taking a message <code>&#34;Hello&#34;</code> and appending it with something else (<code>&#34;Closure!&#34;</code>), we can change the context of the text we want to return. Now scale this to a HTTP <code>GET</code> call, a call to a database, or anything you can imagine. It will just need to end by returning a string or an error. Remember, however, that everything within the <code>setContext</code> function but outside of the anonymous function that we are returning is not concurrent, and will be executed asynchronously before calling execute, so we must try to put as much logic as possible within the anonymous function.</p>
</div>
<h4 id="putting-the-future-together" >Putting the Future together</h4>
<div class="hBody-4" >
<p>We have seen a good way to achieve asynchronous programming by using a function type system. However, we could have done it without functions by setting an interface with <code>Success</code>, <code>Fail</code>, and <code>Execute</code> methods and the types that satisfy them, and using the Template pattern to execute them asynchronously, as we have previously seen in this chapter. It is up to you!</p>
</div>
<h3 id="pipeline-design-pattern" >Pipeline design pattern</h3>
<div class="hBody-3" >
<p>The third and final pattern we will see in this chapter is the Pipeline pattern. You will use this pattern heavily in your concurrent structures, and we can consider it one of the most useful too.</p>
</div>
<h4 id="description" >Description</h4>
<div class="hBody-4" >
<p>We already know what a pipeline is. Every time that we write any function that performs some logic, we are writing a pipeline: If <i>this</i> then <i>that</i>, or else <i>something else</i>. Pipelines pattern can be made more complex by using a few functions that call to each other. They can even get looped in their out execution.</p>
<p>The Pipeline pattern in Go works in a similar fashion, but each step in the Pipeline will be in a different Goroutine and communication, and synchronizing will be done using channels.</p>
</div>
<h4 id="objectives" >Objectives</h4>
<div class="hBody-4" >
<p>When creating a Pipeline, we are mainly looking for the following benefits:</p>
<ul>
<li>
<p>We can create a concurrent structure of a multistep algorithm</p>
</li>
<li>
<p>We can exploit the parallelism of multicore machines by decomposing an algorithm in different Goroutines</p>
</li>
</ul>
<p>However, just because we decompose an algorithm in different Goroutines doesn&#39;t necessarily mean that it will execute the fastest. We are constantly talking about CPUs, so ideally the algorithm must be CPU-intensive to take advantage of a concurrent structure. The overhead of creating Goroutines and channels could make an algorithm smaller.</p>
</div>
<h4 id="a-concurrent-multi-operation" >A concurrent multi-operation</h4>
<div class="hBody-4" >
<p>We are going to do some math for our example. We are going to generate a list of numbers starting with 1 and ending at some arbitrary number N. Then we will take each number, power it to 2, and sum the resulting numbers to a unique result. So, if <span class="math" >N=3</span>, our list will be [1,2,3]. After powering them to 2, our list becomes [1,4,9]. If we sum the resulting list, the resulting value is 14.</p>
</div>
<h4 id="acceptance-criteria" >Acceptance criteria</h4>
<div class="hBody-4" >
<p>Functionally speaking, our Pipeline pattern needs to raise to the power of 2 every number and then sum them all. It will be divided into a number generator and two operations, so:</p>
<ol class="num" >
<li>
<p>Generate a list from 1 to N where N can be any integer number.</p>
</li>
<li>
<p>Take each number of this generated list and raise it to the power of 2.</p>
</li>
<li>
<p>Sum each resulting number into a final result and return it.</p>
</li>
</ol>
</div>
<h4 id="beginning-with-tests" >Beginning with tests</h4>
<div class="hBody-4" >
<p>We will create only one function that will manage everything. We will call this function <code>LaunchPipeline</code> to simplify things. It will take an integer as an argument, which will be our N number, the number of items in our list. The declaration in the implementation file looks like this:</p>
<pre class="code" ><code class="chroma" ><span class="kn">package</span> <span class="nx">pipelines</span>

<span class="kd">func</span> <span class="nx">LaunchPipeline</span><span class="p">(</span><span class="nx">amount</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
  <span class="k">return</span> <span class="mi">0</span>
<span class="p">}</span>
</code></pre>
<p>In our test file, we will create a table of tests by using a slice of slices:</p>
<pre class="code" ><code class="chroma" ><span class="kn">package</span> <span class="nx">pipelines</span>

<span class="kn">import</span> <span class="s">&#34;testing&#34;</span>

<span class="kd">func</span> <span class="nx">TestLaunchPipeline</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">tableTest</span> <span class="o">:=</span> <span class="p">[][]</span><span class="kt">int</span><span class="p">{</span>
    <span class="p">{</span><span class="mi">3</span><span class="p">,</span> <span class="mi">14</span><span class="p">},</span>
    <span class="p">{</span><span class="mi">5</span><span class="p">,</span> <span class="mi">55</span><span class="p">},</span>
  <span class="p">}</span>
  <span class="c1">// ...
</span><span class="c1"></span><span class="p">}</span>
</code></pre>
<p>Our table is a slice of slices of integer types. On each slice, the first integer represents the list size and the second position represents the item within the list. It is, effectively, a matrix. When passing 3, it must return 14. When passing 5, it must return 55. Then we have to iterate over the table and pass the first index of each array to the <code>LaunchPipeline</code> function:</p>
<pre class="code" ><code class="chroma" >  <span class="c1">// ...
</span><span class="c1"></span>
  <span class="kd">var</span> <span class="nx">res</span> <span class="kt">int</span>
  <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">test</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">tableTest</span> <span class="p">{</span>
    <span class="nx">res</span> <span class="p">=</span> <span class="nx">LaunchPipeline</span><span class="p">(</span><span class="nx">test</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">if</span> <span class="nx">res</span> <span class="o">!=</span> <span class="nx">test</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">{</span>
      <span class="nx">t</span><span class="p">.</span><span class="nx">Fatal</span><span class="p">()</span>
    <span class="p">}</span>

    <span class="nx">t</span><span class="p">.</span><span class="nx">Logf</span><span class="p">(</span><span class="s">&#34;%d == %d\n&#34;</span><span class="p">,</span> <span class="nx">res</span><span class="p">,</span> <span class="nx">test</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>Using <code>range</code>, we get every row in the matrix . Each row is contained in a temporary variable called <code>test</code>. <code>test[0]</code> represents <span class="math" >N</span> and <code>test[1]</code> the expected result. We compare the expected result with the returning value of the <code>LaunchPipeline</code> function. If they aren&#39;t the same, the test fails:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go <span class="nb">test</span> -v .
</span><span class="out" >=== RUN   TestLaunchPipeline
--- FAIL: TestLaunchPipeline (0.00s)
        pipeline_test.go:15:
FAIL
exit status 1
FAIL
</span></code></pre>
</div>
<h4 id="implementation" >Implementation</h4>
<div class="hBody-4" >
<p>The key for our implementation is to separate every operation in a different Goroutine and connect them with channels. The <code>LaunchPipeline</code> function is the one that orchestrates them all, as shown in the following diagram:</p>
<figure>
<img src="img/428_1.jpg" />
</figure>
<figure>
<img src="img/429_1.jpg" />
</figure>
<p>The operation consist of three steps: generate a list of numbers, raise them to the power of 2, and add the resulting numbers.</p>
<p>Each step in this Pipeline pattern will have the following structure:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">functionName</span><span class="p">(</span><span class="nx">in</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="o">&lt;-</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">out</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">bool</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>

  <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">for</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">in</span> <span class="p">{</span>
      <span class="c1">// Do something with v and send it to channel out
</span><span class="c1"></span>    <span class="p">}</span>

    <span class="nb">close</span><span class="p">(</span><span class="nx">out</span><span class="p">)</span>
  <span class="p">}()</span>

  <span class="k">return</span> <span class="nx">out</span>
<span class="p">}</span>
</code></pre>
<p>This function represents a common step. Let&#39;s dissect it in the same order that the Go scheduler will probably take to execute it:</p>
<ol class="num" >
<li>
<p>The <code>functionName</code> function will commonly receive a channel to take values from (<code>in &lt;-chan int</code>). We call it the <code>in</code> function, as in the word incoming. We can&#39;t send values through it within the scope of this function; that&#39;s why the arrow points <code>out</code> of the keyword <code>chan</code>.</p>
</li>
<li>
<p>The <code>functionName</code> function returns a channel (<code>&lt;-chan in</code>) that the function caller will only be allowed to take values from (again, represented by the arrow pointing <code>out</code> of the keyword <code>chan</code>). This also means that any value that goes through that channel must be generated within the scope of the function.</p>
</li>
<li>
<p>In the first line of the function, we create a channel called out that will be the return of the function (<i>point 2</i> in this list).</p>
</li>
<li>
<p>Then, we will launch a new Goroutine. Its scope will enter into play after returning this function, so let&#39;s continue.</p>
</li>
<li>
<p>We return the previously created <code>out</code> channel.</p>
</li>
<li>
<p>Eventually, after finishing the execution of the function and returning the channel <code>out</code>, the Goroutine executes. It will take values from the <code>in</code> channel until it&#39;s closed. So the caller of this function is responsible for closing this channel, otherwise the Goroutine will never end!</p>
</li>
<li>
<p>When the <code>in</code> channel is closed, the for loop finishes and we close the <code>out</code> channel. Any Goroutine making use of this channel will not receive any new values since the last that was sent.</p>
</li>
</ol>
<p>The only step that doesn&#39;t completely fit this approach is the first step that receives a number, representing the upper threshold on the list instead of a channel of incoming values. So, if we code this operation for each step in our pipeline, the final diagram looks more like this:</p>
<figure>
<img src="img/431_1.jpg" />
</figure>
<p>Although the idea is exactly the same, now we can see that it&#39;s the function <code>LaunchPipeline</code> that is the one that is going to be receiving channels and sending them back to the next step in the Pipeline. Using this diagram, we can clearly see the flow of the pipeline creation by following the numbers of the arrows. A solid arrow represents a function call and a dashed arrow a channel.</p>
<p>Let&#39;s look a little more closely at the code.</p>
</div>
<h5 id="the-list-generator" >The list generator</h5>
<div class="hBody-5" >
<p>The first step in the operation is list generation. The list starts at 1 and we will receive an integer representing the higher threshold. We have to pass each number in the list to the next step:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">generator</span><span class="p">(</span><span class="nx">max</span> <span class="kt">int</span><span class="p">)</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="kt">int</span> <span class="p">{</span>
  <span class="nx">outChInt</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>

  <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="nx">max</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
      <span class="nx">outChInt</span> <span class="o">&lt;-</span> <span class="nx">i</span>
    <span class="p">}</span>

    <span class="nb">close</span><span class="p">(</span><span class="nx">outChInt</span><span class="p">)</span>
  <span class="p">}()</span>

  <span class="k">return</span> <span class="nx">outChInt</span>
<span class="p">}</span>
</code></pre>
<p>As we mentioned earlier, this is the pattern that we will follow in each step: create a channel, launch the Goroutine that will send the data through the channel, and immediately return the channel. This Goroutine will iterate from 1 to the max argument, which is the higher threshold for our list, and send each number through the channel. After sending every number, the channel is closed so that no more data can be sent through it, but the data already buffered can be retrieved.</p>
</div>
<h5 id="raising-numbers-to-the-power-of-2" >Raising numbers to the power of 2</h5>
<div class="hBody-5" >
<p>The second step will take every incoming number from the first step&#39;s channel (that is taken from the arguments) and raise it to the power of 2. Every result must be sent to the third step using a new channel:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">power</span><span class="p">(</span><span class="nx">in</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="kt">int</span> <span class="p">{</span>
  <span class="nx">out</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>

  <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">for</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">in</span> <span class="p">{</span>
      <span class="nx">out</span> <span class="o">&lt;-</span> <span class="nx">v</span> <span class="o">*</span> <span class="nx">v</span>
    <span class="p">}</span>
    <span class="nb">close</span><span class="p">(</span><span class="nx">out</span><span class="p">)</span>
  <span class="p">}()</span>
  <span class="k">return</span> <span class="nx">out</span>
<span class="p">}</span>
</code></pre>
<p>We use the same pattern again: create a channel and launch the Goroutine while we return the created channel.</p>
<div class="about" >
<div class="about-dt" >Note</div>
<div class="about-dd" >
<p>The for-range loop keeps taking values from a channel indefinitely until the channel is closed.</p>
</div>
</div>
</div>
<h5 id="final-reduce-operation" >Final reduce operation</h5>
<div class="hBody-5" >
<p>The third and final step receives every number from the second step and keeps adding them to a local value until the connection channel is closed:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">sum</span><span class="p">(</span><span class="nx">in</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="kt">int</span> <span class="p">{</span>
  <span class="nx">out</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
  <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">sum</span> <span class="kt">int</span>

    <span class="k">for</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">in</span> <span class="p">{</span>
      <span class="nx">sum</span> <span class="o">+=</span> <span class="nx">v</span>
    <span class="p">}</span>

    <span class="nx">out</span> <span class="o">&lt;-</span> <span class="nx">sum</span>
    <span class="nb">close</span><span class="p">(</span><span class="nx">out</span><span class="p">)</span>
  <span class="p">}()</span>

  <span class="k">return</span> <span class="nx">out</span>
<span class="p">}</span>
</code></pre>
<p>The function sum also takes a channel as an argument (the one returned from <i>step 2</i>). It also follows the same pattern of creating a channel, launching the Goroutine, and returning a channel. Goroutine keeps adding values to a variable called <code>sum</code> until the <code>in</code> channel is closed. When the <code>in</code> channel is closed, the value of sum is sent to the <code>out</code> channel, and it&#39;s immediately closed.</p>
</div>
<h5 id="launching-the-pipeline-pattern" >Launching the Pipeline pattern</h5>
<div class="hBody-5" >
<p>Finally, we can implement the <code>LaunchPipeline</code> function:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">LaunchPipeline</span><span class="p">(</span><span class="nx">amount</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
  <span class="nx">firstCh</span> <span class="o">:=</span> <span class="nx">generator</span><span class="p">(</span><span class="nx">amount</span><span class="p">)</span>
  <span class="nx">secondCh</span> <span class="o">:=</span> <span class="nx">power</span><span class="p">(</span><span class="nx">firstCh</span><span class="p">)</span>
  <span class="nx">thirdCh</span> <span class="o">:=</span> <span class="nx">sum</span><span class="p">(</span><span class="nx">secondCh</span><span class="p">)</span>

  <span class="nx">result</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">thirdCh</span>

  <span class="k">return</span> <span class="nx">result</span>
<span class="p">}</span>
</code></pre>
<p>The function <code>generator</code> first returns the channel that is passed to the power function. The <code>power</code> function returns the second channel that is passed to the <code>sum</code> function. The function <code>sum</code> finally returns the first channel that will receive a unique value, the result. Let&#39;s try to test this now:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go <span class="nb">test</span> -v .
</span><span class="out" >=== RUN   TestLaunchPipeline
--- PASS: TestLaunchPipeline (0.00s)
        pipeline_test.go:18: 14 == 14
        pipeline_test.go:18: 55 == 55
PASS
ok
</span></code></pre>
<p>Awesome! It&#39;s worth mentioning that the <code>LaunchPipeline</code> function doesn&#39;t need to allocate every channel, and can be rewritten like this:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">LaunchPipeline</span><span class="p">(</span><span class="nx">amount</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
  <span class="k">return</span> <span class="o">&lt;-</span><span class="nx">sum</span><span class="p">(</span><span class="nx">power</span><span class="p">(</span><span class="nx">generator</span><span class="p">(</span><span class="nx">amount</span><span class="p">)))</span>
<span class="p">}</span>
</code></pre>
<p>The result of the generator function is passed directly to the power function and the result of <code>power</code> to <code>sum</code> functions.</p>
</div>
<h4 id="final-words-on-the-pipeline-pattern" >Final words on the Pipeline pattern</h4>
<div class="hBody-4" >
<p>With the Pipeline pattern, we can create really complex concurrent workflows in a very easy way. In our case, we created a linear workflow, but it could also have conditionals, pools, and fan-in and fan-out behavior. We will see some of these in the following chapter.</p>
</div>
<h3 id="summary" >Summary</h3>
<div class="hBody-3" >
<p>Concurrency design patterns are a step forward in difficulty, and take some time to grasp. Our biggest mistake as concurrent programmers is thinking in terms of parallelism (How can I make this parallel? or How can I run this in a new thread?) instead of in terms of concurrent structures.</p>
<p>Pure functions (functions that will always produce the same output (given the same input) without affecting anything outside their scope) help in this design.</p>
<p>Concurrent programming requires practice and more practice. Go makes it easy once you understand the basic primitives. Diagrams can help you to understand the possible flow of data, but the best way of understanding it all is simply to practice.</p>
<p>In the following chapter, we will see how to use a pool of pipeline workers to do some work instead of having a unique pipeline. Also, we will learn how to create the publish/subscriber pattern in a concurrent structure and see how different the same pattern can be when we build by using concurrency.</p>
</div>
<h2 id="chapter-10" >Concurrency Patterns - Workers Pool and Publish/Subscriber Design Patterns</h2>
<div class="hBody-2" >
<p>We have reached the final chapter of the book, where we will discuss a couple of patterns with concurrent structures. We will explain every step in detail so you can follow the examples carefully.</p>
<p>The idea is to learn about patterns to design concurrent applications in idiomatic Go. We are using channels and Goroutines heavily, instead of locks or sharing variables.</p>
<ul>
<li>
<p>We will look at one way to develop a pool of workers. This is useful to control the number of Goroutines in an execution.</p>
</li>
<li>
<p>The second example is a rewrite of the Observer pattern, which we saw on <a href="#chapter-7" >Chapter 7</a>, <i>Behavioral Patterns - Visitor, State, Mediator, and Observer Design Patterns</i>, written with a concurrent structure. With this example we&#39;ll dig a bit more into the concurrent structures and look at how they can differ from a common approach.</p>
</li>
</ul>
</div>
<h3 id="workers-pool" >Workers pool</h3>
<div class="hBody-3" >
<p>One problem we may face with some of the previous approaches to concurrency is their unbounded context. We cannot let an app create  an unlimited amount of Goroutines. Goroutines are light, but the work they perform could be very heavy. A workers pool helps us to solve this problem.</p>
</div>
<h4 id="description" >Description</h4>
<div class="hBody-4" >
<p>With a pool of workers, we want to bound the amount of Goroutines available so that we have a deeper control of the pool of resources. This is easy to achieve by creating a channel for each worker and having workers with either an idle or busy status. The task can seem daunting, but it&#39;s not at all.</p>
</div>
<h4 id="objectives" >Objectives</h4>
<div class="hBody-4" >
<p>Creating a <code>Worker</code> pool is all about resource control: CPU, RAM, time, connections, and so on. The workers pool design pattern helps us to do the following:</p>
<ul>
<li>
<p>Control access to shared resources using quotas</p>
</li>
<li>
<p>Create a limited amount of Goroutines per app</p>
</li>
<li>
<p>Provide more parallelism capabilities to other concurrent structures</p>
</li>
</ul>
</div>
<h4 id="a-pool-of-pipelines" >A pool of pipelines</h4>
<div class="hBody-4" >
<p>In the previous chapter, we saw how to work with a pipeline. Now we will launch a bounded number of them so that the Go scheduler can try to process requests in parallel. The idea here is to control the number of Goroutines, stop them gracefully when the app has finished, and maximize parallelism using a concurrent structure without race conditions.</p>
<p>The pipeline we will use is similar to the one we used in the previous chapter, where we were generating numbers, raising them to the power of 2, and summing the final results. In this case, we are going to pass strings to which we will append and prefix data.</p>
</div>
<h4 id="acceptance-criteria" >Acceptance criteria</h4>
<div class="hBody-4" >
<p>In business terms, we want something that tells us that, worker has processed a request, a predefined ending, and incoming data parsed to uppercase:</p>
<ol class="num" >
<li>
<p>When making a request with a string value (any), it must be uppercase.</p>
</li>
<li>
<p>Once the string is uppercase, a predefined text must be appended to it. This text should not be uppercase.</p>
</li>
<li>
<p>With the previous result, the worker ID must be prefixed to the final string.</p>
</li>
<li>
<p>The resulting string must be passed to a predefined handler. We haven&#39;t talked about how to do it technically, just what the business wants. With the entire description, we&#39;ll at least have workers, requests, and handlers.</p>
</li>
</ol>
</div>
<h4 id="implementation" >Implementation</h4>
<div class="hBody-4" >
<p>The very beginning is a request type. According to the description, it must hold the string that will enter the pipeline as well as the handler function:</p>
<pre class="code" ><code class="chroma" ><span class="c1">// workers_pipeline.go file
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Request</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Data</span>    <span class="kd">interface</span><span class="p">{}</span>
    <span class="nx">Handler</span> <span class="nx">RequestHandler</span>
<span class="p">}</span>
</code></pre>
<p>Where is the <code>string</code>? We have a <code>Data</code> field of type <code>interface{}</code> so we can use it to pass a string. By using an interface, we can reuse this type for a <code>string</code>, an <code>int</code>, or a <code>struct</code> data type. The receiver is the one who must know how to deal with the incoming interface.</p>
<p>The <code>Handler</code> field has the type <code>Request</code> handler, which we haven&#39;t defined yet:</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">RequestHandler</span> <span class="kd">func</span><span class="p">(</span><span class="kd">interface</span><span class="p">{})</span>
</code></pre>
<p>A request handler is any function that accepts an interface as its first argument, and returns nothing. Again, we see the <code>interface{}</code>, where we would usually see a string. This is one of the receivers we mentioned previously, which we&#39;ll need to cast the incoming result.</p>
<p>So, when sending a request, we must fill it with some value in the <code>Data</code> field and implement a handler; for example:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">NewStringRequest</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">id</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">wg</span> <span class="o">*</span><span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span><span class="p">)</span>
<span class="nx">Request</span> <span class="p">{</span>
  <span class="nx">myRequest</span> <span class="o">:=</span> <span class="nx">Request</span><span class="p">{</span>
    <span class="nx">Data</span><span class="p">:</span> <span class="s">&#34;Hello&#34;</span><span class="p">,</span> <span class="nx">Handler</span><span class="p">:</span> <span class="kd">func</span><span class="p">(</span><span class="nx">i</span> <span class="kd">interface</span><span class="p">{})</span>
    <span class="p">{</span>
      <span class="k">defer</span> <span class="nx">wg</span><span class="p">.</span><span class="nx">Done</span><span class="p">()</span>
      <span class="nx">s</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">i</span><span class="p">.(</span><span class="kt">string</span><span class="p">)</span>
      <span class="k">if</span> <span class="p">!</span><span class="nx">ok</span><span class="p">{</span>
        <span class="nx">log</span><span class="p">.</span><span class="nx">Fatal</span><span class="p">(</span><span class="s">&#34;Invalid casting to string&#34;</span><span class="p">)</span>
      <span class="p">}</span>
      <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>The handler is defined by using a closure. We again check the type if the interface (and we defer the call to the <code>Done()</code> method at the end). In case of an improper interface, we simply print its contents and return. If the casting is OK, we also print them, but here is where we will usually do something with the result of the operation; we have to use type casting to retrieve the contents of the <code>interface{}</code> (which is a string). This must be done in every step in the pipeline, although it will introduce a bit of overhead.</p>
<p>Now we need a type that can handle <code>Request</code> types. Possible implementations are virtually infinite, so it is better to define an interface first:</p>
<pre class="code" ><code class="chroma" > <span class="c1">// worker.go file
</span><span class="c1"></span> <span class="kd">type</span> <span class="nx">WorkerLauncher</span> <span class="kd">interface</span> <span class="p">{</span>
     <span class="nx">LaunchWorker</span><span class="p">(</span><span class="nx">in</span> <span class="kd">chan</span> <span class="nx">Request</span><span class="p">)</span>
 <span class="p">}</span>
</code></pre>
<p>The <code>WorkerLauncher</code> interface must implement only the <code>LaunchWorker(chan Request)</code> method. Any type that implements this interface will have to receive a channel of <code>Request</code> type to satisfy it. This channel of the <code>Request</code> type is the single entrance point to the pipeline.</p>
</div>
<h5 id="the-dispatcher" >The dispatcher</h5>
<div class="hBody-5" >
<p>Now, to launch workers in parallel and handle all the possible incoming channels, we&#39;ll need something like a dispatcher:</p>
<pre class="code" ><code class="chroma" ><span class="c1">// dispatcher.go file
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Dispatcher</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="nx">LaunchWorker</span><span class="p">(</span><span class="nx">w</span> <span class="nx">WorkerLauncher</span><span class="p">)</span>
    <span class="nx">MakeRequest</span><span class="p">(</span><span class="nx">Request</span><span class="p">)</span>
    <span class="nx">Stop</span><span class="p">()</span>
<span class="p">}</span>
</code></pre>
<p>A <code>Dispatcher</code> interface can launch an injected <code>WorkerLaunchers</code> type in its own <code>LaunchWorker</code> method. The <code>Dispatcher</code> interface must use the <code>LaunchWorker</code> method of any of the <code>WorkerLauncher</code> types to initialize a pipeline. This way we can reuse the <code>Dispatcher</code> interface to launch many types of <code>WorkerLaunchers</code>.</p>
<p>When using <code>MakeRequest(Request)</code>, the <code>Dispatcher</code> interface exposes a nice method to inject a new <code>Request</code> into the workers pool.</p>
<p>Finally, the user must call stop when all <code>Goroutines</code> must be finished. We must handle graceful shutdown in our apps, and we want to avoid Goroutine leaks.</p>
<p>We have enough interfaces, so let&#39;s start with the dispatcher which is a bit less complicated:</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">dispatcher</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">inCh</span> <span class="kd">chan</span> <span class="nx">Request</span>
<span class="p">}</span>
</code></pre>
<p>Our <code>dispatcher</code> structure stores a channel of <code>Request</code> type in one of its fields. This is going to be the single point of entrance for requests in any pipeline. We said that it must implement three methods, as follows:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="p">(</span><span class="nx">d</span> <span class="o">*</span><span class="nx">dispatcher</span><span class="p">)</span> <span class="nx">LaunchWorker</span><span class="p">(</span><span class="nx">id</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">w</span> <span class="nx">WorkerLauncher</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">w</span><span class="p">.</span><span class="nx">LaunchWorker</span><span class="p">(</span><span class="nx">d</span><span class="p">.</span><span class="nx">inCh</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">d</span> <span class="o">*</span><span class="nx">dispatcher</span><span class="p">)</span> <span class="nx">Stop</span><span class="p">(){</span>
  <span class="nb">close</span><span class="p">(</span><span class="nx">d</span><span class="p">.</span><span class="nx">inCh</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">d</span> <span class="o">*</span><span class="nx">dispatcher</span><span class="p">)</span> <span class="nx">MakeRequest</span><span class="p">(</span><span class="nx">r</span> <span class="nx">Request</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">d</span><span class="p">.</span><span class="nx">inCh</span> <span class="o">&lt;-</span> <span class="nx">r</span>
<span class="p">}</span>
</code></pre>
<p>In this example, the <code>Dispatcher</code> interface doesn&#39;t need to do anything special to itself before launching a worker, so the <code>LaunchWorker</code> method on the <code>Dispatcher</code> simply executes the <code>LaunchWorker</code> method of the incoming <code>WorkerLauncher</code>,which also has a <code>LaunchWorker</code> method to initiate itself. We have previously defined that a <code>WorkerLauncher</code> type needs at least an ID and a channel for incoming requests, so that&#39;s what we are passing through.</p>
<p>It may seem unnecessary to implement the <code>LaunchWorker</code> method in the <code>Dispatcher</code> interface. In different scenarios, it could be interesting to save running worker IDs in the dispatcher to control which ones are up or down; the idea is to hide launching implementation details. In this case, the <code>Dispatcher</code> interface is merely acting as a <code>Facade</code> design pattern hiding some implementation details from the user.</p>
<p>The second method is <code>Stop</code>. It closes the incoming requests channel, provoking a chain reaction. We saw in the pipeline example that, when closing the incoming channel, each for-range loop within the Goroutines breaks and the Goroutine is also finished. In this case, when closing a shared channel, it will provoke the same reaction, but in every listening Goroutine, so all pipelines will be stopped. Cool, huh?</p>
<p>Request implementation is very simple; we just pass the request in the argument to the channel of incoming requests. The Goroutine will block there forever until the opposite end of the channel retrieves the request. Forever? That seems like a lot if something happens. We can introduce a timeout, as follows:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="p">(</span><span class="nx">d</span> <span class="o">*</span><span class="nx">dispatcher</span><span class="p">)</span> <span class="nx">MakeRequest</span><span class="p">(</span><span class="nx">r</span> <span class="nx">Request</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">select</span> <span class="p">{</span>
  <span class="k">case</span> <span class="nx">d</span><span class="p">.</span><span class="nx">inCh</span> <span class="o">&lt;-</span> <span class="nx">r</span><span class="p">:</span>
  <span class="k">case</span> <span class="o">&lt;-</span><span class="nx">time</span><span class="p">.</span><span class="nx">After</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span> <span class="o">*</span> <span class="mi">5</span><span class="p">):</span>
    <span class="k">return</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>If you remember from previous chapters, we can use select to control which operation is performed over a channel. Like a <code>switch</code> case, just one operation can be executed. In this case, we have two different operations: sending and receiving.</p>
<p>The first case is a sending operation--try to send this, and it will block there until someone takes the value in the opposite side of the channel. Not a huge improvement, then. The second case is a receiving operation; it will be triggered after 5 seconds if the upper request can&#39;t be sent successfully, and the function will return. It would be very convenient to return an error here, but to make things simple, we will leave it empty</p>
<p>Finally, in the dispatcher, for convenience, we will define a <code>Dispatcher</code> creator:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">NewDispatcher</span><span class="p">(</span><span class="nx">b</span> <span class="kt">int</span><span class="p">)</span> <span class="nx">Dispatcher</span> <span class="p">{</span>
  <span class="k">return</span> <span class="o">&amp;</span><span class="nx">dispatcher</span><span class="p">{</span>
    <span class="nx">inCh</span><span class="p">:</span><span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="nx">Request</span><span class="p">,</span> <span class="nx">b</span><span class="p">),</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>By using this function instead of creating the dispatcher manually, we can simply avoid small mistakes, such as forgetting to initialize the channel field. As you can see, the b argument refers to the buffer size in the channel.</p>
</div>
<h5 id="the-pipeline" >The pipeline</h5>
<div class="hBody-5" >
<p>So, our dispatcher is done and we need to develop the pipeline described in the acceptance criteria. First, we need a type to implement the <code>WorkerLauncher</code> type:</p>
<pre class="code" ><code class="chroma" ><span class="c1">// worker.go file
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">PreffixSuffixWorker</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">id</span> <span class="kt">int</span>
  <span class="nx">prefixS</span> <span class="kt">string</span>
  <span class="nx">suffixS</span> <span class="kt">string</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">w</span> <span class="o">*</span><span class="nx">PreffixSuffixWorker</span><span class="p">)</span> <span class="nx">LaunchWorker</span><span class="p">(</span><span class="nx">i</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">in</span> <span class="kd">chan</span> <span class="nx">Request</span><span class="p">)</span> <span class="p">{}</span>
</code></pre>
<p>The <code>PreffixSuffixWorker</code> variable stores an ID, a string to prefix, and another string to suffix the incoming data of the <code>Request</code> type. So, the values to prefix and append will be static in these fields, and we will take them from there.</p>
<p>We will implement the <code>LaunchWorker</code> method later and begin with each step in the pipeline. According to <i>first acceptance criteria</i>, the incoming string must be uppercase. So, the uppercase method will be the first step in our pipeline:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="p">(</span><span class="nx">w</span> <span class="o">*</span><span class="nx">PreffixSuffixWorker</span><span class="p">)</span> <span class="nx">uppercase</span><span class="p">(</span><span class="nx">in</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="nx">Request</span><span class="p">)</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="nx">Request</span> <span class="p">{</span>
  <span class="nx">out</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="nx">Request</span><span class="p">)</span>

  <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">for</span> <span class="nx">msg</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">in</span> <span class="p">{</span>
      <span class="nx">s</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">msg</span><span class="p">.</span><span class="nx">Data</span><span class="p">.(</span><span class="kt">string</span><span class="p">)</span>

      <span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
        <span class="nx">msg</span><span class="p">.</span><span class="nx">handler</span><span class="p">(</span><span class="kc">nil</span><span class="p">)</span>
        <span class="k">continue</span>
      <span class="p">}</span>

      <span class="nx">msg</span><span class="p">.</span><span class="nx">Data</span> <span class="p">=</span> <span class="nx">strings</span><span class="p">.</span><span class="nx">ToUpper</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>

      <span class="nx">out</span> <span class="o">&lt;-</span> <span class="nx">msg</span>
    <span class="p">}</span>

    <span class="nb">close</span><span class="p">(</span><span class="nx">out</span><span class="p">)</span>
  <span class="p">}()</span>

  <span class="k">return</span> <span class="nx">out</span>
<span class="p">}</span>
</code></pre>
<p>Good. As in the previous chapter, a step in the pipeline accepts a channel of incoming data and returns a channel of the same type. It has a very similar approach to the examples we developed in the previous chapter. This time, though, we aren&#39;t using package functions, and uppercase is part of the <code>PreffixSuffixWorker</code> type and the incoming data is a <code>struct</code> instead of an <code>int</code>.</p>
<p>The <code>msg</code> variable is a <code>Request</code> type and it will have a handler function and data in the form of an interface. The <code>Data</code> field should be a string, so we type cast it before using it. When type casting a value, we will receive the same value with the requested type and a <code>true</code> or <code>false</code> flag (represented by the ok variable). If the ok variable is false, the cast could not be done and we won&#39;t throw the value down the pipeline. We stop this <code>Request</code> here by sending a <code>nil</code> to the handler (which will also provoke a type-casting error).</p>
<p>Once we have a nice string in the <code>s</code> variable, we can uppercase it and store it again in the <code>Data</code> field to send down the pipeline to the next step. Be aware that the value will be sent as an interface again, so the next step will need to cast it again. This is the downside of using this approach.</p>
<p>With the first step done, let&#39;s continue with the second. According to the <i>second acceptance criteria</i> now, a predefined text must be appended. This text is the one stored in the <code>suffixS</code> field:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="p">(</span><span class="nx">w</span> <span class="o">*</span><span class="nx">PreffixSuffixWorker</span><span class="p">)</span> <span class="nb">append</span><span class="p">(</span><span class="nx">in</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="nx">Request</span><span class="p">)</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="nx">Request</span> <span class="p">{</span>
  <span class="nx">out</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="nx">Request</span><span class="p">)</span>
  <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">for</span> <span class="nx">msg</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">in</span> <span class="p">{</span>
      <span class="nx">uppercaseString</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">msg</span><span class="p">.</span><span class="nx">Data</span><span class="p">.(</span><span class="kt">string</span><span class="p">)</span>

      <span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
        <span class="nx">msg</span><span class="p">.</span><span class="nx">handler</span><span class="p">(</span><span class="kc">nil</span><span class="p">)</span>
        <span class="k">continue</span>
      <span class="p">}</span>
      <span class="nx">msg</span><span class="p">.</span><span class="nx">Data</span> <span class="p">=</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintf</span><span class="p">(</span><span class="s">&#34;%s%s&#34;</span><span class="p">,</span> <span class="nx">uppercaseString</span><span class="p">,</span> <span class="nx">w</span><span class="p">.</span><span class="nx">suffixS</span><span class="p">)</span>
      <span class="nx">out</span> <span class="o">&lt;-</span> <span class="nx">msg</span>
    <span class="p">}</span>
    <span class="nb">close</span><span class="p">(</span><span class="nx">out</span><span class="p">)</span>
  <span class="p">}()</span>
  <span class="k">return</span> <span class="nx">out</span>
<span class="p">}</span>
</code></pre>
<p>The <code>append</code> function has the same structure as the <code>uppercase</code> function. It receives and returns a channel of incoming requests, and launches a new Goroutine that iterates over the incoming channel until it is closed. We need to type cast the incoming value, as mentioned previously.</p>
<p>In this step in the pipeline the incoming string is uppercase (after doing a type assertion). To append any text to it, we just need to use the <code>fmt.Sprintf()</code> function, as we have done many times before, which formats a new string with the provided data. In this case, we pass the value of the <code>suffixS</code> field as the second value, to append it to the end of the string.</p>
<p>Just the last step in the pipeline is missing, the prefix operation:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="p">(</span><span class="nx">w</span> <span class="o">*</span><span class="nx">PreffixSuffixWorker</span><span class="p">)</span> <span class="nx">prefix</span><span class="p">(</span><span class="nx">in</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="nx">Request</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">for</span> <span class="nx">msg</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">in</span> <span class="p">{</span>
      <span class="nx">uppercasedStringWithSuffix</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">msg</span><span class="p">.</span><span class="nx">Data</span><span class="p">.(</span><span class="kt">string</span><span class="p">)</span>

      <span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
        <span class="nx">msg</span><span class="p">.</span><span class="nx">handler</span><span class="p">(</span><span class="kc">nil</span><span class="p">)</span>
        <span class="k">continue</span>
      <span class="p">}</span>

      <span class="nx">msg</span><span class="p">.</span><span class="nx">handler</span><span class="p">(</span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintf</span><span class="p">(</span><span class="s">&#34;%s%s&#34;</span><span class="p">,</span> <span class="nx">w</span><span class="p">.</span><span class="nx">prefixS</span><span class="p">,</span> <span class="nx">uppercasedStringWithSuffix</span><span class="p">))</span>
    <span class="p">}</span>
  <span class="p">}()</span>
<span class="p">}</span>
</code></pre>
<p>What&#39;s calling your attention in this function? Yes, it doesn&#39;t return any channel now. We could have done this entire pipeline in two ways. I suppose you have realized that we have used a <code>Future</code> handler function to execute with the final result in the pipeline. A second approach would be to pass a channel to return the data back to its origin. In some cases, a <code>Future</code> would be enough, while in others it could be more convenient to pass a channel so that it can be connected to a different pipeline (for example).</p>
<p>In any case, the structure of a step in a pipeline must be very familiar to you already. We cast the value, check the result of the casting, and send nil to the handler if anything went wrong. But, in case everything was OK, the last thing to do is to format the text again to place the <code>prefixS</code> field at the beginning of the text, to send the resulting string back to the origin by calling the request&#39;s handler.</p>
<p>Now, with our worker almost finished, we can implement the <code>LaunchWorker</code> method:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="p">(</span><span class="nx">w</span> <span class="o">*</span><span class="nx">PreffixSuffixWorker</span><span class="p">)</span> <span class="nx">LaunchWorker</span><span class="p">(</span><span class="nx">in</span> <span class="kd">chan</span> <span class="nx">Request</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">w</span><span class="p">.</span><span class="nx">prefix</span><span class="p">(</span><span class="nx">w</span><span class="p">.</span><span class="nb">append</span><span class="p">(</span><span class="nx">w</span><span class="p">.</span><span class="nx">uppercase</span><span class="p">(</span><span class="nx">in</span><span class="p">)))</span>
<span class="p">}</span>
</code></pre>
<p>That&#39;s all for workers! We simply pass the returning channels to the next steps in the Pipeline, as we did in the previous chapter. Remember that the pipeline is executed from inside to outside of the calls. So, what&#39;s the order of execution of any incoming data to the pipeline?</p>
<ol class="num" >
<li>
<p>The data enters the pipeline through the Goroutine launched in the uppercase method.</p>
</li>
<li>
<p>Then, it goes to the Goroutine launched in append.</p>
</li>
<li>
<p>Finally, in enters the Goroutine launched in prefix method, which doesn&#39;t return anything but executes the handler after prefixing the incoming string with more data.</p>
</li>
</ol>
<p>Now we have a full pipeline and a dispatcher of pipelines. The dispatcher will launch as many instances of the pipelines as we want to route the incoming requests to any available worker.</p>
<p>If none of the workers takes the request within 5 seconds, the request is lost.</p>
<p>Let&#39;s use this library in a small app.</p>
</div>
<h4 id="an-app-using-the-workers-pool" >An app using the workers pool</h4>
<div class="hBody-4" >
<p>We will launch three workers of our defined pipeline. We use the <code>NewDispatcher</code> function to create the dispatcher and the channel that will receive all requests. This channel has a fixed buffer, which will be able to store up to 100 incoming messages before blocking:</p>
<pre class="code" ><code class="chroma" ><span class="c1">// workers_pipeline.go
</span><span class="c1"></span><span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">bufferSize</span> <span class="o">:=</span> <span class="mi">100</span>
  <span class="kd">var</span> <span class="nx">dispatcher</span> <span class="nx">Dispatcher</span> <span class="p">=</span> <span class="nx">NewDispatcher</span><span class="p">(</span><span class="nx">bufferSize</span><span class="p">)</span>
</code></pre>
<p>Then, we will launch the workers by calling the <code>LaunchWorker</code> method in the <code>Dispatcher</code> interface three times with an already filled <code>WorkerLauncher</code> type:</p>
<pre class="code" ><code class="chroma" ><span class="nx">workers</span> <span class="o">:=</span> <span class="mi">3</span>
<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">workers</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">w</span> <span class="nx">WorkerLauncher</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">PreffixSuffixWorker</span><span class="p">{</span>
    <span class="nx">prefixS</span><span class="p">:</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintf</span><span class="p">(</span><span class="s">&#34;WorkerID: %d -&gt; &#34;</span><span class="p">,</span> <span class="nx">i</span><span class="p">),</span>
    <span class="nx">suffixS</span><span class="p">:</span> <span class="s">&#34; World&#34;</span><span class="p">,</span>
    <span class="nx">id</span><span class="p">:</span><span class="nx">i</span><span class="p">,</span>
  <span class="p">}</span>
  <span class="nx">dispatcher</span><span class="p">.</span><span class="nx">LaunchWorker</span><span class="p">(</span><span class="nx">w</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
<p>Each <code>WorkerLauncher</code> type is an instance of <code>PreffixSuffixWorker</code>. The prefix will be a small text showing the worker ID and the suffix text <code>world</code>.</p>
<p>At this point, we have three workers with three Goroutines, each running concurrently and waiting for messages to arrive:</p>
<pre class="code" ><code class="chroma" ><span class="nx">requests</span> <span class="o">:=</span> <span class="mi">10</span>

<span class="kd">var</span> <span class="nx">wg</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span>
<span class="nx">wg</span><span class="p">.</span><span class="nx">Add</span><span class="p">(</span><span class="nx">requests</span><span class="p">)</span>
</code></pre>
<p>We will make 10 requests. We also need a WaitGroup to properly synchronize the app so that it doesn&#39;t exit too early. You can find yourself using WaitGroups quite a lot when dealing with concurrent applications. For 10 requests, we&#39;ll need to wait for 10 calls to the <code>Done()</code> method, so we call the <code>Add()</code> method with a <i>delta</i> of 10. It&#39;s called delta because you can also pass a -5 later to leave it in five requests. In some situations, it can be useful:</p>
<pre class="code" ><code class="chroma" >    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">requests</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="nx">req</span> <span class="o">:=</span> <span class="nx">NewStringRequest</span><span class="p">(</span><span class="s">&#34;(Msg_id: %d) -&gt; Hello&#34;</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">wg</span><span class="p">)</span>
        <span class="nx">dispatcher</span><span class="p">.</span><span class="nx">MakeRequest</span><span class="p">(</span><span class="nx">req</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="nx">dispatcher</span><span class="p">.</span><span class="nx">Stop</span><span class="p">()</span>

    <span class="nx">wg</span><span class="p">.</span><span class="nx">Wait</span><span class="p">()</span>
<span class="p">}</span>
</code></pre>
<p>To make requests, we will iterate a <code>for</code> loop. First, we create a Request using the function <code>NewStringRequest</code> that we wrote at the beginning of the Implementation section. In this value, the <code>Data</code> field will be the text we&#39;ll pass down the pipeline, and it will be the text that is &#34;in the middle&#34; of the appending and suffixing operation. In this case, we will send the message number and the word <code>hello</code>.</p>
<p>Once we have a request, we call the <code>MakeRequest</code> method with it. After all requests have been done, we stop the dispatcher that, as explained previously, will provoke a chain reaction that will stop all Goroutines in the pipeline.</p>
<p>Finally, we wait for the group so that all calls to the <code>Done()</code> method are received, which signals that all operations have been finished. It&#39;s time to try it out:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go run *
</span><span class="out" >WorkerID: 1 -&gt; (MSG_ID: 0) -&gt; HELLO World
WorkerID: 0 -&gt; (MSG_ID: 3) -&gt; HELLO World
WorkerID: 0 -&gt; (MSG_ID: 4) -&gt; HELLO World
WorkerID: 0 -&gt; (MSG_ID: 5) -&gt; HELLO World
WorkerID: 2 -&gt; (MSG_ID: 2) -&gt; HELLO World
WorkerID: 1 -&gt; (MSG_ID: 1) -&gt; HELLO World
WorkerID: 0 -&gt; (MSG_ID: 6) -&gt; HELLO World
WorkerID: 2 -&gt; (MSG_ID: 9) -&gt; HELLO World
WorkerID: 0 -&gt; (MSG_ID: 7) -&gt; HELLO World
WorkerID: 0 -&gt; (MSG_ID: 8) -&gt; HELLO World
</span></code></pre>
<p>Let&#39;s analyze the first message:</p>
<ol class="num" >
<li>
<p>This would be zero, so the message sent is <code>(Msg_id: 0) -&gt; Hello</code>.</p>
</li>
<li>
<p>Then, the text is uppercased, so now we have <code>(MSG_ID: 0) -&gt; HELLO</code>.</p>
</li>
<li>
<p>After uppercasing an append operation with the text <code>world</code> (note the space at the beginning of the text) is done. This will give us the text <code>(MSG_ID: 0) -&gt; HELLO World</code>.</p>
</li>
<li>
<p>Finally, the text <code>WorkerID: 1</code> (in this case, the first worker took the task, but it could be any of them) is appended to the text from step 3 to give us the full returned message, <code>WorkerID: 1 -&gt; (MSG_ID: 0</code> -&gt; HELLO World).</p>
</li>
</ol>
</div>
<h4 id="no-tests?" >No tests?</h4>
<div class="hBody-4" >
<p>Concurrent applications are difficult to test, especially if you are doing networking operations. It can be difficult, and code can change a lot just to test it. In any case, it is not justifiable to not perform tests. In this case, it is not especially difficult to test our small app. Create a test and copy/paste the contents of the <code>main</code> function there:</p>
<pre class="code" ><code class="chroma" ><span class="c1">// workers_pipeline.go file
</span><span class="c1"></span><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&#34;testing&#34;</span>

<span class="kd">func</span> <span class="nx">Test_Dispatcher</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">){</span>
  <span class="c1">// pasted code from main function
</span><span class="c1"></span>  <span class="nx">bufferSize</span> <span class="o">:=</span> <span class="mi">100</span>

  <span class="kd">var</span> <span class="nx">dispatcher</span> <span class="nx">Dispatcher</span> <span class="p">=</span> <span class="nx">NewDispatcher</span><span class="p">(</span><span class="nx">bufferSize</span><span class="p">)</span>

  <span class="nx">workers</span> <span class="o">:=</span> <span class="mi">3</span>

  <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">workers</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">w</span> <span class="nx">WorkerLauncher</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">PreffixSuffixWorker</span><span class="p">{</span>
      <span class="nx">prefixS</span><span class="p">:</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintf</span><span class="p">(</span><span class="s">&#34;WorkerID: %d -&gt; &#34;</span><span class="p">,</span> <span class="nx">i</span><span class="p">),</span>
      <span class="nx">suffixS</span><span class="p">:</span> <span class="s">&#34; World&#34;</span><span class="p">,</span>
      <span class="nx">id</span><span class="p">:</span> <span class="nx">i</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="nx">dispatcher</span><span class="p">.</span><span class="nx">LaunchWorker</span><span class="p">(</span><span class="nx">w</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="c1">// Simulate Requests
</span><span class="c1"></span>
  <span class="nx">requests</span> <span class="o">:=</span> <span class="mi">10</span>

  <span class="kd">var</span> <span class="nx">wg</span>
  <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span>

  <span class="nx">wg</span><span class="p">.</span><span class="nx">Add</span><span class="p">(</span><span class="nx">requests</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
<p>Now we have to rewrite our handler to test that the returned contents are the ones we are expecting. Go to the <code>for</code> loop to modify the function that we are passing as a handler on each <code>Request</code>:</p>
<pre class="code" ><code class="chroma" ><span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">requests</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
  <span class="nx">req</span> <span class="o">:=</span> <span class="nx">Request</span><span class="p">{</span>
    <span class="nx">Data</span><span class="p">:</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintf</span><span class="p">(</span><span class="s">&#34;(Msg_id: %d) -&gt; Hello&#34;</span><span class="p">,</span> <span class="nx">i</span><span class="p">),</span>
    <span class="nx">handler</span><span class="p">:</span> <span class="kd">func</span><span class="p">(</span><span class="nx">i</span> <span class="kd">interface</span><span class="p">{}){</span>
      <span class="nx">s</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">i</span><span class="p">.(</span><span class="kt">string</span><span class="p">)</span>
      <span class="k">defer</span> <span class="nx">wg</span><span class="p">.</span><span class="nx">Done</span><span class="p">()</span>
      <span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
        <span class="nx">t</span><span class="p">.</span><span class="nx">Fail</span><span class="p">()</span>
      <span class="p">}</span>

      <span class="nx">ok</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">regexp</span><span class="p">.</span><span class="nx">Match</span><span class="p">(</span><span class="s">`WorkerID\: \d* -\&gt; \(MSG_ID: \d*\) -&gt; [A-Z]*\sWorld`</span><span class="p">,</span> <span class="p">[]</span><span class="nb">byte</span><span class="p">(</span><span class="nx">s</span><span class="p">))</span>

      <span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="o">||</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nx">t</span><span class="p">.</span><span class="nx">Fail</span><span class="p">()</span>
      <span class="p">}</span>
    <span class="p">},</span>
  <span class="p">}</span>
  <span class="nx">dispatcher</span><span class="p">.</span><span class="nx">MakeRequest</span><span class="p">(</span><span class="nx">req</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
<p>We are going to use regular expressions to test the business. If you are not familiar with regular expressions, they are a quite powerful feature that help you to match content within a string. If you remember in our exercises when we were using the <code>strings</code> package. <code>Contains</code> is the function to find a text inside a string. We can also do it with regular expressions.</p>
<p>The problem is that regular expressions are quite expensive and consume a lot of resources.</p>
<p>We are using the <code>Match</code> function of the <code>regexp</code> package to provide a template to match. Our template is <code>WorkerID\: \d* -&gt; \(MSG_ID: \d\) -&gt; [A-Z]*\sWorld</code> (without quotes). Specifically, it describes the following:</p>
<ul>
<li>
<p>A string that has the content <q><code>WorkerID: \d* -&gt; (MSG_ID: \d*</code></q>, here <q><code>\d*</code></q> indicates any digit written zero or more times, so it will match <q><code>WorkerID: 10 -&gt; (MSG_ID: 1</code></q> and <code><q>WorkerID: 1 -&gt; (MSG_ID: 10</q></code>.</p>
</li>
<li>
<p><q><code>\) -&gt; [A-Z]*\sWorld</code></q> (parentheses must be escaped using backslashes). <q><code>*</code></q> means any uppercase character written zero or more times, so <q><code>\s</code></q> is a white space and it must finish with the text <code>World</code>, so <q><code>) -&gt; HELLO World</code></q> will match, but <q><code>) -&gt; Hello World</code></q> won&#39;t, because <q><code>Hello</code></q> must be all uppercase.</p>
</li>
</ul>
<p>Running this test gives us the following output:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go <span class="nb">test</span> -v .
</span><span class="out" >=== RUN   Test_Dispatcher
--- PASS: Test_Dispatcher (0.00s)
PASS
ok
</span></code></pre>
<p>Not bad, but we aren&#39;t testing that code is being executed concurrently, so this is more a business test than a unit test. Concurrency testing would force us to write the code in a completely different manner to check that it is creating the proper amount of Goroutines and the pipeline is following the expected workflow. This is not bad, but it&#39;s quite complex, and outside of the context of this book.</p>
</div>
<h4 id="wrapping-up-the-worker-pool" >Wrapping up the Worker pool</h4>
<div class="hBody-4" >
<p>With the workers pool, we have our first complex concurrent application that can be used in real-world production systems. It also has room to improve, but it is a very good design pattern to build concurrent bounded apps.</p>
<p>It is key that we always have the number of Goroutines that are being launched under control. While it&#39;s easy to launch thousands to achieve more parallelism in an app, we must be very careful that they don&#39;t have code that can hang them in an infinite loop, too.</p>
<p>With the workers pool, we can now fragment a simple operation in many parallel tasks. Think about it; this could achieve the same result with one simple call to <code>fmt.Printf</code>, but we have done a pipeline with it; then, we launched few instances of this pipeline and finally, distributed the workload between all those pipes.</p>
</div>
<h3 id="concurrent-publish/subscriber-design-pattern" >Concurrent Publish/Subscriber design pattern</h3>
<div class="hBody-3" >
<p>In this section, we will implement the Observer design pattern that we showed previously on Behavioral patterns, but with a concurrent structure and thread safety.</p>
</div>
<h4 id="description" >Description</h4>
<div class="hBody-4" >
<p>If you remember from the previous explanation, the Observer pattern maintains a list of observers or subscribers that want to be notified of a particular event. In this case, each subscriber is going to run in a different Goroutine as well as the publisher. We will have new problems with building this structure:</p>
<ul>
<li>
<p>Now, the access to the list of subscribers must be serialized. If we are reading the list with one Goroutine, we cannot be removing a subscriber from it or we will have a race.</p>
</li>
<li>
<p>When a subscriber is removed, the subscriber&#39;s Goroutine must be closed too, or it will keep iterating forever and we will run into Goroutine leaks.</p>
</li>
<li>
<p>When stopping the publisher, all subscribers must stop their Goroutines, too.</p>
</li>
</ul>
</div>
<h4 id="objectives" >Objectives</h4>
<div class="hBody-4" >
<p>The objectives of this publish/subscriber are the same as the ones we wrote on the Observer pattern. The difference here is the way we will develop it. The idea is to make a concurrent structure to achieve the same functionality, which is as follows:</p>
<ul>
<li>
<p>Providing an event-driven architecture where one event can trigger one or more actions</p>
</li>
<li>
<p>Uncoupling the actions that are performed from the event that triggers them</p>
</li>
<li>
<p>Providing more than one source event that triggers the same action</p>
</li>
</ul>
<p>The idea is to uncouple senders from receivers, hiding from the sender the identity of the receivers that will process its event, and hiding the receivers from the number of senders that can communicate with them.</p>
<p>In particular, if I develop a click in a button in some application, it could do something (such as log us in somewhere). Weeks later, we might decide to make it show a popup, too. If, every time we want to add some functionality to this button, we have to change the code where it handles the click action, that function will become huge and not very portable to other projects. If we use a publisher and one observer for every action, the click function only needs to publish one single event using a publisher, and we will just write subscribers to this event every time we want to improve the functionality. This is especially important in applications with user interfaces where many things to do in a single UI action can slow the responsiveness of an interface, completely destroying the user experience.</p>
<p>By using a concurrent structure to develop the Observer pattern, a UI cannot feel all the tasks that are being executed in the background if a concurrent structure is defined and the device allows us to execute parallel tasks.</p>
</div>
<h4 id="example---a-concurrent-notifier" >Example - a concurrent notifier</h4>
<div class="hBody-4" >
<p>We will develop a <i>notifier</i> similar to the one we developed in <a href="#chapter-7" >Chapter 7</a>, <i>Behavioral Patterns - Visitor, State, Mediator, and Observer Design Patterns</i>. This is to focus on the concurrent nature of the structure instead of detailing too many things that have already been explained.  We have developed an observer already, so we are familiar with the concept.</p>
<p>This particular notifier will work by passing around <code>interface{}</code> values, like in the workers pool example. This way, we can use it for more than a single type by introducing some overhead when casting on the receiver.</p>
<p>We will work with two interfaces now. First, a <code>Subscriber</code> interface:</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">Subscriber</span> <span class="kd">interface</span> <span class="p">{</span>
  <span class="nx">Notify</span><span class="p">(</span><span class="kd">interface</span><span class="p">{})</span> <span class="kt">error</span>
  <span class="nx">Close</span><span class="p">()</span>
<span class="p">}</span>
</code></pre>
<p>Like in the previous example, it must have a <code>Notify</code> method in the <code>Subscriber</code> interface of new events. This is the <code>Notify</code> method that accepts an <code>interface{}</code> value and returns an error. The <code>Close()</code> method, however, is new, and it must trigger whatever actions are needed to stop the Goroutine where the subscriber is listening for new events.</p>
<p>The second and final interface is the <code>Publisher</code> interface:</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">Publisher</span> <span class="kd">interface</span> <span class="p">{</span>
  <span class="nx">start</span><span class="p">()</span>
  <span class="nx">AddSubscriberCh</span><span class="p">()</span> <span class="kd">chan</span><span class="o">&lt;-</span> <span class="nx">Subscriber</span>
  <span class="nx">RemoveSubscriberCh</span><span class="p">()</span> <span class="kd">chan</span><span class="o">&lt;-</span> <span class="nx">Subscriber</span>
  <span class="nx">PublishingCh</span><span class="p">()</span> <span class="kd">chan</span><span class="o">&lt;-</span> <span class="kd">interface</span><span class="p">{}</span>
  <span class="nx">Stop</span><span class="p">()</span>
<span class="p">}</span>
</code></pre>
<p>The <code>Publisher</code> interface has the same actions we already know for a publisher but to work with channels. The <code>AddSubscriberCh</code> and <code>RemoveSubscriberCh</code> methods accepts a <code>Subscriber</code> interface (any type that satisfies the <code>Subscriber</code> interface). It must have a method to publish messages and a <code>Stop</code> method to stop them all (publisher and subscriber Goroutines)</p>
</div>
<h4 id="acceptance-criteria" >Acceptance criteria</h4>
<div class="hBody-4" >
<p>Requirements between this example and the one in the <a href="#chapter-7" >Chapter 7</a>, <i>Behavioral patterns - Visitor, State, Mediator, and Observer Design Patterns</i> must not change. The objective in both examples is the same so the requirements must also be the same. In this case, our requirements are technical, so we actually need to add some more acceptance criteria:</p>
<ol class="num" >
<li>
<p>We must have a publisher with a <code>PublishingCh</code> method that returns a channel to send messages through and triggers a <code>Notify</code> method on every observer subscribed.</p>
</li>
<li>
<p>We must have a method to add new subscribers to the publisher.</p>
</li>
<li>
<p>We must have a method to remove new subscribers from the publisher.</p>
</li>
<li>
<p>We must have a method to stop a subscriber.</p>
</li>
<li>
<p>We must have a method to stop a <code>Publisher</code> interface that will also stop all subscribers.</p>
</li>
<li>
<p>All inter Goroutine communication must be synchronized so that no Goroutine is locked waiting for a response. In such cases, an error is returned after the specified timeout period has passed.</p>
</li>
</ol>
<p>Well, these criteria seem quite daunting. We have left out some requirements that would add even more complexity, such as removing non-responding subscribers or checks to monitor that the publisher Goroutine is always on.</p>
</div>
<h4 id="unit-test" >Unit test</h4>
<div class="hBody-4" >
<p>We have mentioned previously that testing concurrent applications can be difficult. With the correct mechanism, it still can be done, so let&#39;s see how much we can test without big headaches.</p>
</div>
<h5 id="testing-subscriber" >Testing subscriber</h5>
<div class="hBody-5" >
<p>Starting with subscribers, which seem to have a more encapsulated functionality, the first subscriber must print incoming messages from the publisher to an <code>io.Writer</code> interface. We have mentioned that the subscriber has an interface with two methods, <code>Notify(interface{})</code> <code>error</code> and the <code>Close()</code> method:</p>
<pre class="code" ><code class="chroma" ><span class="c1">// writer_sub.go file
</span><span class="c1"></span><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&#34;errors&#34;</span>

<span class="kd">type</span> <span class="nx">writerSubscriber</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">id</span> <span class="kt">int</span>
  <span class="nx">Writer</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Writer</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">writerSubscriber</span><span class="p">)</span> <span class="nx">Notify</span><span class="p">(</span><span class="nx">msg</span> <span class="kd">interface</span><span class="p">{})</span> <span class="kt">error</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">erorrs</span><span class="p">.</span><span class="nx">NeW</span><span class="p">(</span><span class="s">&#34;Not implemented yet&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">writerSubscriber</span><span class="p">)</span> <span class="nx">Close</span><span class="p">()</span> <span class="p">{}</span>
</code></pre>
<p>OK. This is going to be our <span class="file" >writer_sub.go</span> file. Create the corresponding test file, called the <span class="file" >writer_sub_test.go</span> file:</p>
<pre class="code" ><code class="chroma" ><span class="kn">package</span> <span class="nx">main</span>
<span class="kd">func</span> <span class="nx">TestStdoutPrinter</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
</code></pre>
<p>Now, the first problem we have is that the functionality prints to the <code>stdout</code>, so there&#39;s no return value to check. We can solve it in three ways:</p>
<ul>
<li>
<p>Capturing the <code>stdout</code> method.</p>
</li>
<li>
<p>Injecting an <code>io.Writer</code> interface to print to it. This is the preferred solution, as it makes the code more manageable.</p>
</li>
<li>
<p>Redirecting the <code>stdout</code> method to a different file.</p>
</li>
</ul>
<p>We&#39;ll take the second approach. Redirection is also a possibility. The <code>os.Stdout</code> is a pointer to an <code>os.File</code> type, so it involves replacing this file with one we control, and reading from it:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">TestWriter</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">sub</span> <span class="o">:=</span> <span class="nx">NewWriterSubscriber</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
</code></pre>
<p>The <code>NewWriterSubscriber</code> subscriber isn&#39;t defined yet. It must help in the creation of this particular subscriber, returning a type that satisfies the <code>Subscriber</code> interface, so let&#39;s quickly declare it on the <span class="file" >writer_sub.go</span> file:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">NewWriterSubscriber</span><span class="p">(</span><span class="nx">id</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">out</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Writer</span><span class="p">)</span> <span class="nx">Subscriber</span> <span class="p">{</span>
  <span class="k">return</span> <span class="o">&amp;</span><span class="nx">writerSubscriber</span><span class="p">{}</span>
<span class="p">}</span>
</code></pre>
<p>Ideally, it must accept an ID and an <code>io.Writer</code> interface as the destination for its writes. In this case, we need a custom <code>io.Writer</code> interface for our test, so we&#39;ll create a <code>mockWriter</code> on the <span class="file" >writer_sub_test.go</span> file for it:</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">mockWriter</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">testingFunc</span> <span class="kd">func</span><span class="p">(</span><span class="kt">string</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">mockWriter</span><span class="p">)</span> <span class="nx">Write</span><span class="p">(</span><span class="nx">p</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">m</span><span class="p">.</span><span class="nx">testingFunc</span><span class="p">(</span><span class="nb">string</span><span class="p">(</span><span class="nx">p</span><span class="p">))</span>
  <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="nx">p</span><span class="p">),</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre>
<p>The <code>mockWriter</code> structure will accept a <code>testingFunc</code> as one of its fields. This <code>testingFunc</code> field accepts a string that represents the bytes written to the <code>mockWriter</code> structure. To implement an <code>io.Writer</code> interface, we need to define a <code>Write([]byte) (int, error)</code> method. In our definition, we pass the contents of p as a string (remember that we always need to return the bytes read and an error, or not, on every <code>Write</code> method). This approach delegates the definition of <code>testingFunc</code> to the scope of the test.</p>
<p>We are going to call the <code>Notify</code> method on the <code>Subcriber</code> interface, which must write on the <code>io.Writer</code> interface like the <code>mockWriter</code> structure. So, we&#39;ll define the <code>testingFunc</code> of a <code>mockWriter</code> structure before calling the <code>Notify</code> method:</p>
<pre class="code" ><code class="chroma" ><span class="c1">// writer_sub_test.go file
</span><span class="c1"></span><span class="kd">func</span> <span class="nx">TestPublisher</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">msg</span> <span class="o">:=</span> <span class="s">&#34;Hello&#34;</span>

  <span class="kd">var</span> <span class="nx">wg</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span>
  <span class="nx">wg</span><span class="p">.</span><span class="nx">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

  <span class="nx">stdoutPrinter</span> <span class="o">:=</span> <span class="nx">sub</span><span class="p">.(</span><span class="o">*</span><span class="nx">writerSubscriber</span><span class="p">)</span>
  <span class="nx">stdoutPrinter</span><span class="p">.</span><span class="nx">Writer</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">mockWriter</span><span class="p">{</span>
    <span class="nx">testingFunc</span><span class="p">:</span> <span class="kd">func</span><span class="p">(</span><span class="nx">res</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">!</span><span class="nx">strings</span><span class="p">.</span><span class="nx">Contains</span><span class="p">(</span><span class="nx">res</span><span class="p">,</span> <span class="nx">msg</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">t</span><span class="p">.</span><span class="nx">Fatal</span><span class="p">(</span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&#34;Incorrect string: %s&#34;</span><span class="p">,</span> <span class="nx">res</span><span class="p">))</span>
      <span class="p">}</span>
      <span class="nx">wg</span><span class="p">.</span><span class="nx">Done</span><span class="p">()</span>
    <span class="p">},</span>
  <span class="p">}</span>
</code></pre>
<p>We will send the <code>Hello</code> message. This also means that whatever the <code>Subscriber</code> interface does, it must eventually print the <code>Hello</code> message on the provided <code>io.Writer</code> interface.</p>
<p>So if, eventually, we receive a string on the testing function, we&#39;ll need to synchronize with the <code>Subscriber</code> interface to avoid race conditions on tests. That&#39;s why we use so much <code>WaitGroup</code>. It&#39;s a very handy and easy-to-use type to handle this scenario. One <code>Notify</code> method call will need to wait for one call to the <code>Done()</code> method, so we call the <code>Add(1)</code> method (with one unit).</p>
<p>Ideally, the <code>NewWriterSubscriber</code> function must return an interface, so we need to type assert it to the type we are working with during the test, in this case, the <code>stdoutPrinter</code> method. I have omitted error checking when doing the casting on purpose, just to make things easier. Once we have a <code>writerSubscriber</code> type, we can access its <code>Write</code> field to replace it with the <code>mockWriter</code> structure. We could have directly passed an <code>io.Writer</code> interface on the <code>NewWriterSubscriber</code> function, but we wouldn&#39;t cover the scenario where a nil object is passed and it sets the <code>os.Stdout</code> instance to a default value.</p>
<p>So, the testing function will eventually receive a string containing what was written by the subscriber. We just need to check if the received string, the one that the <code>Subscriber</code> interface will receive, prints the word <code>Hello</code> at some point and nothing better that <code>strings.Contains</code> function for it. Everything is defined under the scope of the testing function, so we can use the value of the t object to also signal that the test has failed.</p>
<p>Once we have done the checking, we must call to the <code>Done()</code> method to signal that we have already tested the expected result:</p>
<pre class="code" ><code class="chroma" >  <span class="nx">err</span> <span class="o">:=</span> <span class="nx">sub</span><span class="p">.</span><span class="nx">Notify</span><span class="p">(</span><span class="nx">msg</span><span class="p">)</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">t</span><span class="p">.</span><span class="nx">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="nx">wg</span><span class="p">.</span><span class="nx">Wait</span><span class="p">()</span>
  <span class="nx">sub</span><span class="p">.</span><span class="nx">Close</span><span class="p">()</span>
<span class="p">}</span>
</code></pre>
<p>We must actually call the <code>Notify</code> and <code>Wait</code> methods for the call to the <code>Done</code> method to check that everything was correct.</p>
<div class="about" >
<div class="about-dt" >Note</div>
<div class="about-dd" >
<p>Did you realize that we have defined the behavior on tests more or less in reverse? This is very common in concurrent apps. It can be confusing sometimes, as it becomes difficult to know what a function could be doing if we can&#39;t follow calls linearly, but you get used to it quite quickly. Instead of thinking &#34;it does this, then this, then that,&#34; it&#39;s more like &#34;this will be called when executing that.&#34; This is also because the order of execution in a concurrent application is unknown until some point, unless we use synchronization primitives (such as WaitGroups and channels) to pause execution at certain moments.</p>
</div>
</div>
<p>Let&#39;s execute the test for this type now:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go <span class="nb">test</span> -cover -v -run<span class="o">=</span>TestWriter .
</span><span class="out" >=== RUN   TestWriter
--- FAIL: TestWriter (0.00s)
        writer_sub_test.go:40: Not implemented yet
FAIL
coverage: 6.7% of statements
exit status 1
FAIL
</span></code></pre>
<p>It has exited fast but it has failed. Actually, the call to the <code>Done()</code> method has not been executed, so it would be nice to change the last part of our test to this instead:</p>
<pre class="code" ><code class="chroma" >  <span class="nx">err</span> <span class="o">:=</span> <span class="nx">sub</span><span class="p">.</span><span class="nx">Notify</span><span class="p">(</span><span class="nx">msg</span><span class="p">)</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">wg</span><span class="p">.</span><span class="nx">Done</span><span class="p">()</span>
    <span class="nx">t</span><span class="p">.</span><span class="nx">Error</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="nx">wg</span><span class="p">.</span><span class="nx">Wait</span><span class="p">()</span>
  <span class="nx">sub</span><span class="p">.</span><span class="nx">Close</span><span class="p">()</span>
<span class="p">}</span>
</code></pre>
<p>Now, it doesn&#39;t stop execution because we are calling the <code>Error</code> function instead of the <code>Fatal</code> function, but we call the <code>Done()</code> method and the test ends where we prefer it to end, after the <code>Wait()</code> method is called. You can try to run the tests again, but the output will be the same.</p>
</div>
<h5 id="testing-publisher" >Testing publisher</h5>
<div class="hBody-5" >
<p>We have already seen a <code>Publisher</code> interface and the type that will satisfy which was the <code>publisher</code> type. The only thing we know for sure is that it will need some way to store subscribers, so it will at least have a <code>Subscribers</code> slice:</p>
<pre class="code" ><code class="chroma" ><span class="c1">// publisher.go type
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">publisher</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">subscribers</span> <span class="p">[]</span><span class="nx">Subscriber</span>
<span class="p">}</span>
</code></pre>
<p>To test the <code>publisher</code> type, we will also need a mock for the <code>Subscriber</code> interface:</p>
<pre class="code" ><code class="chroma" ><span class="c1">// publisher_test.go
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">mockSubscriber</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">notifyTestingFunc</span> <span class="kd">func</span><span class="p">(</span><span class="nx">msg</span> <span class="kd">interface</span><span class="p">{})</span>
  <span class="nx">closeTestingFunc</span> <span class="kd">func</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">mockSubscriber</span><span class="p">)</span> <span class="nx">Close</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">m</span><span class="p">.</span><span class="nx">closeTestingFunc</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">mockSubscriber</span><span class="p">)</span> <span class="nx">Notify</span><span class="p">(</span><span class="nx">msg</span> <span class="kd">interface</span><span class="p">{})</span> <span class="kt">error</span> <span class="p">{</span>
  <span class="nx">m</span><span class="p">.</span><span class="nx">notifyTestingFunc</span><span class="p">(</span><span class="nx">msg</span><span class="p">)</span>
  <span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre>
<p>The <code>mockSubscriber</code> type must implement the <code>Subscriber</code> interface, so it must have a <code>Close()</code> and a <code>Notify(interface{}</code>) <code>error</code> method. We can embed an existing type that implements it, such as,  the <code>writerSubscriber</code>, and override just the method that is interesting for us, but we will need to define both, so we won&#39;t embed anything.</p>
<p>So, we need to override the <code>Notify</code> and <code>Close</code> methods in this case to call the testing functions stored on the fields of the mockSubscriber type:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">TestPublisher</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">msg</span> <span class="o">:=</span> <span class="s">&#34;Hello&#34;</span>

  <span class="nx">p</span> <span class="o">:=</span> <span class="nx">NewPublisher</span><span class="p">()</span>
</code></pre>
<p>First of all, we will be sending messages through channels directly, this could lead to potential unwanted deadlocks so the first thing to define is a panic handler for cases such as, sending to close channels or no Goroutines listening on a channel. The message we will send to subscribers is <code>Hello</code>. So, each subscriber that has been received using the channel returned by the <code>AddSubscriberCh</code> method must receive this message. We will also use a <i>New</i> function to create Publishers, called <code>NewPublisher</code>. Change the <span class="file" >publisher.go</span> file now to write it:</p>
<pre class="code" ><code class="chroma" ><span class="c1">// publisher.go file
</span><span class="c1"></span><span class="kd">func</span> <span class="nx">NewPublisher</span><span class="p">()</span> <span class="nx">Publisher</span> <span class="p">{</span>
  <span class="k">return</span> <span class="o">&amp;</span><span class="nx">publisher</span><span class="p">{}</span>
<span class="p">}</span>
</code></pre>
<p>Now we&#39;ll define the <code>mockSubscriber</code> to add it to the publisher list of known subscribers. Back to the <span class="file" >publisher_test.go</span> file:</p>
<pre class="code" ><code class="chroma" ><span class="kd">var</span> <span class="nx">wg</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span>

<span class="nx">sub</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">mockSubscriber</span><span class="p">{</span>
  <span class="nx">notifyTestingFunc</span><span class="p">:</span> <span class="kd">func</span><span class="p">(</span><span class="nx">msg</span> <span class="kd">interface</span><span class="p">{})</span> <span class="p">{</span>
    <span class="k">defer</span> <span class="nx">wg</span><span class="p">.</span><span class="nx">Done</span><span class="p">()</span>

    <span class="nx">s</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">msg</span><span class="p">.(</span><span class="kt">string</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
      <span class="nx">t</span><span class="p">.</span><span class="nx">Fatal</span><span class="p">(</span><span class="nx">errors</span><span class="p">.</span><span class="nx">New</span><span class="p">(</span><span class="s">&#34;Could not assert result&#34;</span><span class="p">))</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="nx">s</span> <span class="o">!=</span> <span class="nx">msg</span> <span class="p">{</span>
      <span class="nx">t</span><span class="p">.</span><span class="nx">Fail</span><span class="p">()</span>
    <span class="p">}</span>
  <span class="p">},</span>
  <span class="nx">closeTestingFunc</span><span class="p">:</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">wg</span><span class="p">.</span><span class="nx">Done</span><span class="p">()</span>
  <span class="p">},</span>
<span class="p">}</span>
</code></pre>
<p>As usual, we start with a WaitGroup. First, testing the function in our subscriber defers a call to the <code>Done()</code> method at the end of its execution. Then it needs to type cast <code>msg</code> variable because it&#39;s coming as an interface. Remember that this way, we can use the <code>Publisher</code> interface with many types by introducing the overhead of the type assertion. This is done on line <code>s, ok := msg.(string)</code>.</p>
<p>Once we have type cast <code>msg</code> to a string, s, we just need to check if the value received in the subscriber is the same as the value we sent, or fail the test if not:</p>
<pre class="code" ><code class="chroma" ><span class="nx">p</span><span class="p">.</span><span class="nx">AddSubscriberCh</span><span class="p">()</span> <span class="o">&lt;-</span> <span class="nx">sub</span>
<span class="nx">wg</span><span class="p">.</span><span class="nx">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

<span class="nx">p</span><span class="p">.</span><span class="nx">PublishingCh</span><span class="p">()</span> <span class="o">&lt;-</span> <span class="nx">msg</span>
<span class="nx">wg</span><span class="p">.</span><span class="nx">Wait</span><span class="p">()</span>
</code></pre>
<p>We add the <code>mockSubscriber</code> type using the <code>AddSubscriberCh</code> method. We publish our message just after getting ready, by adding one to the WaitGroup, and just before setting the WaitGroup to wait so that the test doesn&#39;t continue until the <code>mockSubscriber</code> type calls the <code>Done()</code> method.</p>
<p>Also, we need to check if the number of the <code>Subscriber</code> interface has grown after calling the <code>AddSubscriberCh</code> method, so we&#39;ll need to get the concrete instance of publisher on the test:</p>
<pre class="code" ><code class="chroma" ><span class="nx">pubCon</span> <span class="o">:=</span> <span class="nx">p</span><span class="p">.(</span><span class="o">*</span><span class="nx">publisher</span><span class="p">)</span>
<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">pubCon</span><span class="p">.</span><span class="nx">subscribers</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span> <span class="p">{</span>
  <span class="nx">t</span><span class="p">.</span><span class="nx">Error</span><span class="p">(</span><span class="s">&#34;Unexpected number of subscribers&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
<p>Type assertion is our friend today! Once we have the concrete type, we can access the underlying slice of subscribers for the <code>Publisher</code> interface. The number of subscribers must be 1 after calling the <code>AddSubscriberCh</code> method once, or the test will fail. The next step is to check just the opposite--when we remove a <code>Subscriber</code> interface, it must be taken from this list:</p>
<pre class="code" ><code class="chroma" >   <span class="nx">wg</span><span class="p">.</span><span class="nx">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
   <span class="nx">p</span><span class="p">.</span><span class="nx">RemoveSubscriberCh</span><span class="p">()</span> <span class="o">&lt;-</span> <span class="nx">sub</span>
   <span class="nx">wg</span><span class="p">.</span><span class="nx">Wait</span><span class="p">()</span>

   <span class="c1">// Number of subscribers is restored to zero
</span><span class="c1"></span>   <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">pubCon</span><span class="p">.</span><span class="nx">subscribers</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
         <span class="nx">t</span><span class="p">.</span><span class="nx">Error</span><span class="p">(</span><span class="s">&#34;Expected no subscribers&#34;</span><span class="p">)</span>
   <span class="p">}</span>

   <span class="nx">p</span><span class="p">.</span><span class="nx">Stop</span><span class="p">()</span>
<span class="p">}</span>
</code></pre>
<p>The final step in our test is to stop the publisher so no more messages can be sent and all the Goroutines are stopped.</p>
<p>The test is finished, but we can&#39;t run tests until the <code>publisher</code> type has all the methods implemented; this must be the final result:</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">publisher</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">subscribers</span> <span class="p">[]</span><span class="nx">Subscriber</span>
  <span class="nx">addSubCh</span>    <span class="kd">chan</span> <span class="nx">Subscriber</span>
  <span class="nx">removeSubCh</span> <span class="kd">chan</span> <span class="nx">Subscriber</span>
  <span class="nx">in</span>          <span class="kd">chan</span> <span class="kd">interface</span><span class="p">{}</span>
  <span class="nx">stop</span>        <span class="kd">chan</span> <span class="kd">struct</span><span class="p">{}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">publisher</span><span class="p">)</span> <span class="nx">AddSubscriberCh</span><span class="p">()</span> <span class="kd">chan</span><span class="o">&lt;-</span> <span class="nx">Subscriber</span> <span class="p">{</span>
  <span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">publisher</span><span class="p">)</span> <span class="nx">RemoveSubscriberCh</span><span class="p">()</span> <span class="kd">chan</span><span class="o">&lt;-</span> <span class="nx">Subscriber</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">publisher</span><span class="p">)</span> <span class="nx">PublishingCh</span><span class="p">()</span> <span class="kd">chan</span><span class="o">&lt;-</span> <span class="kd">interface</span><span class="p">{}</span> <span class="p">{</span>
  <span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">publisher</span><span class="p">)</span> <span class="nx">Stop</span><span class="p">(){}</span>
</code></pre>
<p>With this empty implementation, nothing good can happen when running the tests:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go <span class="nb">test</span> -cover -v -run<span class="o">=</span>TestPublisher .
</span><span class="out" >atal error: all goroutines are asleep - deadlock!
goroutine 1 [chan receive]:
testing.(*T).Run(0xc0420780c0, 0x5244c6, 0xd, 0x5335a0, 0xc042037d20)
      /usr/local/go/src/testing/testing.go:647 +0x31d
testing.RunTests.func1(0xc0420780c0)
      /usr/local/go/src/testing/testing.go:793 +0x74
testing.tRunner(0xc0420780c0, 0xc042037e10)
      /usr/local/go/src/testing/testing.go:610 +0x88
testing.RunTests(0x5335b8, 0x5ada40, 0x2, 0x2, 0x40d7e9)
      /usr/local/go/src/testing/testing.go:799 +0x2fc
testing.(*M).Run(0xc042037ed8, 0xc04200a4f0)
      /usr/local/go/src/testing/testing.go:743 +0x8c
main.main()
      go-design-patterns/concurrency_3/pubsub/_test/_testmain.go:56 +0xcd goroutine 5 [chan send (nil chan)]:
      go-design-patterns/concurrency_3/pubsub.TestPublisher(0xc042078180)
      go-design-patterns/concurrency_3/pubsub/publisher_test.go:55 +0x372 testing.tRunner(0xc042078180, 0x5335a0)
      /usr/local/go/src/testing/testing.go:610 +0x88
created by testing.(*T).Run
      /usr/local/go/src/testing/testing.go:646 +0x2f3
exit status 2
FAIL  go-design-patterns/concurrency_3/pubsub   1.587s
</span></code></pre>
<p>Yes it has failed but, it&#39;s not a controlled fail at all. This was done on purpose to show a couple of things to be careful of in Go. First of all, the error produced in this test is a <b>fatal</b> error, which usually points to a bug in the code. This is important because while a <b>panic</b> error can be recovered, you cannot do the same with a fatal error.</p>
<p>In this case, the error is telling us the problem: <code>goroutine 5 [chan send (nil chan)]</code>, a nil channel so it&#39;s actually a bug in our code. How can we solve this? Well, this is also interesting.</p>
<p>The fact that we have a <code>nil</code> channel is caused by the code we wrote to compile unit tests but this particular error won&#39;t be raised once the appropriate code is written (because we&#39;ll never return a nil channel in this case). We could return a channel that is never use we cause a fatal error with a deadlock, which wouldn&#39;t be any progress at all either.</p>
<p>An idiomatic way to solve it would be to return a channel and an error so that you can have an error package with a type implementing the <code>Error</code> interface that returns a specific error such as <code>NoGoroutinesListening</code> or <code>ChannelNotCreated</code>. We have already seen many of this implementations so we&#39;ll leave these as an exercise to the reader and we will move forward to maintain focus on the concurrent nature of the chapter.</p>
<p>Nothing surprising there, so we can move to the implementation phase.</p>
</div>
<h4 id="implementation" >Implementation</h4>
<div class="hBody-4" >
<p>To recall, the <code>writerSubscriber</code> must receive messages that it will write on a type that satisfies the <code>io.Writer</code> interface.</p>
<p>So, where do we start? Well, each subscriber will run its own Goroutine, and we have seen that the best method to communicate with a Goroutine is a channel. So, we will need a field with a channel in the <code>Subscriber</code> type. We can use the same approach as in pipelines to end with the <code>NewWriterSubscriber</code> function and the <code>writerSubscriber</code> type:</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">writerSubscriber</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">in</span>     <span class="kd">chan</span> <span class="kd">interface</span><span class="p">{}</span>
  <span class="nx">id</span>     <span class="kt">int</span>
  <span class="nx">Writer</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Writer</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">NewWriterSubscriber</span><span class="p">(</span><span class="nx">id</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">out</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Writer</span><span class="p">)</span> <span class="nx">Subscriber</span> <span class="p">{</span>
  <span class="k">if</span> <span class="nx">out</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">out</span> <span class="p">=</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Stdout</span>
  <span class="p">}</span>

  <span class="nx">s</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">writerSubscriber</span><span class="p">{</span>
    <span class="nx">id</span><span class="p">:</span>     <span class="nx">id</span><span class="p">,</span>
    <span class="nx">in</span><span class="p">:</span>     <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kd">interface</span><span class="p">{}),</span>
    <span class="nx">Writer</span><span class="p">:</span> <span class="nx">out</span><span class="p">,</span>
  <span class="p">}</span>

  <span class="k">go</span> <span class="kd">func</span><span class="p">(){</span>
    <span class="k">for</span> <span class="nx">msg</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">s</span><span class="p">.</span><span class="nx">in</span> <span class="p">{</span>
      <span class="nx">fmt</span><span class="p">.</span><span class="nx">Fprintf</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">Writer</span><span class="p">,</span> <span class="s">&#34;(W%d): %v\n&#34;</span><span class="p">,</span> <span class="nx">s</span><span class="p">.</span><span class="nx">id</span><span class="p">,</span> <span class="nx">msg</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">}()</span>

  <span class="k">return</span> <span class="nx">s</span>
<span class="p">}</span>
</code></pre>
<p>In the first step, if no writer is specified (the <code>out</code> argument is nil), the default <code>io.Writer</code> interface is <code>stdout</code>. Then, we create a new pointer to the <code>writerSubscriber</code> type with the ID passed in the first argument, the value of out (<code>os.Stdout</code>, or whatever came in the argument if it wasn&#39;t nil), and a channel called in to maintain the same naming as in previous examples.</p>
<p>Then we launch a new Goroutine; this is the launching mechanism we mentioned. Like in the pipelines, the subscriber will iterate over the in channel every time a new message is received and it will format its contents to a string, which also contains the ID of the current subscriber.</p>
<p>As we learned previously, if the <code>in</code> channel is closed, the <code>for range</code> loop will stop and that particular Goroutine will finish, so the only thing we need to do in the <code>Close</code> method is to actually close the <code>in</code> channel:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">writerSubscriber</span><span class="p">)</span> <span class="nx">Close</span><span class="p">()</span> <span class="p">{</span>
  <span class="nb">close</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">in</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
<p>OK, only the <code>Notify</code> method is left; the <code>Notify</code> method is a convenient method to manage a particular behavior when communicating, and we will use a pattern that is common in many calls:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">writerSubscriber</span><span class="p">)</span> <span class="nx">Notify</span><span class="p">(</span><span class="nx">msg</span> <span class="kd">interface</span><span class="p">{})</span> <span class="p">(</span><span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">defer</span> <span class="kd">func</span><span class="p">(){</span>
    <span class="k">if</span> <span class="nx">rec</span> <span class="o">:=</span> <span class="nb">recover</span><span class="p">();</span> <span class="nx">rec</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
      <span class="nx">err</span> <span class="p">=</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&#34;%#v&#34;</span><span class="p">,</span> <span class="nx">rec</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">}()</span>

  <span class="k">select</span> <span class="p">{</span>
  <span class="k">case</span> <span class="nx">s</span><span class="p">.</span><span class="nx">in</span> <span class="o">&lt;-</span> <span class="nx">msg</span><span class="p">:</span>
  <span class="k">case</span> <span class="o">&lt;-</span><span class="nx">time</span><span class="p">.</span><span class="nx">After</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">):</span>
    <span class="nx">err</span> <span class="p">=</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&#34;Timeout\n&#34;</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="k">return</span>
<span class="p">}</span>
</code></pre>
<p>When communicating with a channel, there are two behavior that we must usually control: one is waiting time and the other is when the channel is closed. The deferred function actually works for any panicking error that can occur within the function. If the Goroutine panics, it will still execute the deferred function with the <code>recover()</code> method. The <code>recover()</code> method returns an interface of whatever the error was, so in our case, we set the returning variable error to the formatted value returned by <code>recover</code> (which is an interface). The <q><code>%#v</code></q> parameter gives us most of the information about any type when formatted to a string. The returned error will be ugly, but it will contain most of the information we can extract about the error. For a closed channel, for example, it will return &#34;send on a closed channel&#34;. Well, this seems clear enough.</p>
<p>The second rule is about waiting time. When we send a value over a channel, we will be blocked until another Goroutine takes the value from it (it will happen the same with a filled buffered channel). We don&#39;t want to get blocked forever, so we set a timeout period of one second by using a select handler. In short, with select we are saying: either you take the value in less than 1 second or I will discard it and return an error.</p>
<p>We have the <code>Close</code>, <code>Notify</code>, and <code>NewWriterSubscriber</code> methods, so we can try our test again:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go <span class="nb">test</span> -run<span class="o">=</span>TestWriter -v .
</span><span class="out" >=== RUN   TestWriter
--- PASS: TestWriter (0.00s)
PASS
ok
</span></code></pre>
<p>Much better now. The <code>Writer</code> has taken the mock writer we wrote on the test and has written to it the value we pass to the Notify method. At the same time, close has probably closed the channel effectively, because the <code>Notify</code> method is returning an error after calling the Close method. One thing to mention is that we can&#39;t check if a channel is closed or not without interacting with it; that&#39;s why we had to defer the execution of a closure that will check the contents of the <code>recover()</code> function in the <code>Notify</code> method.</p>
</div>
<h5 id="implementing-the-publisher" >Implementing the publisher</h5>
<div class="hBody-5" >
<p>OK, the publisher will need also a launching mechanism, but the main problems to deal with are race conditions accessing the subscriber list. We can solve this issue with a Mutex object from the <code>sync</code> package but we have already seen how to use this so we will use channels instead.</p>
<p>When using channels, we will need a channel for each action that can be considered dangerous--add a subscriber, remove a subscriber, retrieve the list of subscribers to <code>Notify</code> method them of a message, and a channel to stop all the subscribers. We also need a channel for incoming messages:</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">publisher</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">subscribers</span> <span class="p">[]</span><span class="nx">Subscriber</span>
  <span class="nx">addSubCh</span>    <span class="kd">chan</span> <span class="nx">Subscriber</span>
  <span class="nx">removeSubCh</span> <span class="kd">chan</span> <span class="nx">Subscriber</span>
  <span class="nx">in</span>          <span class="kd">chan</span> <span class="kd">interface</span><span class="p">{}</span>
  <span class="nx">stop</span>        <span class="kd">chan</span> <span class="kd">struct</span><span class="p">{}</span>
<span class="p">}</span>
</code></pre>
<p>Names are self-descriptive but, in short, subscribers maintain the list of subscribers; this is the slice that needs multiplexed access. The <code>addSubCh</code> instance is the channel to communicate with when you want to add a new subscriber; that&#39;s why it&#39;s a channel of subscribers. The same explanation applies to the <code>removeSubCh</code> channel, but this channel is to remove the subscriber. The <code>in</code> channel will handle incoming messages that must be broadcast to all subscribers. Finally, the stop channel must be called when we want to kill all Goroutines.</p>
<p>OK, let&#39;s start with the <code>AddSubscriberCh</code>, <code>RemoveSubscriber</code> and <code>PublishingCh</code> methods, which must return the channel to add and remove subscribers and the channel to send messages to all of them:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">publisher</span><span class="p">)</span> <span class="nx">AddSubscriber</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">p</span><span class="p">.</span><span class="nx">addSubCh</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">publisher</span><span class="p">)</span> <span class="nx">RemoveSubscriberCh</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">p</span><span class="p">.</span><span class="nx">removeSubCh</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">publisher</span><span class="p">)</span> <span class="nx">PublishMessage</span><span class="p">(){</span>
  <span class="k">return</span> <span class="nx">p</span><span class="p">.</span><span class="nx">in</span>
<span class="p">}</span>
</code></pre>
<p>The <code>Stop()</code> function the stop channel by closing it. This will effectively spread the signal to every listening Goroutine:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">publisher</span><span class="p">)</span> <span class="nx">Stop</span><span class="p">(){</span>
  <span class="nb">close</span><span class="p">(</span><span class="nx">p</span><span class="p">.</span><span class="nx">stop</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
<p>The <code>Stop</code> method, the function to stop the publisher and the subscribers, also pushes to its respective channel, called stop.</p>
<p>You may be wondering why we don&#39;t simply leave the channels available so that users push directly to this channel instead of using the proxying function. Well, the idea is that the user that integrates the library in their app doesn&#39;t have to deal with the complexity of the concurrent structure associated with the library, so they can focus on their business while maximizing performance as much as possible.</p>
</div>
<h5 id="handling-channels-without-race-conditions" >Handling channels without race conditions</h5>
<div class="hBody-5" >
<p>Until now, we have forwarded data to the channels on the publisher but we haven&#39;t actually handled any of that data. The launcher mechanism that is going to launch a different Goroutine will handle them all.</p>
<p>We will create a launch method that we will execute by using the <code>go</code> keyword instead of embedding the whole function inside the <code>NewPublisher</code> function:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">publisher</span><span class="p">)</span> <span class="nx">start</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">for</span> <span class="p">{</span>
    <span class="k">select</span> <span class="p">{</span>
    <span class="k">case</span> <span class="nx">msg</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">p</span><span class="p">.</span><span class="nx">in</span><span class="p">:</span>
      <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">ch</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">p</span><span class="p">.</span><span class="nx">subscribers</span> <span class="p">{</span>
        <span class="nx">sub</span><span class="p">.</span><span class="nx">Notify</span><span class="p">(</span><span class="nx">msg</span><span class="p">)</span>
      <span class="p">}</span>
</code></pre>
<p><code>Launch</code> is a private method and we haven&#39;t tested it. Remember that private methods are usually called from public methods (the ones we have tested). Generally, if a private method is not called from a public method, it can&#39;t be called at all!</p>
<p>The first thing we notice with this method is that it is an infinite for loop that will repeat a select operation between many channels but only one of them can be executed each time. The first of these operations is the one that receives a new message to publish to subscribers. The <code>case msg := &lt;- p.in</code>: code handles this incoming operation.</p>
<p>In this case, we are iterating over all subscribers and executing their <code>Notify</code> method. You may be wondering why we don&#39;t add the <code>go</code> keyword in front so that the <code>Notify</code> method is executed as a different Goroutine and therefore iterates much faster. Well, this because we aren&#39;t demultiplexing the actions of receiving a message and of closing the message. So, if we launch the subscriber in a new <code>Goroutine</code> and it is closed while the message is processed in the <code>Notify</code> method, we&#39;ll have a race condition where a message will try to be sent within the <code>Notify</code> method to a closed channel. In fact, we are considering this scenario when we develop the <code>Notify</code> method but, still, we won&#39;t control the number of Goroutines launched if we call the <code>Notify</code> method in a new Goroutine each time. For simplicity, we just call the <code>Notify</code> method, but it is a nice exercise to control the number of Goroutines waiting for a return in a <code>Notify</code> method execution. By buffering the <code>in</code> channel in each subscriber, we can also achieve a good solution:</p>
<pre class="code" ><code class="chroma" ><span class="k">case</span> <span class="nx">sub</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">p</span><span class="p">.</span><span class="nx">addSubCh</span><span class="p">:</span>
<span class="nx">p</span><span class="p">.</span><span class="nx">subscribers</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">p</span><span class="p">.</span><span class="nx">subscribers</span><span class="p">,</span> <span class="nx">sub</span><span class="p">)</span>
</code></pre>
<p>The next operation is what to do when a value arrives to the channel to add subscribers. In this case it&#39;s simple: we update it, appending the new value to it. While this case is executed, not other calls can be executed in this selection:</p>
<pre class="code" ><code class="chroma" ><span class="k">case</span> <span class="nx">sub</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">p</span><span class="p">.</span><span class="nx">removeSubCh</span><span class="p">:</span>
<span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">candidate</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">p</span><span class="p">.</span><span class="nx">subscribers</span> <span class="p">{</span>
  <span class="k">if</span> <span class="nx">candidate</span> <span class="o">==</span> <span class="nx">sub</span> <span class="p">{</span>
    <span class="nx">p</span><span class="p">.</span><span class="nx">subscribers</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">p</span><span class="p">.</span><span class="nx">subscribers</span><span class="p">[:</span><span class="nx">i</span><span class="p">],</span> <span class="nx">p</span><span class="p">.</span><span class="nx">subscribers</span><span class="p">[</span><span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span><span class="o">...</span><span class="p">)</span>
    <span class="nx">candidate</span><span class="p">.</span><span class="nx">Close</span><span class="p">()</span>
    <span class="k">break</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>When a value arrives at the remove channel, the operation is a bit more complex because we have to search for the subscriber in the slice. We use a <span class="math" >O(N)</span> approach for it, iterating from the beginning until we find it, but the search algorithm could be greatly improved. Once we find the corresponding <code>Subscriber</code> interface, we remove it from the subscribers slice and stop it. One thing to mention is that on tests, we are accessing the length of the subscribers slice directly without demultiplexing the operation. This is clearly a race condition, but generally, it isn&#39;t reflected when running the race detector.</p>
<p>The solution will be to develop a method just to multiplex calls to get the length of the slice, but it won&#39;t belong to the public interface. Again, for simplicity, we&#39;ll leave it like this, or this example may become too complex to handle:</p>
<pre class="code" ><code class="chroma" >    <span class="k">case</span> <span class="o">&lt;-</span><span class="nx">p</span><span class="p">.</span><span class="nx">stop</span><span class="p">:</span>
      <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">sub</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">p</span><span class="p">.</span><span class="nx">subscribers</span> <span class="p">{</span>
        <span class="nx">sub</span><span class="p">.</span><span class="nx">Close</span><span class="p">()</span>
      <span class="p">}</span>

      <span class="nb">close</span><span class="p">(</span><span class="nx">p</span><span class="p">.</span><span class="nx">addSubCh</span><span class="p">)</span>
      <span class="nb">close</span><span class="p">(</span><span class="nx">p</span><span class="p">.</span><span class="nx">in</span><span class="p">)</span>
      <span class="nb">close</span><span class="p">(</span><span class="nx">p</span><span class="p">.</span><span class="nx">removeSubCh</span><span class="p">)</span>

      <span class="k">return</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>The last operation to demultiplex is the <code>stop</code> operation, which must stop all Goroutines in the publisher and subscribers. Then we have to iterate through every <code>Subscriber</code> stored in the subscribers field to execute their <code>Close()</code> method, so their Goroutines are closed, too. Finally, if we return this Goroutine, it will finish, too.</p>
<p>OK, time to execute all tests and see how is it going:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go <span class="nb">test</span> -race .
</span><span class="out" >ok
</span></code></pre>
<p>Not so bad. All tests have passed successfully and we have our Observer pattern ready. While the example can still be improved, it is a great example of how we must handle an Observer pattern using channels in Go. As an exercise, we encourage you to try the same example using mutexes instead of channels to control access. It&#39;s a bit easier, and will also give you an insight of how to work with mutexes.</p>
</div>
<h4 id="a-few-words-on-the-concurrent-observer-pattern" >A few words on the concurrent Observer pattern</h4>
<div class="hBody-4" >
<p>This example has demonstrated how to take advantage of multi-core CPUs to build a concurrent message publisher by implementing the Observer pattern. While the example was long, we have tried to show a common pattern when developing concurrent apps in Go.</p>
</div>
<h3 id="summary" >Summary</h3>
<div class="hBody-3" >
<p>We have seen few approaches to develop concurrent structures that can be run in parallel. We have tried to show a few ways to solve the same problem, one without concurrency primitives and one with them. We have seen how different the publish/subscriber example written with a concurrent structure can be compared to the classic one.</p>
<p>We have also seen how to build a concurrent operation using a pipeline and we have parallelize it by using a worker pool, a very common Go pattern to maximize parallelism.</p>
<p>Both examples were simple enough to grasp, while digging as much as possible in to the nature of the Go language instead of in the problem itself.</p>
</div>
</body>
</html>
